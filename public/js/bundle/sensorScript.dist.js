"use strict";

var _typeof5 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass4 = function () {
     function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
               var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
     }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
     };
}();var _typeof4 = typeof Symbol === "function" && _typeof5(Symbol.iterator) === "symbol" ? function (obj) {
     return typeof obj === "undefined" ? "undefined" : _typeof5(obj);
} : function (obj) {
     return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof5(obj);
};function _toConsumableArray(arr) {
     if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
               arr2[i] = arr[i];
          }return arr2;
     } else {
          return Array.from(arr);
     }
}function _possibleConstructorReturn(self, call) {
     if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
     }return call && ((typeof call === "undefined" ? "undefined" : _typeof5(call)) === "object" || typeof call === "function") ? call : self;
}function _inherits(subClass, superClass) {
     if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof5(superClass)));
     }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}function _classCallCheck4(instance, Constructor) {
     if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
     }
}(function () {
     function r(e, n, t) {
          function o(i, f) {
               if (!n[i]) {
                    if (!e[i]) {
                         var c = "function" == typeof require && require;if (!f && c) return c(i, !0);if (u) return u(i, !0);var a = new Error("Cannot find module '" + i + "'");throw a.code = "MODULE_NOT_FOUND", a;
                    }var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {
                         var n = e[i][1][r];return o(n || r);
                    }, p, p.exports, r, e, n, t);
               }return n[i].exports;
          }for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
               o(t[i]);
          }return o;
     }return r;
})()({ 1: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var min = Math.min;var max = Math.max;function clip(value) {
               var lower = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;var upper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : +Infinity;return max(lower, min(upper, value));
          } /**
            * Dictionnary of the available types. Each key correspond to the type of the
            * implemented param while the corresponding object value should the
            * {@link `paramDefinition`} of the defined type.
            *
            * typedef {Object} paramTemplates
            * @type {Object<String, paramTemplate>}
            */ /**
               * Definition of a parameter. The definition should at least contain the entries
               * `type` and `default`. Every parameter can also accept optionnal configuration
               * entries `constant` and `metas`.
               * Available definitions are:
               * - {@link booleanDefinition}
               * - {@link integerDefinition}
               * - {@link floatDefinition}
               * - {@link stringDefinition}
               * - {@link enumDefinition}
               *
               * typedef {Object} paramDefinition
               * @property {String} type - Type of the parameter.
               * @property {Mixed} default - Default value of the parameter if no
               *  initialization value is provided.
               * @property {Boolean} [constant=false] - Define if the parameter can be change
               *  after its initialization.
               * @property {Object} [metas=null] - Any user defined data associated to the
               *  parameter that couls be usefull in the application.
               */exports.default = { /**
                                     * @typedef {Object} booleanDefinition
                                     * @property {String} [type='boolean'] - Define a boolean parameter.
                                     * @property {Boolean} default - Default value of the parameter.
                                     * @property {Boolean} [constant=false] - Define if the parameter is constant.
                                     * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
                                     * @property {Object} [metas={}] - Optionnal metadata of the parameter.
                                     */boolean: { definitionTemplate: ['default'], typeCheckFunction: function typeCheckFunction(value, definition, name) {
                         if (typeof value !== 'boolean') throw new Error('Invalid value for boolean param "' + name + '": ' + value);return value;
                    } }, /**
                         * @typedef {Object} integerDefinition
                         * @property {String} [type='integer'] - Define a boolean parameter.
                         * @property {Mixed} default - Default value of the parameter.
                         * @property {Number} [min=-Infinity] - Minimum value of the parameter.
                         * @property {Number} [max=+Infinity] - Maximum value of the parameter.
                         * @property {Boolean} [constant=false] - Define if the parameter is constant.
                         * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
                         * @property {Object} [metas={}] - Optionnal metadata of the parameter.
                         */integer: { definitionTemplate: ['default'], typeCheckFunction: function typeCheckFunction(value, definition, name) {
                         if (!(typeof value === 'number' && Math.floor(value) === value)) throw new Error('Invalid value for integer param "' + name + '": ' + value);return clip(value, definition.min, definition.max);
                    } }, /**
                         * @typedef {Object} floatDefinition
                         * @property {String} [type='float'] - Define a boolean parameter.
                         * @property {Mixed} default - Default value of the parameter.
                         * @property {Number} [min=-Infinity] - Minimum value of the parameter.
                         * @property {Number} [max=+Infinity] - Maximum value of the parameter.
                         * @property {Boolean} [constant=false] - Define if the parameter is constant.
                         * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
                         * @property {Object} [metas={}] - Optionnal metadata of the parameter.
                         */float: { definitionTemplate: ['default'], typeCheckFunction: function typeCheckFunction(value, definition, name) {
                         if (typeof value !== 'number' || value !== value) // reject NaN
                              throw new Error('Invalid value for float param "' + name + '": ' + value);return clip(value, definition.min, definition.max);
                    } }, /**
                         * @typedef {Object} stringDefinition
                         * @property {String} [type='string'] - Define a boolean parameter.
                         * @property {Mixed} default - Default value of the parameter.
                         * @property {Boolean} [constant=false] - Define if the parameter is constant.
                         * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
                         * @property {Object} [metas={}] - Optionnal metadata of the parameter.
                         */string: { definitionTemplate: ['default'], typeCheckFunction: function typeCheckFunction(value, definition, name) {
                         if (typeof value !== 'string') throw new Error('Invalid value for string param "' + name + '": ' + value);return value;
                    } }, /**
                         * @typedef {Object} enumDefinition
                         * @property {String} [type='enum'] - Define a boolean parameter.
                         * @property {Mixed} default - Default value of the parameter.
                         * @property {Array} list - Possible values of the parameter.
                         * @property {Boolean} [constant=false] - Define if the parameter is constant.
                         * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
                         * @property {Object} [metas={}] - Optionnal metadata of the parameter.
                         */enum: { definitionTemplate: ['default', 'list'], typeCheckFunction: function typeCheckFunction(value, definition, name) {
                         if (definition.list.indexOf(value) === -1) throw new Error('Invalid value for enum param "' + name + '": ' + value);return value;
                    } }, /**
                         * @typedef {Object} anyDefinition
                         * @property {String} [type='enum'] - Define a parameter of any type.
                         * @property {Mixed} default - Default value of the parameter.
                         * @property {Boolean} [constant=false] - Define if the parameter is constant.
                         * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
                         * @property {Object} [metas={}] - Optionnal metadata of the parameter.
                         */any: { definitionTemplate: ['default'], typeCheckFunction: function typeCheckFunction(value, definition, name) {
                         // no check as it can have any type...
                         return value;
                    } } };
     }, {}], 2: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _createClass = function () {
               function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                         var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
                    }
               }return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
               };
          }();var _paramTemplates = require('./paramTemplates');var _paramTemplates2 = _interopRequireDefault(_paramTemplates);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }function _classCallCheck(instance, Constructor) {
               if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
               }
          } /**
            * Generic class for typed parameters.
            *
            * @param {String} name - Name of the parameter.
            * @param {Array} definitionTemplate - List of mandatory keys in the param
            *  definition.
            * @param {Function} typeCheckFunction - Function to be used in order to check
            *  the value against the param definition.
            * @param {Object} definition - Definition of the parameter.
            * @param {Mixed} value - Value of the parameter.
            * @private
            */var Param = function () {
               function Param(name, definitionTemplate, typeCheckFunction, definition, value) {
                    _classCallCheck(this, Param);definitionTemplate.forEach(function (key) {
                         if (definition.hasOwnProperty(key) === false) throw new Error('Invalid definition for param "' + name + '", ' + key + ' is not defined');
                    });this.name = name;this.type = definition.type;this.definition = definition;if (this.definition.nullable === true && value === null) this.value = null;else this.value = typeCheckFunction(value, definition, name);this._typeCheckFunction = typeCheckFunction;
               } /**
                 * Returns the current value.
                 * @return {Mixed}
                 */_createClass(Param, [{ key: 'getValue', value: function getValue() {
                         return this.value;
                    } /**
                      * Update the current value.
                      * @param {Mixed} value - New value of the parameter.
                      * @return {Boolean} - `true` if the param has been updated, false otherwise
                      *  (e.g. if the parameter already had this value).
                      */ }, { key: 'setValue', value: function setValue(value) {
                         if (this.definition.constant === true) throw new Error('Invalid assignement to constant param "' + this.name + '"');if (!(this.definition.nullable === true && value === null)) value = this._typeCheckFunction(value, this.definition, this.name);if (this.value !== value) {
                              this.value = value;return true;
                         }return false;
                    } }]);return Param;
          }(); /**
               * Bag of parameters. Main interface of the library
               */var ParameterBag = function () {
               function ParameterBag(params, definitions) {
                    _classCallCheck(this, ParameterBag); /**
                                                         * List of parameters.
                                                         *
                                                         * @type {Object<String, Param>}
                                                         * @name _params
                                                         * @memberof ParameterBag
                                                         * @instance
                                                         * @private
                                                         */this._params = params; /**
                                                                                  * List of definitions with init values.
                                                                                  *
                                                                                  * @type {Object<String, paramDefinition>}
                                                                                  * @name _definitions
                                                                                  * @memberof ParameterBag
                                                                                  * @instance
                                                                                  * @private
                                                                                  */this._definitions = definitions; /**
                                                                                                                     * List of global listeners.
                                                                                                                     *
                                                                                                                     * @type {Set}
                                                                                                                     * @name _globalListeners
                                                                                                                     * @memberof ParameterBag
                                                                                                                     * @instance
                                                                                                                     * @private
                                                                                                                     */this._globalListeners = new Set(); /**
                                                                                                                                                          * List of params listeners.
                                                                                                                                                          *
                                                                                                                                                          * @type {Object<String, Set>}
                                                                                                                                                          * @name _paramsListeners
                                                                                                                                                          * @memberof ParameterBag
                                                                                                                                                          * @instance
                                                                                                                                                          * @private
                                                                                                                                                          */this._paramsListeners = {}; // initialize empty Set for each param
                    for (var name in params) {
                         this._paramsListeners[name] = new Set();
                    }
               } /**
                 * Return the given definitions along with the initialization values.
                 *
                 * @return {Object}
                 */_createClass(ParameterBag, [{ key: 'getDefinitions', value: function getDefinitions() {
                         var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;if (name !== null) return this._definitions[name];else return this._definitions;
                    } /**
                      * Return the value of the given parameter.
                      *
                      * @param {String} name - Name of the parameter.
                      * @return {Mixed} - Value of the parameter.
                      */ }, { key: 'get', value: function get(name) {
                         if (!this._params[name]) throw new Error('Cannot read property value of undefined parameter "' + name + '"');return this._params[name].value;
                    } /**
                      * Set the value of a parameter. If the value of the parameter is updated
                      * (aka if previous value is different from new value) all registered
                      * callbacks are registered.
                      *
                      * @param {String} name - Name of the parameter.
                      * @param {Mixed} value - Value of the parameter.
                      * @return {Mixed} - New value of the parameter.
                      */ }, { key: 'set', value: function set(name, value) {
                         var param = this._params[name];var updated = param.setValue(value);value = param.getValue();if (updated) {
                              var metas = param.definition.metas; // trigger global listeners
                              var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
                                   for (var _iterator = this._globalListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                        var listener = _step.value;listener(name, value, metas);
                                   } // trigger param listeners
                              } catch (err) {
                                   _didIteratorError = true;_iteratorError = err;
                              } finally {
                                   try {
                                        if (!_iteratorNormalCompletion && _iterator.return) {
                                             _iterator.return();
                                        }
                                   } finally {
                                        if (_didIteratorError) {
                                             throw _iteratorError;
                                        }
                                   }
                              }var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {
                                   for (var _iterator2 = this._paramsListeners[name][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                        var _listener = _step2.value;_listener(value, metas);
                                   }
                              } catch (err) {
                                   _didIteratorError2 = true;_iteratorError2 = err;
                              } finally {
                                   try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                             _iterator2.return();
                                        }
                                   } finally {
                                        if (_didIteratorError2) {
                                             throw _iteratorError2;
                                        }
                                   }
                              }
                         }return value;
                    } /**
                      * Define if the `name` parameter exists or not.
                      *
                      * @param {String} name - Name of the parameter.
                      * @return {Boolean}
                      */ }, { key: 'has', value: function has(name) {
                         return this._params[name] ? true : false;
                    } /**
                      * Reset a parameter to its init value. Reset all parameters if no argument.
                      *
                      * @param {String} [name=null] - Name of the parameter to reset.
                      */ }, { key: 'reset', value: function reset() {
                         var _this = this;var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;if (name !== null) this.set(name, param.definition.initValue);else Object.keys(this._params).forEach(function (name) {
                              return _this.reset(name);
                         });
                    } /**
                      * @callback ParameterBag~listenerCallback
                      * @param {String} name - Parameter name.
                      * @param {Mixed} value - Updated value of the parameter.
                      * @param {Object} [meta=] - Given meta data of the parameter.
                      */ /**
                         * Add controller to all param updates.
                         *
                         * @param {ParameterBag~listenerCallack} callback - Listener to register.
                         */ }, { key: 'addListener', value: function addListener(callback) {
                         this._globalListeners.add(callback);
                    } /**
                      * Remove controller from all param changes.
                      *
                      * @param {ParameterBag~listenerCallack} callback - Listener to remove. If
                      *  `null` remove all listeners.
                      */ }, { key: 'removeListener', value: function removeListener() {
                         var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;if (callback === null) this._globalListeners.clear();else this._globalListeners.delete(callback);
                    } /**
                      * @callback ParameterBag~paramListenerCallack
                      * @param {Mixed} value - Updated value of the parameter.
                      * @param {Object} [meta=] - Given meta data of the parameter.
                      */ /**
                         * Add controller to a given param updates.
                         *
                         * @param {String} name - Parameter name.
                         * @param {ParameterBag~paramListenerCallack} callback - Function to apply
                         *  when the value of the parameter changes.
                         * @param {Boolean} [trigger=false] - Execute the callback immediately with
                         *  current parameter value.
                         */ }, { key: 'addParamListener', value: function addParamListener(name, callback) {
                         var trigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;this._paramsListeners[name].add(callback);if (trigger) {
                              var _param = this._params[name];var value = _param.getValue();var metas = _param.definition.metas;callback(value, metas);
                         }
                    } /**
                      * Remove controller from a given param updates.
                      *
                      * @param {String} name - Parameter name.
                      * @param {ParameterBag~paramListenerCallack} callback - Listener to remove.
                      *  If `null` remove all listeners.
                      */ }, { key: 'removeParamListener', value: function removeParamListener(name) {
                         var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;if (callback === null) this._paramsListeners[name].clear();else this._paramsListeners[name].delete(callback);
                    } }]);return ParameterBag;
          }(); /**
               * Factory for the `ParameterBag` class.
               *
               * @param {Object<String, paramDefinition>} definitions - Object describing the
               *  parameters.
               * @param {Object<String, Mixed>} values - Initialization values for the
               *  parameters.
               * @return {ParameterBag}
               */function parameters(definitions) {
               var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var params = {};for (var name in values) {
                    if (definitions.hasOwnProperty(name) === false) throw new Error('Unknown param "' + name + '"');
               }for (var _name in definitions) {
                    if (params.hasOwnProperty(_name) === true) throw new Error('Parameter "' + _name + '" already defined');var definition = definitions[_name];if (!_paramTemplates2.default[definition.type]) throw new Error('Unknown param type "' + definition.type + '"');var _paramTemplates$defin = _paramTemplates2.default[definition.type],
                        definitionTemplate = _paramTemplates$defin.definitionTemplate,
                        typeCheckFunction = _paramTemplates$defin.typeCheckFunction;var value = void 0;if (values.hasOwnProperty(_name) === true) value = values[_name];else value = definition.default; // store init value in definition
                    definition.initValue = value;if (!typeCheckFunction || !definitionTemplate) throw new Error('Invalid param type definition "' + definition.type + '"');params[_name] = new Param(_name, definitionTemplate, typeCheckFunction, definition, value);
               }return new ParameterBag(params, definitions);
          } /**
            * Register a new type for the `parameters` factory.
            * @param {String} typeName - Value that will be available as the `type` of a
            *  param definition.
            * @param {parameterDefinition} parameterDefinition - Object describing the
            *  parameter.
            */parameters.defineType = function (typeName, parameterDefinition) {
               _paramTemplates2.default[typeName] = parameterDefinition;
          };exports.default = parameters;
     }, { "./paramTemplates": 1 }], 3: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
     }, { "core-js/library/fn/json/stringify": 22 }], 4: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/math/log10"), __esModule: true };
     }, { "core-js/library/fn/math/log10": 23 }], 5: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/number/is-finite"), __esModule: true };
     }, { "core-js/library/fn/number/is-finite": 24 }], 6: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
     }, { "core-js/library/fn/object/assign": 25 }], 7: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
     }, { "core-js/library/fn/object/create": 26 }], 8: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
     }, { "core-js/library/fn/object/define-property": 27 }], 9: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
     }, { "core-js/library/fn/object/get-own-property-descriptor": 28 }], 10: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
     }, { "core-js/library/fn/object/get-prototype-of": 29 }], 11: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
     }, { "core-js/library/fn/object/set-prototype-of": 30 }], 12: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
     }, { "core-js/library/fn/promise": 31 }], 13: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
     }, { "core-js/library/fn/symbol": 32 }], 14: [function (require, module, exports) {
          module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
     }, { "core-js/library/fn/symbol/iterator": 33 }], 15: [function (require, module, exports) {
          "use strict";
          exports.__esModule = true;exports.default = function (instance, Constructor) {
               if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
               }
          };
     }, {}], 16: [function (require, module, exports) {
          "use strict";
          exports.__esModule = true;var _defineProperty = require("../core-js/object/define-property");var _defineProperty2 = _interopRequireDefault(_defineProperty);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }exports.default = function () {
               function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                         var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;(0, _defineProperty2.default)(target, descriptor.key, descriptor);
                    }
               }return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
               };
          }();
     }, { "../core-js/object/define-property": 8 }], 17: [function (require, module, exports) {
          "use strict";
          exports.__esModule = true;var _defineProperty = require("../core-js/object/define-property");var _defineProperty2 = _interopRequireDefault(_defineProperty);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }exports.default = function (obj, key, value) {
               if (key in obj) {
                    (0, _defineProperty2.default)(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
               } else {
                    obj[key] = value;
               }return obj;
          };
     }, { "../core-js/object/define-property": 8 }], 18: [function (require, module, exports) {
          "use strict";
          exports.__esModule = true;var _getPrototypeOf = require("../core-js/object/get-prototype-of");var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _getOwnPropertyDescriptor = require("../core-js/object/get-own-property-descriptor");var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }exports.default = function get(object, property, receiver) {
               if (object === null) object = Function.prototype;var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);if (desc === undefined) {
                    var parent = (0, _getPrototypeOf2.default)(object);if (parent === null) {
                         return undefined;
                    } else {
                         return get(parent, property, receiver);
                    }
               } else if ("value" in desc) {
                    return desc.value;
               } else {
                    var getter = desc.get;if (getter === undefined) {
                         return undefined;
                    }return getter.call(receiver);
               }
          };
     }, { "../core-js/object/get-own-property-descriptor": 9, "../core-js/object/get-prototype-of": 10 }], 19: [function (require, module, exports) {
          "use strict";
          exports.__esModule = true;var _setPrototypeOf = require("../core-js/object/set-prototype-of");var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);var _create = require("../core-js/object/create");var _create2 = _interopRequireDefault(_create);var _typeof2 = require("../helpers/typeof");var _typeof3 = _interopRequireDefault(_typeof2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }exports.default = function (subClass, superClass) {
               if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
               }subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
          };
     }, { "../core-js/object/create": 7, "../core-js/object/set-prototype-of": 11, "../helpers/typeof": 21 }], 20: [function (require, module, exports) {
          "use strict";
          exports.__esModule = true;var _typeof2 = require("../helpers/typeof");var _typeof3 = _interopRequireDefault(_typeof2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }exports.default = function (self, call) {
               if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
               }return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
          };
     }, { "../helpers/typeof": 21 }], 21: [function (require, module, exports) {
          "use strict";
          exports.__esModule = true;var _iterator = require("../core-js/symbol/iterator");var _iterator2 = _interopRequireDefault(_iterator);var _symbol = require("../core-js/symbol");var _symbol2 = _interopRequireDefault(_symbol);var _typeof = typeof _symbol2.default === "function" && _typeof4(_iterator2.default) === "symbol" ? function (obj) {
               return typeof obj === "undefined" ? "undefined" : _typeof4(obj);
          } : function (obj) {
               return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof4(obj);
          };function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
               return typeof obj === "undefined" ? "undefined" : _typeof(obj);
          } : function (obj) {
               return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
          };
     }, { "../core-js/symbol": 13, "../core-js/symbol/iterator": 14 }], 22: [function (require, module, exports) {
          var core = require('../../modules/_core');var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });module.exports = function stringify(it) {
               // eslint-disable-line no-unused-vars
               return $JSON.stringify.apply($JSON, arguments);
          };
     }, { "../../modules/_core": 41 }], 23: [function (require, module, exports) {
          require('../../modules/es6.math.log10');module.exports = require('../../modules/_core').Math.log10;
     }, { "../../modules/_core": 41, "../../modules/es6.math.log10": 109 }], 24: [function (require, module, exports) {
          require('../../modules/es6.number.is-finite');module.exports = require('../../modules/_core').Number.isFinite;
     }, { "../../modules/_core": 41, "../../modules/es6.number.is-finite": 110 }], 25: [function (require, module, exports) {
          require('../../modules/es6.object.assign');module.exports = require('../../modules/_core').Object.assign;
     }, { "../../modules/_core": 41, "../../modules/es6.object.assign": 111 }], 26: [function (require, module, exports) {
          require('../../modules/es6.object.create');var $Object = require('../../modules/_core').Object;module.exports = function create(P, D) {
               return $Object.create(P, D);
          };
     }, { "../../modules/_core": 41, "../../modules/es6.object.create": 112 }], 27: [function (require, module, exports) {
          require('../../modules/es6.object.define-property');var $Object = require('../../modules/_core').Object;module.exports = function defineProperty(it, key, desc) {
               return $Object.defineProperty(it, key, desc);
          };
     }, { "../../modules/_core": 41, "../../modules/es6.object.define-property": 113 }], 28: [function (require, module, exports) {
          require('../../modules/es6.object.get-own-property-descriptor');var $Object = require('../../modules/_core').Object;module.exports = function getOwnPropertyDescriptor(it, key) {
               return $Object.getOwnPropertyDescriptor(it, key);
          };
     }, { "../../modules/_core": 41, "../../modules/es6.object.get-own-property-descriptor": 114 }], 29: [function (require, module, exports) {
          require('../../modules/es6.object.get-prototype-of');module.exports = require('../../modules/_core').Object.getPrototypeOf;
     }, { "../../modules/_core": 41, "../../modules/es6.object.get-prototype-of": 115 }], 30: [function (require, module, exports) {
          require('../../modules/es6.object.set-prototype-of');module.exports = require('../../modules/_core').Object.setPrototypeOf;
     }, { "../../modules/_core": 41, "../../modules/es6.object.set-prototype-of": 116 }], 31: [function (require, module, exports) {
          require('../modules/es6.object.to-string');require('../modules/es6.string.iterator');require('../modules/web.dom.iterable');require('../modules/es6.promise');require('../modules/es7.promise.finally');require('../modules/es7.promise.try');module.exports = require('../modules/_core').Promise;
     }, { "../modules/_core": 41, "../modules/es6.object.to-string": 117, "../modules/es6.promise": 118, "../modules/es6.string.iterator": 119, "../modules/es7.promise.finally": 121, "../modules/es7.promise.try": 122, "../modules/web.dom.iterable": 125 }], 32: [function (require, module, exports) {
          require('../../modules/es6.symbol');require('../../modules/es6.object.to-string');require('../../modules/es7.symbol.async-iterator');require('../../modules/es7.symbol.observable');module.exports = require('../../modules/_core').Symbol;
     }, { "../../modules/_core": 41, "../../modules/es6.object.to-string": 117, "../../modules/es6.symbol": 120, "../../modules/es7.symbol.async-iterator": 123, "../../modules/es7.symbol.observable": 124 }], 33: [function (require, module, exports) {
          require('../../modules/es6.string.iterator');require('../../modules/web.dom.iterable');module.exports = require('../../modules/_wks-ext').f('iterator');
     }, { "../../modules/_wks-ext": 105, "../../modules/es6.string.iterator": 119, "../../modules/web.dom.iterable": 125 }], 34: [function (require, module, exports) {
          module.exports = function (it) {
               if (typeof it != 'function') throw TypeError(it + ' is not a function!');return it;
          };
     }, {}], 35: [function (require, module, exports) {
          module.exports = function () {/* empty */};
     }, {}], 36: [function (require, module, exports) {
          module.exports = function (it, Constructor, name, forbiddenField) {
               if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
                    throw TypeError(name + ': incorrect invocation!');
               }return it;
          };
     }, {}], 37: [function (require, module, exports) {
          var isObject = require('./_is-object');module.exports = function (it) {
               if (!isObject(it)) throw TypeError(it + ' is not an object!');return it;
          };
     }, { "./_is-object": 60 }], 38: [function (require, module, exports) {
          // false -> Array#indexOf
          // true  -> Array#includes
          var toIObject = require('./_to-iobject');var toLength = require('./_to-length');var toAbsoluteIndex = require('./_to-absolute-index');module.exports = function (IS_INCLUDES) {
               return function ($this, el, fromIndex) {
                    var O = toIObject($this);var length = toLength(O.length);var index = toAbsoluteIndex(fromIndex, length);var value; // Array#includes uses SameValueZero equality algorithm
                    // eslint-disable-next-line no-self-compare
                    if (IS_INCLUDES && el != el) while (length > index) {
                         value = O[index++]; // eslint-disable-next-line no-self-compare
                         if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
                    } else for (; length > index; index++) {
                         if (IS_INCLUDES || index in O) {
                              if (O[index] === el) return IS_INCLUDES || index || 0;
                         }
                    }return !IS_INCLUDES && -1;
               };
          };
     }, { "./_to-absolute-index": 97, "./_to-iobject": 99, "./_to-length": 100 }], 39: [function (require, module, exports) {
          // getting tag from 19.1.3.6 Object.prototype.toString()
          var cof = require('./_cof');var TAG = require('./_wks')('toStringTag'); // ES3 wrong here
          var ARG = cof(function () {
               return arguments;
          }()) == 'Arguments'; // fallback for IE11 Script Access Denied error
          var tryGet = function tryGet(it, key) {
               try {
                    return it[key];
               } catch (e) {/* empty */}
          };module.exports = function (it) {
               var O, T, B;return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
               : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
               : ARG ? cof(O) // ES3 arguments fallback
               : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
          };
     }, { "./_cof": 40, "./_wks": 106 }], 40: [function (require, module, exports) {
          var toString = {}.toString;module.exports = function (it) {
               return toString.call(it).slice(8, -1);
          };
     }, {}], 41: [function (require, module, exports) {
          var core = module.exports = { version: '2.5.5' };if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
     }, {}], 42: [function (require, module, exports) {
          // optional / simple context binding
          var aFunction = require('./_a-function');module.exports = function (fn, that, length) {
               aFunction(fn);if (that === undefined) return fn;switch (length) {case 1:
                         return function (a) {
                              return fn.call(that, a);
                         };case 2:
                         return function (a, b) {
                              return fn.call(that, a, b);
                         };case 3:
                         return function (a, b, c) {
                              return fn.call(that, a, b, c);
                         };}return function () /* ...args */{
                    return fn.apply(that, arguments);
               };
          };
     }, { "./_a-function": 34 }], 43: [function (require, module, exports) {
          // 7.2.1 RequireObjectCoercible(argument)
          module.exports = function (it) {
               if (it == undefined) throw TypeError("Can't call method on  " + it);return it;
          };
     }, {}], 44: [function (require, module, exports) {
          // Thank's IE8 for his funny defineProperty
          module.exports = !require('./_fails')(function () {
               return Object.defineProperty({}, 'a', { get: function get() {
                         return 7;
                    } }).a != 7;
          });
     }, { "./_fails": 49 }], 45: [function (require, module, exports) {
          var isObject = require('./_is-object');var document = require('./_global').document; // typeof document.createElement is 'object' in old IE
          var is = isObject(document) && isObject(document.createElement);module.exports = function (it) {
               return is ? document.createElement(it) : {};
          };
     }, { "./_global": 51, "./_is-object": 60 }], 46: [function (require, module, exports) {
          // IE 8- don't enum bug keys
          module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
     }, {}], 47: [function (require, module, exports) {
          // all enumerable object keys, includes symbols
          var getKeys = require('./_object-keys');var gOPS = require('./_object-gops');var pIE = require('./_object-pie');module.exports = function (it) {
               var result = getKeys(it);var getSymbols = gOPS.f;if (getSymbols) {
                    var symbols = getSymbols(it);var isEnum = pIE.f;var i = 0;var key;while (symbols.length > i) {
                         if (isEnum.call(it, key = symbols[i++])) result.push(key);
                    }
               }return result;
          };
     }, { "./_object-gops": 78, "./_object-keys": 81, "./_object-pie": 82 }], 48: [function (require, module, exports) {
          var global = require('./_global');var core = require('./_core');var ctx = require('./_ctx');var hide = require('./_hide');var has = require('./_has');var PROTOTYPE = 'prototype';var $export = function $export(type, name, source) {
               var IS_FORCED = type & $export.F;var IS_GLOBAL = type & $export.G;var IS_STATIC = type & $export.S;var IS_PROTO = type & $export.P;var IS_BIND = type & $export.B;var IS_WRAP = type & $export.W;var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});var expProto = exports[PROTOTYPE];var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];var key, own, out;if (IS_GLOBAL) source = name;for (key in source) {
                    // contains in native
                    own = !IS_FORCED && target && target[key] !== undefined;if (own && has(exports, key)) continue; // export native or passed
                    out = own ? target[key] : source[key]; // prevent global pollution for namespaces
                    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
                    : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
                    : IS_WRAP && target[key] == out ? function (C) {
                         var F = function F(a, b, c) {
                              if (this instanceof C) {
                                   switch (arguments.length) {case 0:
                                             return new C();case 1:
                                             return new C(a);case 2:
                                             return new C(a, b);}return new C(a, b, c);
                              }return C.apply(this, arguments);
                         };F[PROTOTYPE] = C[PROTOTYPE];return F; // make static versions for prototype methods
                    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
                    if (IS_PROTO) {
                         (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
                         if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
                    }
               }
          }; // type bitmap
          $export.F = 1; // forced
          $export.G = 2; // global
          $export.S = 4; // static
          $export.P = 8; // proto
          $export.B = 16; // bind
          $export.W = 32; // wrap
          $export.U = 64; // safe
          $export.R = 128; // real proto method for `library`
          module.exports = $export;
     }, { "./_core": 41, "./_ctx": 42, "./_global": 51, "./_has": 52, "./_hide": 53 }], 49: [function (require, module, exports) {
          module.exports = function (exec) {
               try {
                    return !!exec();
               } catch (e) {
                    return true;
               }
          };
     }, {}], 50: [function (require, module, exports) {
          var ctx = require('./_ctx');var call = require('./_iter-call');var isArrayIter = require('./_is-array-iter');var anObject = require('./_an-object');var toLength = require('./_to-length');var getIterFn = require('./core.get-iterator-method');var BREAK = {};var RETURN = {};var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
               var iterFn = ITERATOR ? function () {
                    return iterable;
               } : getIterFn(iterable);var f = ctx(fn, that, entries ? 2 : 1);var index = 0;var length, step, iterator, result;if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator
               if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
                    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);if (result === BREAK || result === RETURN) return result;
               } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
                    result = call(iterator, f, step.value, entries);if (result === BREAK || result === RETURN) return result;
               }
          };exports.BREAK = BREAK;exports.RETURN = RETURN;
     }, { "./_an-object": 37, "./_ctx": 42, "./_is-array-iter": 58, "./_iter-call": 61, "./_to-length": 100, "./core.get-iterator-method": 107 }], 51: [function (require, module, exports) {
          // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
          var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
          : Function('return this')();if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
     }, {}], 52: [function (require, module, exports) {
          var hasOwnProperty = {}.hasOwnProperty;module.exports = function (it, key) {
               return hasOwnProperty.call(it, key);
          };
     }, {}], 53: [function (require, module, exports) {
          var dP = require('./_object-dp');var createDesc = require('./_property-desc');module.exports = require('./_descriptors') ? function (object, key, value) {
               return dP.f(object, key, createDesc(1, value));
          } : function (object, key, value) {
               object[key] = value;return object;
          };
     }, { "./_descriptors": 44, "./_object-dp": 73, "./_property-desc": 86 }], 54: [function (require, module, exports) {
          var document = require('./_global').document;module.exports = document && document.documentElement;
     }, { "./_global": 51 }], 55: [function (require, module, exports) {
          module.exports = !require('./_descriptors') && !require('./_fails')(function () {
               return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function get() {
                         return 7;
                    } }).a != 7;
          });
     }, { "./_descriptors": 44, "./_dom-create": 45, "./_fails": 49 }], 56: [function (require, module, exports) {
          // fast apply, http://jsperf.lnkit.com/fast-apply/5
          module.exports = function (fn, args, that) {
               var un = that === undefined;switch (args.length) {case 0:
                         return un ? fn() : fn.call(that);case 1:
                         return un ? fn(args[0]) : fn.call(that, args[0]);case 2:
                         return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);case 3:
                         return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);case 4:
                         return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);}return fn.apply(that, args);
          };
     }, {}], 57: [function (require, module, exports) {
          // fallback for non-array-like ES3 and non-enumerable old V8 strings
          var cof = require('./_cof'); // eslint-disable-next-line no-prototype-builtins
          module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
               return cof(it) == 'String' ? it.split('') : Object(it);
          };
     }, { "./_cof": 40 }], 58: [function (require, module, exports) {
          // check on default Array iterator
          var Iterators = require('./_iterators');var ITERATOR = require('./_wks')('iterator');var ArrayProto = Array.prototype;module.exports = function (it) {
               return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
          };
     }, { "./_iterators": 66, "./_wks": 106 }], 59: [function (require, module, exports) {
          // 7.2.2 IsArray(argument)
          var cof = require('./_cof');module.exports = Array.isArray || function isArray(arg) {
               return cof(arg) == 'Array';
          };
     }, { "./_cof": 40 }], 60: [function (require, module, exports) {
          module.exports = function (it) {
               return (typeof it === "undefined" ? "undefined" : _typeof4(it)) === 'object' ? it !== null : typeof it === 'function';
          };
     }, {}], 61: [function (require, module, exports) {
          // call something on iterator step with safe closing on error
          var anObject = require('./_an-object');module.exports = function (iterator, fn, value, entries) {
               try {
                    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
               } catch (e) {
                    var ret = iterator['return'];if (ret !== undefined) anObject(ret.call(iterator));throw e;
               }
          };
     }, { "./_an-object": 37 }], 62: [function (require, module, exports) {
          'use strict';
          var create = require('./_object-create');var descriptor = require('./_property-desc');var setToStringTag = require('./_set-to-string-tag');var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
          require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () {
               return this;
          });module.exports = function (Constructor, NAME, next) {
               Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });setToStringTag(Constructor, NAME + ' Iterator');
          };
     }, { "./_hide": 53, "./_object-create": 72, "./_property-desc": 86, "./_set-to-string-tag": 91, "./_wks": 106 }], 63: [function (require, module, exports) {
          'use strict';
          var LIBRARY = require('./_library');var $export = require('./_export');var redefine = require('./_redefine');var hide = require('./_hide');var Iterators = require('./_iterators');var $iterCreate = require('./_iter-create');var setToStringTag = require('./_set-to-string-tag');var getPrototypeOf = require('./_object-gpo');var ITERATOR = require('./_wks')('iterator');var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
          var FF_ITERATOR = '@@iterator';var KEYS = 'keys';var VALUES = 'values';var returnThis = function returnThis() {
               return this;
          };module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
               $iterCreate(Constructor, NAME, next);var getMethod = function getMethod(kind) {
                    if (!BUGGY && kind in proto) return proto[kind];switch (kind) {case KEYS:
                              return function keys() {
                                   return new Constructor(this, kind);
                              };case VALUES:
                              return function values() {
                                   return new Constructor(this, kind);
                              };}return function entries() {
                         return new Constructor(this, kind);
                    };
               };var TAG = NAME + ' Iterator';var DEF_VALUES = DEFAULT == VALUES;var VALUES_BUG = false;var proto = Base.prototype;var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];var $default = $native || getMethod(DEFAULT);var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;var methods, key, IteratorPrototype; // Fix native
               if ($anyNative) {
                    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                         // Set @@toStringTag to native iterators
                         setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines
                         if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
                    }
               } // fix Array#{values, @@iterator}.name in V8 / FF
               if (DEF_VALUES && $native && $native.name !== VALUES) {
                    VALUES_BUG = true;$default = function values() {
                         return $native.call(this);
                    };
               } // Define iterator
               if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                    hide(proto, ITERATOR, $default);
               } // Plug for library
               Iterators[NAME] = $default;Iterators[TAG] = returnThis;if (DEFAULT) {
                    methods = { values: DEF_VALUES ? $default : getMethod(VALUES), keys: IS_SET ? $default : getMethod(KEYS), entries: $entries };if (FORCED) for (key in methods) {
                         if (!(key in proto)) redefine(proto, key, methods[key]);
                    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
               }return methods;
          };
     }, { "./_export": 48, "./_hide": 53, "./_iter-create": 62, "./_iterators": 66, "./_library": 67, "./_object-gpo": 79, "./_redefine": 88, "./_set-to-string-tag": 91, "./_wks": 106 }], 64: [function (require, module, exports) {
          var ITERATOR = require('./_wks')('iterator');var SAFE_CLOSING = false;try {
               var riter = [7][ITERATOR]();riter['return'] = function () {
                    SAFE_CLOSING = true;
               }; // eslint-disable-next-line no-throw-literal
               Array.from(riter, function () {
                    throw 2;
               });
          } catch (e) {/* empty */}module.exports = function (exec, skipClosing) {
               if (!skipClosing && !SAFE_CLOSING) return false;var safe = false;try {
                    var arr = [7];var iter = arr[ITERATOR]();iter.next = function () {
                         return { done: safe = true };
                    };arr[ITERATOR] = function () {
                         return iter;
                    };exec(arr);
               } catch (e) {/* empty */}return safe;
          };
     }, { "./_wks": 106 }], 65: [function (require, module, exports) {
          module.exports = function (done, value) {
               return { value: value, done: !!done };
          };
     }, {}], 66: [function (require, module, exports) {
          module.exports = {};
     }, {}], 67: [function (require, module, exports) {
          module.exports = true;
     }, {}], 68: [function (require, module, exports) {
          var META = require('./_uid')('meta');var isObject = require('./_is-object');var has = require('./_has');var setDesc = require('./_object-dp').f;var id = 0;var isExtensible = Object.isExtensible || function () {
               return true;
          };var FREEZE = !require('./_fails')(function () {
               return isExtensible(Object.preventExtensions({}));
          });var setMeta = function setMeta(it) {
               setDesc(it, META, { value: { i: 'O' + ++id, // object ID
                         w: {} // weak collections IDs
                    } });
          };var fastKey = function fastKey(it, create) {
               // return primitive with prefix
               if (!isObject(it)) return (typeof it === "undefined" ? "undefined" : _typeof4(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;if (!has(it, META)) {
                    // can't set metadata to uncaught frozen object
                    if (!isExtensible(it)) return 'F'; // not necessary to add metadata
                    if (!create) return 'E'; // add missing metadata
                    setMeta(it); // return object ID
               }return it[META].i;
          };var getWeak = function getWeak(it, create) {
               if (!has(it, META)) {
                    // can't set metadata to uncaught frozen object
                    if (!isExtensible(it)) return true; // not necessary to add metadata
                    if (!create) return false; // add missing metadata
                    setMeta(it); // return hash weak collections IDs
               }return it[META].w;
          }; // add metadata on freeze-family methods calling
          var onFreeze = function onFreeze(it) {
               if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);return it;
          };var meta = module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze };
     }, { "./_fails": 49, "./_has": 52, "./_is-object": 60, "./_object-dp": 73, "./_uid": 103 }], 69: [function (require, module, exports) {
          var global = require('./_global');var macrotask = require('./_task').set;var Observer = global.MutationObserver || global.WebKitMutationObserver;var process = global.process;var Promise = global.Promise;var isNode = require('./_cof')(process) == 'process';module.exports = function () {
               var head, last, notify;var flush = function flush() {
                    var parent, fn;if (isNode && (parent = process.domain)) parent.exit();while (head) {
                         fn = head.fn;head = head.next;try {
                              fn();
                         } catch (e) {
                              if (head) notify();else last = undefined;throw e;
                         }
                    }last = undefined;if (parent) parent.enter();
               }; // Node.js
               if (isNode) {
                    notify = function notify() {
                         process.nextTick(flush);
                    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
               } else if (Observer && !(global.navigator && global.navigator.standalone)) {
                    var toggle = true;var node = document.createTextNode('');new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
                    notify = function notify() {
                         node.data = toggle = !toggle;
                    }; // environments with maybe non-completely correct, but existent Promise
               } else if (Promise && Promise.resolve) {
                    var promise = Promise.resolve();notify = function notify() {
                         promise.then(flush);
                    }; // for other environments - macrotask based on:
                    // - setImmediate
                    // - MessageChannel
                    // - window.postMessag
                    // - onreadystatechange
                    // - setTimeout
               } else {
                    notify = function notify() {
                         // strange IE + webpack dev server bug - use .call(global)
                         macrotask.call(global, flush);
                    };
               }return function (fn) {
                    var task = { fn: fn, next: undefined };if (last) last.next = task;if (!head) {
                         head = task;notify();
                    }last = task;
               };
          };
     }, { "./_cof": 40, "./_global": 51, "./_task": 96 }], 70: [function (require, module, exports) {
          'use strict'; // 25.4.1.5 NewPromiseCapability(C)

          var aFunction = require('./_a-function');function PromiseCapability(C) {
               var resolve, reject;this.promise = new C(function ($$resolve, $$reject) {
                    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');resolve = $$resolve;reject = $$reject;
               });this.resolve = aFunction(resolve);this.reject = aFunction(reject);
          }module.exports.f = function (C) {
               return new PromiseCapability(C);
          };
     }, { "./_a-function": 34 }], 71: [function (require, module, exports) {
          'use strict'; // 19.1.2.1 Object.assign(target, source, ...)

          var getKeys = require('./_object-keys');var gOPS = require('./_object-gops');var pIE = require('./_object-pie');var toObject = require('./_to-object');var IObject = require('./_iobject');var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)
          module.exports = !$assign || require('./_fails')(function () {
               var A = {};var B = {}; // eslint-disable-next-line no-undef
               var S = Symbol();var K = 'abcdefghijklmnopqrst';A[S] = 7;K.split('').forEach(function (k) {
                    B[k] = k;
               });return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
          }) ? function assign(target, source) {
               // eslint-disable-line no-unused-vars
               var T = toObject(target);var aLen = arguments.length;var index = 1;var getSymbols = gOPS.f;var isEnum = pIE.f;while (aLen > index) {
                    var S = IObject(arguments[index++]);var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);var length = keys.length;var j = 0;var key;while (length > j) {
                         if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
                    }
               }return T;
          } : $assign;
     }, { "./_fails": 49, "./_iobject": 57, "./_object-gops": 78, "./_object-keys": 81, "./_object-pie": 82, "./_to-object": 101 }], 72: [function (require, module, exports) {
          // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
          var anObject = require('./_an-object');var dPs = require('./_object-dps');var enumBugKeys = require('./_enum-bug-keys');var IE_PROTO = require('./_shared-key')('IE_PROTO');var Empty = function Empty() {/* empty */};var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype
          var _createDict = function createDict() {
               // Thrash, waste and sodomy: IE GC bug
               var iframe = require('./_dom-create')('iframe');var i = enumBugKeys.length;var lt = '<';var gt = '>';var iframeDocument;iframe.style.display = 'none';require('./_html').appendChild(iframe);iframe.src = 'javascript:'; // eslint-disable-line no-script-url
               // createDict = iframe.contentWindow.Object;
               // html.removeChild(iframe);
               iframeDocument = iframe.contentWindow.document;iframeDocument.open();iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);iframeDocument.close();_createDict = iframeDocument.F;while (i--) {
                    delete _createDict[PROTOTYPE][enumBugKeys[i]];
               }return _createDict();
          };module.exports = Object.create || function create(O, Properties) {
               var result;if (O !== null) {
                    Empty[PROTOTYPE] = anObject(O);result = new Empty();Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill
                    result[IE_PROTO] = O;
               } else result = _createDict();return Properties === undefined ? result : dPs(result, Properties);
          };
     }, { "./_an-object": 37, "./_dom-create": 45, "./_enum-bug-keys": 46, "./_html": 54, "./_object-dps": 74, "./_shared-key": 92 }], 73: [function (require, module, exports) {
          var anObject = require('./_an-object');var IE8_DOM_DEFINE = require('./_ie8-dom-define');var toPrimitive = require('./_to-primitive');var dP = Object.defineProperty;exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
               anObject(O);P = toPrimitive(P, true);anObject(Attributes);if (IE8_DOM_DEFINE) try {
                    return dP(O, P, Attributes);
               } catch (e) {/* empty */}if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');if ('value' in Attributes) O[P] = Attributes.value;return O;
          };
     }, { "./_an-object": 37, "./_descriptors": 44, "./_ie8-dom-define": 55, "./_to-primitive": 102 }], 74: [function (require, module, exports) {
          var dP = require('./_object-dp');var anObject = require('./_an-object');var getKeys = require('./_object-keys');module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
               anObject(O);var keys = getKeys(Properties);var length = keys.length;var i = 0;var P;while (length > i) {
                    dP.f(O, P = keys[i++], Properties[P]);
               }return O;
          };
     }, { "./_an-object": 37, "./_descriptors": 44, "./_object-dp": 73, "./_object-keys": 81 }], 75: [function (require, module, exports) {
          var pIE = require('./_object-pie');var createDesc = require('./_property-desc');var toIObject = require('./_to-iobject');var toPrimitive = require('./_to-primitive');var has = require('./_has');var IE8_DOM_DEFINE = require('./_ie8-dom-define');var gOPD = Object.getOwnPropertyDescriptor;exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
               O = toIObject(O);P = toPrimitive(P, true);if (IE8_DOM_DEFINE) try {
                    return gOPD(O, P);
               } catch (e) {/* empty */}if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
          };
     }, { "./_descriptors": 44, "./_has": 52, "./_ie8-dom-define": 55, "./_object-pie": 82, "./_property-desc": 86, "./_to-iobject": 99, "./_to-primitive": 102 }], 76: [function (require, module, exports) {
          // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
          var toIObject = require('./_to-iobject');var gOPN = require('./_object-gopn').f;var toString = {}.toString;var windowNames = (typeof window === "undefined" ? "undefined" : _typeof4(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];var getWindowNames = function getWindowNames(it) {
               try {
                    return gOPN(it);
               } catch (e) {
                    return windowNames.slice();
               }
          };module.exports.f = function getOwnPropertyNames(it) {
               return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
          };
     }, { "./_object-gopn": 77, "./_to-iobject": 99 }], 77: [function (require, module, exports) {
          // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
          var $keys = require('./_object-keys-internal');var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
               return $keys(O, hiddenKeys);
          };
     }, { "./_enum-bug-keys": 46, "./_object-keys-internal": 80 }], 78: [function (require, module, exports) {
          exports.f = Object.getOwnPropertySymbols;
     }, {}], 79: [function (require, module, exports) {
          // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
          var has = require('./_has');var toObject = require('./_to-object');var IE_PROTO = require('./_shared-key')('IE_PROTO');var ObjectProto = Object.prototype;module.exports = Object.getPrototypeOf || function (O) {
               O = toObject(O);if (has(O, IE_PROTO)) return O[IE_PROTO];if (typeof O.constructor == 'function' && O instanceof O.constructor) {
                    return O.constructor.prototype;
               }return O instanceof Object ? ObjectProto : null;
          };
     }, { "./_has": 52, "./_shared-key": 92, "./_to-object": 101 }], 80: [function (require, module, exports) {
          var has = require('./_has');var toIObject = require('./_to-iobject');var arrayIndexOf = require('./_array-includes')(false);var IE_PROTO = require('./_shared-key')('IE_PROTO');module.exports = function (object, names) {
               var O = toIObject(object);var i = 0;var result = [];var key;for (key in O) {
                    if (key != IE_PROTO) has(O, key) && result.push(key);
               } // Don't enum bug & hidden keys
               while (names.length > i) {
                    if (has(O, key = names[i++])) {
                         ~arrayIndexOf(result, key) || result.push(key);
                    }
               }return result;
          };
     }, { "./_array-includes": 38, "./_has": 52, "./_shared-key": 92, "./_to-iobject": 99 }], 81: [function (require, module, exports) {
          // 19.1.2.14 / 15.2.3.14 Object.keys(O)
          var $keys = require('./_object-keys-internal');var enumBugKeys = require('./_enum-bug-keys');module.exports = Object.keys || function keys(O) {
               return $keys(O, enumBugKeys);
          };
     }, { "./_enum-bug-keys": 46, "./_object-keys-internal": 80 }], 82: [function (require, module, exports) {
          exports.f = {}.propertyIsEnumerable;
     }, {}], 83: [function (require, module, exports) {
          // most Object methods by ES6 should accept primitives
          var $export = require('./_export');var core = require('./_core');var fails = require('./_fails');module.exports = function (KEY, exec) {
               var fn = (core.Object || {})[KEY] || Object[KEY];var exp = {};exp[KEY] = exec(fn);$export($export.S + $export.F * fails(function () {
                    fn(1);
               }), 'Object', exp);
          };
     }, { "./_core": 41, "./_export": 48, "./_fails": 49 }], 84: [function (require, module, exports) {
          module.exports = function (exec) {
               try {
                    return { e: false, v: exec() };
               } catch (e) {
                    return { e: true, v: e };
               }
          };
     }, {}], 85: [function (require, module, exports) {
          var anObject = require('./_an-object');var isObject = require('./_is-object');var newPromiseCapability = require('./_new-promise-capability');module.exports = function (C, x) {
               anObject(C);if (isObject(x) && x.constructor === C) return x;var promiseCapability = newPromiseCapability.f(C);var resolve = promiseCapability.resolve;resolve(x);return promiseCapability.promise;
          };
     }, { "./_an-object": 37, "./_is-object": 60, "./_new-promise-capability": 70 }], 86: [function (require, module, exports) {
          module.exports = function (bitmap, value) {
               return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value: value };
          };
     }, {}], 87: [function (require, module, exports) {
          var hide = require('./_hide');module.exports = function (target, src, safe) {
               for (var key in src) {
                    if (safe && target[key]) target[key] = src[key];else hide(target, key, src[key]);
               }return target;
          };
     }, { "./_hide": 53 }], 88: [function (require, module, exports) {
          module.exports = require('./_hide');
     }, { "./_hide": 53 }], 89: [function (require, module, exports) {
          // Works with __proto__ only. Old v8 can't work with null proto objects.
          /* eslint-disable no-proto */var isObject = require('./_is-object');var anObject = require('./_an-object');var check = function check(O, proto) {
               anObject(O);if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
          };module.exports = { set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
               function (test, buggy, set) {
                    try {
                         set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);set(test, []);buggy = !(test instanceof Array);
                    } catch (e) {
                         buggy = true;
                    }return function setPrototypeOf(O, proto) {
                         check(O, proto);if (buggy) O.__proto__ = proto;else set(O, proto);return O;
                    };
               }({}, false) : undefined), check: check };
     }, { "./_an-object": 37, "./_ctx": 42, "./_is-object": 60, "./_object-gopd": 75 }], 90: [function (require, module, exports) {
          'use strict';
          var global = require('./_global');var core = require('./_core');var dP = require('./_object-dp');var DESCRIPTORS = require('./_descriptors');var SPECIES = require('./_wks')('species');module.exports = function (KEY) {
               var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, { configurable: true, get: function get() {
                         return this;
                    } });
          };
     }, { "./_core": 41, "./_descriptors": 44, "./_global": 51, "./_object-dp": 73, "./_wks": 106 }], 91: [function (require, module, exports) {
          var def = require('./_object-dp').f;var has = require('./_has');var TAG = require('./_wks')('toStringTag');module.exports = function (it, tag, stat) {
               if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
          };
     }, { "./_has": 52, "./_object-dp": 73, "./_wks": 106 }], 92: [function (require, module, exports) {
          var shared = require('./_shared')('keys');var uid = require('./_uid');module.exports = function (key) {
               return shared[key] || (shared[key] = uid(key));
          };
     }, { "./_shared": 93, "./_uid": 103 }], 93: [function (require, module, exports) {
          var global = require('./_global');var SHARED = '__core-js_shared__';var store = global[SHARED] || (global[SHARED] = {});module.exports = function (key) {
               return store[key] || (store[key] = {});
          };
     }, { "./_global": 51 }], 94: [function (require, module, exports) {
          // 7.3.20 SpeciesConstructor(O, defaultConstructor)
          var anObject = require('./_an-object');var aFunction = require('./_a-function');var SPECIES = require('./_wks')('species');module.exports = function (O, D) {
               var C = anObject(O).constructor;var S;return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
          };
     }, { "./_a-function": 34, "./_an-object": 37, "./_wks": 106 }], 95: [function (require, module, exports) {
          var toInteger = require('./_to-integer');var defined = require('./_defined'); // true  -> String#at
          // false -> String#codePointAt
          module.exports = function (TO_STRING) {
               return function (that, pos) {
                    var s = String(defined(that));var i = toInteger(pos);var l = s.length;var a, b;if (i < 0 || i >= l) return TO_STRING ? '' : undefined;a = s.charCodeAt(i);return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
               };
          };
     }, { "./_defined": 43, "./_to-integer": 98 }], 96: [function (require, module, exports) {
          var ctx = require('./_ctx');var invoke = require('./_invoke');var html = require('./_html');var cel = require('./_dom-create');var global = require('./_global');var process = global.process;var setTask = global.setImmediate;var clearTask = global.clearImmediate;var MessageChannel = global.MessageChannel;var Dispatch = global.Dispatch;var counter = 0;var queue = {};var ONREADYSTATECHANGE = 'onreadystatechange';var defer, channel, port;var run = function run() {
               var id = +this; // eslint-disable-next-line no-prototype-builtins
               if (queue.hasOwnProperty(id)) {
                    var fn = queue[id];delete queue[id];fn();
               }
          };var listener = function listener(event) {
               run.call(event.data);
          }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
          if (!setTask || !clearTask) {
               setTask = function setImmediate(fn) {
                    var args = [];var i = 1;while (arguments.length > i) {
                         args.push(arguments[i++]);
                    }queue[++counter] = function () {
                         // eslint-disable-next-line no-new-func
                         invoke(typeof fn == 'function' ? fn : Function(fn), args);
                    };defer(counter);return counter;
               };clearTask = function clearImmediate(id) {
                    delete queue[id];
               }; // Node.js 0.8-
               if (require('./_cof')(process) == 'process') {
                    defer = function defer(id) {
                         process.nextTick(ctx(run, id, 1));
                    }; // Sphere (JS game engine) Dispatch API
               } else if (Dispatch && Dispatch.now) {
                    defer = function defer(id) {
                         Dispatch.now(ctx(run, id, 1));
                    }; // Browsers with MessageChannel, includes WebWorkers
               } else if (MessageChannel) {
                    channel = new MessageChannel();port = channel.port2;channel.port1.onmessage = listener;defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
                    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
               } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
                    defer = function defer(id) {
                         global.postMessage(id + '', '*');
                    };global.addEventListener('message', listener, false); // IE8-
               } else if (ONREADYSTATECHANGE in cel('script')) {
                    defer = function defer(id) {
                         html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
                              html.removeChild(this);run.call(id);
                         };
                    }; // Rest old browsers
               } else {
                    defer = function defer(id) {
                         setTimeout(ctx(run, id, 1), 0);
                    };
               }
          }module.exports = { set: setTask, clear: clearTask };
     }, { "./_cof": 40, "./_ctx": 42, "./_dom-create": 45, "./_global": 51, "./_html": 54, "./_invoke": 56 }], 97: [function (require, module, exports) {
          var toInteger = require('./_to-integer');var max = Math.max;var min = Math.min;module.exports = function (index, length) {
               index = toInteger(index);return index < 0 ? max(index + length, 0) : min(index, length);
          };
     }, { "./_to-integer": 98 }], 98: [function (require, module, exports) {
          // 7.1.4 ToInteger
          var ceil = Math.ceil;var floor = Math.floor;module.exports = function (it) {
               return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
          };
     }, {}], 99: [function (require, module, exports) {
          // to indexed object, toObject with fallback for non-array-like ES3 strings
          var IObject = require('./_iobject');var defined = require('./_defined');module.exports = function (it) {
               return IObject(defined(it));
          };
     }, { "./_defined": 43, "./_iobject": 57 }], 100: [function (require, module, exports) {
          // 7.1.15 ToLength
          var toInteger = require('./_to-integer');var min = Math.min;module.exports = function (it) {
               return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
          };
     }, { "./_to-integer": 98 }], 101: [function (require, module, exports) {
          // 7.1.13 ToObject(argument)
          var defined = require('./_defined');module.exports = function (it) {
               return Object(defined(it));
          };
     }, { "./_defined": 43 }], 102: [function (require, module, exports) {
          // 7.1.1 ToPrimitive(input [, PreferredType])
          var isObject = require('./_is-object'); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
          // and the second argument - flag - preferred type is a string
          module.exports = function (it, S) {
               if (!isObject(it)) return it;var fn, val;if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;throw TypeError("Can't convert object to primitive value");
          };
     }, { "./_is-object": 60 }], 103: [function (require, module, exports) {
          var id = 0;var px = Math.random();module.exports = function (key) {
               return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
          };
     }, {}], 104: [function (require, module, exports) {
          var global = require('./_global');var core = require('./_core');var LIBRARY = require('./_library');var wksExt = require('./_wks-ext');var defineProperty = require('./_object-dp').f;module.exports = function (name) {
               var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
          };
     }, { "./_core": 41, "./_global": 51, "./_library": 67, "./_object-dp": 73, "./_wks-ext": 105 }], 105: [function (require, module, exports) {
          exports.f = require('./_wks');
     }, { "./_wks": 106 }], 106: [function (require, module, exports) {
          var store = require('./_shared')('wks');var uid = require('./_uid');var _Symbol = require('./_global').Symbol;var USE_SYMBOL = typeof _Symbol == 'function';var $exports = module.exports = function (name) {
               return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
          };$exports.store = store;
     }, { "./_global": 51, "./_shared": 93, "./_uid": 103 }], 107: [function (require, module, exports) {
          var classof = require('./_classof');var ITERATOR = require('./_wks')('iterator');var Iterators = require('./_iterators');module.exports = require('./_core').getIteratorMethod = function (it) {
               if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
          };
     }, { "./_classof": 39, "./_core": 41, "./_iterators": 66, "./_wks": 106 }], 108: [function (require, module, exports) {
          'use strict';
          var addToUnscopables = require('./_add-to-unscopables');var step = require('./_iter-step');var Iterators = require('./_iterators');var toIObject = require('./_to-iobject'); // 22.1.3.4 Array.prototype.entries()
          // 22.1.3.13 Array.prototype.keys()
          // 22.1.3.29 Array.prototype.values()
          // 22.1.3.30 Array.prototype[@@iterator]()
          module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
               this._t = toIObject(iterated); // target
               this._i = 0; // next index
               this._k = kind; // kind
               // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
          }, function () {
               var O = this._t;var kind = this._k;var index = this._i++;if (!O || index >= O.length) {
                    this._t = undefined;return step(1);
               }if (kind == 'keys') return step(0, index);if (kind == 'values') return step(0, O[index]);return step(0, [index, O[index]]);
          }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
          Iterators.Arguments = Iterators.Array;addToUnscopables('keys');addToUnscopables('values');addToUnscopables('entries');
     }, { "./_add-to-unscopables": 35, "./_iter-define": 63, "./_iter-step": 65, "./_iterators": 66, "./_to-iobject": 99 }], 109: [function (require, module, exports) {
          // 20.2.2.21 Math.log10(x)
          var $export = require('./_export');$export($export.S, 'Math', { log10: function log10(x) {
                    return Math.log(x) * Math.LOG10E;
               } });
     }, { "./_export": 48 }], 110: [function (require, module, exports) {
          // 20.1.2.2 Number.isFinite(number)
          var $export = require('./_export');var _isFinite = require('./_global').isFinite;$export($export.S, 'Number', { isFinite: function isFinite(it) {
                    return typeof it == 'number' && _isFinite(it);
               } });
     }, { "./_export": 48, "./_global": 51 }], 111: [function (require, module, exports) {
          // 19.1.3.1 Object.assign(target, source)
          var $export = require('./_export');$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });
     }, { "./_export": 48, "./_object-assign": 71 }], 112: [function (require, module, exports) {
          var $export = require('./_export'); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
          $export($export.S, 'Object', { create: require('./_object-create') });
     }, { "./_export": 48, "./_object-create": 72 }], 113: [function (require, module, exports) {
          var $export = require('./_export'); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
          $export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });
     }, { "./_descriptors": 44, "./_export": 48, "./_object-dp": 73 }], 114: [function (require, module, exports) {
          // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
          var toIObject = require('./_to-iobject');var $getOwnPropertyDescriptor = require('./_object-gopd').f;require('./_object-sap')('getOwnPropertyDescriptor', function () {
               return function getOwnPropertyDescriptor(it, key) {
                    return $getOwnPropertyDescriptor(toIObject(it), key);
               };
          });
     }, { "./_object-gopd": 75, "./_object-sap": 83, "./_to-iobject": 99 }], 115: [function (require, module, exports) {
          // 19.1.2.9 Object.getPrototypeOf(O)
          var toObject = require('./_to-object');var $getPrototypeOf = require('./_object-gpo');require('./_object-sap')('getPrototypeOf', function () {
               return function getPrototypeOf(it) {
                    return $getPrototypeOf(toObject(it));
               };
          });
     }, { "./_object-gpo": 79, "./_object-sap": 83, "./_to-object": 101 }], 116: [function (require, module, exports) {
          // 19.1.3.19 Object.setPrototypeOf(O, proto)
          var $export = require('./_export');$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });
     }, { "./_export": 48, "./_set-proto": 89 }], 117: [function (require, module, exports) {}, {}], 118: [function (require, module, exports) {
          'use strict';
          var LIBRARY = require('./_library');var global = require('./_global');var ctx = require('./_ctx');var classof = require('./_classof');var $export = require('./_export');var isObject = require('./_is-object');var aFunction = require('./_a-function');var anInstance = require('./_an-instance');var forOf = require('./_for-of');var speciesConstructor = require('./_species-constructor');var task = require('./_task').set;var microtask = require('./_microtask')();var newPromiseCapabilityModule = require('./_new-promise-capability');var perform = require('./_perform');var promiseResolve = require('./_promise-resolve');var PROMISE = 'Promise';var TypeError = global.TypeError;var process = global.process;var $Promise = global[PROMISE];var isNode = classof(process) == 'process';var empty = function empty() {/* empty */};var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;var USE_NATIVE = !!function () {
               try {
                    // correct subclassing with @@species support
                    var promise = $Promise.resolve(1);var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
                         exec(empty, empty);
                    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
                    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
               } catch (e) {/* empty */}
          }(); // helpers
          var isThenable = function isThenable(it) {
               var then;return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
          };var notify = function notify(promise, isReject) {
               if (promise._n) return;promise._n = true;var chain = promise._c;microtask(function () {
                    var value = promise._v;var ok = promise._s == 1;var i = 0;var run = function run(reaction) {
                         var handler = ok ? reaction.ok : reaction.fail;var resolve = reaction.resolve;var reject = reaction.reject;var domain = reaction.domain;var result, then, exited;try {
                              if (handler) {
                                   if (!ok) {
                                        if (promise._h == 2) onHandleUnhandled(promise);promise._h = 1;
                                   }if (handler === true) result = value;else {
                                        if (domain) domain.enter();result = handler(value); // may throw
                                        if (domain) {
                                             domain.exit();exited = true;
                                        }
                                   }if (result === reaction.promise) {
                                        reject(TypeError('Promise-chain cycle'));
                                   } else if (then = isThenable(result)) {
                                        then.call(result, resolve, reject);
                                   } else resolve(result);
                              } else reject(value);
                         } catch (e) {
                              if (domain && !exited) domain.exit();reject(e);
                         }
                    };while (chain.length > i) {
                         run(chain[i++]);
                    } // variable length - can't use forEach
                    promise._c = [];promise._n = false;if (isReject && !promise._h) onUnhandled(promise);
               });
          };var onUnhandled = function onUnhandled(promise) {
               task.call(global, function () {
                    var value = promise._v;var unhandled = isUnhandled(promise);var result, handler, console;if (unhandled) {
                         result = perform(function () {
                              if (isNode) {
                                   process.emit('unhandledRejection', value, promise);
                              } else if (handler = global.onunhandledrejection) {
                                   handler({ promise: promise, reason: value });
                              } else if ((console = global.console) && console.error) {
                                   console.error('Unhandled promise rejection', value);
                              }
                         }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
                         promise._h = isNode || isUnhandled(promise) ? 2 : 1;
                    }promise._a = undefined;if (unhandled && result.e) throw result.v;
               });
          };var isUnhandled = function isUnhandled(promise) {
               return promise._h !== 1 && (promise._a || promise._c).length === 0;
          };var onHandleUnhandled = function onHandleUnhandled(promise) {
               task.call(global, function () {
                    var handler;if (isNode) {
                         process.emit('rejectionHandled', promise);
                    } else if (handler = global.onrejectionhandled) {
                         handler({ promise: promise, reason: promise._v });
                    }
               });
          };var $reject = function $reject(value) {
               var promise = this;if (promise._d) return;promise._d = true;promise = promise._w || promise; // unwrap
               promise._v = value;promise._s = 2;if (!promise._a) promise._a = promise._c.slice();notify(promise, true);
          };var $resolve = function $resolve(value) {
               var promise = this;var then;if (promise._d) return;promise._d = true;promise = promise._w || promise; // unwrap
               try {
                    if (promise === value) throw TypeError("Promise can't be resolved itself");if (then = isThenable(value)) {
                         microtask(function () {
                              var wrapper = { _w: promise, _d: false }; // wrap
                              try {
                                   then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
                              } catch (e) {
                                   $reject.call(wrapper, e);
                              }
                         });
                    } else {
                         promise._v = value;promise._s = 1;notify(promise, false);
                    }
               } catch (e) {
                    $reject.call({ _w: promise, _d: false }, e); // wrap
               }
          }; // constructor polyfill
          if (!USE_NATIVE) {
               // 25.4.3.1 Promise(executor)
               $Promise = function Promise(executor) {
                    anInstance(this, $Promise, PROMISE, '_h');aFunction(executor);Internal.call(this);try {
                         executor(ctx($resolve, this, 1), ctx($reject, this, 1));
                    } catch (err) {
                         $reject.call(this, err);
                    }
               }; // eslint-disable-next-line no-unused-vars
               Internal = function Promise(executor) {
                    this._c = []; // <- awaiting reactions
                    this._a = undefined; // <- checked in isUnhandled reactions
                    this._s = 0; // <- state
                    this._d = false; // <- done
                    this._v = undefined; // <- value
                    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
                    this._n = false; // <- notify
               };Internal.prototype = require('./_redefine-all')($Promise.prototype, { // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
                    then: function then(onFulfilled, onRejected) {
                         var reaction = newPromiseCapability(speciesConstructor(this, $Promise));reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;reaction.fail = typeof onRejected == 'function' && onRejected;reaction.domain = isNode ? process.domain : undefined;this._c.push(reaction);if (this._a) this._a.push(reaction);if (this._s) notify(this, false);return reaction.promise;
                    }, // 25.4.5.1 Promise.prototype.catch(onRejected)
                    'catch': function _catch(onRejected) {
                         return this.then(undefined, onRejected);
                    } });OwnPromiseCapability = function OwnPromiseCapability() {
                    var promise = new Internal();this.promise = promise;this.resolve = ctx($resolve, promise, 1);this.reject = ctx($reject, promise, 1);
               };newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
                    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
               };
          }$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });require('./_set-to-string-tag')($Promise, PROMISE);require('./_set-species')(PROMISE);Wrapper = require('./_core')[PROMISE]; // statics
          $export($export.S + $export.F * !USE_NATIVE, PROMISE, { // 25.4.4.5 Promise.reject(r)
               reject: function reject(r) {
                    var capability = newPromiseCapability(this);var $$reject = capability.reject;$$reject(r);return capability.promise;
               } });$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, { // 25.4.4.6 Promise.resolve(x)
               resolve: function resolve(x) {
                    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
               } });$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
               $Promise.all(iter)['catch'](empty);
          })), PROMISE, { // 25.4.4.1 Promise.all(iterable)
               all: function all(iterable) {
                    var C = this;var capability = newPromiseCapability(C);var resolve = capability.resolve;var reject = capability.reject;var result = perform(function () {
                         var values = [];var index = 0;var remaining = 1;forOf(iterable, false, function (promise) {
                              var $index = index++;var alreadyCalled = false;values.push(undefined);remaining++;C.resolve(promise).then(function (value) {
                                   if (alreadyCalled) return;alreadyCalled = true;values[$index] = value;--remaining || resolve(values);
                              }, reject);
                         });--remaining || resolve(values);
                    });if (result.e) reject(result.v);return capability.promise;
               }, // 25.4.4.4 Promise.race(iterable)
               race: function race(iterable) {
                    var C = this;var capability = newPromiseCapability(C);var reject = capability.reject;var result = perform(function () {
                         forOf(iterable, false, function (promise) {
                              C.resolve(promise).then(capability.resolve, reject);
                         });
                    });if (result.e) reject(result.v);return capability.promise;
               } });
     }, { "./_a-function": 34, "./_an-instance": 36, "./_classof": 39, "./_core": 41, "./_ctx": 42, "./_export": 48, "./_for-of": 50, "./_global": 51, "./_is-object": 60, "./_iter-detect": 64, "./_library": 67, "./_microtask": 69, "./_new-promise-capability": 70, "./_perform": 84, "./_promise-resolve": 85, "./_redefine-all": 87, "./_set-species": 90, "./_set-to-string-tag": 91, "./_species-constructor": 94, "./_task": 96, "./_wks": 106 }], 119: [function (require, module, exports) {
          'use strict';
          var $at = require('./_string-at')(true); // 21.1.3.27 String.prototype[@@iterator]()
          require('./_iter-define')(String, 'String', function (iterated) {
               this._t = String(iterated); // target
               this._i = 0; // next index
               // 21.1.5.2.1 %StringIteratorPrototype%.next()
          }, function () {
               var O = this._t;var index = this._i;var point;if (index >= O.length) return { value: undefined, done: true };point = $at(O, index);this._i += point.length;return { value: point, done: false };
          });
     }, { "./_iter-define": 63, "./_string-at": 95 }], 120: [function (require, module, exports) {
          'use strict'; // ECMAScript 6 symbols shim

          var global = require('./_global');var has = require('./_has');var DESCRIPTORS = require('./_descriptors');var $export = require('./_export');var redefine = require('./_redefine');var META = require('./_meta').KEY;var $fails = require('./_fails');var shared = require('./_shared');var setToStringTag = require('./_set-to-string-tag');var uid = require('./_uid');var wks = require('./_wks');var wksExt = require('./_wks-ext');var wksDefine = require('./_wks-define');var enumKeys = require('./_enum-keys');var isArray = require('./_is-array');var anObject = require('./_an-object');var isObject = require('./_is-object');var toIObject = require('./_to-iobject');var toPrimitive = require('./_to-primitive');var createDesc = require('./_property-desc');var _create = require('./_object-create');var gOPNExt = require('./_object-gopn-ext');var $GOPD = require('./_object-gopd');var $DP = require('./_object-dp');var $keys = require('./_object-keys');var gOPD = $GOPD.f;var dP = $DP.f;var gOPN = gOPNExt.f;var $Symbol = global.Symbol;var $JSON = global.JSON;var _stringify = $JSON && $JSON.stringify;var PROTOTYPE = 'prototype';var HIDDEN = wks('_hidden');var TO_PRIMITIVE = wks('toPrimitive');var isEnum = {}.propertyIsEnumerable;var SymbolRegistry = shared('symbol-registry');var AllSymbols = shared('symbols');var OPSymbols = shared('op-symbols');var ObjectProto = Object[PROTOTYPE];var USE_NATIVE = typeof $Symbol == 'function';var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
          var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
          var setSymbolDesc = DESCRIPTORS && $fails(function () {
               return _create(dP({}, 'a', { get: function get() {
                         return dP(this, 'a', { value: 7 }).a;
                    } })).a != 7;
          }) ? function (it, key, D) {
               var protoDesc = gOPD(ObjectProto, key);if (protoDesc) delete ObjectProto[key];dP(it, key, D);if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
          } : dP;var wrap = function wrap(tag) {
               var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);sym._k = tag;return sym;
          };var isSymbol = USE_NATIVE && _typeof4($Symbol.iterator) == 'symbol' ? function (it) {
               return (typeof it === "undefined" ? "undefined" : _typeof4(it)) == 'symbol';
          } : function (it) {
               return it instanceof $Symbol;
          };var $defineProperty = function defineProperty(it, key, D) {
               if (it === ObjectProto) $defineProperty(OPSymbols, key, D);anObject(it);key = toPrimitive(key, true);anObject(D);if (has(AllSymbols, key)) {
                    if (!D.enumerable) {
                         if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));it[HIDDEN][key] = true;
                    } else {
                         if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;D = _create(D, { enumerable: createDesc(0, false) });
                    }return setSymbolDesc(it, key, D);
               }return dP(it, key, D);
          };var $defineProperties = function defineProperties(it, P) {
               anObject(it);var keys = enumKeys(P = toIObject(P));var i = 0;var l = keys.length;var key;while (l > i) {
                    $defineProperty(it, key = keys[i++], P[key]);
               }return it;
          };var $create = function create(it, P) {
               return P === undefined ? _create(it) : $defineProperties(_create(it), P);
          };var $propertyIsEnumerable = function propertyIsEnumerable(key) {
               var E = isEnum.call(this, key = toPrimitive(key, true));if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
          };var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
               it = toIObject(it);key = toPrimitive(key, true);if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;var D = gOPD(it, key);if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;return D;
          };var $getOwnPropertyNames = function getOwnPropertyNames(it) {
               var names = gOPN(toIObject(it));var result = [];var i = 0;var key;while (names.length > i) {
                    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
               }return result;
          };var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
               var IS_OP = it === ObjectProto;var names = gOPN(IS_OP ? OPSymbols : toIObject(it));var result = [];var i = 0;var key;while (names.length > i) {
                    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
               }return result;
          }; // 19.4.1.1 Symbol([description])
          if (!USE_NATIVE) {
               $Symbol = function _Symbol2() {
                    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');var tag = uid(arguments.length > 0 ? arguments[0] : undefined);var $set = function $set(value) {
                         if (this === ObjectProto) $set.call(OPSymbols, value);if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;setSymbolDesc(this, tag, createDesc(1, value));
                    };if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });return wrap(tag);
               };redefine($Symbol[PROTOTYPE], 'toString', function toString() {
                    return this._k;
               });$GOPD.f = $getOwnPropertyDescriptor;$DP.f = $defineProperty;require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;require('./_object-pie').f = $propertyIsEnumerable;require('./_object-gops').f = $getOwnPropertySymbols;if (DESCRIPTORS && !require('./_library')) {
                    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
               }wksExt.f = function (name) {
                    return wrap(wks(name));
               };
          }$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
          'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
               wks(es6Symbols[j++]);
          }for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
               wksDefine(wellKnownSymbols[k++]);
          }$export($export.S + $export.F * !USE_NATIVE, 'Symbol', { // 19.4.2.1 Symbol.for(key)
               'for': function _for(key) {
                    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
               }, // 19.4.2.5 Symbol.keyFor(sym)
               keyFor: function keyFor(sym) {
                    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');for (var key in SymbolRegistry) {
                         if (SymbolRegistry[key] === sym) return key;
                    }
               }, useSetter: function useSetter() {
                    setter = true;
               }, useSimple: function useSimple() {
                    setter = false;
               } });$export($export.S + $export.F * !USE_NATIVE, 'Object', { // 19.1.2.2 Object.create(O [, Properties])
               create: $create, // 19.1.2.4 Object.defineProperty(O, P, Attributes)
               defineProperty: $defineProperty, // 19.1.2.3 Object.defineProperties(O, Properties)
               defineProperties: $defineProperties, // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
               getOwnPropertyDescriptor: $getOwnPropertyDescriptor, // 19.1.2.7 Object.getOwnPropertyNames(O)
               getOwnPropertyNames: $getOwnPropertyNames, // 19.1.2.8 Object.getOwnPropertySymbols(O)
               getOwnPropertySymbols: $getOwnPropertySymbols }); // 24.3.2 JSON.stringify(value [, replacer [, space]])
          $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
               var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
               // WebKit converts symbol values to JSON as null
               // V8 throws on boxed symbols
               return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
          })), 'JSON', { stringify: function stringify(it) {
                    var args = [it];var i = 1;var replacer, $replacer;while (arguments.length > i) {
                         args.push(arguments[i++]);
                    }$replacer = replacer = args[1];if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
                    if (!isArray(replacer)) replacer = function replacer(key, value) {
                         if (typeof $replacer == 'function') value = $replacer.call(this, key, value);if (!isSymbol(value)) return value;
                    };args[1] = replacer;return _stringify.apply($JSON, args);
               } }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
          $Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]
          setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]
          setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]
          setToStringTag(global.JSON, 'JSON', true);
     }, { "./_an-object": 37, "./_descriptors": 44, "./_enum-keys": 47, "./_export": 48, "./_fails": 49, "./_global": 51, "./_has": 52, "./_hide": 53, "./_is-array": 59, "./_is-object": 60, "./_library": 67, "./_meta": 68, "./_object-create": 72, "./_object-dp": 73, "./_object-gopd": 75, "./_object-gopn": 77, "./_object-gopn-ext": 76, "./_object-gops": 78, "./_object-keys": 81, "./_object-pie": 82, "./_property-desc": 86, "./_redefine": 88, "./_set-to-string-tag": 91, "./_shared": 93, "./_to-iobject": 99, "./_to-primitive": 102, "./_uid": 103, "./_wks": 106, "./_wks-define": 104, "./_wks-ext": 105 }], 121: [function (require, module, exports) {
          // https://github.com/tc39/proposal-promise-finally
          'use strict';
          var $export = require('./_export');var core = require('./_core');var global = require('./_global');var speciesConstructor = require('./_species-constructor');var promiseResolve = require('./_promise-resolve');$export($export.P + $export.R, 'Promise', { 'finally': function _finally(onFinally) {
                    var C = speciesConstructor(this, core.Promise || global.Promise);var isFunction = typeof onFinally == 'function';return this.then(isFunction ? function (x) {
                         return promiseResolve(C, onFinally()).then(function () {
                              return x;
                         });
                    } : onFinally, isFunction ? function (e) {
                         return promiseResolve(C, onFinally()).then(function () {
                              throw e;
                         });
                    } : onFinally);
               } });
     }, { "./_core": 41, "./_export": 48, "./_global": 51, "./_promise-resolve": 85, "./_species-constructor": 94 }], 122: [function (require, module, exports) {
          'use strict'; // https://github.com/tc39/proposal-promise-try

          var $export = require('./_export');var newPromiseCapability = require('./_new-promise-capability');var perform = require('./_perform');$export($export.S, 'Promise', { 'try': function _try(callbackfn) {
                    var promiseCapability = newPromiseCapability.f(this);var result = perform(callbackfn);(result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);return promiseCapability.promise;
               } });
     }, { "./_export": 48, "./_new-promise-capability": 70, "./_perform": 84 }], 123: [function (require, module, exports) {
          require('./_wks-define')('asyncIterator');
     }, { "./_wks-define": 104 }], 124: [function (require, module, exports) {
          require('./_wks-define')('observable');
     }, { "./_wks-define": 104 }], 125: [function (require, module, exports) {
          require('./es6.array.iterator');var global = require('./_global');var hide = require('./_hide');var Iterators = require('./_iterators');var TO_STRING_TAG = require('./_wks')('toStringTag');var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(',');for (var i = 0; i < DOMIterables.length; i++) {
               var NAME = DOMIterables[i];var Collection = global[NAME];var proto = Collection && Collection.prototype;if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);Iterators[NAME] = Iterators.Array;
          }
     }, { "./_global": 51, "./_hide": 53, "./_iterators": 66, "./_wks": 106, "./es6.array.iterator": 108 }], 126: [function (require, module, exports) {
          'use strict';
          var hasOwn = Object.prototype.hasOwnProperty;var toStr = Object.prototype.toString;var isArray = function isArray(arr) {
               if (typeof Array.isArray === 'function') {
                    return Array.isArray(arr);
               }return toStr.call(arr) === '[object Array]';
          };var isPlainObject = function isPlainObject(obj) {
               if (!obj || toStr.call(obj) !== '[object Object]') {
                    return false;
               }var hasOwnConstructor = hasOwn.call(obj, 'constructor');var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf'); // Not own constructor property must be Object
               if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                    return false;
               } // Own properties are enumerated firstly, so to speed up,
               // if last one is own, then all properties are own.
               var key;for (key in obj) {/**/}return typeof key === 'undefined' || hasOwn.call(obj, key);
          };module.exports = function extend() {
               var options, name, src, copy, copyIsArray, clone;var target = arguments[0];var i = 1;var length = arguments.length;var deep = false; // Handle a deep copy situation
               if (typeof target === 'boolean') {
                    deep = target;target = arguments[1] || {}; // skip the boolean and the target
                    i = 2;
               }if (target == null || (typeof target === "undefined" ? "undefined" : _typeof4(target)) !== 'object' && typeof target !== 'function') {
                    target = {};
               }for (; i < length; ++i) {
                    options = arguments[i]; // Only deal with non-null/undefined values
                    if (options != null) {
                         // Extend the base object
                         for (name in options) {
                              src = target[name];copy = options[name]; // Prevent never-ending loop
                              if (target !== copy) {
                                   // Recurse if we're merging plain objects or arrays
                                   if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                                        if (copyIsArray) {
                                             copyIsArray = false;clone = src && isArray(src) ? src : [];
                                        } else {
                                             clone = src && isPlainObject(src) ? src : {};
                                        } // Never move original objects, clone them
                                        target[name] = extend(deep, clone, copy); // Don't bring in undefined values
                                   } else if (typeof copy !== 'undefined') {
                                        target[name] = copy;
                                   }
                              }
                         }
                    }
               } // Return the modified object
               return target;
          };
     }, {}], 127: [function (require, module, exports) {
          'use strict'; /**
                        * Computes the maximum of the given values
                        * @param {Array<number>} input
                        * @return {number}
                        */
          function max(input) {
               if (!Array.isArray(input)) {
                    throw new Error('input must be an array');
               }if (input.length === 0) {
                    throw new Error('input must not be empty');
               }var max = input[0];for (var i = 1; i < input.length; i++) {
                    if (input[i] > max) max = input[i];
               }return max;
          }module.exports = max;
     }, {}], 128: [function (require, module, exports) {
          'use strict'; /**
                        * Computes the minimum of the given values
                        * @param {Array<number>} input
                        * @return {number}
                        */
          function min(input) {
               if (!Array.isArray(input)) {
                    throw new Error('input must be an array');
               }if (input.length === 0) {
                    throw new Error('input must not be empty');
               }var min = input[0];for (var i = 1; i < input.length; i++) {
                    if (input[i] < min) min = input[i];
               }return min;
          }module.exports = min;
     }, {}], 129: [function (require, module, exports) {
          'use strict';
          function _interopDefault(ex) {
               return ex && (typeof ex === "undefined" ? "undefined" : _typeof4(ex)) === 'object' && 'default' in ex ? ex['default'] : ex;
          }var max = _interopDefault(require('ml-array-max'));var min = _interopDefault(require('ml-array-min'));function rescale(input) {
               var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};if (!Array.isArray(input)) {
                    throw new TypeError('input must be an array');
               } else if (input.length === 0) {
                    throw new TypeError('input must not be empty');
               }var output = void 0;if (options.output !== undefined) {
                    if (!Array.isArray(options.output)) {
                         throw new TypeError('output option must be an array if specified');
                    }output = options.output;
               } else {
                    output = new Array(input.length);
               }var currentMin = min(input);var currentMax = max(input);if (currentMin === currentMax) {
                    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
               }var _options$min = options.min,
                   minValue = _options$min === undefined ? options.autoMinMax ? currentMin : 0 : _options$min,
                   _options$max = options.max,
                   maxValue = _options$max === undefined ? options.autoMinMax ? currentMax : 1 : _options$max;if (minValue >= maxValue) {
                    throw new RangeError('min option must be smaller than max option');
               }var factor = (maxValue - minValue) / (currentMax - currentMin);for (var i = 0; i < input.length; i++) {
                    output[i] = (input[i] - currentMin) * factor + minValue;
               }return output;
          }module.exports = rescale;
     }, { "ml-array-max": 127, "ml-array-min": 128 }], 130: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });function _interopDefault(ex) {
               return ex && (typeof ex === "undefined" ? "undefined" : _typeof4(ex)) === 'object' && 'default' in ex ? ex['default'] : ex;
          }var rescale = _interopDefault(require('ml-array-rescale'));if (!Symbol.species) {
               Symbol.species = Symbol.for('@@species');
          } /**
            * @class LuDecomposition
            * @link https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs
            * @param {Matrix} matrix
            */var LuDecomposition$$1 = function () {
               function LuDecomposition$$1(matrix) {
                    _classCallCheck4(this, LuDecomposition$$1);matrix = WrapperMatrix2D.checkMatrix(matrix);var lu = matrix.clone();var rows = lu.rows;var columns = lu.columns;var pivotVector = new Array(rows);var pivotSign = 1;var i, j, k, p, s, t, v;var LUcolj, kmax;for (i = 0; i < rows; i++) {
                         pivotVector[i] = i;
                    }LUcolj = new Array(rows);for (j = 0; j < columns; j++) {
                         for (i = 0; i < rows; i++) {
                              LUcolj[i] = lu.get(i, j);
                         }for (i = 0; i < rows; i++) {
                              kmax = Math.min(i, j);s = 0;for (k = 0; k < kmax; k++) {
                                   s += lu.get(i, k) * LUcolj[k];
                              }LUcolj[i] -= s;lu.set(i, j, LUcolj[i]);
                         }p = j;for (i = j + 1; i < rows; i++) {
                              if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
                                   p = i;
                              }
                         }if (p !== j) {
                              for (k = 0; k < columns; k++) {
                                   t = lu.get(p, k);lu.set(p, k, lu.get(j, k));lu.set(j, k, t);
                              }v = pivotVector[p];pivotVector[p] = pivotVector[j];pivotVector[j] = v;pivotSign = -pivotSign;
                         }if (j < rows && lu.get(j, j) !== 0) {
                              for (i = j + 1; i < rows; i++) {
                                   lu.set(i, j, lu.get(i, j) / lu.get(j, j));
                              }
                         }
                    }this.LU = lu;this.pivotVector = pivotVector;this.pivotSign = pivotSign;
               } /**
                 *
                 * @return {boolean}
                 */_createClass4(LuDecomposition$$1, [{ key: "isSingular", value: function isSingular() {
                         var data = this.LU;var col = data.columns;for (var j = 0; j < col; j++) {
                              if (data[j][j] === 0) {
                                   return true;
                              }
                         }return false;
                    } /**
                      *
                      * @param {Matrix} value
                      * @return {Matrix}
                      */ }, { key: "solve", value: function solve(value) {
                         value = Matrix.checkMatrix(value);var lu = this.LU;var rows = lu.rows;if (rows !== value.rows) {
                              throw new Error('Invalid matrix dimensions');
                         }if (this.isSingular()) {
                              throw new Error('LU matrix is singular');
                         }var count = value.columns;var X = value.subMatrixRow(this.pivotVector, 0, count - 1);var columns = lu.columns;var i, j, k;for (k = 0; k < columns; k++) {
                              for (i = k + 1; i < columns; i++) {
                                   for (j = 0; j < count; j++) {
                                        X[i][j] -= X[k][j] * lu[i][k];
                                   }
                              }
                         }for (k = columns - 1; k >= 0; k--) {
                              for (j = 0; j < count; j++) {
                                   X[k][j] /= lu[k][k];
                              }for (i = 0; i < k; i++) {
                                   for (j = 0; j < count; j++) {
                                        X[i][j] -= X[k][j] * lu[i][k];
                                   }
                              }
                         }return X;
                    } /**
                      *
                      * @return {number}
                      */ }, { key: "determinant", get: function get() {
                         var data = this.LU;if (!data.isSquare()) {
                              throw new Error('Matrix must be square');
                         }var determinant = this.pivotSign;var col = data.columns;for (var j = 0; j < col; j++) {
                              determinant *= data[j][j];
                         }return determinant;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "lowerTriangularMatrix", get: function get() {
                         var data = this.LU;var rows = data.rows;var columns = data.columns;var X = new Matrix(rows, columns);for (var i = 0; i < rows; i++) {
                              for (var j = 0; j < columns; j++) {
                                   if (i > j) {
                                        X[i][j] = data[i][j];
                                   } else if (i === j) {
                                        X[i][j] = 1;
                                   } else {
                                        X[i][j] = 0;
                                   }
                              }
                         }return X;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "upperTriangularMatrix", get: function get() {
                         var data = this.LU;var rows = data.rows;var columns = data.columns;var X = new Matrix(rows, columns);for (var i = 0; i < rows; i++) {
                              for (var j = 0; j < columns; j++) {
                                   if (i <= j) {
                                        X[i][j] = data[i][j];
                                   } else {
                                        X[i][j] = 0;
                                   }
                              }
                         }return X;
                    } /**
                      *
                      * @return {Array<number>}
                      */ }, { key: "pivotPermutationVector", get: function get() {
                         return this.pivotVector.slice();
                    } }]);return LuDecomposition$$1;
          }();function hypotenuse(a, b) {
               var r = 0;if (Math.abs(a) > Math.abs(b)) {
                    r = b / a;return Math.abs(a) * Math.sqrt(1 + r * r);
               }if (b !== 0) {
                    r = a / b;return Math.abs(b) * Math.sqrt(1 + r * r);
               }return 0;
          }function getFilled2DArray(rows, columns, value) {
               var array = new Array(rows);for (var i = 0; i < rows; i++) {
                    array[i] = new Array(columns);for (var j = 0; j < columns; j++) {
                         array[i][j] = value;
                    }
               }return array;
          } /**
            * @class SingularValueDecomposition
            * @link https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs
            * @param {Matrix} value
            * @param {object} [options]
            * @param {boolean} [options.computeLeftSingularVectors=true]
            * @param {boolean} [options.computeRightSingularVectors=true]
            * @param {boolean} [options.autoTranspose=false]
            */var SingularValueDecomposition$$1 = function () {
               function SingularValueDecomposition$$1(value) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck4(this, SingularValueDecomposition$$1);value = WrapperMatrix2D.checkMatrix(value);var m = value.rows;var n = value.columns;var nu = Math.min(m, n);var _options$computeLeftS = options.computeLeftSingularVectors,
                        computeLeftSingularVectors = _options$computeLeftS === undefined ? true : _options$computeLeftS,
                        _options$computeRight = options.computeRightSingularVectors,
                        computeRightSingularVectors = _options$computeRight === undefined ? true : _options$computeRight,
                        _options$autoTranspos = options.autoTranspose,
                        autoTranspose = _options$autoTranspos === undefined ? false : _options$autoTranspos;var wantu = Boolean(computeLeftSingularVectors);var wantv = Boolean(computeRightSingularVectors);var swapped = false;var a;if (m < n) {
                         if (!autoTranspose) {
                              a = value.clone(); // eslint-disable-next-line no-console
                              console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');
                         } else {
                              a = value.transpose();m = a.rows;n = a.columns;swapped = true;var aux = wantu;wantu = wantv;wantv = aux;
                         }
                    } else {
                         a = value.clone();
                    }var s = new Array(Math.min(m + 1, n));var U = getFilled2DArray(m, nu, 0);var V = getFilled2DArray(n, n, 0);var e = new Array(n);var work = new Array(m);var nct = Math.min(m - 1, n);var nrt = Math.max(0, Math.min(n - 2, m));var i, j, k, p, t, ks, f, cs, sn, max, kase, scale, sp, spm1, epm1, sk, ek, b, c, shift, g;for (k = 0, max = Math.max(nct, nrt); k < max; k++) {
                         if (k < nct) {
                              s[k] = 0;for (i = k; i < m; i++) {
                                   s[k] = hypotenuse(s[k], a[i][k]);
                              }if (s[k] !== 0) {
                                   if (a[k][k] < 0) {
                                        s[k] = -s[k];
                                   }for (i = k; i < m; i++) {
                                        a[i][k] /= s[k];
                                   }a[k][k] += 1;
                              }s[k] = -s[k];
                         }for (j = k + 1; j < n; j++) {
                              if (k < nct && s[k] !== 0) {
                                   t = 0;for (i = k; i < m; i++) {
                                        t += a[i][k] * a[i][j];
                                   }t = -t / a[k][k];for (i = k; i < m; i++) {
                                        a[i][j] += t * a[i][k];
                                   }
                              }e[j] = a[k][j];
                         }if (wantu && k < nct) {
                              for (i = k; i < m; i++) {
                                   U[i][k] = a[i][k];
                              }
                         }if (k < nrt) {
                              e[k] = 0;for (i = k + 1; i < n; i++) {
                                   e[k] = hypotenuse(e[k], e[i]);
                              }if (e[k] !== 0) {
                                   if (e[k + 1] < 0) {
                                        e[k] = 0 - e[k];
                                   }for (i = k + 1; i < n; i++) {
                                        e[i] /= e[k];
                                   }e[k + 1] += 1;
                              }e[k] = -e[k];if (k + 1 < m && e[k] !== 0) {
                                   for (i = k + 1; i < m; i++) {
                                        work[i] = 0;
                                   }for (j = k + 1; j < n; j++) {
                                        for (i = k + 1; i < m; i++) {
                                             work[i] += e[j] * a[i][j];
                                        }
                                   }for (j = k + 1; j < n; j++) {
                                        t = -e[j] / e[k + 1];for (i = k + 1; i < m; i++) {
                                             a[i][j] += t * work[i];
                                        }
                                   }
                              }if (wantv) {
                                   for (i = k + 1; i < n; i++) {
                                        V[i][k] = e[i];
                                   }
                              }
                         }
                    }p = Math.min(n, m + 1);if (nct < n) {
                         s[nct] = a[nct][nct];
                    }if (m < p) {
                         s[p - 1] = 0;
                    }if (nrt + 1 < p) {
                         e[nrt] = a[nrt][p - 1];
                    }e[p - 1] = 0;if (wantu) {
                         for (j = nct; j < nu; j++) {
                              for (i = 0; i < m; i++) {
                                   U[i][j] = 0;
                              }U[j][j] = 1;
                         }for (k = nct - 1; k >= 0; k--) {
                              if (s[k] !== 0) {
                                   for (j = k + 1; j < nu; j++) {
                                        t = 0;for (i = k; i < m; i++) {
                                             t += U[i][k] * U[i][j];
                                        }t = -t / U[k][k];for (i = k; i < m; i++) {
                                             U[i][j] += t * U[i][k];
                                        }
                                   }for (i = k; i < m; i++) {
                                        U[i][k] = -U[i][k];
                                   }U[k][k] = 1 + U[k][k];for (i = 0; i < k - 1; i++) {
                                        U[i][k] = 0;
                                   }
                              } else {
                                   for (i = 0; i < m; i++) {
                                        U[i][k] = 0;
                                   }U[k][k] = 1;
                              }
                         }
                    }if (wantv) {
                         for (k = n - 1; k >= 0; k--) {
                              if (k < nrt && e[k] !== 0) {
                                   for (j = k + 1; j < n; j++) {
                                        t = 0;for (i = k + 1; i < n; i++) {
                                             t += V[i][k] * V[i][j];
                                        }t = -t / V[k + 1][k];for (i = k + 1; i < n; i++) {
                                             V[i][j] += t * V[i][k];
                                        }
                                   }
                              }for (i = 0; i < n; i++) {
                                   V[i][k] = 0;
                              }V[k][k] = 1;
                         }
                    }var pp = p - 1;var iter = 0;var eps = Number.EPSILON;while (p > 0) {
                         for (k = p - 2; k >= -1; k--) {
                              if (k === -1) {
                                   break;
                              }if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
                                   e[k] = 0;break;
                              }
                         }if (k === p - 2) {
                              kase = 4;
                         } else {
                              for (ks = p - 1; ks >= k; ks--) {
                                   if (ks === k) {
                                        break;
                                   }t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);if (Math.abs(s[ks]) <= eps * t) {
                                        s[ks] = 0;break;
                                   }
                              }if (ks === k) {
                                   kase = 3;
                              } else if (ks === p - 1) {
                                   kase = 1;
                              } else {
                                   kase = 2;k = ks;
                              }
                         }k++;switch (kase) {case 1:
                                   {
                                        f = e[p - 2];e[p - 2] = 0;for (j = p - 2; j >= k; j--) {
                                             t = hypotenuse(s[j], f);cs = s[j] / t;sn = f / t;s[j] = t;if (j !== k) {
                                                  f = -sn * e[j - 1];e[j - 1] = cs * e[j - 1];
                                             }if (wantv) {
                                                  for (i = 0; i < n; i++) {
                                                       t = cs * V[i][j] + sn * V[i][p - 1];V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];V[i][j] = t;
                                                  }
                                             }
                                        }break;
                                   }case 2:
                                   {
                                        f = e[k - 1];e[k - 1] = 0;for (j = k; j < p; j++) {
                                             t = hypotenuse(s[j], f);cs = s[j] / t;sn = f / t;s[j] = t;f = -sn * e[j];e[j] = cs * e[j];if (wantu) {
                                                  for (i = 0; i < m; i++) {
                                                       t = cs * U[i][j] + sn * U[i][k - 1];U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];U[i][j] = t;
                                                  }
                                             }
                                        }break;
                                   }case 3:
                                   {
                                        scale = Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2]), Math.abs(e[p - 2]), Math.abs(s[k]), Math.abs(e[k]));sp = s[p - 1] / scale;spm1 = s[p - 2] / scale;epm1 = e[p - 2] / scale;sk = s[k] / scale;ek = e[k] / scale;b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;c = sp * epm1 * (sp * epm1);shift = 0;if (b !== 0 || c !== 0) {
                                             shift = Math.sqrt(b * b + c);if (b < 0) {
                                                  shift = -shift;
                                             }shift = c / (b + shift);
                                        }f = (sk + sp) * (sk - sp) + shift;g = sk * ek;for (j = k; j < p - 1; j++) {
                                             t = hypotenuse(f, g);cs = f / t;sn = g / t;if (j !== k) {
                                                  e[j - 1] = t;
                                             }f = cs * s[j] + sn * e[j];e[j] = cs * e[j] - sn * s[j];g = sn * s[j + 1];s[j + 1] = cs * s[j + 1];if (wantv) {
                                                  for (i = 0; i < n; i++) {
                                                       t = cs * V[i][j] + sn * V[i][j + 1];V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];V[i][j] = t;
                                                  }
                                             }t = hypotenuse(f, g);cs = f / t;sn = g / t;s[j] = t;f = cs * e[j] + sn * s[j + 1];s[j + 1] = -sn * e[j] + cs * s[j + 1];g = sn * e[j + 1];e[j + 1] = cs * e[j + 1];if (wantu && j < m - 1) {
                                                  for (i = 0; i < m; i++) {
                                                       t = cs * U[i][j] + sn * U[i][j + 1];U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];U[i][j] = t;
                                                  }
                                             }
                                        }e[p - 2] = f;iter = iter + 1;break;
                                   }case 4:
                                   {
                                        if (s[k] <= 0) {
                                             s[k] = s[k] < 0 ? -s[k] : 0;if (wantv) {
                                                  for (i = 0; i <= pp; i++) {
                                                       V[i][k] = -V[i][k];
                                                  }
                                             }
                                        }while (k < pp) {
                                             if (s[k] >= s[k + 1]) {
                                                  break;
                                             }t = s[k];s[k] = s[k + 1];s[k + 1] = t;if (wantv && k < n - 1) {
                                                  for (i = 0; i < n; i++) {
                                                       t = V[i][k + 1];V[i][k + 1] = V[i][k];V[i][k] = t;
                                                  }
                                             }if (wantu && k < m - 1) {
                                                  for (i = 0; i < m; i++) {
                                                       t = U[i][k + 1];U[i][k + 1] = U[i][k];U[i][k] = t;
                                                  }
                                             }k++;
                                        }iter = 0;p--;break;
                                   } // no default
                         }
                    }if (swapped) {
                         var tmp = V;V = U;U = tmp;
                    }this.m = m;this.n = n;this.s = s;this.U = U;this.V = V;
               } /**
                 * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
                 * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
                 * var svd = SingularValueDecomposition(A);
                 * var x = svd.solve(b);
                 * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
                 * @return {Matrix} - The vector x
                 */_createClass4(SingularValueDecomposition$$1, [{ key: "solve", value: function solve(value) {
                         var Y = value;var e = this.threshold;var scols = this.s.length;var Ls = Matrix.zeros(scols, scols);var i;for (i = 0; i < scols; i++) {
                              if (Math.abs(this.s[i]) <= e) {
                                   Ls[i][i] = 0;
                              } else {
                                   Ls[i][i] = 1 / this.s[i];
                              }
                         }var U = this.U;var V = this.rightSingularVectors;var VL = V.mmul(Ls);var vrows = V.rows;var urows = U.length;var VLU = Matrix.zeros(vrows, urows);var j, k, sum;for (i = 0; i < vrows; i++) {
                              for (j = 0; j < urows; j++) {
                                   sum = 0;for (k = 0; k < scols; k++) {
                                        sum += VL[i][k] * U[j][k];
                                   }VLU[i][j] = sum;
                              }
                         }return VLU.mmul(Y);
                    } /**
                      *
                      * @param {Array<number>} value
                      * @return {Matrix}
                      */ }, { key: "solveForDiagonal", value: function solveForDiagonal(value) {
                         return this.solve(Matrix.diag(value));
                    } /**
                      * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
                      * var svd = SingularValueDecomposition(A);
                      * var inverseA = svd.inverse();
                      * @return {Matrix} - The approximation of the inverse of the matrix
                      */ }, { key: "inverse", value: function inverse() {
                         var V = this.V;var e = this.threshold;var vrows = V.length;var vcols = V[0].length;var X = new Matrix(vrows, this.s.length);var i, j;for (i = 0; i < vrows; i++) {
                              for (j = 0; j < vcols; j++) {
                                   if (Math.abs(this.s[j]) > e) {
                                        X[i][j] = V[i][j] / this.s[j];
                                   } else {
                                        X[i][j] = 0;
                                   }
                              }
                         }var U = this.U;var urows = U.length;var ucols = U[0].length;var Y = new Matrix(vrows, urows);var k, sum;for (i = 0; i < vrows; i++) {
                              for (j = 0; j < urows; j++) {
                                   sum = 0;for (k = 0; k < ucols; k++) {
                                        sum += X[i][k] * U[j][k];
                                   }Y[i][j] = sum;
                              }
                         }return Y;
                    } /**
                      *
                      * @return {number}
                      */ }, { key: "condition", get: function get() {
                         return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
                    } /**
                      *
                      * @return {number}
                      */ }, { key: "norm2", get: function get() {
                         return this.s[0];
                    } /**
                      *
                      * @return {number}
                      */ }, { key: "rank", get: function get() {
                         var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;var r = 0;var s = this.s;for (var i = 0, ii = s.length; i < ii; i++) {
                              if (s[i] > tol) {
                                   r++;
                              }
                         }return r;
                    } /**
                      *
                      * @return {Array<number>}
                      */ }, { key: "diagonal", get: function get() {
                         return this.s;
                    } /**
                      *
                      * @return {number}
                      */ }, { key: "threshold", get: function get() {
                         return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "leftSingularVectors", get: function get() {
                         if (!Matrix.isMatrix(this.U)) {
                              this.U = new Matrix(this.U);
                         }return this.U;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "rightSingularVectors", get: function get() {
                         if (!Matrix.isMatrix(this.V)) {
                              this.V = new Matrix(this.V);
                         }return this.V;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "diagonalMatrix", get: function get() {
                         return Matrix.diag(this.s);
                    } }]);return SingularValueDecomposition$$1;
          }(); /**
               * @private
               * Check that a row index is not out of bounds
               * @param {Matrix} matrix
               * @param {number} index
               * @param {boolean} [outer]
               */function checkRowIndex(matrix, index, outer) {
               var max = outer ? matrix.rows : matrix.rows - 1;if (index < 0 || index > max) {
                    throw new RangeError('Row index out of range');
               }
          } /**
            * @private
            * Check that a column index is not out of bounds
            * @param {Matrix} matrix
            * @param {number} index
            * @param {boolean} [outer]
            */function checkColumnIndex(matrix, index, outer) {
               var max = outer ? matrix.columns : matrix.columns - 1;if (index < 0 || index > max) {
                    throw new RangeError('Column index out of range');
               }
          } /**
            * @private
            * Check that the provided vector is an array with the right length
            * @param {Matrix} matrix
            * @param {Array|Matrix} vector
            * @return {Array}
            * @throws {RangeError}
            */function checkRowVector(matrix, vector) {
               if (vector.to1DArray) {
                    vector = vector.to1DArray();
               }if (vector.length !== matrix.columns) {
                    throw new RangeError('vector size must be the same as the number of columns');
               }return vector;
          } /**
            * @private
            * Check that the provided vector is an array with the right length
            * @param {Matrix} matrix
            * @param {Array|Matrix} vector
            * @return {Array}
            * @throws {RangeError}
            */function checkColumnVector(matrix, vector) {
               if (vector.to1DArray) {
                    vector = vector.to1DArray();
               }if (vector.length !== matrix.rows) {
                    throw new RangeError('vector size must be the same as the number of rows');
               }return vector;
          }function checkIndices(matrix, rowIndices, columnIndices) {
               return { row: checkRowIndices(matrix, rowIndices), column: checkColumnIndices(matrix, columnIndices) };
          }function checkRowIndices(matrix, rowIndices) {
               if ((typeof rowIndices === "undefined" ? "undefined" : _typeof4(rowIndices)) !== 'object') {
                    throw new TypeError('unexpected type for row indices');
               }var rowOut = rowIndices.some(function (r) {
                    return r < 0 || r >= matrix.rows;
               });if (rowOut) {
                    throw new RangeError('row indices are out of range');
               }if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);return rowIndices;
          }function checkColumnIndices(matrix, columnIndices) {
               if ((typeof columnIndices === "undefined" ? "undefined" : _typeof4(columnIndices)) !== 'object') {
                    throw new TypeError('unexpected type for column indices');
               }var columnOut = columnIndices.some(function (c) {
                    return c < 0 || c >= matrix.columns;
               });if (columnOut) {
                    throw new RangeError('column indices are out of range');
               }if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);return columnIndices;
          }function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
               if (arguments.length !== 5) throw new TypeError('Invalid argument type');var notAllNumbers = Array.from(arguments).slice(1).some(function (arg) {
                    return typeof arg !== 'number';
               });if (notAllNumbers) throw new TypeError('Invalid argument type');if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {
                    throw new RangeError('Submatrix indices are out of range');
               }
          }function sumByRow(matrix) {
               var sum = Matrix.zeros(matrix.rows, 1);for (var i = 0; i < matrix.rows; ++i) {
                    for (var j = 0; j < matrix.columns; ++j) {
                         sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
                    }
               }return sum;
          }function sumByColumn(matrix) {
               var sum = Matrix.zeros(1, matrix.columns);for (var i = 0; i < matrix.rows; ++i) {
                    for (var j = 0; j < matrix.columns; ++j) {
                         sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
                    }
               }return sum;
          }function sumAll(matrix) {
               var v = 0;for (var i = 0; i < matrix.rows; i++) {
                    for (var j = 0; j < matrix.columns; j++) {
                         v += matrix.get(i, j);
                    }
               }return v;
          }var BaseView = function (_AbstractMatrix) {
               _inherits(BaseView, _AbstractMatrix);function BaseView(matrix, rows, columns) {
                    _classCallCheck4(this, BaseView);var _this3 = _possibleConstructorReturn(this, (BaseView.__proto__ || Object.getPrototypeOf(BaseView)).call(this));_this3.matrix = matrix;_this3.rows = rows;_this3.columns = columns;return _this3;
               }_createClass4(BaseView, null, [{ key: Symbol.species, get: function get() {
                         return Matrix;
                    } }]);return BaseView;
          }(AbstractMatrix());var MatrixTransposeView = function (_BaseView) {
               _inherits(MatrixTransposeView, _BaseView);function MatrixTransposeView(matrix) {
                    _classCallCheck4(this, MatrixTransposeView);return _possibleConstructorReturn(this, (MatrixTransposeView.__proto__ || Object.getPrototypeOf(MatrixTransposeView)).call(this, matrix, matrix.columns, matrix.rows));
               }_createClass4(MatrixTransposeView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(columnIndex, rowIndex, value);return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.matrix.get(columnIndex, rowIndex);
                    } }]);return MatrixTransposeView;
          }(BaseView);var MatrixRowView = function (_BaseView2) {
               _inherits(MatrixRowView, _BaseView2);function MatrixRowView(matrix, row) {
                    _classCallCheck4(this, MatrixRowView);var _this5 = _possibleConstructorReturn(this, (MatrixRowView.__proto__ || Object.getPrototypeOf(MatrixRowView)).call(this, matrix, 1, matrix.columns));_this5.row = row;return _this5;
               }_createClass4(MatrixRowView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(this.row, columnIndex, value);return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.matrix.get(this.row, columnIndex);
                    } }]);return MatrixRowView;
          }(BaseView);var MatrixSubView = function (_BaseView3) {
               _inherits(MatrixSubView, _BaseView3);function MatrixSubView(matrix, startRow, endRow, startColumn, endColumn) {
                    _classCallCheck4(this, MatrixSubView);checkRange(matrix, startRow, endRow, startColumn, endColumn);var _this6 = _possibleConstructorReturn(this, (MatrixSubView.__proto__ || Object.getPrototypeOf(MatrixSubView)).call(this, matrix, endRow - startRow + 1, endColumn - startColumn + 1));_this6.startRow = startRow;_this6.startColumn = startColumn;return _this6;
               }_createClass4(MatrixSubView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(this.startRow + rowIndex, this.startColumn + columnIndex, value);return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.matrix.get(this.startRow + rowIndex, this.startColumn + columnIndex);
                    } }]);return MatrixSubView;
          }(BaseView);var MatrixSelectionView = function (_BaseView4) {
               _inherits(MatrixSelectionView, _BaseView4);function MatrixSelectionView(matrix, rowIndices, columnIndices) {
                    _classCallCheck4(this, MatrixSelectionView);var indices = checkIndices(matrix, rowIndices, columnIndices);var _this7 = _possibleConstructorReturn(this, (MatrixSelectionView.__proto__ || Object.getPrototypeOf(MatrixSelectionView)).call(this, matrix, indices.row.length, indices.column.length));_this7.rowIndices = indices.row;_this7.columnIndices = indices.column;return _this7;
               }_createClass4(MatrixSelectionView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(this.rowIndices[rowIndex], this.columnIndices[columnIndex], value);return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.matrix.get(this.rowIndices[rowIndex], this.columnIndices[columnIndex]);
                    } }]);return MatrixSelectionView;
          }(BaseView);var MatrixRowSelectionView = function (_BaseView5) {
               _inherits(MatrixRowSelectionView, _BaseView5);function MatrixRowSelectionView(matrix, rowIndices) {
                    _classCallCheck4(this, MatrixRowSelectionView);rowIndices = checkRowIndices(matrix, rowIndices);var _this8 = _possibleConstructorReturn(this, (MatrixRowSelectionView.__proto__ || Object.getPrototypeOf(MatrixRowSelectionView)).call(this, matrix, rowIndices.length, matrix.columns));_this8.rowIndices = rowIndices;return _this8;
               }_createClass4(MatrixRowSelectionView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
                    } }]);return MatrixRowSelectionView;
          }(BaseView);var MatrixColumnSelectionView = function (_BaseView6) {
               _inherits(MatrixColumnSelectionView, _BaseView6);function MatrixColumnSelectionView(matrix, columnIndices) {
                    _classCallCheck4(this, MatrixColumnSelectionView);columnIndices = checkColumnIndices(matrix, columnIndices);var _this9 = _possibleConstructorReturn(this, (MatrixColumnSelectionView.__proto__ || Object.getPrototypeOf(MatrixColumnSelectionView)).call(this, matrix, matrix.rows, columnIndices.length));_this9.columnIndices = columnIndices;return _this9;
               }_createClass4(MatrixColumnSelectionView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
                    } }]);return MatrixColumnSelectionView;
          }(BaseView);var MatrixColumnView = function (_BaseView7) {
               _inherits(MatrixColumnView, _BaseView7);function MatrixColumnView(matrix, column) {
                    _classCallCheck4(this, MatrixColumnView);var _this10 = _possibleConstructorReturn(this, (MatrixColumnView.__proto__ || Object.getPrototypeOf(MatrixColumnView)).call(this, matrix, matrix.rows, 1));_this10.column = column;return _this10;
               }_createClass4(MatrixColumnView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(rowIndex, this.column, value);return this;
                    } }, { key: "get", value: function get(rowIndex) {
                         return this.matrix.get(rowIndex, this.column);
                    } }]);return MatrixColumnView;
          }(BaseView);var MatrixFlipRowView = function (_BaseView8) {
               _inherits(MatrixFlipRowView, _BaseView8);function MatrixFlipRowView(matrix) {
                    _classCallCheck4(this, MatrixFlipRowView);return _possibleConstructorReturn(this, (MatrixFlipRowView.__proto__ || Object.getPrototypeOf(MatrixFlipRowView)).call(this, matrix, matrix.rows, matrix.columns));
               }_createClass4(MatrixFlipRowView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
                    } }]);return MatrixFlipRowView;
          }(BaseView);var MatrixFlipColumnView = function (_BaseView9) {
               _inherits(MatrixFlipColumnView, _BaseView9);function MatrixFlipColumnView(matrix) {
                    _classCallCheck4(this, MatrixFlipColumnView);return _possibleConstructorReturn(this, (MatrixFlipColumnView.__proto__ || Object.getPrototypeOf(MatrixFlipColumnView)).call(this, matrix, matrix.rows, matrix.columns));
               }_createClass4(MatrixFlipColumnView, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
                    } }]);return MatrixFlipColumnView;
          }(BaseView);function AbstractMatrix(superCtor) {
               if (superCtor === undefined) superCtor = Object; /**
                                                                * Real matrix
                                                                * @class Matrix
                                                                * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,
                                                                * 2D array containing the data or Matrix instance to clone
                                                                * @param {number} [nColumns] - Number of columns of the new matrix
                                                                */var Matrix = function (_superCtor) {
                    _inherits(Matrix, _superCtor);function Matrix() {
                         _classCallCheck4(this, Matrix);return _possibleConstructorReturn(this, (Matrix.__proto__ || Object.getPrototypeOf(Matrix)).apply(this, arguments));
                    }_createClass4(Matrix, [{ key: "apply", /**
                                                            * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.
                                                            * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)
                                                            * @return {Matrix} this
                                                            */value: function apply(callback) {
                              if (typeof callback !== 'function') {
                                   throw new TypeError('callback must be a function');
                              }var ii = this.rows;var jj = this.columns;for (var i = 0; i < ii; i++) {
                                   for (var j = 0; j < jj; j++) {
                                        callback.call(this, i, j);
                                   }
                              }return this;
                         } /**
                           * Returns a new 1D array filled row by row with the matrix values
                           * @return {Array}
                           */ }, { key: "to1DArray", value: function to1DArray() {
                              var array = new Array(this.size);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        array[i * this.columns + j] = this.get(i, j);
                                   }
                              }return array;
                         } /**
                           * Returns a 2D array containing a copy of the data
                           * @return {Array}
                           */ }, { key: "to2DArray", value: function to2DArray() {
                              var copy = new Array(this.rows);for (var i = 0; i < this.rows; i++) {
                                   copy[i] = new Array(this.columns);for (var j = 0; j < this.columns; j++) {
                                        copy[i][j] = this.get(i, j);
                                   }
                              }return copy;
                         } /**
                           * @return {boolean} true if the matrix has one row
                           */ }, { key: "isRowVector", value: function isRowVector() {
                              return this.rows === 1;
                         } /**
                           * @return {boolean} true if the matrix has one column
                           */ }, { key: "isColumnVector", value: function isColumnVector() {
                              return this.columns === 1;
                         } /**
                           * @return {boolean} true if the matrix has one row or one column
                           */ }, { key: "isVector", value: function isVector() {
                              return this.rows === 1 || this.columns === 1;
                         } /**
                           * @return {boolean} true if the matrix has the same number of rows and columns
                           */ }, { key: "isSquare", value: function isSquare() {
                              return this.rows === this.columns;
                         } /**
                           * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal
                           */ }, { key: "isSymmetric", value: function isSymmetric() {
                              if (this.isSquare()) {
                                   for (var i = 0; i < this.rows; i++) {
                                        for (var j = 0; j <= i; j++) {
                                             if (this.get(i, j) !== this.get(j, i)) {
                                                  return false;
                                             }
                                        }
                                   }return true;
                              }return false;
                         } /**
                           * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1
                           * @abstract
                           * @param {number} rowIndex - Index of the row
                           * @param {number} columnIndex - Index of the column
                           * @param {number} value - The new value for the element
                           * @return {Matrix} this
                           */ }, { key: "set", value: function set(rowIndex, columnIndex, value) {
                              // eslint-disable-line no-unused-vars
                              throw new Error('set method is unimplemented');
                         } /**
                           * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]
                           * @abstract
                           * @param {number} rowIndex - Index of the row
                           * @param {number} columnIndex - Index of the column
                           * @return {number}
                           */ }, { key: "get", value: function get(rowIndex, columnIndex) {
                              // eslint-disable-line no-unused-vars
                              throw new Error('get method is unimplemented');
                         } /**
                           * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of
                           * rows of the matrix, and colRep times the number of columns of the matrix
                           * @param {number} rowRep - Number of times the rows should be repeated
                           * @param {number} colRep - Number of times the columns should be re
                           * @return {Matrix}
                           * @example
                           * var matrix = new Matrix([[1,2]]);
                           * matrix.repeat(2); // [[1,2],[1,2]]
                           */ }, { key: "repeat", value: function repeat(rowRep, colRep) {
                              rowRep = rowRep || 1;colRep = colRep || 1;var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);for (var i = 0; i < rowRep; i++) {
                                   for (var j = 0; j < colRep; j++) {
                                        matrix.setSubMatrix(this, this.rows * i, this.columns * j);
                                   }
                              }return matrix;
                         } /**
                           * Fills the matrix with a given value. All elements will be set to this value.
                           * @param {number} value - New value
                           * @return {Matrix} this
                           */ }, { key: "fill", value: function fill(value) {
                              for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, value);
                                   }
                              }return this;
                         } /**
                           * Negates the matrix. All elements will be multiplied by (-1)
                           * @return {Matrix} this
                           */ }, { key: "neg", value: function neg() {
                              return this.mulS(-1);
                         } /**
                           * Returns a new array from the given row index
                           * @param {number} index - Row index
                           * @return {Array}
                           */ }, { key: "getRow", value: function getRow(index) {
                              checkRowIndex(this, index);var row = new Array(this.columns);for (var i = 0; i < this.columns; i++) {
                                   row[i] = this.get(index, i);
                              }return row;
                         } /**
                           * Returns a new row vector from the given row index
                           * @param {number} index - Row index
                           * @return {Matrix}
                           */ }, { key: "getRowVector", value: function getRowVector(index) {
                              return this.constructor.rowVector(this.getRow(index));
                         } /**
                           * Sets a row at the given index
                           * @param {number} index - Row index
                           * @param {Array|Matrix} array - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "setRow", value: function setRow(index, array) {
                              checkRowIndex(this, index);array = checkRowVector(this, array);for (var i = 0; i < this.columns; i++) {
                                   this.set(index, i, array[i]);
                              }return this;
                         } /**
                           * Swaps two rows
                           * @param {number} row1 - First row index
                           * @param {number} row2 - Second row index
                           * @return {Matrix} this
                           */ }, { key: "swapRows", value: function swapRows(row1, row2) {
                              checkRowIndex(this, row1);checkRowIndex(this, row2);for (var i = 0; i < this.columns; i++) {
                                   var temp = this.get(row1, i);this.set(row1, i, this.get(row2, i));this.set(row2, i, temp);
                              }return this;
                         } /**
                           * Returns a new array from the given column index
                           * @param {number} index - Column index
                           * @return {Array}
                           */ }, { key: "getColumn", value: function getColumn(index) {
                              checkColumnIndex(this, index);var column = new Array(this.rows);for (var i = 0; i < this.rows; i++) {
                                   column[i] = this.get(i, index);
                              }return column;
                         } /**
                           * Returns a new column vector from the given column index
                           * @param {number} index - Column index
                           * @return {Matrix}
                           */ }, { key: "getColumnVector", value: function getColumnVector(index) {
                              return this.constructor.columnVector(this.getColumn(index));
                         } /**
                           * Sets a column at the given index
                           * @param {number} index - Column index
                           * @param {Array|Matrix} array - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "setColumn", value: function setColumn(index, array) {
                              checkColumnIndex(this, index);array = checkColumnVector(this, array);for (var i = 0; i < this.rows; i++) {
                                   this.set(i, index, array[i]);
                              }return this;
                         } /**
                           * Swaps two columns
                           * @param {number} column1 - First column index
                           * @param {number} column2 - Second column index
                           * @return {Matrix} this
                           */ }, { key: "swapColumns", value: function swapColumns(column1, column2) {
                              checkColumnIndex(this, column1);checkColumnIndex(this, column2);for (var i = 0; i < this.rows; i++) {
                                   var temp = this.get(i, column1);this.set(i, column1, this.get(i, column2));this.set(i, column2, temp);
                              }return this;
                         } /**
                           * Adds the values of a vector to each row
                           * @param {Array|Matrix} vector - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "addRowVector", value: function addRowVector(vector) {
                              vector = checkRowVector(this, vector);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, this.get(i, j) + vector[j]);
                                   }
                              }return this;
                         } /**
                           * Subtracts the values of a vector from each row
                           * @param {Array|Matrix} vector - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "subRowVector", value: function subRowVector(vector) {
                              vector = checkRowVector(this, vector);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, this.get(i, j) - vector[j]);
                                   }
                              }return this;
                         } /**
                           * Multiplies the values of a vector with each row
                           * @param {Array|Matrix} vector - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "mulRowVector", value: function mulRowVector(vector) {
                              vector = checkRowVector(this, vector);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, this.get(i, j) * vector[j]);
                                   }
                              }return this;
                         } /**
                           * Divides the values of each row by those of a vector
                           * @param {Array|Matrix} vector - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "divRowVector", value: function divRowVector(vector) {
                              vector = checkRowVector(this, vector);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, this.get(i, j) / vector[j]);
                                   }
                              }return this;
                         } /**
                           * Adds the values of a vector to each column
                           * @param {Array|Matrix} vector - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "addColumnVector", value: function addColumnVector(vector) {
                              vector = checkColumnVector(this, vector);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, this.get(i, j) + vector[i]);
                                   }
                              }return this;
                         } /**
                           * Subtracts the values of a vector from each column
                           * @param {Array|Matrix} vector - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "subColumnVector", value: function subColumnVector(vector) {
                              vector = checkColumnVector(this, vector);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, this.get(i, j) - vector[i]);
                                   }
                              }return this;
                         } /**
                           * Multiplies the values of a vector with each column
                           * @param {Array|Matrix} vector - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "mulColumnVector", value: function mulColumnVector(vector) {
                              vector = checkColumnVector(this, vector);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, this.get(i, j) * vector[i]);
                                   }
                              }return this;
                         } /**
                           * Divides the values of each column by those of a vector
                           * @param {Array|Matrix} vector - Array or vector
                           * @return {Matrix} this
                           */ }, { key: "divColumnVector", value: function divColumnVector(vector) {
                              vector = checkColumnVector(this, vector);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        this.set(i, j, this.get(i, j) / vector[i]);
                                   }
                              }return this;
                         } /**
                           * Multiplies the values of a row with a scalar
                           * @param {number} index - Row index
                           * @param {number} value
                           * @return {Matrix} this
                           */ }, { key: "mulRow", value: function mulRow(index, value) {
                              checkRowIndex(this, index);for (var i = 0; i < this.columns; i++) {
                                   this.set(index, i, this.get(index, i) * value);
                              }return this;
                         } /**
                           * Multiplies the values of a column with a scalar
                           * @param {number} index - Column index
                           * @param {number} value
                           * @return {Matrix} this
                           */ }, { key: "mulColumn", value: function mulColumn(index, value) {
                              checkColumnIndex(this, index);for (var i = 0; i < this.rows; i++) {
                                   this.set(i, index, this.get(i, index) * value);
                              }return this;
                         } /**
                           * Returns the maximum value of the matrix
                           * @return {number}
                           */ }, { key: "max", value: function max() {
                              var v = this.get(0, 0);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        if (this.get(i, j) > v) {
                                             v = this.get(i, j);
                                        }
                                   }
                              }return v;
                         } /**
                           * Returns the index of the maximum value
                           * @return {Array}
                           */ }, { key: "maxIndex", value: function maxIndex() {
                              var v = this.get(0, 0);var idx = [0, 0];for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        if (this.get(i, j) > v) {
                                             v = this.get(i, j);idx[0] = i;idx[1] = j;
                                        }
                                   }
                              }return idx;
                         } /**
                           * Returns the minimum value of the matrix
                           * @return {number}
                           */ }, { key: "min", value: function min() {
                              var v = this.get(0, 0);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        if (this.get(i, j) < v) {
                                             v = this.get(i, j);
                                        }
                                   }
                              }return v;
                         } /**
                           * Returns the index of the minimum value
                           * @return {Array}
                           */ }, { key: "minIndex", value: function minIndex() {
                              var v = this.get(0, 0);var idx = [0, 0];for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        if (this.get(i, j) < v) {
                                             v = this.get(i, j);idx[0] = i;idx[1] = j;
                                        }
                                   }
                              }return idx;
                         } /**
                           * Returns the maximum value of one row
                           * @param {number} row - Row index
                           * @return {number}
                           */ }, { key: "maxRow", value: function maxRow(row) {
                              checkRowIndex(this, row);var v = this.get(row, 0);for (var i = 1; i < this.columns; i++) {
                                   if (this.get(row, i) > v) {
                                        v = this.get(row, i);
                                   }
                              }return v;
                         } /**
                           * Returns the index of the maximum value of one row
                           * @param {number} row - Row index
                           * @return {Array}
                           */ }, { key: "maxRowIndex", value: function maxRowIndex(row) {
                              checkRowIndex(this, row);var v = this.get(row, 0);var idx = [row, 0];for (var i = 1; i < this.columns; i++) {
                                   if (this.get(row, i) > v) {
                                        v = this.get(row, i);idx[1] = i;
                                   }
                              }return idx;
                         } /**
                           * Returns the minimum value of one row
                           * @param {number} row - Row index
                           * @return {number}
                           */ }, { key: "minRow", value: function minRow(row) {
                              checkRowIndex(this, row);var v = this.get(row, 0);for (var i = 1; i < this.columns; i++) {
                                   if (this.get(row, i) < v) {
                                        v = this.get(row, i);
                                   }
                              }return v;
                         } /**
                           * Returns the index of the maximum value of one row
                           * @param {number} row - Row index
                           * @return {Array}
                           */ }, { key: "minRowIndex", value: function minRowIndex(row) {
                              checkRowIndex(this, row);var v = this.get(row, 0);var idx = [row, 0];for (var i = 1; i < this.columns; i++) {
                                   if (this.get(row, i) < v) {
                                        v = this.get(row, i);idx[1] = i;
                                   }
                              }return idx;
                         } /**
                           * Returns the maximum value of one column
                           * @param {number} column - Column index
                           * @return {number}
                           */ }, { key: "maxColumn", value: function maxColumn(column) {
                              checkColumnIndex(this, column);var v = this.get(0, column);for (var i = 1; i < this.rows; i++) {
                                   if (this.get(i, column) > v) {
                                        v = this.get(i, column);
                                   }
                              }return v;
                         } /**
                           * Returns the index of the maximum value of one column
                           * @param {number} column - Column index
                           * @return {Array}
                           */ }, { key: "maxColumnIndex", value: function maxColumnIndex(column) {
                              checkColumnIndex(this, column);var v = this.get(0, column);var idx = [0, column];for (var i = 1; i < this.rows; i++) {
                                   if (this.get(i, column) > v) {
                                        v = this.get(i, column);idx[0] = i;
                                   }
                              }return idx;
                         } /**
                           * Returns the minimum value of one column
                           * @param {number} column - Column index
                           * @return {number}
                           */ }, { key: "minColumn", value: function minColumn(column) {
                              checkColumnIndex(this, column);var v = this.get(0, column);for (var i = 1; i < this.rows; i++) {
                                   if (this.get(i, column) < v) {
                                        v = this.get(i, column);
                                   }
                              }return v;
                         } /**
                           * Returns the index of the minimum value of one column
                           * @param {number} column - Column index
                           * @return {Array}
                           */ }, { key: "minColumnIndex", value: function minColumnIndex(column) {
                              checkColumnIndex(this, column);var v = this.get(0, column);var idx = [0, column];for (var i = 1; i < this.rows; i++) {
                                   if (this.get(i, column) < v) {
                                        v = this.get(i, column);idx[0] = i;
                                   }
                              }return idx;
                         } /**
                           * Returns an array containing the diagonal values of the matrix
                           * @return {Array}
                           */ }, { key: "diag", value: function diag() {
                              var min = Math.min(this.rows, this.columns);var diag = new Array(min);for (var i = 0; i < min; i++) {
                                   diag[i] = this.get(i, i);
                              }return diag;
                         } /**
                           * Returns the sum by the argument given, if no argument given,
                           * it returns the sum of all elements of the matrix.
                           * @param {string} by - sum by 'row' or 'column'.
                           * @return {Matrix|number}
                           */ }, { key: "sum", value: function sum(by) {
                              switch (by) {case 'row':
                                        return sumByRow(this);case 'column':
                                        return sumByColumn(this);default:
                                        return sumAll(this);}
                         } /**
                           * Returns the mean of all elements of the matrix
                           * @return {number}
                           */ }, { key: "mean", value: function mean() {
                              return this.sum() / this.size;
                         } /**
                           * Returns the product of all elements of the matrix
                           * @return {number}
                           */ }, { key: "prod", value: function prod() {
                              var prod = 1;for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        prod *= this.get(i, j);
                                   }
                              }return prod;
                         } /**
                           * Returns the norm of a matrix.
                           * @param {string} type - "frobenius" (default) or "max" return resp. the Frobenius norm and the max norm.
                           * @return {number}
                           */ }, { key: "norm", value: function norm() {
                              var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'frobenius';var result = 0;if (type === 'max') {
                                   return this.max();
                              } else if (type === 'frobenius') {
                                   for (var i = 0; i < this.rows; i++) {
                                        for (var j = 0; j < this.columns; j++) {
                                             result = result + this.get(i, j) * this.get(i, j);
                                        }
                                   }return Math.sqrt(result);
                              } else {
                                   throw new RangeError("unknown norm type: " + type);
                              }
                         } /**
                           * Computes the cumulative sum of the matrix elements (in place, row by row)
                           * @return {Matrix} this
                           */ }, { key: "cumulativeSum", value: function cumulativeSum() {
                              var sum = 0;for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        sum += this.get(i, j);this.set(i, j, sum);
                                   }
                              }return this;
                         } /**
                           * Computes the dot (scalar) product between the matrix and another
                           * @param {Matrix} vector2 vector
                           * @return {number}
                           */ }, { key: "dot", value: function dot(vector2) {
                              if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();var vector1 = this.to1DArray();if (vector1.length !== vector2.length) {
                                   throw new RangeError('vectors do not have the same size');
                              }var dot = 0;for (var i = 0; i < vector1.length; i++) {
                                   dot += vector1[i] * vector2[i];
                              }return dot;
                         } /**
                           * Returns the matrix product between this and other
                           * @param {Matrix} other
                           * @return {Matrix}
                           */ }, { key: "mmul", value: function mmul(other) {
                              other = this.constructor.checkMatrix(other);if (this.columns !== other.rows) {
                                   // eslint-disable-next-line no-console
                                   console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
                              }var m = this.rows;var n = this.columns;var p = other.columns;var result = new this.constructor[Symbol.species](m, p);var Bcolj = new Array(n);for (var j = 0; j < p; j++) {
                                   for (var k = 0; k < n; k++) {
                                        Bcolj[k] = other.get(k, j);
                                   }for (var i = 0; i < m; i++) {
                                        var s = 0;for (k = 0; k < n; k++) {
                                             s += this.get(i, k) * Bcolj[k];
                                        }result.set(i, j, s);
                                   }
                              }return result;
                         } }, { key: "strassen2x2", value: function strassen2x2(other) {
                              var result = new this.constructor[Symbol.species](2, 2);var a11 = this.get(0, 0);var b11 = other.get(0, 0);var a12 = this.get(0, 1);var b12 = other.get(0, 1);var a21 = this.get(1, 0);var b21 = other.get(1, 0);var a22 = this.get(1, 1);var b22 = other.get(1, 1); // Compute intermediate values.
                              var m1 = (a11 + a22) * (b11 + b22);var m2 = (a21 + a22) * b11;var m3 = a11 * (b12 - b22);var m4 = a22 * (b21 - b11);var m5 = (a11 + a12) * b22;var m6 = (a21 - a11) * (b11 + b12);var m7 = (a12 - a22) * (b21 + b22); // Combine intermediate values into the output.
                              var c00 = m1 + m4 - m5 + m7;var c01 = m3 + m5;var c10 = m2 + m4;var c11 = m1 - m2 + m3 + m6;result.set(0, 0, c00);result.set(0, 1, c01);result.set(1, 0, c10);result.set(1, 1, c11);return result;
                         } }, { key: "strassen3x3", value: function strassen3x3(other) {
                              var result = new this.constructor[Symbol.species](3, 3);var a00 = this.get(0, 0);var a01 = this.get(0, 1);var a02 = this.get(0, 2);var a10 = this.get(1, 0);var a11 = this.get(1, 1);var a12 = this.get(1, 2);var a20 = this.get(2, 0);var a21 = this.get(2, 1);var a22 = this.get(2, 2);var b00 = other.get(0, 0);var b01 = other.get(0, 1);var b02 = other.get(0, 2);var b10 = other.get(1, 0);var b11 = other.get(1, 1);var b12 = other.get(1, 2);var b20 = other.get(2, 0);var b21 = other.get(2, 1);var b22 = other.get(2, 2);var m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;var m2 = (a00 - a10) * (-b01 + b11);var m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);var m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);var m5 = (a10 + a11) * (-b00 + b01);var m6 = a00 * b00;var m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);var m8 = (-a00 + a20) * (b02 - b12);var m9 = (a20 + a21) * (-b00 + b02);var m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;var m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);var m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);var m13 = (a02 - a22) * (b11 - b21);var m14 = a02 * b20;var m15 = (a21 + a22) * (-b20 + b21);var m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);var m17 = (a02 - a12) * (b12 - b22);var m18 = (a11 + a12) * (-b20 + b22);var m19 = a01 * b10;var m20 = a12 * b21;var m21 = a10 * b02;var m22 = a20 * b01;var m23 = a22 * b22;var c00 = m6 + m14 + m19;var c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;var c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;var c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;var c11 = m2 + m4 + m5 + m6 + m20;var c12 = m14 + m16 + m17 + m18 + m21;var c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;var c21 = m12 + m13 + m14 + m15 + m22;var c22 = m6 + m7 + m8 + m9 + m23;result.set(0, 0, c00);result.set(0, 1, c01);result.set(0, 2, c02);result.set(1, 0, c10);result.set(1, 1, c11);result.set(1, 2, c12);result.set(2, 0, c20);result.set(2, 1, c21);result.set(2, 2, c22);return result;
                         } /**
                           * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.
                           * @param {Matrix} y
                           * @return {Matrix}
                           */ }, { key: "mmulStrassen", value: function mmulStrassen(y) {
                              var x = this.clone();var r1 = x.rows;var c1 = x.columns;var r2 = y.rows;var c2 = y.columns;if (c1 !== r2) {
                                   // eslint-disable-next-line no-console
                                   console.warn("Multiplying " + r1 + " x " + c1 + " and " + r2 + " x " + c2 + " matrix: dimensions do not match.");
                              } // Put a matrix into the top left of a matrix of zeros.
                              // `rows` and `cols` are the dimensions of the output matrix.
                              function embed(mat, rows, cols) {
                                   var r = mat.rows;var c = mat.columns;if (r === rows && c === cols) {
                                        return mat;
                                   } else {
                                        var resultat = Matrix.zeros(rows, cols);resultat = resultat.setSubMatrix(mat, 0, 0);return resultat;
                                   }
                              } // Make sure both matrices are the same size.
                              // This is exclusively for simplicity:
                              // this algorithm can be implemented with matrices of different sizes.
                              var r = Math.max(r1, r2);var c = Math.max(c1, c2);x = embed(x, r, c);y = embed(y, r, c); // Our recursive multiplication function.
                              function blockMult(a, b, rows, cols) {
                                   // For small matrices, resort to naive multiplication.
                                   if (rows <= 512 || cols <= 512) {
                                        return a.mmul(b); // a is equivalent to this
                                   } // Apply dynamic padding.
                                   if (rows % 2 === 1 && cols % 2 === 1) {
                                        a = embed(a, rows + 1, cols + 1);b = embed(b, rows + 1, cols + 1);
                                   } else if (rows % 2 === 1) {
                                        a = embed(a, rows + 1, cols);b = embed(b, rows + 1, cols);
                                   } else if (cols % 2 === 1) {
                                        a = embed(a, rows, cols + 1);b = embed(b, rows, cols + 1);
                                   }var halfRows = parseInt(a.rows / 2);var halfCols = parseInt(a.columns / 2); // Subdivide input matrices.
                                   var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1); // Compute intermediate values.
                                   var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols); // Combine intermediate values into the output.
                                   var c11 = Matrix.add(m1, m4);c11.sub(m5);c11.add(m7);var c12 = Matrix.add(m3, m5);var c21 = Matrix.add(m2, m4);var c22 = Matrix.sub(m1, m2);c22.add(m3);c22.add(m6); //Crop output to the desired size (undo dynamic padding).
                                   var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);resultat = resultat.setSubMatrix(c11, 0, 0);resultat = resultat.setSubMatrix(c12, c11.rows, 0);resultat = resultat.setSubMatrix(c21, 0, c11.columns);resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);return resultat.subMatrix(0, rows - 1, 0, cols - 1);
                              }return blockMult(x, y, r, c);
                         } /**
                           * Returns a row-by-row scaled matrix
                           * @param {number} [min=0] - Minimum scaled value
                           * @param {number} [max=1] - Maximum scaled value
                           * @return {Matrix} - The scaled matrix
                           */ }, { key: "scaleRows", value: function scaleRows(min, max) {
                              min = min === undefined ? 0 : min;max = max === undefined ? 1 : max;if (min >= max) {
                                   throw new RangeError('min should be strictly smaller than max');
                              }var newMatrix = this.constructor.empty(this.rows, this.columns);for (var i = 0; i < this.rows; i++) {
                                   var scaled = rescale(this.getRow(i), { min: min, max: max });newMatrix.setRow(i, scaled);
                              }return newMatrix;
                         } /**
                           * Returns a new column-by-column scaled matrix
                           * @param {number} [min=0] - Minimum scaled value
                           * @param {number} [max=1] - Maximum scaled value
                           * @return {Matrix} - The new scaled matrix
                           * @example
                           * var matrix = new Matrix([[1,2],[-1,0]]);
                           * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]
                           */ }, { key: "scaleColumns", value: function scaleColumns(min, max) {
                              min = min === undefined ? 0 : min;max = max === undefined ? 1 : max;if (min >= max) {
                                   throw new RangeError('min should be strictly smaller than max');
                              }var newMatrix = this.constructor.empty(this.rows, this.columns);for (var i = 0; i < this.columns; i++) {
                                   var scaled = rescale(this.getColumn(i), { min: min, max: max });newMatrix.setColumn(i, scaled);
                              }return newMatrix;
                         } /**
                           * Returns the Kronecker product (also known as tensor product) between this and other
                           * See https://en.wikipedia.org/wiki/Kronecker_product
                           * @param {Matrix} other
                           * @return {Matrix}
                           */ }, { key: "kroneckerProduct", value: function kroneckerProduct(other) {
                              other = this.constructor.checkMatrix(other);var m = this.rows;var n = this.columns;var p = other.rows;var q = other.columns;var result = new this.constructor[Symbol.species](m * p, n * q);for (var i = 0; i < m; i++) {
                                   for (var j = 0; j < n; j++) {
                                        for (var k = 0; k < p; k++) {
                                             for (var l = 0; l < q; l++) {
                                                  result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);
                                             }
                                        }
                                   }
                              }return result;
                         } /**
                           * Transposes the matrix and returns a new one containing the result
                           * @return {Matrix}
                           */ }, { key: "transpose", value: function transpose() {
                              var result = new this.constructor[Symbol.species](this.columns, this.rows);for (var i = 0; i < this.rows; i++) {
                                   for (var j = 0; j < this.columns; j++) {
                                        result.set(j, i, this.get(i, j));
                                   }
                              }return result;
                         } /**
                           * Sorts the rows (in place)
                           * @param {function} compareFunction - usual Array.prototype.sort comparison function
                           * @return {Matrix} this
                           */ }, { key: "sortRows", value: function sortRows(compareFunction) {
                              if (compareFunction === undefined) compareFunction = compareNumbers;for (var i = 0; i < this.rows; i++) {
                                   this.setRow(i, this.getRow(i).sort(compareFunction));
                              }return this;
                         } /**
                           * Sorts the columns (in place)
                           * @param {function} compareFunction - usual Array.prototype.sort comparison function
                           * @return {Matrix} this
                           */ }, { key: "sortColumns", value: function sortColumns(compareFunction) {
                              if (compareFunction === undefined) compareFunction = compareNumbers;for (var i = 0; i < this.columns; i++) {
                                   this.setColumn(i, this.getColumn(i).sort(compareFunction));
                              }return this;
                         } /**
                           * Returns a subset of the matrix
                           * @param {number} startRow - First row index
                           * @param {number} endRow - Last row index
                           * @param {number} startColumn - First column index
                           * @param {number} endColumn - Last column index
                           * @return {Matrix}
                           */ }, { key: "subMatrix", value: function subMatrix(startRow, endRow, startColumn, endColumn) {
                              checkRange(this, startRow, endRow, startColumn, endColumn);var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);for (var i = startRow; i <= endRow; i++) {
                                   for (var j = startColumn; j <= endColumn; j++) {
                                        newMatrix[i - startRow][j - startColumn] = this.get(i, j);
                                   }
                              }return newMatrix;
                         } /**
                           * Returns a subset of the matrix based on an array of row indices
                           * @param {Array} indices - Array containing the row indices
                           * @param {number} [startColumn = 0] - First column index
                           * @param {number} [endColumn = this.columns-1] - Last column index
                           * @return {Matrix}
                           */ }, { key: "subMatrixRow", value: function subMatrixRow(indices, startColumn, endColumn) {
                              if (startColumn === undefined) startColumn = 0;if (endColumn === undefined) endColumn = this.columns - 1;if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
                                   throw new RangeError('Argument out of range');
                              }var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);for (var i = 0; i < indices.length; i++) {
                                   for (var j = startColumn; j <= endColumn; j++) {
                                        if (indices[i] < 0 || indices[i] >= this.rows) {
                                             throw new RangeError('Row index out of range: ' + indices[i]);
                                        }newMatrix.set(i, j - startColumn, this.get(indices[i], j));
                                   }
                              }return newMatrix;
                         } /**
                           * Returns a subset of the matrix based on an array of column indices
                           * @param {Array} indices - Array containing the column indices
                           * @param {number} [startRow = 0] - First row index
                           * @param {number} [endRow = this.rows-1] - Last row index
                           * @return {Matrix}
                           */ }, { key: "subMatrixColumn", value: function subMatrixColumn(indices, startRow, endRow) {
                              if (startRow === undefined) startRow = 0;if (endRow === undefined) endRow = this.rows - 1;if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
                                   throw new RangeError('Argument out of range');
                              }var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);for (var i = 0; i < indices.length; i++) {
                                   for (var j = startRow; j <= endRow; j++) {
                                        if (indices[i] < 0 || indices[i] >= this.columns) {
                                             throw new RangeError('Column index out of range: ' + indices[i]);
                                        }newMatrix.set(j - startRow, i, this.get(j, indices[i]));
                                   }
                              }return newMatrix;
                         } /**
                           * Set a part of the matrix to the given sub-matrix
                           * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.
                           * @param {number} startRow - The index of the first row to set
                           * @param {number} startColumn - The index of the first column to set
                           * @return {Matrix}
                           */ }, { key: "setSubMatrix", value: function setSubMatrix(matrix, startRow, startColumn) {
                              matrix = this.constructor.checkMatrix(matrix);var endRow = startRow + matrix.rows - 1;var endColumn = startColumn + matrix.columns - 1;checkRange(this, startRow, endRow, startColumn, endColumn);for (var i = 0; i < matrix.rows; i++) {
                                   for (var j = 0; j < matrix.columns; j++) {
                                        this[startRow + i][startColumn + j] = matrix.get(i, j);
                                   }
                              }return this;
                         } /**
                           * Return a new matrix based on a selection of rows and columns
                           * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.
                           * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.
                           * @return {Matrix} The new matrix
                           */ }, { key: "selection", value: function selection(rowIndices, columnIndices) {
                              var indices = checkIndices(this, rowIndices, columnIndices);var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);for (var i = 0; i < indices.row.length; i++) {
                                   var rowIndex = indices.row[i];for (var j = 0; j < indices.column.length; j++) {
                                        var columnIndex = indices.column[j];newMatrix[i][j] = this.get(rowIndex, columnIndex);
                                   }
                              }return newMatrix;
                         } /**
                           * Returns the trace of the matrix (sum of the diagonal elements)
                           * @return {number}
                           */ }, { key: "trace", value: function trace() {
                              var min = Math.min(this.rows, this.columns);var trace = 0;for (var i = 0; i < min; i++) {
                                   trace += this.get(i, i);
                              }return trace;
                         } /*
                           Matrix views
                           */ /**
                              * Returns a view of the transposition of the matrix
                              * @return {MatrixTransposeView}
                              */ }, { key: "transposeView", value: function transposeView() {
                              return new MatrixTransposeView(this);
                         } /**
                           * Returns a view of the row vector with the given index
                           * @param {number} row - row index of the vector
                           * @return {MatrixRowView}
                           */ }, { key: "rowView", value: function rowView(row) {
                              checkRowIndex(this, row);return new MatrixRowView(this, row);
                         } /**
                           * Returns a view of the column vector with the given index
                           * @param {number} column - column index of the vector
                           * @return {MatrixColumnView}
                           */ }, { key: "columnView", value: function columnView(column) {
                              checkColumnIndex(this, column);return new MatrixColumnView(this, column);
                         } /**
                           * Returns a view of the matrix flipped in the row axis
                           * @return {MatrixFlipRowView}
                           */ }, { key: "flipRowView", value: function flipRowView() {
                              return new MatrixFlipRowView(this);
                         } /**
                           * Returns a view of the matrix flipped in the column axis
                           * @return {MatrixFlipColumnView}
                           */ }, { key: "flipColumnView", value: function flipColumnView() {
                              return new MatrixFlipColumnView(this);
                         } /**
                           * Returns a view of a submatrix giving the index boundaries
                           * @param {number} startRow - first row index of the submatrix
                           * @param {number} endRow - last row index of the submatrix
                           * @param {number} startColumn - first column index of the submatrix
                           * @param {number} endColumn - last column index of the submatrix
                           * @return {MatrixSubView}
                           */ }, { key: "subMatrixView", value: function subMatrixView(startRow, endRow, startColumn, endColumn) {
                              return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);
                         } /**
                           * Returns a view of the cross of the row indices and the column indices
                           * @example
                           * // resulting vector is [[2], [2]]
                           * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])
                           * @param {Array<number>} rowIndices
                           * @param {Array<number>} columnIndices
                           * @return {MatrixSelectionView}
                           */ }, { key: "selectionView", value: function selectionView(rowIndices, columnIndices) {
                              return new MatrixSelectionView(this, rowIndices, columnIndices);
                         } /**
                           * Returns a view of the row indices
                           * @example
                           * // resulting vector is [[1,2,3], [1,2,3]]
                           * var matrix = new Matrix([[1,2,3], [4,5,6]]).rowSelectionView([0, 0])
                           * @param {Array<number>} rowIndices
                           * @return {MatrixRowSelectionView}
                           */ }, { key: "rowSelectionView", value: function rowSelectionView(rowIndices) {
                              return new MatrixRowSelectionView(this, rowIndices);
                         } /**
                           * Returns a view of the column indices
                           * @example
                           * // resulting vector is [[2, 2], [5, 5]]
                           * var matrix = new Matrix([[1,2,3], [4,5,6]]).columnSelectionView([1, 1])
                           * @param {Array<number>} columnIndices
                           * @return {MatrixColumnSelectionView}
                           */ }, { key: "columnSelectionView", value: function columnSelectionView(columnIndices) {
                              return new MatrixColumnSelectionView(this, columnIndices);
                         } /**
                           * Calculates and returns the determinant of a matrix as a Number
                           * @example
                           *   new Matrix([[1,2,3], [4,5,6]]).det()
                           * @return {number}
                           */ }, { key: "det", value: function det() {
                              if (this.isSquare()) {
                                   var a, b, c, d;if (this.columns === 2) {
                                        // 2 x 2 matrix
                                        a = this.get(0, 0);b = this.get(0, 1);c = this.get(1, 0);d = this.get(1, 1);return a * d - b * c;
                                   } else if (this.columns === 3) {
                                        // 3 x 3 matrix
                                        var subMatrix0, subMatrix1, subMatrix2;subMatrix0 = this.selectionView([1, 2], [1, 2]);subMatrix1 = this.selectionView([1, 2], [0, 2]);subMatrix2 = this.selectionView([1, 2], [0, 1]);a = this.get(0, 0);b = this.get(0, 1);c = this.get(0, 2);return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();
                                   } else {
                                        // general purpose determinant using the LU decomposition
                                        return new LuDecomposition$$1(this).determinant;
                                   }
                              } else {
                                   throw Error('Determinant can only be calculated for a square matrix.');
                              }
                         } /**
                           * Returns inverse of a matrix if it exists or the pseudoinverse
                           * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)
                           * @return {Matrix} the (pseudo)inverted matrix.
                           */ }, { key: "pseudoInverse", value: function pseudoInverse(threshold) {
                              if (threshold === undefined) threshold = Number.EPSILON;var svdSolution = new SingularValueDecomposition$$1(this, { autoTranspose: true });var U = svdSolution.leftSingularVectors;var V = svdSolution.rightSingularVectors;var s = svdSolution.diagonal;for (var i = 0; i < s.length; i++) {
                                   if (Math.abs(s[i]) > threshold) {
                                        s[i] = 1.0 / s[i];
                                   } else {
                                        s[i] = 0.0;
                                   }
                              } // convert list to diagonal
                              s = this.constructor[Symbol.species].diag(s);return V.mmul(s.mmul(U.transposeView()));
                         } /**
                           * Creates an exact and independent copy of the matrix
                           * @return {Matrix}
                           */ }, { key: "clone", value: function clone() {
                              var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);for (var row = 0; row < this.rows; row++) {
                                   for (var column = 0; column < this.columns; column++) {
                                        newMatrix.set(row, column, this.get(row, column));
                                   }
                              }return newMatrix;
                         } }, { key: "size", /**
                                             * @prop {number} size - The number of elements in the matrix.
                                             */get: function get() {
                              return this.rows * this.columns;
                         } }], [{ key: "from1DArray", /**
                                                      * Constructs a Matrix with the chosen dimensions from a 1D array
                                                      * @param {number} newRows - Number of rows
                                                      * @param {number} newColumns - Number of columns
                                                      * @param {Array} newData - A 1D array containing data for the matrix
                                                      * @return {Matrix} - The new matrix
                                                      */value: function from1DArray(newRows, newColumns, newData) {
                              var length = newRows * newColumns;if (length !== newData.length) {
                                   throw new RangeError('Data length does not match given dimensions');
                              }var newMatrix = new this(newRows, newColumns);for (var row = 0; row < newRows; row++) {
                                   for (var column = 0; column < newColumns; column++) {
                                        newMatrix.set(row, column, newData[row * newColumns + column]);
                                   }
                              }return newMatrix;
                         } /**
                           * Creates a row vector, a matrix with only one row.
                           * @param {Array} newData - A 1D array containing data for the vector
                           * @return {Matrix} - The new matrix
                           */ }, { key: "rowVector", value: function rowVector(newData) {
                              var vector = new this(1, newData.length);for (var i = 0; i < newData.length; i++) {
                                   vector.set(0, i, newData[i]);
                              }return vector;
                         } /**
                           * Creates a column vector, a matrix with only one column.
                           * @param {Array} newData - A 1D array containing data for the vector
                           * @return {Matrix} - The new matrix
                           */ }, { key: "columnVector", value: function columnVector(newData) {
                              var vector = new this(newData.length, 1);for (var i = 0; i < newData.length; i++) {
                                   vector.set(i, 0, newData[i]);
                              }return vector;
                         } /**
                           * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).
                           * @param {number} rows - Number of rows
                           * @param {number} columns - Number of columns
                           * @return {Matrix} - The new matrix
                           */ }, { key: "empty", value: function empty(rows, columns) {
                              return new this(rows, columns);
                         } /**
                           * Creates a matrix with the given dimensions. Values will be set to zero.
                           * @param {number} rows - Number of rows
                           * @param {number} columns - Number of columns
                           * @return {Matrix} - The new matrix
                           */ }, { key: "zeros", value: function zeros(rows, columns) {
                              return this.empty(rows, columns).fill(0);
                         } /**
                           * Creates a matrix with the given dimensions. Values will be set to one.
                           * @param {number} rows - Number of rows
                           * @param {number} columns - Number of columns
                           * @return {Matrix} - The new matrix
                           */ }, { key: "ones", value: function ones(rows, columns) {
                              return this.empty(rows, columns).fill(1);
                         } /**
                           * Creates a matrix with the given dimensions. Values will be randomly set.
                           * @param {number} rows - Number of rows
                           * @param {number} columns - Number of columns
                           * @param {function} [rng=Math.random] - Random number generator
                           * @return {Matrix} The new matrix
                           */ }, { key: "rand", value: function rand(rows, columns, rng) {
                              if (rng === undefined) rng = Math.random;var matrix = this.empty(rows, columns);for (var i = 0; i < rows; i++) {
                                   for (var j = 0; j < columns; j++) {
                                        matrix.set(i, j, rng());
                                   }
                              }return matrix;
                         } /**
                           * Creates a matrix with the given dimensions. Values will be random integers.
                           * @param {number} rows - Number of rows
                           * @param {number} columns - Number of columns
                           * @param {number} [maxValue=1000] - Maximum value
                           * @param {function} [rng=Math.random] - Random number generator
                           * @return {Matrix} The new matrix
                           */ }, { key: "randInt", value: function randInt(rows, columns, maxValue, rng) {
                              if (maxValue === undefined) maxValue = 1000;if (rng === undefined) rng = Math.random;var matrix = this.empty(rows, columns);for (var i = 0; i < rows; i++) {
                                   for (var j = 0; j < columns; j++) {
                                        var value = Math.floor(rng() * maxValue);matrix.set(i, j, value);
                                   }
                              }return matrix;
                         } /**
                           * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.
                           * @param {number} rows - Number of rows
                           * @param {number} [columns=rows] - Number of columns
                           * @param {number} [value=1] - Value to fill the diagonal with
                           * @return {Matrix} - The new identity matrix
                           */ }, { key: "eye", value: function eye(rows, columns, value) {
                              if (columns === undefined) columns = rows;if (value === undefined) value = 1;var min = Math.min(rows, columns);var matrix = this.zeros(rows, columns);for (var i = 0; i < min; i++) {
                                   matrix.set(i, i, value);
                              }return matrix;
                         } /**
                           * Creates a diagonal matrix based on the given array.
                           * @param {Array} data - Array containing the data for the diagonal
                           * @param {number} [rows] - Number of rows (Default: data.length)
                           * @param {number} [columns] - Number of columns (Default: rows)
                           * @return {Matrix} - The new diagonal matrix
                           */ }, { key: "diag", value: function diag(data, rows, columns) {
                              var l = data.length;if (rows === undefined) rows = l;if (columns === undefined) columns = rows;var min = Math.min(l, rows, columns);var matrix = this.zeros(rows, columns);for (var i = 0; i < min; i++) {
                                   matrix.set(i, i, data[i]);
                              }return matrix;
                         } /**
                           * Returns a matrix whose elements are the minimum between matrix1 and matrix2
                           * @param {Matrix} matrix1
                           * @param {Matrix} matrix2
                           * @return {Matrix}
                           */ }, { key: "min", value: function min(matrix1, matrix2) {
                              matrix1 = this.checkMatrix(matrix1);matrix2 = this.checkMatrix(matrix2);var rows = matrix1.rows;var columns = matrix1.columns;var result = new this(rows, columns);for (var i = 0; i < rows; i++) {
                                   for (var j = 0; j < columns; j++) {
                                        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
                                   }
                              }return result;
                         } /**
                           * Returns a matrix whose elements are the maximum between matrix1 and matrix2
                           * @param {Matrix} matrix1
                           * @param {Matrix} matrix2
                           * @return {Matrix}
                           */ }, { key: "max", value: function max(matrix1, matrix2) {
                              matrix1 = this.checkMatrix(matrix1);matrix2 = this.checkMatrix(matrix2);var rows = matrix1.rows;var columns = matrix1.columns;var result = new this(rows, columns);for (var i = 0; i < rows; i++) {
                                   for (var j = 0; j < columns; j++) {
                                        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
                                   }
                              }return result;
                         } /**
                           * Check that the provided value is a Matrix and tries to instantiate one if not
                           * @param {*} value - The value to check
                           * @return {Matrix}
                           */ }, { key: "checkMatrix", value: function checkMatrix(value) {
                              return Matrix.isMatrix(value) ? value : new this(value);
                         } /**
                           * Returns true if the argument is a Matrix, false otherwise
                           * @param {*} value - The value to check
                           * @return {boolean}
                           */ }, { key: "isMatrix", value: function isMatrix(value) {
                              return value != null && value.klass === 'Matrix';
                         } }, { key: Symbol.species, get: function get() {
                              return this;
                         } }]);return Matrix;
               }(superCtor);Matrix.prototype.klass = 'Matrix';function compareNumbers(a, b) {
                    return a - b;
               } /*
                 Synonyms
                 */Matrix.random = Matrix.rand;Matrix.diagonal = Matrix.diag;Matrix.prototype.diagonal = Matrix.prototype.diag;Matrix.identity = Matrix.eye;Matrix.prototype.negate = Matrix.prototype.neg;Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;Matrix.prototype.determinant = Matrix.prototype.det; /*
                                                                                                                                                                                                                                                                                                                                   Add dynamically instance and static methods for mathematical operations
                                                                                                                                                                                                                                                                                                                                   */var inplaceOperator = "\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n";var inplaceOperatorScalar = "\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% value);\n        }\n    }\n    return this;\n})\n";var inplaceOperatorMatrix = "\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n        this.columns !== matrix.columns) {\n        throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\n        }\n    }\n    return this;\n})\n";var staticOperator = "\n(function %name%(matrix, value) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(value);\n})\n";var inplaceMethod = "\n(function %name%() {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j)));\n        }\n    }\n    return this;\n})\n";var staticMethod = "\n(function %name%(matrix) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%();\n})\n";var inplaceMethodWithArgs = "\n(function %name%(%args%) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), %args%));\n        }\n    }\n    return this;\n})\n";var staticMethodWithArgs = "\n(function %name%(matrix, %args%) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(%args%);\n})\n";var inplaceMethodWithOneArgScalar = "\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), value));\n        }\n    }\n    return this;\n})\n";var inplaceMethodWithOneArgMatrix = "\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n        this.columns !== matrix.columns) {\n        throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\n        }\n    }\n    return this;\n})\n";var inplaceMethodWithOneArg = "\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n";var staticMethodWithOneArg = staticMethodWithArgs;var operators = [// Arithmetic operators
               ['+', 'add'], ['-', 'sub', 'subtract'], ['*', 'mul', 'multiply'], ['/', 'div', 'divide'], ['%', 'mod', 'modulus'], // Bitwise operators
               ['&', 'and'], ['|', 'or'], ['^', 'xor'], ['<<', 'leftShift'], ['>>', 'signPropagatingRightShift'], ['>>>', 'rightShift', 'zeroFillRightShift']];var i;var eval2 = eval;var _iteratorNormalCompletion3 = true;var _didIteratorError3 = false;var _iteratorError3 = undefined;try {
                    for (var _iterator3 = operators[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                         var operator = _step3.value;var inplaceOp = eval2(fillTemplateFunction(inplaceOperator, { name: operator[1], op: operator[0] }));var inplaceOpS = eval2(fillTemplateFunction(inplaceOperatorScalar, { name: operator[1] + 'S', op: operator[0] }));var inplaceOpM = eval2(fillTemplateFunction(inplaceOperatorMatrix, { name: operator[1] + 'M', op: operator[0] }));var staticOp = eval2(fillTemplateFunction(staticOperator, { name: operator[1] }));for (i = 1; i < operator.length; i++) {
                              Matrix.prototype[operator[i]] = inplaceOp;Matrix.prototype[operator[i] + 'S'] = inplaceOpS;Matrix.prototype[operator[i] + 'M'] = inplaceOpM;Matrix[operator[i]] = staticOp;
                         }
                    }
               } catch (err) {
                    _didIteratorError3 = true;_iteratorError3 = err;
               } finally {
                    try {
                         if (!_iteratorNormalCompletion3 && _iterator3.return) {
                              _iterator3.return();
                         }
                    } finally {
                         if (_didIteratorError3) {
                              throw _iteratorError3;
                         }
                    }
               }var methods = [['~', 'not']];['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil', 'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p', 'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'].forEach(function (mathMethod) {
                    methods.push(['Math.' + mathMethod, mathMethod]);
               });var _iteratorNormalCompletion4 = true;var _didIteratorError4 = false;var _iteratorError4 = undefined;try {
                    for (var _iterator4 = methods[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                         var method = _step4.value;var inplaceMeth = eval2(fillTemplateFunction(inplaceMethod, { name: method[1], method: method[0] }));var staticMeth = eval2(fillTemplateFunction(staticMethod, { name: method[1] }));for (i = 1; i < method.length; i++) {
                              Matrix.prototype[method[i]] = inplaceMeth;Matrix[method[i]] = staticMeth;
                         }
                    }
               } catch (err) {
                    _didIteratorError4 = true;_iteratorError4 = err;
               } finally {
                    try {
                         if (!_iteratorNormalCompletion4 && _iterator4.return) {
                              _iterator4.return();
                         }
                    } finally {
                         if (_didIteratorError4) {
                              throw _iteratorError4;
                         }
                    }
               }var methodsWithArgs = [['Math.pow', 1, 'pow']];var _iteratorNormalCompletion5 = true;var _didIteratorError5 = false;var _iteratorError5 = undefined;try {
                    for (var _iterator5 = methodsWithArgs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                         var methodWithArg = _step5.value;var args = 'arg0';for (i = 1; i < methodWithArg[1]; i++) {
                              args += ", arg" + i;
                         }if (methodWithArg[1] !== 1) {
                              var inplaceMethWithArgs = eval2(fillTemplateFunction(inplaceMethodWithArgs, { name: methodWithArg[2], method: methodWithArg[0], args: args }));var staticMethWithArgs = eval2(fillTemplateFunction(staticMethodWithArgs, { name: methodWithArg[2], args: args }));for (i = 2; i < methodWithArg.length; i++) {
                                   Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;Matrix[methodWithArg[i]] = staticMethWithArgs;
                              }
                         } else {
                              var tmplVar = { name: methodWithArg[2], args: args, method: methodWithArg[0] };var inplaceMethod2 = eval2(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));var inplaceMethodS = eval2(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));var inplaceMethodM = eval2(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));var staticMethod2 = eval2(fillTemplateFunction(staticMethodWithOneArg, tmplVar));for (i = 2; i < methodWithArg.length; i++) {
                                   Matrix.prototype[methodWithArg[i]] = inplaceMethod2;Matrix.prototype[methodWithArg[i] + 'M'] = inplaceMethodM;Matrix.prototype[methodWithArg[i] + 'S'] = inplaceMethodS;Matrix[methodWithArg[i]] = staticMethod2;
                              }
                         }
                    }
               } catch (err) {
                    _didIteratorError5 = true;_iteratorError5 = err;
               } finally {
                    try {
                         if (!_iteratorNormalCompletion5 && _iterator5.return) {
                              _iterator5.return();
                         }
                    } finally {
                         if (_didIteratorError5) {
                              throw _iteratorError5;
                         }
                    }
               }function fillTemplateFunction(template, values) {
                    for (var value in values) {
                         template = template.replace(new RegExp('%' + value + '%', 'g'), values[value]);
                    }return template;
               }return Matrix;
          }var Matrix = function (_AbstractMatrix2) {
               _inherits(Matrix, _AbstractMatrix2);function Matrix(nRows, nColumns) {
                    var _ret3;_classCallCheck4(this, Matrix);var i;if (arguments.length === 1 && typeof nRows === 'number') {
                         var _ret;return _ret = new Array(nRows), _possibleConstructorReturn(_this14, _ret);
                    }if (Matrix.isMatrix(nRows)) {
                         var _ret2;return _ret2 = nRows.clone(), _possibleConstructorReturn(_this14, _ret2);
                    } else if (Number.isInteger(nRows) && nRows > 0) {
                         var _this14 = _possibleConstructorReturn(this, (Matrix.__proto__ || Object.getPrototypeOf(Matrix)).call(this, nRows)); // Create an empty matrix
                         if (Number.isInteger(nColumns) && nColumns > 0) {
                              for (i = 0; i < nRows; i++) {
                                   _this14[i] = new Array(nColumns);
                              }
                         } else {
                              throw new TypeError('nColumns must be a positive integer');
                         }
                    } else if (Array.isArray(nRows)) {
                         // Copy the values from the 2D array
                         var matrix = nRows;nRows = matrix.length;nColumns = matrix[0].length;if (typeof nColumns !== 'number' || nColumns === 0) {
                              throw new TypeError('Data must be a 2D array with at least one element');
                         }var _this14 = _possibleConstructorReturn(this, (Matrix.__proto__ || Object.getPrototypeOf(Matrix)).call(this, nRows));for (i = 0; i < nRows; i++) {
                              if (matrix[i].length !== nColumns) {
                                   throw new RangeError('Inconsistent array dimensions');
                              }_this14[i] = [].concat(matrix[i]);
                         }
                    } else {
                         throw new TypeError('First argument must be a positive number or an array');
                    }_this14.rows = nRows;_this14.columns = nColumns;return _ret3 = _this14, _possibleConstructorReturn(_this14, _ret3);
               }_createClass4(Matrix, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this[rowIndex][columnIndex] = value;return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this[rowIndex][columnIndex];
                    } /**
                      * Removes a row from the given index
                      * @param {number} index - Row index
                      * @return {Matrix} this
                      */ }, { key: "removeRow", value: function removeRow(index) {
                         checkRowIndex(this, index);if (this.rows === 1) {
                              throw new RangeError('A matrix cannot have less than one row');
                         }this.splice(index, 1);this.rows -= 1;return this;
                    } /**
                      * Adds a row at the given index
                      * @param {number} [index = this.rows] - Row index
                      * @param {Array|Matrix} array - Array or vector
                      * @return {Matrix} this
                      */ }, { key: "addRow", value: function addRow(index, array) {
                         if (array === undefined) {
                              array = index;index = this.rows;
                         }checkRowIndex(this, index, true);array = checkRowVector(this, array, true);this.splice(index, 0, array);this.rows += 1;return this;
                    } /**
                      * Removes a column from the given index
                      * @param {number} index - Column index
                      * @return {Matrix} this
                      */ }, { key: "removeColumn", value: function removeColumn(index) {
                         checkColumnIndex(this, index);if (this.columns === 1) {
                              throw new RangeError('A matrix cannot have less than one column');
                         }for (var i = 0; i < this.rows; i++) {
                              this[i].splice(index, 1);
                         }this.columns -= 1;return this;
                    } /**
                      * Adds a column at the given index
                      * @param {number} [index = this.columns] - Column index
                      * @param {Array|Matrix} array - Array or vector
                      * @return {Matrix} this
                      */ }, { key: "addColumn", value: function addColumn(index, array) {
                         if (typeof array === 'undefined') {
                              array = index;index = this.columns;
                         }checkColumnIndex(this, index, true);array = checkColumnVector(this, array);for (var i = 0; i < this.rows; i++) {
                              this[i].splice(index, 0, array[i]);
                         }this.columns += 1;return this;
                    } }]);return Matrix;
          }(AbstractMatrix(Array));var WrapperMatrix1D = function (_AbstractMatrix3) {
               _inherits(WrapperMatrix1D, _AbstractMatrix3); /**
                                                             * @class WrapperMatrix1D
                                                             * @param {Array<number>} data
                                                             * @param {object} [options]
                                                             * @param {object} [options.rows = 1]
                                                             */function WrapperMatrix1D(data) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck4(this, WrapperMatrix1D);var _options$rows = options.rows,
                        rows = _options$rows === undefined ? 1 : _options$rows;if (data.length % rows !== 0) {
                         throw new Error('the data length is not divisible by the number of rows');
                    }var _this15 = _possibleConstructorReturn(this, (WrapperMatrix1D.__proto__ || Object.getPrototypeOf(WrapperMatrix1D)).call(this));_this15.rows = rows;_this15.columns = data.length / rows;_this15.data = data;return _this15;
               }_createClass4(WrapperMatrix1D, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         var index = this._calculateIndex(rowIndex, columnIndex);this.data[index] = value;return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         var index = this._calculateIndex(rowIndex, columnIndex);return this.data[index];
                    } }, { key: "_calculateIndex", value: function _calculateIndex(row, column) {
                         return row * this.columns + column;
                    } }], [{ key: Symbol.species, get: function get() {
                         return Matrix;
                    } }]);return WrapperMatrix1D;
          }(AbstractMatrix());var WrapperMatrix2D = function (_AbstractMatrix4) {
               _inherits(WrapperMatrix2D, _AbstractMatrix4); /**
                                                             * @class WrapperMatrix2D
                                                             * @param {Array<Array<number>>} data
                                                             */function WrapperMatrix2D(data) {
                    _classCallCheck4(this, WrapperMatrix2D);var _this16 = _possibleConstructorReturn(this, (WrapperMatrix2D.__proto__ || Object.getPrototypeOf(WrapperMatrix2D)).call(this));_this16.data = data;_this16.rows = data.length;_this16.columns = data[0].length;return _this16;
               }_createClass4(WrapperMatrix2D, [{ key: "set", value: function set(rowIndex, columnIndex, value) {
                         this.data[rowIndex][columnIndex] = value;return this;
                    } }, { key: "get", value: function get(rowIndex, columnIndex) {
                         return this.data[rowIndex][columnIndex];
                    } }], [{ key: Symbol.species, get: function get() {
                         return Matrix;
                    } }]);return WrapperMatrix2D;
          }(AbstractMatrix()); /**
                               * @param {Array<Array<number>>|Array<number>} array
                               * @param {object} [options]
                               * @param {object} [options.rows = 1]
                               * @return {WrapperMatrix1D|WrapperMatrix2D}
                               */function wrap(array, options) {
               if (Array.isArray(array)) {
                    if (array[0] && Array.isArray(array[0])) {
                         return new WrapperMatrix2D(array);
                    } else {
                         return new WrapperMatrix1D(array, options);
                    }
               } else {
                    throw new Error('the argument is not an array');
               }
          } /**
            * @class QrDecomposition
            * @link https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs
            * @param {Matrix} value
            */var QrDecomposition$$1 = function () {
               function QrDecomposition$$1(value) {
                    _classCallCheck4(this, QrDecomposition$$1);value = WrapperMatrix2D.checkMatrix(value);var qr = value.clone();var m = value.rows;var n = value.columns;var rdiag = new Array(n);var i, j, k, s;for (k = 0; k < n; k++) {
                         var nrm = 0;for (i = k; i < m; i++) {
                              nrm = hypotenuse(nrm, qr.get(i, k));
                         }if (nrm !== 0) {
                              if (qr.get(k, k) < 0) {
                                   nrm = -nrm;
                              }for (i = k; i < m; i++) {
                                   qr.set(i, k, qr.get(i, k) / nrm);
                              }qr.set(k, k, qr.get(k, k) + 1);for (j = k + 1; j < n; j++) {
                                   s = 0;for (i = k; i < m; i++) {
                                        s += qr.get(i, k) * qr.get(i, j);
                                   }s = -s / qr.get(k, k);for (i = k; i < m; i++) {
                                        qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
                                   }
                              }
                         }rdiag[k] = -nrm;
                    }this.QR = qr;this.Rdiag = rdiag;
               } /**
                 * Solve a problem of least square (Ax=b) by using the QR decomposition. Useful when A is rectangular, but not working when A is singular.
                 * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
                 * var qr = QrDecomposition(A);
                 * var x = qr.solve(b);
                 * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
                 * @return {Matrix} - The vector x
                 */_createClass4(QrDecomposition$$1, [{ key: "solve", value: function solve(value) {
                         value = Matrix.checkMatrix(value);var qr = this.QR;var m = qr.rows;if (value.rows !== m) {
                              throw new Error('Matrix row dimensions must agree');
                         }if (!this.isFullRank()) {
                              throw new Error('Matrix is rank deficient');
                         }var count = value.columns;var X = value.clone();var n = qr.columns;var i, j, k, s;for (k = 0; k < n; k++) {
                              for (j = 0; j < count; j++) {
                                   s = 0;for (i = k; i < m; i++) {
                                        s += qr[i][k] * X[i][j];
                                   }s = -s / qr[k][k];for (i = k; i < m; i++) {
                                        X[i][j] += s * qr[i][k];
                                   }
                              }
                         }for (k = n - 1; k >= 0; k--) {
                              for (j = 0; j < count; j++) {
                                   X[k][j] /= this.Rdiag[k];
                              }for (i = 0; i < k; i++) {
                                   for (j = 0; j < count; j++) {
                                        X[i][j] -= X[k][j] * qr[i][k];
                                   }
                              }
                         }return X.subMatrix(0, n - 1, 0, count - 1);
                    } /**
                      *
                      * @return {boolean}
                      */ }, { key: "isFullRank", value: function isFullRank() {
                         var columns = this.QR.columns;for (var i = 0; i < columns; i++) {
                              if (this.Rdiag[i] === 0) {
                                   return false;
                              }
                         }return true;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "upperTriangularMatrix", get: function get() {
                         var qr = this.QR;var n = qr.columns;var X = new Matrix(n, n);var i, j;for (i = 0; i < n; i++) {
                              for (j = 0; j < n; j++) {
                                   if (i < j) {
                                        X[i][j] = qr[i][j];
                                   } else if (i === j) {
                                        X[i][j] = this.Rdiag[i];
                                   } else {
                                        X[i][j] = 0;
                                   }
                              }
                         }return X;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "orthogonalMatrix", get: function get() {
                         var qr = this.QR;var rows = qr.rows;var columns = qr.columns;var X = new Matrix(rows, columns);var i, j, k, s;for (k = columns - 1; k >= 0; k--) {
                              for (i = 0; i < rows; i++) {
                                   X[i][k] = 0;
                              }X[k][k] = 1;for (j = k; j < columns; j++) {
                                   if (qr[k][k] !== 0) {
                                        s = 0;for (i = k; i < rows; i++) {
                                             s += qr[i][k] * X[i][j];
                                        }s = -s / qr[k][k];for (i = k; i < rows; i++) {
                                             X[i][j] += s * qr[i][k];
                                        }
                                   }
                              }
                         }return X;
                    } }]);return QrDecomposition$$1;
          }(); /**
               * Computes the inverse of a Matrix
               * @param {Matrix} matrix
               * @param {boolean} [useSVD=false]
               * @return {Matrix}
               */function inverse$$1(matrix) {
               var useSVD = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;matrix = WrapperMatrix2D.checkMatrix(matrix);if (useSVD) {
                    return new SingularValueDecomposition$$1(matrix).inverse();
               } else {
                    return solve$$1(matrix, Matrix.eye(matrix.rows));
               }
          } /**
            *
            * @param {Matrix} leftHandSide
            * @param {Matrix} rightHandSide
            * @param {boolean} [useSVD = false]
            * @return {Matrix}
            */function solve$$1(leftHandSide, rightHandSide) {
               var useSVD = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);if (useSVD) {
                    return new SingularValueDecomposition$$1(leftHandSide).solve(rightHandSide);
               } else {
                    return leftHandSide.isSquare() ? new LuDecomposition$$1(leftHandSide).solve(rightHandSide) : new QrDecomposition$$1(leftHandSide).solve(rightHandSide);
               }
          } /**
            * @class EigenvalueDecomposition
            * @link https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs
            * @param {Matrix} matrix
            * @param {object} [options]
            * @param {boolean} [options.assumeSymmetric=false]
            */var EigenvalueDecomposition$$1 = function () {
               function EigenvalueDecomposition$$1(matrix) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck4(this, EigenvalueDecomposition$$1);var _options$assumeSymmet = options.assumeSymmetric,
                        assumeSymmetric = _options$assumeSymmet === undefined ? false : _options$assumeSymmet;matrix = WrapperMatrix2D.checkMatrix(matrix);if (!matrix.isSquare()) {
                         throw new Error('Matrix is not a square matrix');
                    }var n = matrix.columns;var V = getFilled2DArray(n, n, 0);var d = new Array(n);var e = new Array(n);var value = matrix;var i, j;var isSymmetric = false;if (assumeSymmetric) {
                         isSymmetric = true;
                    } else {
                         isSymmetric = matrix.isSymmetric();
                    }if (isSymmetric) {
                         for (i = 0; i < n; i++) {
                              for (j = 0; j < n; j++) {
                                   V[i][j] = value.get(i, j);
                              }
                         }tred2(n, e, d, V);tql2(n, e, d, V);
                    } else {
                         var H = getFilled2DArray(n, n, 0);var ort = new Array(n);for (j = 0; j < n; j++) {
                              for (i = 0; i < n; i++) {
                                   H[i][j] = value.get(i, j);
                              }
                         }orthes(n, H, ort, V);hqr2(n, e, d, V, H);
                    }this.n = n;this.e = e;this.d = d;this.V = V;
               } /**
                 *
                 * @return {Array<number>}
                 */_createClass4(EigenvalueDecomposition$$1, [{ key: "realEigenvalues", get: function get() {
                         return this.d;
                    } /**
                      *
                      * @return {Array<number>}
                      */ }, { key: "imaginaryEigenvalues", get: function get() {
                         return this.e;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "eigenvectorMatrix", get: function get() {
                         if (!Matrix.isMatrix(this.V)) {
                              this.V = new Matrix(this.V);
                         }return this.V;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "diagonalMatrix", get: function get() {
                         var n = this.n;var e = this.e;var d = this.d;var X = new Matrix(n, n);var i, j;for (i = 0; i < n; i++) {
                              for (j = 0; j < n; j++) {
                                   X[i][j] = 0;
                              }X[i][i] = d[i];if (e[i] > 0) {
                                   X[i][i + 1] = e[i];
                              } else if (e[i] < 0) {
                                   X[i][i - 1] = e[i];
                              }
                         }return X;
                    } }]);return EigenvalueDecomposition$$1;
          }();function tred2(n, e, d, V) {
               var f, g, h, i, j, k, hh, scale;for (j = 0; j < n; j++) {
                    d[j] = V[n - 1][j];
               }for (i = n - 1; i > 0; i--) {
                    scale = 0;h = 0;for (k = 0; k < i; k++) {
                         scale = scale + Math.abs(d[k]);
                    }if (scale === 0) {
                         e[i] = d[i - 1];for (j = 0; j < i; j++) {
                              d[j] = V[i - 1][j];V[i][j] = 0;V[j][i] = 0;
                         }
                    } else {
                         for (k = 0; k < i; k++) {
                              d[k] /= scale;h += d[k] * d[k];
                         }f = d[i - 1];g = Math.sqrt(h);if (f > 0) {
                              g = -g;
                         }e[i] = scale * g;h = h - f * g;d[i - 1] = f - g;for (j = 0; j < i; j++) {
                              e[j] = 0;
                         }for (j = 0; j < i; j++) {
                              f = d[j];V[j][i] = f;g = e[j] + V[j][j] * f;for (k = j + 1; k <= i - 1; k++) {
                                   g += V[k][j] * d[k];e[k] += V[k][j] * f;
                              }e[j] = g;
                         }f = 0;for (j = 0; j < i; j++) {
                              e[j] /= h;f += e[j] * d[j];
                         }hh = f / (h + h);for (j = 0; j < i; j++) {
                              e[j] -= hh * d[j];
                         }for (j = 0; j < i; j++) {
                              f = d[j];g = e[j];for (k = j; k <= i - 1; k++) {
                                   V[k][j] -= f * e[k] + g * d[k];
                              }d[j] = V[i - 1][j];V[i][j] = 0;
                         }
                    }d[i] = h;
               }for (i = 0; i < n - 1; i++) {
                    V[n - 1][i] = V[i][i];V[i][i] = 1;h = d[i + 1];if (h !== 0) {
                         for (k = 0; k <= i; k++) {
                              d[k] = V[k][i + 1] / h;
                         }for (j = 0; j <= i; j++) {
                              g = 0;for (k = 0; k <= i; k++) {
                                   g += V[k][i + 1] * V[k][j];
                              }for (k = 0; k <= i; k++) {
                                   V[k][j] -= g * d[k];
                              }
                         }
                    }for (k = 0; k <= i; k++) {
                         V[k][i + 1] = 0;
                    }
               }for (j = 0; j < n; j++) {
                    d[j] = V[n - 1][j];V[n - 1][j] = 0;
               }V[n - 1][n - 1] = 1;e[0] = 0;
          }function tql2(n, e, d, V) {
               var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;for (i = 1; i < n; i++) {
                    e[i - 1] = e[i];
               }e[n - 1] = 0;var f = 0;var tst1 = 0;var eps = Number.EPSILON;for (l = 0; l < n; l++) {
                    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));m = l;while (m < n) {
                         if (Math.abs(e[m]) <= eps * tst1) {
                              break;
                         }m++;
                    }if (m > l) {
                         iter = 0;do {
                              iter = iter + 1;g = d[l];p = (d[l + 1] - g) / (2 * e[l]);r = hypotenuse(p, 1);if (p < 0) {
                                   r = -r;
                              }d[l] = e[l] / (p + r);d[l + 1] = e[l] * (p + r);dl1 = d[l + 1];h = g - d[l];for (i = l + 2; i < n; i++) {
                                   d[i] -= h;
                              }f = f + h;p = d[m];c = 1;c2 = c;c3 = c;el1 = e[l + 1];s = 0;s2 = 0;for (i = m - 1; i >= l; i--) {
                                   c3 = c2;c2 = c;s2 = s;g = c * e[i];h = c * p;r = hypotenuse(p, e[i]);e[i + 1] = s * r;s = e[i] / r;c = p / r;p = c * d[i] - s * g;d[i + 1] = h + s * (c * g + s * d[i]);for (k = 0; k < n; k++) {
                                        h = V[k][i + 1];V[k][i + 1] = s * V[k][i] + c * h;V[k][i] = c * V[k][i] - s * h;
                                   }
                              }p = -s * s2 * c3 * el1 * e[l] / dl1;e[l] = s * p;d[l] = c * p;
                         } while (Math.abs(e[l]) > eps * tst1);
                    }d[l] = d[l] + f;e[l] = 0;
               }for (i = 0; i < n - 1; i++) {
                    k = i;p = d[i];for (j = i + 1; j < n; j++) {
                         if (d[j] < p) {
                              k = j;p = d[j];
                         }
                    }if (k !== i) {
                         d[k] = d[i];d[i] = p;for (j = 0; j < n; j++) {
                              p = V[j][i];V[j][i] = V[j][k];V[j][k] = p;
                         }
                    }
               }
          }function orthes(n, H, ort, V) {
               var low = 0;var high = n - 1;var f, g, h, i, j, m;var scale;for (m = low + 1; m <= high - 1; m++) {
                    scale = 0;for (i = m; i <= high; i++) {
                         scale = scale + Math.abs(H[i][m - 1]);
                    }if (scale !== 0) {
                         h = 0;for (i = high; i >= m; i--) {
                              ort[i] = H[i][m - 1] / scale;h += ort[i] * ort[i];
                         }g = Math.sqrt(h);if (ort[m] > 0) {
                              g = -g;
                         }h = h - ort[m] * g;ort[m] = ort[m] - g;for (j = m; j < n; j++) {
                              f = 0;for (i = high; i >= m; i--) {
                                   f += ort[i] * H[i][j];
                              }f = f / h;for (i = m; i <= high; i++) {
                                   H[i][j] -= f * ort[i];
                              }
                         }for (i = 0; i <= high; i++) {
                              f = 0;for (j = high; j >= m; j--) {
                                   f += ort[j] * H[i][j];
                              }f = f / h;for (j = m; j <= high; j++) {
                                   H[i][j] -= f * ort[j];
                              }
                         }ort[m] = scale * ort[m];H[m][m - 1] = scale * g;
                    }
               }for (i = 0; i < n; i++) {
                    for (j = 0; j < n; j++) {
                         V[i][j] = i === j ? 1 : 0;
                    }
               }for (m = high - 1; m >= low + 1; m--) {
                    if (H[m][m - 1] !== 0) {
                         for (i = m + 1; i <= high; i++) {
                              ort[i] = H[i][m - 1];
                         }for (j = m; j <= high; j++) {
                              g = 0;for (i = m; i <= high; i++) {
                                   g += ort[i] * V[i][j];
                              }g = g / ort[m] / H[m][m - 1];for (i = m; i <= high; i++) {
                                   V[i][j] += g * ort[i];
                              }
                         }
                    }
               }
          }function hqr2(nn, e, d, V, H) {
               var n = nn - 1;var low = 0;var high = nn - 1;var eps = Number.EPSILON;var exshift = 0;var norm = 0;var p = 0;var q = 0;var r = 0;var s = 0;var z = 0;var iter = 0;var i, j, k, l, m, t, w, x, y;var ra, sa, vr, vi;var notlast, cdivres;for (i = 0; i < nn; i++) {
                    if (i < low || i > high) {
                         d[i] = H[i][i];e[i] = 0;
                    }for (j = Math.max(i - 1, 0); j < nn; j++) {
                         norm = norm + Math.abs(H[i][j]);
                    }
               }while (n >= low) {
                    l = n;while (l > low) {
                         s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);if (s === 0) {
                              s = norm;
                         }if (Math.abs(H[l][l - 1]) < eps * s) {
                              break;
                         }l--;
                    }if (l === n) {
                         H[n][n] = H[n][n] + exshift;d[n] = H[n][n];e[n] = 0;n--;iter = 0;
                    } else if (l === n - 1) {
                         w = H[n][n - 1] * H[n - 1][n];p = (H[n - 1][n - 1] - H[n][n]) / 2;q = p * p + w;z = Math.sqrt(Math.abs(q));H[n][n] = H[n][n] + exshift;H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;x = H[n][n];if (q >= 0) {
                              z = p >= 0 ? p + z : p - z;d[n - 1] = x + z;d[n] = d[n - 1];if (z !== 0) {
                                   d[n] = x - w / z;
                              }e[n - 1] = 0;e[n] = 0;x = H[n][n - 1];s = Math.abs(x) + Math.abs(z);p = x / s;q = z / s;r = Math.sqrt(p * p + q * q);p = p / r;q = q / r;for (j = n - 1; j < nn; j++) {
                                   z = H[n - 1][j];H[n - 1][j] = q * z + p * H[n][j];H[n][j] = q * H[n][j] - p * z;
                              }for (i = 0; i <= n; i++) {
                                   z = H[i][n - 1];H[i][n - 1] = q * z + p * H[i][n];H[i][n] = q * H[i][n] - p * z;
                              }for (i = low; i <= high; i++) {
                                   z = V[i][n - 1];V[i][n - 1] = q * z + p * V[i][n];V[i][n] = q * V[i][n] - p * z;
                              }
                         } else {
                              d[n - 1] = x + p;d[n] = x + p;e[n - 1] = z;e[n] = -z;
                         }n = n - 2;iter = 0;
                    } else {
                         x = H[n][n];y = 0;w = 0;if (l < n) {
                              y = H[n - 1][n - 1];w = H[n][n - 1] * H[n - 1][n];
                         }if (iter === 10) {
                              exshift += x;for (i = low; i <= n; i++) {
                                   H[i][i] -= x;
                              }s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);x = y = 0.75 * s;w = -0.4375 * s * s;
                         }if (iter === 30) {
                              s = (y - x) / 2;s = s * s + w;if (s > 0) {
                                   s = Math.sqrt(s);if (y < x) {
                                        s = -s;
                                   }s = x - w / ((y - x) / 2 + s);for (i = low; i <= n; i++) {
                                        H[i][i] -= s;
                                   }exshift += s;x = y = w = 0.964;
                              }
                         }iter = iter + 1;m = n - 2;while (m >= l) {
                              z = H[m][m];r = x - z;s = y - z;p = (r * s - w) / H[m + 1][m] + H[m][m + 1];q = H[m + 1][m + 1] - z - r - s;r = H[m + 2][m + 1];s = Math.abs(p) + Math.abs(q) + Math.abs(r);p = p / s;q = q / s;r = r / s;if (m === l) {
                                   break;
                              }if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {
                                   break;
                              }m--;
                         }for (i = m + 2; i <= n; i++) {
                              H[i][i - 2] = 0;if (i > m + 2) {
                                   H[i][i - 3] = 0;
                              }
                         }for (k = m; k <= n - 1; k++) {
                              notlast = k !== n - 1;if (k !== m) {
                                   p = H[k][k - 1];q = H[k + 1][k - 1];r = notlast ? H[k + 2][k - 1] : 0;x = Math.abs(p) + Math.abs(q) + Math.abs(r);if (x !== 0) {
                                        p = p / x;q = q / x;r = r / x;
                                   }
                              }if (x === 0) {
                                   break;
                              }s = Math.sqrt(p * p + q * q + r * r);if (p < 0) {
                                   s = -s;
                              }if (s !== 0) {
                                   if (k !== m) {
                                        H[k][k - 1] = -s * x;
                                   } else if (l !== m) {
                                        H[k][k - 1] = -H[k][k - 1];
                                   }p = p + s;x = p / s;y = q / s;z = r / s;q = q / p;r = r / p;for (j = k; j < nn; j++) {
                                        p = H[k][j] + q * H[k + 1][j];if (notlast) {
                                             p = p + r * H[k + 2][j];H[k + 2][j] = H[k + 2][j] - p * z;
                                        }H[k][j] = H[k][j] - p * x;H[k + 1][j] = H[k + 1][j] - p * y;
                                   }for (i = 0; i <= Math.min(n, k + 3); i++) {
                                        p = x * H[i][k] + y * H[i][k + 1];if (notlast) {
                                             p = p + z * H[i][k + 2];H[i][k + 2] = H[i][k + 2] - p * r;
                                        }H[i][k] = H[i][k] - p;H[i][k + 1] = H[i][k + 1] - p * q;
                                   }for (i = low; i <= high; i++) {
                                        p = x * V[i][k] + y * V[i][k + 1];if (notlast) {
                                             p = p + z * V[i][k + 2];V[i][k + 2] = V[i][k + 2] - p * r;
                                        }V[i][k] = V[i][k] - p;V[i][k + 1] = V[i][k + 1] - p * q;
                                   }
                              }
                         }
                    }
               }if (norm === 0) {
                    return;
               }for (n = nn - 1; n >= 0; n--) {
                    p = d[n];q = e[n];if (q === 0) {
                         l = n;H[n][n] = 1;for (i = n - 1; i >= 0; i--) {
                              w = H[i][i] - p;r = 0;for (j = l; j <= n; j++) {
                                   r = r + H[i][j] * H[j][n];
                              }if (e[i] < 0) {
                                   z = w;s = r;
                              } else {
                                   l = i;if (e[i] === 0) {
                                        H[i][n] = w !== 0 ? -r / w : -r / (eps * norm);
                                   } else {
                                        x = H[i][i + 1];y = H[i + 1][i];q = (d[i] - p) * (d[i] - p) + e[i] * e[i];t = (x * s - z * r) / q;H[i][n] = t;H[i + 1][n] = Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z;
                                   }t = Math.abs(H[i][n]);if (eps * t * t > 1) {
                                        for (j = i; j <= n; j++) {
                                             H[j][n] = H[j][n] / t;
                                        }
                                   }
                              }
                         }
                    } else if (q < 0) {
                         l = n - 1;if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
                              H[n - 1][n - 1] = q / H[n][n - 1];H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
                         } else {
                              cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);H[n - 1][n - 1] = cdivres[0];H[n - 1][n] = cdivres[1];
                         }H[n][n - 1] = 0;H[n][n] = 1;for (i = n - 2; i >= 0; i--) {
                              ra = 0;sa = 0;for (j = l; j <= n; j++) {
                                   ra = ra + H[i][j] * H[j][n - 1];sa = sa + H[i][j] * H[j][n];
                              }w = H[i][i] - p;if (e[i] < 0) {
                                   z = w;r = ra;s = sa;
                              } else {
                                   l = i;if (e[i] === 0) {
                                        cdivres = cdiv(-ra, -sa, w, q);H[i][n - 1] = cdivres[0];H[i][n] = cdivres[1];
                                   } else {
                                        x = H[i][i + 1];y = H[i + 1][i];vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;vi = (d[i] - p) * 2 * q;if (vr === 0 && vi === 0) {
                                             vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));
                                        }cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);H[i][n - 1] = cdivres[0];H[i][n] = cdivres[1];if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
                                             H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
                                        } else {
                                             cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);H[i + 1][n - 1] = cdivres[0];H[i + 1][n] = cdivres[1];
                                        }
                                   }t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));if (eps * t * t > 1) {
                                        for (j = i; j <= n; j++) {
                                             H[j][n - 1] = H[j][n - 1] / t;H[j][n] = H[j][n] / t;
                                        }
                                   }
                              }
                         }
                    }
               }for (i = 0; i < nn; i++) {
                    if (i < low || i > high) {
                         for (j = i; j < nn; j++) {
                              V[i][j] = H[i][j];
                         }
                    }
               }for (j = nn - 1; j >= low; j--) {
                    for (i = low; i <= high; i++) {
                         z = 0;for (k = low; k <= Math.min(j, high); k++) {
                              z = z + V[i][k] * H[k][j];
                         }V[i][j] = z;
                    }
               }
          }function cdiv(xr, xi, yr, yi) {
               var r, d;if (Math.abs(yr) > Math.abs(yi)) {
                    r = yi / yr;d = yr + r * yi;return [(xr + r * xi) / d, (xi - r * xr) / d];
               } else {
                    r = yr / yi;d = yi + r * yr;return [(r * xr + xi) / d, (r * xi - xr) / d];
               }
          } /**
            * @class CholeskyDecomposition
            * @link https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs
            * @param {Matrix} value
            */var CholeskyDecomposition$$1 = function () {
               function CholeskyDecomposition$$1(value) {
                    _classCallCheck4(this, CholeskyDecomposition$$1);value = WrapperMatrix2D.checkMatrix(value);if (!value.isSymmetric()) {
                         throw new Error('Matrix is not symmetric');
                    }var a = value;var dimension = a.rows;var l = new Matrix(dimension, dimension);var positiveDefinite = true;var i, j, k;for (j = 0; j < dimension; j++) {
                         var Lrowj = l[j];var d = 0;for (k = 0; k < j; k++) {
                              var Lrowk = l[k];var s = 0;for (i = 0; i < k; i++) {
                                   s += Lrowk[i] * Lrowj[i];
                              }Lrowj[k] = s = (a.get(j, k) - s) / l[k][k];d = d + s * s;
                         }d = a.get(j, j) - d;positiveDefinite &= d > 0;l[j][j] = Math.sqrt(Math.max(d, 0));for (k = j + 1; k < dimension; k++) {
                              l[j][k] = 0;
                         }
                    }if (!positiveDefinite) {
                         throw new Error('Matrix is not positive definite');
                    }this.L = l;
               } /**
                 *
                 * @param {Matrix} value
                 * @return {Matrix}
                 */_createClass4(CholeskyDecomposition$$1, [{ key: "solve", value: function solve(value) {
                         value = WrapperMatrix2D.checkMatrix(value);var l = this.L;var dimension = l.rows;if (value.rows !== dimension) {
                              throw new Error('Matrix dimensions do not match');
                         }var count = value.columns;var B = value.clone();var i, j, k;for (k = 0; k < dimension; k++) {
                              for (j = 0; j < count; j++) {
                                   for (i = 0; i < k; i++) {
                                        B[k][j] -= B[i][j] * l[k][i];
                                   }B[k][j] /= l[k][k];
                              }
                         }for (k = dimension - 1; k >= 0; k--) {
                              for (j = 0; j < count; j++) {
                                   for (i = k + 1; i < dimension; i++) {
                                        B[k][j] -= B[i][j] * l[i][k];
                                   }B[k][j] /= l[k][k];
                              }
                         }return B;
                    } /**
                      *
                      * @return {Matrix}
                      */ }, { key: "lowerTriangularMatrix", get: function get() {
                         return this.L;
                    } }]);return CholeskyDecomposition$$1;
          }();exports['default'] = Matrix;exports.Matrix = Matrix;exports.abstractMatrix = AbstractMatrix;exports.wrap = wrap;exports.WrapperMatrix2D = WrapperMatrix2D;exports.WrapperMatrix1D = WrapperMatrix1D;exports.solve = solve$$1;exports.inverse = inverse$$1;exports.SingularValueDecomposition = SingularValueDecomposition$$1;exports.SVD = SingularValueDecomposition$$1;exports.EigenvalueDecomposition = EigenvalueDecomposition$$1;exports.EVD = EigenvalueDecomposition$$1;exports.CholeskyDecomposition = CholeskyDecomposition$$1;exports.CHO = CholeskyDecomposition$$1;exports.LuDecomposition = LuDecomposition$$1;exports.LU = LuDecomposition$$1;exports.QrDecomposition = QrDecomposition$$1;exports.QR = QrDecomposition$$1;
     }, { "ml-array-rescale": 129 }], 131: [function (require, module, exports) {
          'use strict';
          var extend = require('extend');var defaultOptions = { size: 1, value: 0 }; /**
                                                                                     * Case when the entry is an array
                                                                                     * @param data
                                                                                     * @param options
                                                                                     * @returns {Array}
                                                                                     */function arrayCase(data, options) {
               var len = data.length;if (typeof options.size === 'number') options.size = [options.size, options.size];var cond = len + options.size[0] + options.size[1];var output;if (options.output) {
                    if (options.output.length !== cond) throw new RangeError('Wrong output size');output = options.output;
               } else output = new Array(cond);var i; // circular option
               if (options.value === 'circular') {
                    for (i = 0; i < cond; i++) {
                         if (i < options.size[0]) output[i] = data[(len - options.size[0] % len + i) % len];else if (i < options.size[0] + len) output[i] = data[i - options.size[0]];else output[i] = data[(i - options.size[0]) % len];
                    }
               } // replicate option
               else if (options.value === 'replicate') {
                         for (i = 0; i < cond; i++) {
                              if (i < options.size[0]) output[i] = data[0];else if (i < options.size[0] + len) output[i] = data[i - options.size[0]];else output[i] = data[len - 1];
                         }
                    } // symmetric option
                    else if (options.value === 'symmetric') {
                              if (options.size[0] > len || options.size[1] > len) throw new RangeError('expanded value should not be bigger than the data length');for (i = 0; i < cond; i++) {
                                   if (i < options.size[0]) output[i] = data[options.size[0] - 1 - i];else if (i < options.size[0] + len) output[i] = data[i - options.size[0]];else output[i] = data[2 * len + options.size[0] - i - 1];
                              }
                         } // default option
                         else {
                                   for (i = 0; i < cond; i++) {
                                        if (i < options.size[0]) output[i] = options.value;else if (i < options.size[0] + len) output[i] = data[i - options.size[0]];else output[i] = options.value;
                                   }
                              }return output;
          } /**
            * Case when the entry is a matrix
            * @param data
            * @param options
            * @returns {Array}
            */function matrixCase(data, options) {
               var row = data.length;var col = data[0].length;if (options.size[0] === undefined) options.size = [options.size, options.size, options.size, options.size];throw new Error('matrix not supported yet, sorry');
          } /**
            * Pads and array
            * @param {Array <number>} data
            * @param {object} options
            */function padArray(data, options) {
               options = extend({}, defaultOptions, options);if (Array.isArray(data)) {
                    if (Array.isArray(data[0])) return matrixCase(data, options);else return arrayCase(data, options);
               } else throw new TypeError('data should be an array');
          }module.exports = padArray;
     }, { "extend": 126 }], 132: [function (require, module, exports) {
          'use strict';
          var matrixLib = require('ml-matrix');var Matrix = matrixLib.Matrix;var inverse = matrixLib.inverse;var padArray = require('ml-pad-array');var extend = require('extend');var defaultOptions = { windowSize: 5, derivative: 1, polynomial: 2, pad: 'none', padValue: 'replicate' }; /**
                                                                                                                                                                                                                                                                                             * Savitzky-Golay filter
                                                                                                                                                                                                                                                                                             * @param {Array <number>} data
                                                                                                                                                                                                                                                                                             * @param {number} h
                                                                                                                                                                                                                                                                                             * @param {Object} options
                                                                                                                                                                                                                                                                                             * @returns {Array}
                                                                                                                                                                                                                                                                                             */function SavitzkyGolay(data, h, options) {
               options = extend({}, defaultOptions, options);if (options.windowSize % 2 === 0 || options.windowSize < 5 || !Number.isInteger(options.windowSize)) throw new RangeError('Invalid window size (should be odd and at least 5 integer number)');if (options.derivative < 0 || !Number.isInteger(options.derivative)) throw new RangeError('Derivative should be a positive integer');if (options.polynomial < 1 || !Number.isInteger(options.polynomial)) throw new RangeError('Polynomial should be a positive integer');var C, norm;var step = Math.floor(options.windowSize / 2);if (options.pad === 'pre') {
                    data = padArray(data, { size: step, value: options.padValue });
               }var ans = new Array(data.length - 2 * step);if (options.windowSize === 5 && options.polynomial === 2 && (options.derivative === 1 || options.derivative === 2)) {
                    if (options.derivative === 1) {
                         C = [-2, -1, 0, 1, 2];norm = 10;
                    } else {
                         C = [2, -1, -2, -1, 2];norm = 7;
                    }
               } else {
                    var J = Matrix.ones(options.windowSize, options.polynomial + 1);var inic = -(options.windowSize - 1) / 2;for (var i = 0; i < J.length; i++) {
                         for (var j = 0; j < J[i].length; j++) {
                              if (inic + 1 !== 0 || j !== 0) J[i][j] = Math.pow(inic + i, j);
                         }
                    }var Jtranspose = J.transposeView();var Jinv = inverse(Jtranspose.mmul(J));C = Jinv.mmul(Jtranspose);C = C[options.derivative];norm = 1;
               }var det = norm * Math.pow(h, options.derivative);for (var k = step; k < data.length - step; k++) {
                    var d = 0;for (var l = 0; l < C.length; l++) {
                         d += C[l] * data[l + k - step] / det;
                    }ans[k - step] = d;
               }if (options.pad === 'post') {
                    ans = padArray(ans, { size: step, value: options.padValue });
               }return ans;
          }module.exports = SavitzkyGolay;
     }, { "extend": 126, "ml-matrix": 130, "ml-pad-array": 131 }], 133: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });exports.sink = exports.source = exports.utils = exports.operator = exports.core = exports.version = undefined;var _namespace = require('../common/operator/_namespace');Object.defineProperty(exports, 'operator', { enumerable: true, get: function get() {
                    return _interopRequireDefault(_namespace).default;
               } });var _namespace2 = require('./utils/_namespace');Object.defineProperty(exports, 'utils', { enumerable: true, get: function get() {
                    return _interopRequireDefault(_namespace2).default;
               } });var _namespace3 = require('./source/_namespace');Object.defineProperty(exports, 'source', { enumerable: true, get: function get() {
                    return _interopRequireDefault(_namespace3).default;
               } });var _namespace4 = require('./sink/_namespace');Object.defineProperty(exports, 'sink', { enumerable: true, get: function get() {
                    return _interopRequireDefault(_namespace4).default;
               } });var _core2 = require('../core');var _core = _interopRequireWildcard(_core2);function _interopRequireWildcard(obj) {
               if (obj && obj.__esModule) {
                    return obj;
               } else {
                    var newObj = {};if (obj != null) {
                         for (var key in obj) {
                              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                         }
                    }newObj.default = obj;return newObj;
               }
          }function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var version = exports.version = '1.1.6';var core = exports.core = _core;
     }, { "../common/operator/_namespace": 174, "../core": 184, "./sink/_namespace": 144, "./source/_namespace": 148, "./utils/_namespace": 150 }], 134: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseDisplay2 = require('./BaseDisplay');var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);var _Fft = require('../../common/operator/Fft');var _Fft2 = _interopRequireDefault(_Fft);var _displayUtils = require('../utils/display-utils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { scale: { type: 'float', default: 1, metas: { kind: 'dynamic' } }, colors: { type: 'any', default: (0, _displayUtils.getColors)('bar-chart'), nullable: true, metas: { kind: 'dynamic' } }, min: { type: 'float', default: 0, metas: { kind: 'dynamic' } }, max: { type: 'float', default: 1, metas: { kind: 'dynamic' } } }; /**
                                                                                                                                                                                                                                                                                                                                                            * Display a bar chart from an incomming `vector` input.
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * @memberof module:client.sink
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                                                            * @param {String} [options.colors=null] - Colors of the bars.
                                                                                                                                                                                                                                                                                                                                                            * @param {Number} [options.min=-80] - Minimum displayed value.
                                                                                                                                                                                                                                                                                                                                                            * @param {Number} [options.max=6] - Maximum displayed value.
                                                                                                                                                                                                                                                                                                                                                            * @param {Number} [options.width=300] - Width of the canvas.
                                                                                                                                                                                                                                                                                                                                                            *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                            * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                                                                                                                                                                                                                                                            *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                            * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                                                                                                                                                                                                                                                            *  in which to insert the canvas. _constant parameter_
                                                                                                                                                                                                                                                                                                                                                            * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                                                                                                                                                                                                                                                            *  in which to draw. _constant parameter_
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * @example
                                                                                                                                                                                                                                                                                                                                                            * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                                                            * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * const frameSize = 5;
                                                                                                                                                                                                                                                                                                                                                            * const dt = 0.02;
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * const eventIn = new lfo.source.EventIn({
                                                                                                                                                                                                                                                                                                                                                            *   frameSize: frameSize,
                                                                                                                                                                                                                                                                                                                                                            *   frameRate: 1 / dt,
                                                                                                                                                                                                                                                                                                                                                            *   frameType: 'vector',
                                                                                                                                                                                                                                                                                                                                                            * });
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * const barChart = new lfo.sink.BarChartDisplay({
                                                                                                                                                                                                                                                                                                                                                            *   canvas: '#bar-chart',
                                                                                                                                                                                                                                                                                                                                                            * });
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * eventIn.connect(barChart);
                                                                                                                                                                                                                                                                                                                                                            * eventIn.start();
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * const data = [0, 0.2, 0.4, 0.6, 0.8];
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            * (function generateData() {
                                                                                                                                                                                                                                                                                                                                                            *   for (let i = 0; i < frameSize; i++)
                                                                                                                                                                                                                                                                                                                                                            *     data[i] = (data[i] + 0.001) % 1;
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            *   eventIn.process(null, data);
                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                            *   setTimeout(generateData, dt * 1000);
                                                                                                                                                                                                                                                                                                                                                            * }());
                                                                                                                                                                                                                                                                                                                                                            */var BarChartDisplay = function (_BaseDisplay) {
               (0, _inherits3.default)(BarChartDisplay, _BaseDisplay);function BarChartDisplay() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, BarChartDisplay);return (0, _possibleConstructorReturn3.default)(this, (BarChartDisplay.__proto__ || (0, _getPrototypeOf2.default)(BarChartDisplay)).call(this, definitions, options, false));
               } /** @private */(0, _createClass3.default)(BarChartDisplay, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.propagateStreamParams();
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         var frameSize = this.streamParams.frameSize;var width = this.canvasWidth;var height = this.canvasHeight;var colors = this.params.get('colors');var data = frame.data;var barWidth = width / frameSize;var ctx = this.ctx; // error handling needs review...
                         var error = 0;for (var i = 0; i < frameSize; i++) {
                              var x1Float = i * barWidth + error;var x1Int = Math.round(x1Float);var x2Float = x1Float + (barWidth - error);var x2Int = Math.round(x2Float);error = x2Int - x2Float;if (x1Int !== x2Int) {
                                   var _width = x2Int - x1Int;var y = this.getYPosition(data[i]);ctx.fillStyle = colors[i % colors.length];ctx.fillRect(x1Int, y, _width, height - y);
                              } else {
                                   error -= barWidth;
                              }
                         }
                    } }]);return BarChartDisplay;
          }(_BaseDisplay3.default);exports.default = BarChartDisplay;
     }, { "../../common/operator/Fft": 156, "../utils/display-utils": 151, "./BaseDisplay": 135, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 135: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _assign = require('babel-runtime/core-js/object/assign');var _assign2 = _interopRequireDefault(_assign);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var commonDefinitions = { min: { type: 'float', default: -1, metas: { kind: 'dynamic' } }, max: { type: 'float', default: 1, metas: { kind: 'dynamic' } }, width: { type: 'integer', default: 300, metas: { kind: 'dynamic' } }, height: { type: 'integer', default: 150, metas: { kind: 'dynamic' } }, container: { type: 'any', default: null, constant: true }, canvas: { type: 'any', default: null, constant: true } };var hasDurationDefinitions = { duration: { type: 'float', min: 0, max: +Infinity, default: 1, metas: { kind: 'dynamic' } }, referenceTime: { type: 'float', default: 0, constant: true } }; /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Base class to extend in order to create graphic sinks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * <span class="warning">_This class should be considered abstract and only
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * be used to be extended._</span>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @todo - fix float rounding errors (produce decays in sync draws)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @memberof module:client.sink
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Number} [options.min=-1] - Minimum value represented in the canvas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Number} [options.max=1] - Maximum value represented in the canvas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Number} [options.width=300] - Width of the canvas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  in which to insert the canvas. _constant parameter_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  in which to draw. _constant parameter_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Number} [options.duration=1] - Duration (in seconds) represented in
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  the canvas. This parameter only exists for operators that display several
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  consecutive frames on the canvas. _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {Number} [options.referenceTime=null] - Optionnal reference time the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  display should considerer as the origin. Is only usefull when synchronizing
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  several display using the `DisplaySync` class. This parameter only exists
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *  for operators that display several consecutive frames on the canvas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */var BaseDisplay = function (_BaseLfo) {
               (0, _inherits3.default)(BaseDisplay, _BaseLfo);function BaseDisplay(defs) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var hasDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;(0, _classCallCheck3.default)(this, BaseDisplay);var commonDefs = void 0;if (hasDuration) commonDefs = (0, _assign2.default)({}, commonDefinitions, hasDurationDefinitions);else commonDefs = commonDefinitions;var definitions = (0, _assign2.default)({}, commonDefs, defs);var _this = (0, _possibleConstructorReturn3.default)(this, (BaseDisplay.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay)).call(this, definitions, options));if (_this.params.get('canvas') === null && _this.params.get('container') === null) throw new Error('Invalid parameter: `canvas` or `container` not defined');var canvasParam = _this.params.get('canvas');var containerParam = _this.params.get('container'); // prepare canvas
                    if (canvasParam) {
                         if (typeof canvasParam === 'string') _this.canvas = document.querySelector(canvasParam);else _this.canvas = canvasParam;
                    } else if (containerParam) {
                         var container = void 0;if (typeof containerParam === 'string') container = document.querySelector(containerParam);else container = containerParam;_this.canvas = document.createElement('canvas');container.appendChild(_this.canvas);
                    }_this.ctx = _this.canvas.getContext('2d');_this.cachedCanvas = document.createElement('canvas');_this.cachedCtx = _this.cachedCanvas.getContext('2d');_this.hasDuration = hasDuration;_this.previousFrame = null;_this.currentTime = hasDuration ? _this.params.get('referenceTime') : null; /**
                                                                                                                                                                                                                                                                                                                  * Instance of the `DisplaySync` used to synchronize the different displays
                                                                                                                                                                                                                                                                                                                  * @private
                                                                                                                                                                                                                                                                                                                  */_this.displaySync = false;_this._stack = [];_this._rafId = null;_this.renderStack = _this.renderStack.bind(_this);_this.shiftError = 0; // initialize canvas size and y scale transfert function
                    _this._resize();return _this;
               } /** @private */(0, _createClass3.default)(BaseDisplay, [{ key: '_resize', value: function _resize() {
                         var width = this.params.get('width');var height = this.params.get('height');var ctx = this.ctx;var cachedCtx = this.cachedCtx;var dPR = window.devicePixelRatio || 1;var bPR = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;this.pixelRatio = dPR / bPR;var lastWidth = this.canvasWidth;var lastHeight = this.canvasHeight;this.canvasWidth = width * this.pixelRatio;this.canvasHeight = height * this.pixelRatio;cachedCtx.canvas.width = this.canvasWidth;cachedCtx.canvas.height = this.canvasHeight; // copy current image from ctx (resize)
                         if (lastWidth && lastHeight) {
                              cachedCtx.drawImage(ctx.canvas, 0, 0, lastWidth, lastHeight, 0, 0, this.canvasWidth, this.canvasHeight);
                         }ctx.canvas.width = this.canvasWidth;ctx.canvas.height = this.canvasHeight;ctx.canvas.style.width = width + 'px';ctx.canvas.style.height = height + 'px'; // update scale
                         this._setYScale();
                    } /**
                      * Create the transfert function used to map values to pixel in the y axis
                      * @private
                      */ }, { key: '_setYScale', value: function _setYScale() {
                         var min = this.params.get('min');var max = this.params.get('max');var height = this.canvasHeight;var a = (0 - height) / (max - min);var b = height - a * min;this.getYPosition = function (x) {
                              return a * x + b;
                         };
                    } /**
                      * Returns the width in pixel a `vector` frame needs to be drawn.
                      * @private
                      */ }, { key: 'getMinimumFrameWidth', value: function getMinimumFrameWidth() {
                         return 1; // need one pixel to draw the line
                    } /**
                          * Callback function executed when a parameter is updated.
                          *
                          * @param {String} name - Parameter name.
                          * @param {Mixed} value - Parameter value.
                          * @param {Object} metas - Metadatas of the parameter.
                          * @private
                          */ }, { key: 'onParamUpdate', value: function onParamUpdate(name, value, metas) {
                         (0, _get3.default)(BaseDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay.prototype), 'onParamUpdate', this).call(this, name, value, metas);switch (name) {case 'min':case 'max':
                                   // @todo - make sure that min and max are different
                                   this._setYScale();break;case 'width':case 'height':
                                   this._resize();}
                    } /** @private */ }, { key: 'propagateStreamParams', value: function propagateStreamParams() {
                         (0, _get3.default)(BaseDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay.prototype), 'propagateStreamParams', this).call(this);
                    } /** @private */ }, { key: 'resetStream', value: function resetStream() {
                         (0, _get3.default)(BaseDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay.prototype), 'resetStream', this).call(this);var width = this.canvasWidth;var height = this.canvasHeight;this.previousFrame = null;this.currentTime = this.hasDuration ? this.params.get('referenceTime') : null;this.ctx.clearRect(0, 0, width, height);this.cachedCtx.clearRect(0, 0, width, height);
                    } /** @private */ }, { key: 'finalizeStream', value: function finalizeStream(endTime) {
                         this.currentTime = null;(0, _get3.default)(BaseDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseDisplay.prototype), 'finalizeStream', this).call(this, endTime);this._rafId = null; // clear the stack if not empty
                         if (this._stack.length > 0) this.renderStack();
                    } /**
                      * Add the current frame to the frames to draw. Should not be overriden.
                      * @private
                      */ }, { key: 'processFrame', value: function processFrame(frame) {
                         var frameSize = this.streamParams.frameSize;var copy = new Float32Array(frameSize);var data = frame.data; // copy values of the input frame as they might be updated
                         // in reference before being consumed in the draw function
                         for (var i = 0; i < frameSize; i++) {
                              copy[i] = data[i];
                         }this._stack.push({ time: frame.time, data: copy, metadata: frame.metadata });if (this._rafId === null) this._rafId = window.requestAnimationFrame(this.renderStack);
                    } /**
                      * Render the accumulated frames. Method called in `requestAnimationFrame`.
                      * @private
                      */ }, { key: 'renderStack', value: function renderStack() {
                         if (this.params.has('duration')) {
                              // render all frame since last `renderStack` call
                              for (var i = 0, l = this._stack.length; i < l; i++) {
                                   this.scrollModeDraw(this._stack[i]);
                              }
                         } else {
                              // only render last received frame if any
                              if (this._stack.length > 0) {
                                   var frame = this._stack[this._stack.length - 1];this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);this.processFunction(frame);
                              }
                         }this._stack.length = 0; // reinit stack for next call
                         this._rafId = null;
                    } /**
                      * Draw data from right to left with scrolling
                      * @private
                      * @todo - check possibility of maintaining all values from one place to
                      *         minimize float error tracking.
                      */ }, { key: 'scrollModeDraw', value: function scrollModeDraw(frame) {
                         var frameType = this.streamParams.frameType;var frameRate = this.streamParams.frameRate;var frameSize = this.streamParams.frameSize;var sourceSampleRate = this.streamParams.sourceSampleRate;var canvasDuration = this.params.get('duration');var ctx = this.ctx;var canvasWidth = this.canvasWidth;var canvasHeight = this.canvasHeight;var previousFrame = this.previousFrame; // current time at the left of the canvas
                         var currentTime = this.currentTime !== null ? this.currentTime : frame.time;var frameStartTime = frame.time;var lastFrameTime = previousFrame ? previousFrame.time : 0;var lastFrameDuration = this.lastFrameDuration ? this.lastFrameDuration : 0;var frameDuration = void 0;if (frameType === 'scalar' || frameType === 'vector') {
                              var pixelDuration = canvasDuration / canvasWidth;frameDuration = this.getMinimumFrameWidth() * pixelDuration;
                         } else if (this.streamParams.frameType === 'signal') {
                              frameDuration = frameSize / sourceSampleRate;
                         }var frameEndTime = frameStartTime + frameDuration; // define if we need to shift the canvas
                         var shiftTime = frameEndTime - currentTime; // if the canvas is not synced, should never go to `else`
                         if (shiftTime > 0) {
                              // shift the canvas of shiftTime in pixels
                              var fShift = shiftTime / canvasDuration * canvasWidth - this.shiftError;var iShift = Math.floor(fShift + 0.5);this.shiftError = fShift - iShift;var _currentTime = frameStartTime + frameDuration;this.shiftCanvas(iShift, _currentTime); // if siblings, share the information
                              if (this.displaySync) this.displaySync.shiftSiblings(iShift, _currentTime, this);
                         } // width of the frame in pixels
                         var floatFrameWidth = frameDuration / canvasDuration * canvasWidth;var frameWidth = Math.floor(floatFrameWidth + 0.5); // define position of the head in the canvas
                         var canvasStartTime = this.currentTime - canvasDuration;var startTimeRatio = (frameStartTime - canvasStartTime) / canvasDuration;var startTimePosition = startTimeRatio * canvasWidth; // number of pixels since last frame
                         var pixelsSinceLastFrame = this.lastFrameWidth;if ((frameType === 'scalar' || frameType === 'vector') && previousFrame) {
                              var frameInterval = frame.time - previousFrame.time;pixelsSinceLastFrame = frameInterval / canvasDuration * canvasWidth;
                         } // draw current frame
                         ctx.save();ctx.translate(startTimePosition, 0);this.processFunction(frame, frameWidth, pixelsSinceLastFrame);ctx.restore(); // save current canvas state into cached canvas
                         this.cachedCtx.clearRect(0, 0, canvasWidth, canvasHeight);this.cachedCtx.drawImage(this.canvas, 0, 0, canvasWidth, canvasHeight); // update lastFrameDuration, lastFrameWidth
                         this.lastFrameDuration = frameDuration;this.lastFrameWidth = frameWidth;this.previousFrame = frame;
                    } /**
                      * Shift canvas, also called from `DisplaySync`
                      * @private
                      */ }, { key: 'shiftCanvas', value: function shiftCanvas(iShift, time) {
                         var ctx = this.ctx;var cache = this.cachedCanvas;var cachedCtx = this.cachedCtx;var width = this.canvasWidth;var height = this.canvasHeight;var croppedWidth = width - iShift;this.currentTime = time;ctx.clearRect(0, 0, width, height);ctx.drawImage(cache, iShift, 0, croppedWidth, height, 0, 0, croppedWidth, height); // save current canvas state into cached canvas
                         cachedCtx.clearRect(0, 0, width, height);cachedCtx.drawImage(this.canvas, 0, 0, width, height);
                    } // @todo - Fix trigger mode
                    // allow to witch easily between the 2 modes
                    // setTrigger(bool) {
                    //   this.params.trigger = bool;
                    //   // clear canvas and cache
                    //   this.ctx.clearRect(0, 0, this.params.width, this.params.height);
                    //   this.cachedCtx.clearRect(0, 0, this.params.width, this.params.height);
                    //   // reset _currentXPosition
                    //   this._currentXPosition = 0;
                    //   this.lastShiftError = 0;
                    // }
                    // /**
                    //  * Alternative drawing mode.
                    //  * Draw from left to right, go back to left when > width
                    //  */
                    // triggerModeDraw(time, frame) {
                    //   const width  = this.params.width;
                    //   const height = this.params.height;
                    //   const duration = this.params.duration;
                    //   const ctx = this.ctx;
                    //   const dt = time - this.previousTime;
                    //   const fShift = (dt / duration) * width - this.lastShiftError; // px
                    //   const iShift = Math.round(fShift);
                    //   this.lastShiftError = iShift - fShift;
                    //   this.currentXPosition += iShift;
                    //   // draw the right part
                    //   ctx.save();
                    //   ctx.translate(this.currentXPosition, 0);
                    //   ctx.clearRect(-iShift, 0, iShift, height);
                    //   this.drawCurve(frame, iShift);
                    //   ctx.restore();
                    //   // go back to the left of the canvas and redraw the same thing
                    //   if (this.currentXPosition > width) {
                    //     // go back to start
                    //     this.currentXPosition -= width;
                    //     ctx.save();
                    //     ctx.translate(this.currentXPosition, 0);
                    //     ctx.clearRect(-iShift, 0, iShift, height);
                    //     this.drawCurve(frame, this.previousFrame, iShift);
                    //     ctx.restore();
                    //   }
                    // }
               }]);return BaseDisplay;
          }(_BaseLfo3.default);exports.default = BaseDisplay;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/assign": 6, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 136: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseDisplay2 = require('./BaseDisplay');var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);var _displayUtils = require('../utils/display-utils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { radius: { type: 'float', min: 0, default: 0, metas: { kind: 'dynamic' } }, line: { type: 'boolean', default: true, metas: { kind: 'dynamic' } }, colors: { type: 'any', default: null /**
                                                                                                                                                                                                                     * Breakpoint Function, display a stream of type `vector`.
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     * @memberof module:client.sink
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                     * @param {String} [options.colors=null] - Array of colors for each index of the
                                                                                                                                                                                                                     *  vector. _dynamic parameter_
                                                                                                                                                                                                                     * @param {String} [options.radius=0] - Radius of the dot at each value.
                                                                                                                                                                                                                     *  _dynamic parameter_
                                                                                                                                                                                                                     * @param {String} [options.line=true] - Display a line between each consecutive
                                                                                                                                                                                                                     *  values of the vector. _dynamic parameter_
                                                                                                                                                                                                                     * @param {Number} [options.min=-1] - Minimum value represented in the canvas.
                                                                                                                                                                                                                     *  _dynamic parameter_
                                                                                                                                                                                                                     * @param {Number} [options.max=1] - Maximum value represented in the canvas.
                                                                                                                                                                                                                     *  _dynamic parameter_
                                                                                                                                                                                                                     * @param {Number} [options.width=300] - Width of the canvas.
                                                                                                                                                                                                                     *  _dynamic parameter_
                                                                                                                                                                                                                     * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                                                                                                                     *  _dynamic parameter_
                                                                                                                                                                                                                     * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                                                                                                                     *  in which to insert the canvas. _constant parameter_
                                                                                                                                                                                                                     * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                                                                                                                     *  in which to draw. _constant parameter_
                                                                                                                                                                                                                     * @param {Number} [options.duration=1] - Duration (in seconds) represented in
                                                                                                                                                                                                                     *  the canvas. _dynamic parameter_
                                                                                                                                                                                                                     * @param {Number} [options.referenceTime=null] - Optionnal reference time the
                                                                                                                                                                                                                     *  display should considerer as the origin. Is only usefull when synchronizing
                                                                                                                                                                                                                     *  several display using the `DisplaySync` class.
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     * @example
                                                                                                                                                                                                                     * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     * const eventIn = new lfo.source.EventIn({
                                                                                                                                                                                                                     *   frameSize: 2,
                                                                                                                                                                                                                     *   frameRate: 0.1,
                                                                                                                                                                                                                     *   frameType: 'vector'
                                                                                                                                                                                                                     * });
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     * const bpf = new lfo.sink.BpfDisplay({
                                                                                                                                                                                                                     *   canvas: '#bpf',
                                                                                                                                                                                                                     *   duration: 10,
                                                                                                                                                                                                                     * });
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     * eventIn.connect(bpf);
                                                                                                                                                                                                                     * eventIn.start();
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     * let time = 0;
                                                                                                                                                                                                                     * const dt = 0.1;
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     * (function generateData() {
                                                                                                                                                                                                                     *   eventIn.process(time, [Math.random() * 2 - 1, Math.random() * 2 - 1]);
                                                                                                                                                                                                                     *   time += dt;
                                                                                                                                                                                                                     *
                                                                                                                                                                                                                     *   setTimeout(generateData, dt * 1000);
                                                                                                                                                                                                                     * }());
                                                                                                                                                                                                                     */ } };var BpfDisplay = function (_BaseDisplay) {
               (0, _inherits3.default)(BpfDisplay, _BaseDisplay);function BpfDisplay(options) {
                    (0, _classCallCheck3.default)(this, BpfDisplay);var _this = (0, _possibleConstructorReturn3.default)(this, (BpfDisplay.__proto__ || (0, _getPrototypeOf2.default)(BpfDisplay)).call(this, definitions, options));_this.prevFrame = null;return _this;
               } /** @private */(0, _createClass3.default)(BpfDisplay, [{ key: 'getMinimumFrameWidth', value: function getMinimumFrameWidth() {
                         return this.params.get('radius');
                    } }, { key: 'resetStream', value: function resetStream() {
                         (0, _get3.default)(BpfDisplay.prototype.__proto__ || (0, _getPrototypeOf2.default)(BpfDisplay.prototype), 'resetStream', this).call(this);this.prevFrame = null;
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);if (this.params.get('colors') === null) this.params.set('colors', (0, _displayUtils.getColors)('bpf', this.streamParams.frameSize));this.propagateStreamParams();
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame, frameWidth, pixelsSinceLastFrame) {
                         var colors = this.params.get('colors');var radius = this.params.get('radius');var drawLine = this.params.get('line');var frameSize = this.streamParams.frameSize;var ctx = this.ctx;var data = frame.data;var prevData = this.prevFrame ? this.prevFrame.data : null;ctx.save();for (var i = 0, l = frameSize; i < l; i++) {
                              var posY = this.getYPosition(data[i]);var color = colors[i];ctx.strokeStyle = color;ctx.fillStyle = color;if (prevData && drawLine) {
                                   var lastPosY = this.getYPosition(prevData[i]);ctx.beginPath();ctx.moveTo(-pixelsSinceLastFrame, lastPosY);ctx.lineTo(0, posY);ctx.stroke();ctx.closePath();
                              }if (radius > 0) {
                                   ctx.beginPath();ctx.arc(0, posY, radius, 0, Math.PI * 2, false);ctx.fill();ctx.closePath();
                              }
                         }ctx.restore();this.prevFrame = frame;
                    } }]);return BpfDisplay;
          }(_BaseDisplay3.default);exports.default = BpfDisplay;
     }, { "../utils/display-utils": 151, "./BaseDisplay": 135, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 137: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseDisplay2 = require('./BaseDisplay');var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);var _displayUtils = require('../utils/display-utils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { threshold: { type: 'float', default: null, nullable: true, metas: { kind: 'dynamic' } }, thresholdIndex: { type: 'integer', default: 0, metas: { kind: 'dynamic' } }, color: { type: 'string', default: (0, _displayUtils.getColors)('marker'), nullable: true, metas: { kind: 'dynamic' } } }; /**
                                                                                                                                                                                                                                                                                                                               * Display a marker according to a `vector` input frame.
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * @memberof module:client.sink
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                               * @param {String} options.color - Color of the marker.
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.thresholdIndex=0] - Index of the incomming frame
                                                                                                                                                                                                                                                                                                                               *  data to compare against the threshold. _Should be used in conjonction with
                                                                                                                                                                                                                                                                                                                               *  `threshold`_.
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.threshold=null] - Minimum value the incomming value
                                                                                                                                                                                                                                                                                                                               *  must have to trigger the display of a marker. If null each incomming event
                                                                                                                                                                                                                                                                                                                               *  triggers a marker. _Should be used in conjonction with `thresholdIndex`_.
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.width=300] - Width of the canvas.
                                                                                                                                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                               * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                                                                                                                                                                                                                               *  in which to insert the canvas. _constant parameter_
                                                                                                                                                                                                                                                                                                                               * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                                                                                                                                                                                                                               *  in which to draw. _constant parameter_
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.duration=1] - Duration (in seconds) represented in
                                                                                                                                                                                                                                                                                                                               *  the canvas. This parameter only exists for operators that display several
                                                                                                                                                                                                                                                                                                                               *  consecutive frames on the canvas. _dynamic parameter_
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.referenceTime=null] - Optionnal reference time the
                                                                                                                                                                                                                                                                                                                               *  display should considerer as the origin. Is only usefull when synchronizing
                                                                                                                                                                                                                                                                                                                               *  several display using the `DisplaySync` class. This parameter only exists
                                                                                                                                                                                                                                                                                                                               *  for operators that display several consecutive frames on the canvas.
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * @example
                                                                                                                                                                                                                                                                                                                               * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * const eventIn = new lfo.source.EventIn({
                                                                                                                                                                                                                                                                                                                               *   frameType: 'scalar',
                                                                                                                                                                                                                                                                                                                               * });
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * const marker = new lfo.sink.MarkerDisplay({
                                                                                                                                                                                                                                                                                                                               *   canvas: '#marker',
                                                                                                                                                                                                                                                                                                                               *   threshold: 0.5,
                                                                                                                                                                                                                                                                                                                               * });
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * eventIn.connect(marker);
                                                                                                                                                                                                                                                                                                                               * eventIn.start();
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * let time = 0;
                                                                                                                                                                                                                                                                                                                               * const period = 1;
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * (function generateData() {
                                                                                                                                                                                                                                                                                                                               *   eventIn.process(time, Math.random());
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               *   time += period;
                                                                                                                                                                                                                                                                                                                               *   setTimeout(generateData, period * 1000);
                                                                                                                                                                                                                                                                                                                               * }());
                                                                                                                                                                                                                                                                                                                               */var MarkerDisplay = function (_BaseDisplay) {
               (0, _inherits3.default)(MarkerDisplay, _BaseDisplay);function MarkerDisplay() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, MarkerDisplay);return (0, _possibleConstructorReturn3.default)(this, (MarkerDisplay.__proto__ || (0, _getPrototypeOf2.default)(MarkerDisplay)).call(this, definitions, options));
               } /** @private */(0, _createClass3.default)(MarkerDisplay, [{ key: 'processVector', value: function processVector(frame, frameWidth, pixelsSinceLastFrame) {
                         var color = this.params.get('color');var threshold = this.params.get('threshold');var thresholdIndex = this.params.get('thresholdIndex');var ctx = this.ctx;var height = ctx.height;var value = frame.data[thresholdIndex];if (threshold === null || value >= threshold) {
                              var yMin = this.getYPosition(this.params.get('min'));var yMax = this.getYPosition(this.params.get('max'));if (yMin > yMax) {
                                   var v = yMax;yMax = yMin;yMin = v;
                              }ctx.save();ctx.fillStyle = color;ctx.fillRect(0, yMin, 1, yMax);ctx.restore();
                         }
                    } }]);return MarkerDisplay;
          }(_BaseDisplay3.default);exports.default = MarkerDisplay;
     }, { "../utils/display-utils": 151, "./BaseDisplay": 135, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 138: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseDisplay2 = require('./BaseDisplay');var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);var _displayUtils = require('../utils/display-utils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var floor = Math.floor;var ceil = Math.ceil;function downSample(data, targetLength) {
               var length = data.length;var hop = length / targetLength;var target = new Float32Array(targetLength);var counter = 0;for (var i = 0; i < targetLength; i++) {
                    var index = floor(counter);var phase = counter - index;var prev = data[index];var next = data[index + 1];target[i] = (next - prev) * phase + prev;counter += hop;
               }return target;
          }var definitions = { color: { type: 'string', default: (0, _displayUtils.getColors)('signal'), nullable: true } }; /**
                                                                                                                             * Display a stream of type `signal` on a canvas.
                                                                                                                             *
                                                                                                                             * @param {Object} options - Override default parameters.
                                                                                                                             * @param {String} [options.color='#00e600'] - Color of the signal.
                                                                                                                             * @param {Number} [options.min=-1] - Minimum value represented in the canvas.
                                                                                                                             *  _dynamic parameter_
                                                                                                                             * @param {Number} [options.max=1] - Maximum value represented in the canvas.
                                                                                                                             *  _dynamic parameter_
                                                                                                                             * @param {Number} [options.width=300] - Width of the canvas.
                                                                                                                             *  _dynamic parameter_
                                                                                                                             * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                             *  _dynamic parameter_
                                                                                                                             * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                             *  in which to insert the canvas. _constant parameter_
                                                                                                                             * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                             *  in which to draw. _constant parameter_
                                                                                                                             * @param {Number} [options.duration=1] - Duration (in seconds) represented in
                                                                                                                             *  the canvas. This parameter only exists for operators that display several
                                                                                                                             *  consecutive frames on the canvas. _dynamic parameter_
                                                                                                                             * @param {Number} [options.referenceTime=null] - Optionnal reference time the
                                                                                                                             *  display should considerer as the origin. Is only usefull when synchronizing
                                                                                                                             *  several display using the `DisplaySync` class. This parameter only exists
                                                                                                                             *  for operators that display several consecutive frames on the canvas.
                                                                                                                             *
                                                                                                                             * @memberof module:client.sink
                                                                                                                             *
                                                                                                                             * @example
                                                                                                                             * const eventIn = new lfo.source.EventIn({
                                                                                                                             *   frameType: 'signal',
                                                                                                                             *   sampleRate: 8,
                                                                                                                             *   frameSize: 4,
                                                                                                                             * });
                                                                                                                             *
                                                                                                                             * const signalDisplay = new lfo.sink.SignalDisplay({
                                                                                                                             *   canvas: '#signal-canvas',
                                                                                                                             * });
                                                                                                                             *
                                                                                                                             * eventIn.connect(signalDisplay);
                                                                                                                             * eventIn.start();
                                                                                                                             *
                                                                                                                             * // push triangle signal in the graph
                                                                                                                             * eventIn.process(0, [0, 0.5, 1, 0.5]);
                                                                                                                             * eventIn.process(0.5, [0, -0.5, -1, -0.5]);
                                                                                                                             * // ...
                                                                                                                             */var SignalDisplay = function (_BaseDisplay) {
               (0, _inherits3.default)(SignalDisplay, _BaseDisplay);function SignalDisplay(options) {
                    (0, _classCallCheck3.default)(this, SignalDisplay);var _this = (0, _possibleConstructorReturn3.default)(this, (SignalDisplay.__proto__ || (0, _getPrototypeOf2.default)(SignalDisplay)).call(this, definitions, options, true));_this.lastPosY = null;return _this;
               } /** @private */(0, _createClass3.default)(SignalDisplay, [{ key: 'processSignal', value: function processSignal(frame, frameWidth, pixelsSinceLastFrame) {
                         var color = this.params.get('color');var frameSize = this.streamParams.frameSize;var ctx = this.ctx;var data = frame.data;if (frameWidth < frameSize) data = downSample(data, frameWidth);var length = data.length;var hopX = frameWidth / length;var posX = 0;var lastY = this.lastPosY;ctx.strokeStyle = color;ctx.beginPath();for (var i = 0; i < data.length; i++) {
                              var posY = this.getYPosition(data[i]);if (lastY === null) {
                                   ctx.moveTo(posX, posY);
                              } else {
                                   if (i === 0) ctx.moveTo(-hopX, lastY);ctx.lineTo(posX, posY);
                              }posX += hopX;lastY = posY;
                         }ctx.stroke();ctx.closePath();this.lastPosY = lastY;
                    } }]);return SignalDisplay;
          }(_BaseDisplay3.default);exports.default = SignalDisplay;
     }, { "../utils/display-utils": 151, "./BaseDisplay": 135, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 139: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _promise = require('babel-runtime/core-js/promise');var _promise2 = _interopRequireDefault(_promise);var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);var _wsUtils = require('../../common/utils/wsUtils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var parameters = { port: { type: 'integer', default: 8000, nullable: true, constant: true }, url: { type: 'string', default: null, nullable: true, constant: true /**
                                                                                                                                                                             * Send an lfo frame as a socket message to a `node.source.SocketReceive`
                                                                                                                                                                             * instance.
                                                                                                                                                                             *
                                                                                                                                                                             * <p class="warning">Experimental</p>
                                                                                                                                                                             *
                                                                                                                                                                             * @memberof module:client.sink
                                                                                                                                                                             *
                                                                                                                                                                             * @example
                                                                                                                                                                             * const eventIn = new lfo.source.EventIn({
                                                                                                                                                                             *   frameType: 'vector',
                                                                                                                                                                             *   frameSize: 2,
                                                                                                                                                                             *   frameRate: 1,
                                                                                                                                                                             * });
                                                                                                                                                                             *
                                                                                                                                                                             * const socketSend = new lfo.sink.SocketSend({
                                                                                                                                                                             *   port: 3000
                                                                                                                                                                             * });
                                                                                                                                                                             *
                                                                                                                                                                             * eventIn.connect(socketSend);
                                                                                                                                                                             *
                                                                                                                                                                             * eventIn.init().then(() => {
                                                                                                                                                                             *   eventIn.start();
                                                                                                                                                                             *
                                                                                                                                                                             *   let time = 0;
                                                                                                                                                                             *
                                                                                                                                                                             *   (function createFrame() {
                                                                                                                                                                             *     eventIn.process(time, [Math.random(), Math.random()], { test: true });
                                                                                                                                                                             *     time += 1;
                                                                                                                                                                             *
                                                                                                                                                                             *     setTimeout(createFrame, 1000);
                                                                                                                                                                             *   }());
                                                                                                                                                                             * });
                                                                                                                                                                             */ } };var SocketSend = function (_BaseLfo) {
               (0, _inherits3.default)(SocketSend, _BaseLfo);function SocketSend() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, SocketSend);var _this = (0, _possibleConstructorReturn3.default)(this, (SocketSend.__proto__ || (0, _getPrototypeOf2.default)(SocketSend)).call(this, parameters, options));var protocol = window.location.protocol.replace(/^http/, 'ws');var address = _this.params.get('url') || window.location.hostname;var port = _this.params.get('port') || ''; // everything falsy becomes ''
                    var socketAddress = protocol + '//' + address + ':' + port;_this.socket = new WebSocket(socketAddress);_this.socket.binaryType = 'arraybuffer';_this.openedPromise = new _promise2.default(function (resolve, reject) {
                         _this.socket.onopen = resolve;
                    });_this.socket.onerror = function (err) {
                         return console.error(err.stack);
                    };return _this;
               }(0, _createClass3.default)(SocketSend, [{ key: 'initModule', value: function initModule() {
                         var _this2 = this; // send a INIT_MODULE_REQ and wait for INIT_MODULE_ACK
                         // no need to get children promises as we are in a leef
                         return this.openedPromise.then(function () {
                              return new _promise2.default(function (resolve, reject) {
                                   _this2.socket.onmessage = function (e) {
                                        var opcode = _wsUtils.decoders.opcode(e.data);if (opcode === _wsUtils.opcodes.INIT_MODULE_ACK) resolve();
                                   };var buffer = _wsUtils.encoders.initModuleReq();_this2.socket.send(buffer);
                              });
                         });
                    } }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         (0, _get3.default)(SocketSend.prototype.__proto__ || (0, _getPrototypeOf2.default)(SocketSend.prototype), 'processStreamParams', this).call(this, prevStreamParams);var buffer = _wsUtils.encoders.streamParams(this.streamParams);this.socket.send(buffer);
                    } }, { key: 'resetStream', value: function resetStream() {
                         (0, _get3.default)(SocketSend.prototype.__proto__ || (0, _getPrototypeOf2.default)(SocketSend.prototype), 'resetStream', this).call(this);var buffer = _wsUtils.encoders.resetStream();this.socket.send(buffer);
                    } /** @private */ }, { key: 'finalizeStream', value: function finalizeStream(endTime) {
                         (0, _get3.default)(SocketSend.prototype.__proto__ || (0, _getPrototypeOf2.default)(SocketSend.prototype), 'finalizeStream', this).call(this, endTime);var buffer = _wsUtils.encoders.finalizeStream(endTime);this.socket.send(buffer);
                    } // process any type
                    /** @private */ }, { key: 'processScalar', value: function processScalar() {} /** @private */ }, { key: 'processVector', value: function processVector() {} /** @private */ }, { key: 'processSignal', value: function processSignal() {} }, { key: 'processFrame', value: function processFrame(frame) {
                         var frameSize = this.streamParams.frameSize;this.frame.time = frame.time;this.frame.data.set(frame.data, 0);this.frame.metadata = frame.metadata;var buffer = _wsUtils.encoders.processFrame(this.frame, frameSize);this.socket.send(buffer);
                    } }]);return SocketSend;
          }(_BaseLfo3.default);exports.default = SocketSend;
     }, { "../../common/utils/wsUtils": 181, "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/core-js/promise": 12, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 140: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _log = require('babel-runtime/core-js/math/log10');var _log2 = _interopRequireDefault(_log);var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseDisplay2 = require('./BaseDisplay');var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);var _Fft = require('../../common/operator/Fft');var _Fft2 = _interopRequireDefault(_Fft);var _displayUtils = require('../utils/display-utils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { scale: { type: 'float', default: 1, metas: { kind: 'dynamic' } }, color: { type: 'string', default: (0, _displayUtils.getColors)('spectrum'), nullable: true, metas: { kind: 'dynamic' } }, min: { type: 'float', default: -80, metas: { kind: 'dynamic' } }, max: { type: 'float', default: 6, metas: { kind: 'dynamic' } } }; /**
                                                                                                                                                                                                                                                                                                                                                               * Display the spectrum of the incomming `signal` input.
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               * @memberof module:client.sink
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.scale=1] - Scale display of the spectrogram.
                                                                                                                                                                                                                                                                                                                                                               * @param {String} [options.color=null] - Color of the spectrogram.
                                                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.min=-80] - Minimum displayed value (in dB).
                                                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.max=6] - Maximum displayed value (in dB).
                                                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.width=300] - Width of the canvas.
                                                                                                                                                                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                                                                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                                                                                                                                                                               * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                                                                                                                                                                                                                                                               *  in which to insert the canvas. _constant parameter_
                                                                                                                                                                                                                                                                                                                                                               * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                                                                                                                                                                                                                                                               *  in which to draw. _constant parameter_
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               * @todo - expose more `fft` config options
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               * @example
                                                                                                                                                                                                                                                                                                                                                               * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               * const audioContext = new AudioContext();
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               * navigator.mediaDevices
                                                                                                                                                                                                                                                                                                                                                               *   .getUserMedia({ audio: true })
                                                                                                                                                                                                                                                                                                                                                               *   .then(init)
                                                                                                                                                                                                                                                                                                                                                               *   .catch((err) => console.error(err.stack));
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               * function init(stream) {
                                                                                                                                                                                                                                                                                                                                                               *   const source = audioContext.createMediaStreamSource(stream);
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               *   const audioInNode = new lfo.source.AudioInNode({
                                                                                                                                                                                                                                                                                                                                                               *     audioContext: audioContext,
                                                                                                                                                                                                                                                                                                                                                               *     sourceNode: source,
                                                                                                                                                                                                                                                                                                                                                               *   });
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               *   const spectrum = new lfo.sink.SpectrumDisplay({
                                                                                                                                                                                                                                                                                                                                                               *     canvas: '#spectrum',
                                                                                                                                                                                                                                                                                                                                                               *   });
                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                               *   audioInNode.connect(spectrum);
                                                                                                                                                                                                                                                                                                                                                               *   audioInNode.start();
                                                                                                                                                                                                                                                                                                                                                               * }
                                                                                                                                                                                                                                                                                                                                                               */var SpectrumDisplay = function (_BaseDisplay) {
               (0, _inherits3.default)(SpectrumDisplay, _BaseDisplay);function SpectrumDisplay() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, SpectrumDisplay);return (0, _possibleConstructorReturn3.default)(this, (SpectrumDisplay.__proto__ || (0, _getPrototypeOf2.default)(SpectrumDisplay)).call(this, definitions, options, false));
               } /** @private */(0, _createClass3.default)(SpectrumDisplay, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.fft = new _Fft2.default({ size: this.streamParams.frameSize, window: 'hann', norm: 'linear' });this.fft.initStream(this.streamParams);this.propagateStreamParams();
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         var bins = this.fft.inputSignal(frame.data);var nbrBins = bins.length;var width = this.canvasWidth;var height = this.canvasHeight;var scale = this.params.get('scale');var binWidth = width / nbrBins;var ctx = this.ctx;ctx.fillStyle = this.params.get('color'); // error handling needs review...
                         var error = 0;for (var i = 0; i < nbrBins; i++) {
                              var x1Float = i * binWidth + error;var x1Int = Math.round(x1Float);var x2Float = x1Float + (binWidth - error);var x2Int = Math.round(x2Float);error = x2Int - x2Float;if (x1Int !== x2Int) {
                                   var _width = x2Int - x1Int;var db = 20 * (0, _log2.default)(bins[i]);var y = this.getYPosition(db * scale);ctx.fillRect(x1Int, y, _width, height - y);
                              } else {
                                   error -= binWidth;
                              }
                         }
                    } }]);return SpectrumDisplay;
          }(_BaseDisplay3.default);exports.default = SpectrumDisplay;
     }, { "../../common/operator/Fft": 156, "../utils/display-utils": 151, "./BaseDisplay": 135, "babel-runtime/core-js/math/log10": 4, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 141: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseDisplay2 = require('./BaseDisplay');var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);var _displayUtils = require('../utils/display-utils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { color: { type: 'string', default: (0, _displayUtils.getColors)('trace'), metas: { kind: 'dynamic' } }, colorScheme: { type: 'enum', default: 'none', list: ['none', 'hue', 'opacity'] } }; /**
                                                                                                                                                                                                                          * Display a range value around a mean value (for example mean
                                                                                                                                                                                                                          * and standart deviation).
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          * This sink can handle input of type `vector` of frameSize >= 2.
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                          * @param {String} [options.color='orange'] - Color.
                                                                                                                                                                                                                          * @param {String} [options.colorScheme='none'] - If a third value is available
                                                                                                                                                                                                                          *  in the input, can be used to control the opacity or the hue. If input frame
                                                                                                                                                                                                                          *  size is 2, this param is automatically set to `none`
                                                                                                                                                                                                                          * @param {Number} [options.min=-1] - Minimum value represented in the canvas.
                                                                                                                                                                                                                          *  _dynamic parameter_
                                                                                                                                                                                                                          * @param {Number} [options.max=1] - Maximum value represented in the canvas.
                                                                                                                                                                                                                          *  _dynamic parameter_
                                                                                                                                                                                                                          * @param {Number} [options.width=300] - Width of the canvas.
                                                                                                                                                                                                                          *  _dynamic parameter_
                                                                                                                                                                                                                          * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                                                                                                                          *  _dynamic parameter_
                                                                                                                                                                                                                          * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                                                                                                                          *  in which to insert the canvas. _constant parameter_
                                                                                                                                                                                                                          * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                                                                                                                          *  in which to draw. _constant parameter_
                                                                                                                                                                                                                          * @param {Number} [options.duration=1] - Duration (in seconds) represented in
                                                                                                                                                                                                                          *  the canvas. _dynamic parameter_
                                                                                                                                                                                                                          * @param {Number} [options.referenceTime=null] - Optionnal reference time the
                                                                                                                                                                                                                          *  display should considerer as the origin. Is only usefull when synchronizing
                                                                                                                                                                                                                          *  several display using the `DisplaySync` class.
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          * @memberof module:client.sink
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          * @example
                                                                                                                                                                                                                          * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          * const AudioContext = (window.AudioContext ||window.webkitAudioContext);
                                                                                                                                                                                                                          * const audioContext = new AudioContext();
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          * navigator.mediaDevices
                                                                                                                                                                                                                          *   .getUserMedia({ audio: true })
                                                                                                                                                                                                                          *   .then(init)
                                                                                                                                                                                                                          *   .catch((err) => console.error(err.stack));
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          * function init(stream) {
                                                                                                                                                                                                                          *   const source = audioContext.createMediaStreamSource(stream);
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          *   const audioInNode = new lfo.source.AudioInNode({
                                                                                                                                                                                                                          *     sourceNode: source,
                                                                                                                                                                                                                          *     audioContext: audioContext,
                                                                                                                                                                                                                          *   });
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          *   // not sure it make sens but...
                                                                                                                                                                                                                          *   const meanStddev = new lfo.operator.MeanStddev();
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          *   const traceDisplay = new lfo.sink.TraceDisplay({
                                                                                                                                                                                                                          *     canvas: '#trace',
                                                                                                                                                                                                                          *   });
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          *   const logger = new lfo.sink.Logger({ data: true });
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          *   audioInNode.connect(meanStddev);
                                                                                                                                                                                                                          *   meanStddev.connect(traceDisplay);
                                                                                                                                                                                                                          *
                                                                                                                                                                                                                          *   audioInNode.start();
                                                                                                                                                                                                                          * }
                                                                                                                                                                                                                          */var TraceDisplay = function (_BaseDisplay) {
               (0, _inherits3.default)(TraceDisplay, _BaseDisplay);function TraceDisplay() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, TraceDisplay);var _this = (0, _possibleConstructorReturn3.default)(this, (TraceDisplay.__proto__ || (0, _getPrototypeOf2.default)(TraceDisplay)).call(this, definitions, options));_this.prevFrame = null;return _this;
               } /** @private */(0, _createClass3.default)(TraceDisplay, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);if (this.streamParams.frameSize === 2) this.params.set('colorScheme', 'none');this.propagateStreamParams();
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame, frameWidth, pixelsSinceLastFrame) {
                         var colorScheme = this.params.get('colorScheme');var ctx = this.ctx;var prevData = this.prevFrame ? this.prevFrame.data : null;var data = frame.data;var halfRange = data[1] / 2;var mean = this.getYPosition(data[0]);var min = this.getYPosition(data[0] - halfRange);var max = this.getYPosition(data[0] + halfRange);var prevHalfRange = void 0;var prevMean = void 0;var prevMin = void 0;var prevMax = void 0;if (prevData !== null) {
                              prevHalfRange = prevData[1] / 2;prevMean = this.getYPosition(prevData[0]);prevMin = this.getYPosition(prevData[0] - prevHalfRange);prevMax = this.getYPosition(prevData[0] + prevHalfRange);
                         }var color = this.params.get('color');var gradient = void 0;var rgb = void 0;switch (colorScheme) {case 'none':
                                   rgb = (0, _displayUtils.hexToRGB)(color);ctx.fillStyle = 'rgba(' + rgb.join(',') + ', 0.7)';ctx.strokeStyle = color;break;case 'hue':
                                   gradient = ctx.createLinearGradient(-pixelsSinceLastFrame, 0, 0, 0);if (prevData) gradient.addColorStop(0, 'hsl(' + (0, _displayUtils.getHue)(prevData[2]) + ', 100%, 50%)');else gradient.addColorStop(0, 'hsl(' + (0, _displayUtils.getHue)(data[2]) + ', 100%, 50%)');gradient.addColorStop(1, 'hsl(' + (0, _displayUtils.getHue)(data[2]) + ', 100%, 50%)');ctx.fillStyle = gradient;break;case 'opacity':
                                   rgb = (0, _displayUtils.hexToRGB)(this.params.get('color'));gradient = ctx.createLinearGradient(-pixelsSinceLastFrame, 0, 0, 0);if (prevData) gradient.addColorStop(0, 'rgba(' + rgb.join(',') + ', ' + prevData[2] + ')');else gradient.addColorStop(0, 'rgba(' + rgb.join(',') + ', ' + data[2] + ')');gradient.addColorStop(1, 'rgba(' + rgb.join(',') + ', ' + data[2] + ')');ctx.fillStyle = gradient;break;}ctx.save(); // draw range
                         ctx.beginPath();ctx.moveTo(0, mean);ctx.lineTo(0, max);if (prevData !== null) {
                              ctx.lineTo(-pixelsSinceLastFrame, prevMax);ctx.lineTo(-pixelsSinceLastFrame, prevMin);
                         }ctx.lineTo(0, min);ctx.closePath();ctx.fill(); // draw mean
                         if (colorScheme === 'none' && prevMean) {
                              ctx.beginPath();ctx.moveTo(-pixelsSinceLastFrame, prevMean);ctx.lineTo(0, mean);ctx.closePath();ctx.stroke();
                         }ctx.restore();this.prevFrame = frame;
                    } }]);return TraceDisplay;
          }(_BaseDisplay3.default);;exports.default = TraceDisplay;
     }, { "../utils/display-utils": 151, "./BaseDisplay": 135, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 142: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _log = require('babel-runtime/core-js/math/log10');var _log2 = _interopRequireDefault(_log);var _BaseDisplay2 = require('./BaseDisplay');var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);var _Rms = require('../../common/operator/Rms');var _Rms2 = _interopRequireDefault(_Rms);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var log10 = _log2.default;var definitions = { offset: { type: 'float', default: -14, metas: { kind: 'dyanmic' } }, min: { type: 'float', default: -80, metas: { kind: 'dynamic' } }, max: { type: 'float', default: 6, metas: { kind: 'dynamic' } }, width: { type: 'integer', default: 6, metas: { kind: 'dynamic' /**
                                                                                                                                                                                                                                                                                                                               * Simple VU-Meter to used on a `signal` stream.
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * @memberof module:client.sink
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * @param {Object} options - Override defaults parameters.
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.offset=-14] - dB offset applied to the signal.
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.min=-80] - Minimum displayed value (in dB).
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.max=6] - Maximum displayed value (in dB).
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.width=6] - Width of the display (in pixels).
                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                                                                                                                                                                                                                               * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                                                                                                                                                                                                                               *  in which to insert the canvas.
                                                                                                                                                                                                                                                                                                                               * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                                                                                                                                                                                                                               *  in which to draw.
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * @example
                                                                                                                                                                                                                                                                                                                               * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * const audioContext = new window.AudioContext();
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * navigator.mediaDevices
                                                                                                                                                                                                                                                                                                                               *   .getUserMedia({ audio: true })
                                                                                                                                                                                                                                                                                                                               *   .then(init)
                                                                                                                                                                                                                                                                                                                               *   .catch((err) => console.error(err.stack));
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               * function init(stream) {
                                                                                                                                                                                                                                                                                                                               *   const source = audioContext.createMediaStreamSource(stream);
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               *   const audioInNode = new lfo.source.AudioInNode({
                                                                                                                                                                                                                                                                                                                               *     audioContext: audioContext,
                                                                                                                                                                                                                                                                                                                               *     sourceNode: source,
                                                                                                                                                                                                                                                                                                                               *   });
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               *   const vuMeter = new lfo.sink.VuMeterDisplay({
                                                                                                                                                                                                                                                                                                                               *     canvas: '#vu-meter',
                                                                                                                                                                                                                                                                                                                               *   });
                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                               *   audioInNode.connect(vuMeter);
                                                                                                                                                                                                                                                                                                                               *   audioInNode.start();
                                                                                                                                                                                                                                                                                                                               * }
                                                                                                                                                                                                                                                                                                                               */ } } };var VuMeterDisplay = function (_BaseDisplay) {
               (0, _inherits3.default)(VuMeterDisplay, _BaseDisplay);function VuMeterDisplay() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, VuMeterDisplay);var _this = (0, _possibleConstructorReturn3.default)(this, (VuMeterDisplay.__proto__ || (0, _getPrototypeOf2.default)(VuMeterDisplay)).call(this, definitions, options, false));_this.rmsOperator = new _Rms2.default();_this.lastDB = 0;_this.peak = { value: 0, time: 0 };_this.peakLifetime = 1; // sec
                    return _this;
               } /** @private */(0, _createClass3.default)(VuMeterDisplay, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.rmsOperator.initStream(this.streamParams);this.propagateStreamParams();
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         var now = new Date().getTime() / 1000; // sec
                         var offset = this.params.get('offset'); // offset zero of the vu meter
                         var height = this.canvasHeight;var width = this.canvasWidth;var ctx = this.ctx;var lastDB = this.lastDB;var peak = this.peak;var red = '#ff2121';var yellow = '#ffff1f';var green = '#00ff00'; // handle current db value
                         var rms = this.rmsOperator.inputSignal(frame.data);var dB = 20 * log10(rms) - offset; // slow release (could probably be improved)
                         if (lastDB > dB) dB = lastDB - 6; // handle peak
                         if (dB > peak.value || now - peak.time > this.peakLifetime) {
                              peak.value = dB;peak.time = now;
                         }var y0 = this.getYPosition(0);var y = this.getYPosition(dB);var yPeak = this.getYPosition(peak.value);ctx.save();ctx.fillStyle = '#000000';ctx.fillRect(0, 0, width, height);var gradient = ctx.createLinearGradient(0, height, 0, 0);gradient.addColorStop(0, green);gradient.addColorStop((height - y0) / height, yellow);gradient.addColorStop(1, red); // dB
                         ctx.fillStyle = gradient;ctx.fillRect(0, y, width, height - y); // 0 dB marker
                         ctx.fillStyle = '#dcdcdc';ctx.fillRect(0, y0, width, 2); // peak
                         ctx.fillStyle = gradient;ctx.fillRect(0, yPeak, width, 2);ctx.restore();this.lastDB = dB;
                    } }]);return VuMeterDisplay;
          }(_BaseDisplay3.default);exports.default = VuMeterDisplay;
     }, { "../../common/operator/Rms": 168, "./BaseDisplay": 135, "babel-runtime/core-js/math/log10": 4, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 143: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseDisplay2 = require('./BaseDisplay');var _BaseDisplay3 = _interopRequireDefault(_BaseDisplay2);var _MinMax = require('../../common/operator/MinMax');var _MinMax2 = _interopRequireDefault(_MinMax);var _Rms = require('../../common/operator/Rms');var _Rms2 = _interopRequireDefault(_Rms);var _displayUtils = require('../utils/display-utils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { colors: { type: 'any', default: (0, _displayUtils.getColors)('waveform'), metas: { kind: 'dyanmic' } }, rms: { type: 'boolean', default: false, metas: { kind: 'dyanmic' } } }; /**
                                                                                                                                                                                                               * Display a waveform (along with optionnal Rms) of a given `signal` input in
                                                                                                                                                                                                               * a canvas.
                                                                                                                                                                                                               *
                                                                                                                                                                                                               * @param {Object} options - Override default parameters.
                                                                                                                                                                                                               * @param {Array<String>} [options.colors=['waveform', 'rms']] - Array
                                                                                                                                                                                                               *  containing the color codes for the waveform (index 0) and rms (index 1).
                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                               * @param {Boolean} [options.rms=false] - Set to `true` to display the rms.
                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                               * @param {Number} [options.duration=1] - Duration (in seconds) represented in
                                                                                                                                                                                                               *  the canvas. _dynamic parameter_
                                                                                                                                                                                                               * @param {Number} [options.min=-1] - Minimum value represented in the canvas.
                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                               * @param {Number} [options.max=1] - Maximum value represented in the canvas.
                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                               * @param {Number} [options.width=300] - Width of the canvas.
                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                               * @param {Number} [options.height=150] - Height of the canvas.
                                                                                                                                                                                                               *  _dynamic parameter_
                                                                                                                                                                                                               * @param {Element|CSSSelector} [options.container=null] - Container element
                                                                                                                                                                                                               *  in which to insert the canvas. _constant parameter_
                                                                                                                                                                                                               * @param {Element|CSSSelector} [options.canvas=null] - Canvas element
                                                                                                                                                                                                               *  in which to draw. _constant parameter_
                                                                                                                                                                                                               * @param {Number} [options.referenceTime=null] - Optionnal reference time the
                                                                                                                                                                                                               *  display should considerer as the origin. Is only usefull when synchronizing
                                                                                                                                                                                                               *  several display using the `DisplaySync` class.
                                                                                                                                                                                                               *
                                                                                                                                                                                                               * @memberof module:client.sink
                                                                                                                                                                                                               *
                                                                                                                                                                                                               * @example
                                                                                                                                                                                                               * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                               *
                                                                                                                                                                                                               * const audioContext = new window.AudioContext();
                                                                                                                                                                                                               *
                                                                                                                                                                                                               * navigator.mediaDevices
                                                                                                                                                                                                               *   .getUserMedia({ audio: true })
                                                                                                                                                                                                               *   .then(init)
                                                                                                                                                                                                               *   .catch((err) => console.error(err.stack));
                                                                                                                                                                                                               *
                                                                                                                                                                                                               * function init(stream) {
                                                                                                                                                                                                               *   const audioIn = audioContext.createMediaStreamSource(stream);
                                                                                                                                                                                                               *
                                                                                                                                                                                                               *   const audioInNode = new lfo.source.AudioInNode({
                                                                                                                                                                                                               *     audioContext: audioContext,
                                                                                                                                                                                                               *     sourceNode: audioIn,
                                                                                                                                                                                                               *     frameSize: 512,
                                                                                                                                                                                                               *   });
                                                                                                                                                                                                               *
                                                                                                                                                                                                               *   const waveformDisplay = new lfo.sink.WaveformDisplay({
                                                                                                                                                                                                               *     canvas: '#waveform',
                                                                                                                                                                                                               *     duration: 3.5,
                                                                                                                                                                                                               *     rms: true,
                                                                                                                                                                                                               *   });
                                                                                                                                                                                                               *
                                                                                                                                                                                                               *   audioInNode.connect(waveformDisplay);
                                                                                                                                                                                                               *   audioInNode.start();
                                                                                                                                                                                                               * });
                                                                                                                                                                                                               */var WaveformDisplay = function (_BaseDisplay) {
               (0, _inherits3.default)(WaveformDisplay, _BaseDisplay);function WaveformDisplay(options) {
                    (0, _classCallCheck3.default)(this, WaveformDisplay);var _this = (0, _possibleConstructorReturn3.default)(this, (WaveformDisplay.__proto__ || (0, _getPrototypeOf2.default)(WaveformDisplay)).call(this, definitions, options, true));_this.minMaxOperator = new _MinMax2.default();_this.rmsOperator = new _Rms2.default();return _this;
               } /** @private */(0, _createClass3.default)(WaveformDisplay, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.minMaxOperator.initStream(this.streamParams);this.rmsOperator.initStream(this.streamParams);this.propagateStreamParams();
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame, frameWidth, pixelsSinceLastFrame) {
                         // drop frames that cannot be displayed
                         if (frameWidth < 1) return;var colors = this.params.get('colors');var showRms = this.params.get('rms');var ctx = this.ctx;var data = frame.data;var iSamplesPerPixels = Math.floor(data.length / frameWidth);for (var index = 0; index < frameWidth; index++) {
                              var start = index * iSamplesPerPixels;var end = index === frameWidth - 1 ? undefined : start + iSamplesPerPixels;var slice = data.subarray(start, end);var minMax = this.minMaxOperator.inputSignal(slice);var minY = this.getYPosition(minMax[0]);var maxY = this.getYPosition(minMax[1]);ctx.strokeStyle = colors[0];ctx.beginPath();ctx.moveTo(index, minY);ctx.lineTo(index, maxY);ctx.closePath();ctx.stroke();if (showRms) {
                                   var rms = this.rmsOperator.inputSignal(slice);var rmsMaxY = this.getYPosition(rms);var rmsMinY = this.getYPosition(-rms);ctx.strokeStyle = colors[1];ctx.beginPath();ctx.moveTo(index, rmsMinY);ctx.lineTo(index, rmsMaxY);ctx.closePath();ctx.stroke();
                              }
                         }
                    } }]);return WaveformDisplay;
          }(_BaseDisplay3.default);exports.default = WaveformDisplay;
     }, { "../../common/operator/MinMax": 162, "../../common/operator/Rms": 168, "../utils/display-utils": 151, "./BaseDisplay": 135, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 144: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _Bridge = require('../../common/sink/Bridge');var _Bridge2 = _interopRequireDefault(_Bridge);var _Logger = require('../../common/sink/Logger');var _Logger2 = _interopRequireDefault(_Logger);var _DataRecorder = require('../../common/sink/DataRecorder');var _DataRecorder2 = _interopRequireDefault(_DataRecorder);var _SignalRecorder = require('../../common/sink/SignalRecorder');var _SignalRecorder2 = _interopRequireDefault(_SignalRecorder);var _BaseDisplay = require('./BaseDisplay');var _BaseDisplay2 = _interopRequireDefault(_BaseDisplay);var _BarChartDisplay = require('./BarChartDisplay');var _BarChartDisplay2 = _interopRequireDefault(_BarChartDisplay);var _BpfDisplay = require('./BpfDisplay');var _BpfDisplay2 = _interopRequireDefault(_BpfDisplay);var _MarkerDisplay = require('./MarkerDisplay');var _MarkerDisplay2 = _interopRequireDefault(_MarkerDisplay);var _SignalDisplay = require('./SignalDisplay');var _SignalDisplay2 = _interopRequireDefault(_SignalDisplay);var _SocketSend = require('./SocketSend');var _SocketSend2 = _interopRequireDefault(_SocketSend);var _SpectrumDisplay = require('./SpectrumDisplay');var _SpectrumDisplay2 = _interopRequireDefault(_SpectrumDisplay);var _TraceDisplay = require('./TraceDisplay');var _TraceDisplay2 = _interopRequireDefault(_TraceDisplay);var _VuMeterDisplay = require('./VuMeterDisplay');var _VuMeterDisplay2 = _interopRequireDefault(_VuMeterDisplay);var _WaveformDisplay = require('./WaveformDisplay');var _WaveformDisplay2 = _interopRequireDefault(_WaveformDisplay);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          } // client only
          // common
          exports.default = { Bridge: _Bridge2.default, Logger: _Logger2.default, DataRecorder: _DataRecorder2.default, SignalRecorder: _SignalRecorder2.default, BaseDisplay: _BaseDisplay2.default, BarChartDisplay: _BarChartDisplay2.default, BpfDisplay: _BpfDisplay2.default, MarkerDisplay: _MarkerDisplay2.default, SignalDisplay: _SignalDisplay2.default, SocketSend: _SocketSend2.default, SpectrumDisplay: _SpectrumDisplay2.default, TraceDisplay: _TraceDisplay2.default, VuMeterDisplay: _VuMeterDisplay2.default, WaveformDisplay: _WaveformDisplay2.default };
     }, { "../../common/sink/Bridge": 175, "../../common/sink/DataRecorder": 176, "../../common/sink/Logger": 177, "../../common/sink/SignalRecorder": 178, "./BarChartDisplay": 134, "./BaseDisplay": 135, "./BpfDisplay": 136, "./MarkerDisplay": 137, "./SignalDisplay": 138, "./SocketSend": 139, "./SpectrumDisplay": 140, "./TraceDisplay": 141, "./VuMeterDisplay": 142, "./WaveformDisplay": 143 }], 145: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _defineProperty2 = require('babel-runtime/helpers/defineProperty');var _defineProperty3 = _interopRequireDefault(_defineProperty2);var _definitions;var _BaseLfo = require('../../core/BaseLfo');var _BaseLfo2 = _interopRequireDefault(_BaseLfo);var _SourceMixin2 = require('../../core/SourceMixin');var _SourceMixin3 = _interopRequireDefault(_SourceMixin2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = (_definitions = { audioBuffer: { type: 'any', default: null, constant: true }, frameSize: { type: 'integer', default: 512, constant: true }, channel: { type: 'integer', default: 0, constant: true }, progressCallback: { type: 'any', default: null, nullable: true, constant: true } }, (0, _defineProperty3.default)(_definitions, 'progressCallback', { type: 'any', default: null, nullable: true, constant: true }), (0, _defineProperty3.default)(_definitions, 'async', { type: 'boolean', default: false }), _definitions);var noop = function noop() {}; /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * Slice an `AudioBuffer` into signal blocks and propagate the resulting frames
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * through the graph.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * @param {Object} options - Override parameter' default values.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * @param {AudioBuffer} [options.audioBuffer] - Audio buffer to process.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * @param {Number} [options.frameSize=512] - Size of the output blocks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * @param {Number} [options.channel=0] - Number of the channel to process.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * @param {Number} [options.progressCallback=null] - Callback to be excuted on each
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *  frame output, receive as argument the current progress ratio.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * @memberof module:client.source
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * @example
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * const audioInBuffer = new lfo.source.AudioInBuffer({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *   audioBuffer: audioBuffer,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *   frameSize: 512,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * const waveform = new lfo.sink.Waveform({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *   canvas: '#waveform',
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *   duration: 1,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *   color: 'steelblue',
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *   rms: true,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * audioInBuffer.connect(waveform);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * audioInBuffer.start();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 */var AudioInBuffer = function (_SourceMixin) {
               (0, _inherits3.default)(AudioInBuffer, _SourceMixin);function AudioInBuffer() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, AudioInBuffer);var _this = (0, _possibleConstructorReturn3.default)(this, (AudioInBuffer.__proto__ || (0, _getPrototypeOf2.default)(AudioInBuffer)).call(this, definitions, options));var audioBuffer = _this.params.get('audioBuffer');if (!audioBuffer) throw new Error('Invalid "audioBuffer" parameter');_this.endTime = 0;return _this;
               } /**
                 * Propagate the `streamParams` in the graph and start propagating frames.
                 * When called, the slicing of the given `audioBuffer` starts immediately and
                 * each resulting frame is propagated in graph.
                 *
                 * @see {@link module:core.BaseLfo#processStreamParams}
                 * @see {@link module:core.BaseLfo#resetStream}
                 * @see {@link module:client.source.AudioInBuffer#stop}
                 */(0, _createClass3.default)(AudioInBuffer, [{ key: 'start', value: function start() {
                         if (this.initialized === false) {
                              if (this.initPromise === null) // init has not yet been called
                                   this.initPromise = this.init();this.initPromise.then(this.start);return;
                         }var channel = this.params.get('channel');var audioBuffer = this.params.get('audioBuffer');var buffer = audioBuffer.getChannelData(channel);this.endTime = 0;this.started = true;this.processFrame(buffer);
                    } /**
                      * Finalize the stream and stop the whole graph. When called, the slicing of
                      * the `audioBuffer` stops immediately.
                      *
                      * @see {@link module:core.BaseLfo#finalizeStream}
                      * @see {@link module:client.source.AudioInBuffer#start}
                      */ }, { key: 'stop', value: function stop() {
                         this.finalizeStream(this.endTime);this.started = false;
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams() {
                         var audioBuffer = this.params.get('audioBuffer');var frameSize = this.params.get('frameSize');var sourceSampleRate = audioBuffer.sampleRate;var frameRate = sourceSampleRate / frameSize;this.streamParams.frameSize = frameSize;this.streamParams.frameRate = frameRate;this.streamParams.frameType = 'signal';this.streamParams.sourceSampleRate = sourceSampleRate;this.streamParams.sourceSampleCount = frameSize;this.propagateStreamParams();
                    } /** @private */ }, { key: 'processFrame', value: function processFrame(buffer) {
                         var async = this.params.get('async');var sampleRate = this.streamParams.sourceSampleRate;var frameSize = this.streamParams.frameSize;var progressCallback = this.params.get('progressCallback') || noop;var length = buffer.length;var nbrFrames = Math.ceil(buffer.length / frameSize);var data = this.frame.data;var that = this;var i = 0;function slice() {
                              var offset = i * frameSize;var nbrCopy = Math.min(length - offset, frameSize);for (var j = 0; j < frameSize; j++) {
                                   data[j] = j < nbrCopy ? buffer[offset + j] : 0;
                              }that.frame.time = offset / sampleRate;that.endTime = that.frame.time + nbrCopy / sampleRate;that.propagateFrame();i += 1;progressCallback(i / nbrFrames);if (i < nbrFrames) {
                                   if (async) setTimeout(slice, 0);else slice();
                              } else {
                                   that.finalizeStream(that.endTime);
                              }
                         }; // allow the following to do the expected thing:
                         // audioIn.connect(recorder);
                         // audioIn.start();
                         // recorder.start();
                         setTimeout(slice, 0);
                    } }]);return AudioInBuffer;
          }((0, _SourceMixin3.default)(_BaseLfo2.default));exports.default = AudioInBuffer;
     }, { "../../core/BaseLfo": 182, "../../core/SourceMixin": 183, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/defineProperty": 17, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 146: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo = require('../../core/BaseLfo');var _BaseLfo2 = _interopRequireDefault(_BaseLfo);var _SourceMixin2 = require('../../core/SourceMixin');var _SourceMixin3 = _interopRequireDefault(_SourceMixin2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var AudioContext = window.AudioContext || window.webkitAudioContext;var definitions = { frameSize: { type: 'integer', default: 512, constant: true }, channel: { type: 'integer', default: 0, constant: true }, sourceNode: { type: 'any', default: null, constant: true }, audioContext: { type: 'any', default: null, constant: true } }; /**
                                                                                                                                                                                                                                                                                                                                                       * Use a `WebAudio` node as a source for the graph.
                                                                                                                                                                                                                                                                                                                                                       *
                                                                                                                                                                                                                                                                                                                                                       * @param {Object} options - Override parameter' default values.
                                                                                                                                                                                                                                                                                                                                                       * @param {AudioNode} [options.sourceNode=null] - Audio node to process
                                                                                                                                                                                                                                                                                                                                                       *  (mandatory).
                                                                                                                                                                                                                                                                                                                                                       * @param {AudioContext} [options.audioContext=null] - Audio context used to
                                                                                                                                                                                                                                                                                                                                                       *  create the audio node (mandatory).
                                                                                                                                                                                                                                                                                                                                                       * @param {Number} [options.frameSize=512] - Size of the output blocks, define
                                                                                                                                                                                                                                                                                                                                                       *  the `frameSize` in the `streamParams`.
                                                                                                                                                                                                                                                                                                                                                       * @param {Number} [options.channel=0] - Number of the channel to process.
                                                                                                                                                                                                                                                                                                                                                       *
                                                                                                                                                                                                                                                                                                                                                       * @memberof module:client.source
                                                                                                                                                                                                                                                                                                                                                       *
                                                                                                                                                                                                                                                                                                                                                       * @example
                                                                                                                                                                                                                                                                                                                                                       * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                                                       *
                                                                                                                                                                                                                                                                                                                                                       * const audioContext = new AudioContext();
                                                                                                                                                                                                                                                                                                                                                       * const sine = audioContext.createOscillator();
                                                                                                                                                                                                                                                                                                                                                       * sine.frequency.value = 2;
                                                                                                                                                                                                                                                                                                                                                       *
                                                                                                                                                                                                                                                                                                                                                       * const audioInNode = new lfo.source.AudioInNode({
                                                                                                                                                                                                                                                                                                                                                       *   audioContext: audioContext,
                                                                                                                                                                                                                                                                                                                                                       *   sourceNode: sine,
                                                                                                                                                                                                                                                                                                                                                       * });
                                                                                                                                                                                                                                                                                                                                                       *
                                                                                                                                                                                                                                                                                                                                                       * const signalDisplay = new lfo.sink.SignalDisplay({
                                                                                                                                                                                                                                                                                                                                                       *   canvas: '#signal',
                                                                                                                                                                                                                                                                                                                                                       *   duration: 1,
                                                                                                                                                                                                                                                                                                                                                       * });
                                                                                                                                                                                                                                                                                                                                                       *
                                                                                                                                                                                                                                                                                                                                                       * audioInNode.connect(signalDisplay);
                                                                                                                                                                                                                                                                                                                                                       *
                                                                                                                                                                                                                                                                                                                                                       * // start the sine oscillator node and the lfo graph
                                                                                                                                                                                                                                                                                                                                                       * sine.start();
                                                                                                                                                                                                                                                                                                                                                       * audioInNode.start();
                                                                                                                                                                                                                                                                                                                                                       */var AudioInNode = function (_SourceMixin) {
               (0, _inherits3.default)(AudioInNode, _SourceMixin);function AudioInNode() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, AudioInNode);var _this = (0, _possibleConstructorReturn3.default)(this, (AudioInNode.__proto__ || (0, _getPrototypeOf2.default)(AudioInNode)).call(this, definitions, options));var audioContext = _this.params.get('audioContext');var sourceNode = _this.params.get('sourceNode');if (!audioContext || !(audioContext instanceof AudioContext)) throw new Error('Invalid `audioContext` parameter');if (!sourceNode || !(sourceNode instanceof AudioNode)) throw new Error('Invalid `sourceNode` parameter');_this.sourceNode = sourceNode;_this._channel = _this.params.get('channel');_this._blockDuration = null;_this.processFrame = _this.processFrame.bind(_this);return _this;
               } /**
                 * Propagate the `streamParams` in the graph and start to propagate signal
                 * blocks produced by the audio node into the graph.
                 *
                 * @see {@link module:core.BaseLfo#processStreamParams}
                 * @see {@link module:core.BaseLfo#resetStream}
                 * @see {@link module:client.source.AudioInNode#stop}
                 */(0, _createClass3.default)(AudioInNode, [{ key: 'start', value: function start() {
                         if (this.initialized === false) {
                              if (this.initPromise === null) // init has not yet been called
                                   this.initPromise = this.init();this.initPromise.then(this.start);return;
                         }var audioContext = this.params.get('audioContext');var frameSize = this.params.get('frameSize');this.frame.time = 0; // @note: recreate each time because of a firefox weird behavior
                         this.scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);this.scriptProcessor.onaudioprocess = this.processFrame;this.started = true;this.sourceNode.connect(this.scriptProcessor);this.scriptProcessor.connect(audioContext.destination);
                    } /**
                      * Finalize the stream and stop the whole graph.
                      *
                      * @see {@link module:core.BaseLfo#finalizeStream}
                      * @see {@link module:client.source.AudioInNode#start}
                      */ }, { key: 'stop', value: function stop() {
                         this.finalizeStream(this.frame.time);this.started = false;this.sourceNode.disconnect();this.scriptProcessor.disconnect();
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams() {
                         var audioContext = this.params.get('audioContext');var frameSize = this.params.get('frameSize');var sampleRate = audioContext.sampleRate;this.streamParams.frameSize = frameSize;this.streamParams.frameRate = sampleRate / frameSize;this.streamParams.frameType = 'signal';this.streamParams.sourceSampleRate = sampleRate;this.streamParams.sourceSampleCount = frameSize;this._blockDuration = frameSize / sampleRate;this.propagateStreamParams();
                    } /**
                      * Basically the `scriptProcessor.onaudioprocess` callback
                      * @private
                      */ }, { key: 'processFrame', value: function processFrame(e) {
                         if (this.started === false) return;this.frame.data = e.inputBuffer.getChannelData(this._channel);this.propagateFrame();this.frame.time += this._blockDuration;
                    } }]);return AudioInNode;
          }((0, _SourceMixin3.default)(_BaseLfo2.default));exports.default = AudioInNode;
     }, { "../../core/BaseLfo": 182, "../../core/SourceMixin": 183, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 147: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _promise = require('babel-runtime/core-js/promise');var _promise2 = _interopRequireDefault(_promise);var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);var _wsUtils = require('../../common/utils/wsUtils');function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var parameters = { port: { type: 'integer', default: 8000, nullable: true, constant: true }, url: { type: 'string', default: null, nullable: true, constant: true /**
                                                                                                                                                                             * Receive an lfo frame as a socket message from a `node.sink.SocketSend`
                                                                                                                                                                             * instance.
                                                                                                                                                                             *
                                                                                                                                                                             * <p class="warning">Experimental</p>
                                                                                                                                                                             *
                                                                                                                                                                             * @memberof module:client.source
                                                                                                                                                                             *
                                                                                                                                                                             * @todo - handle init / start properly.
                                                                                                                                                                             */ } };var SocketReceive = function (_BaseLfo) {
               (0, _inherits3.default)(SocketReceive, _BaseLfo);function SocketReceive() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, SocketReceive);var _this = (0, _possibleConstructorReturn3.default)(this, (SocketReceive.__proto__ || (0, _getPrototypeOf2.default)(SocketReceive)).call(this, parameters, options));var protocol = window.location.protocol.replace(/^http/, 'ws');var address = _this.params.get('url') || window.location.hostname;var port = _this.params.get('port') || ''; // everything falsy becomes ''
                    var socketAddress = protocol + '//' + address + ':' + port;_this._dispatch = _this._dispatch.bind(_this);_this.socket = new WebSocket(socketAddress);_this.socket.binaryType = 'arraybuffer';_this.openedPromise = new _promise2.default(function (resolve, reject) {
                         _this.socket.onopen = resolve;
                    });_this.socket.onmessage = _this._dispatch;_this.socket.onerror = function (err) {
                         return console.error(err.stack);
                    };return _this;
               } /** @private */(0, _createClass3.default)(SocketReceive, [{ key: 'initModule', value: function initModule() {
                         var _this2 = this;var promises = this.nextModules.map(function (mod) {
                              return mod.initModule();
                         });promises.push(this.openedPromise); // wait for children promises and send INIT_MODULE_ACK
                         _promise2.default.all(promises).then(function () {
                              var buffer = _wsUtils.encoders.initModuleAck();_this2.socket.send(buffer);
                         });
                    } // process any type
                    /** @private */ }, { key: 'processScalar', value: function processScalar() {} /** @private */ }, { key: 'processVector', value: function processVector() {} /** @private */ }, { key: 'processSignal', value: function processSignal() {} /** @private */ }, { key: 'processFrame', value: function processFrame(frame) {
                         this.prepareFrame();this.frame = frame;this.propagateFrame();
                    } /**
                      * Decode and dispatch incomming frame according to opcode
                      * @private
                      */ }, { key: '_dispatch', value: function _dispatch(e) {
                         var arrayBuffer = e.data;var opcode = _wsUtils.decoders.opcode(arrayBuffer);switch (opcode) {case _wsUtils.opcodes.INIT_MODULE_REQ:
                                   this.initModule();break;case _wsUtils.opcodes.PROCESS_STREAM_PARAMS:
                                   var prevStreamParams = _wsUtils.decoders.streamParams(arrayBuffer);this.processStreamParams(prevStreamParams);break;case _wsUtils.opcodes.RESET_STREAM:
                                   this.resetStream();break;case _wsUtils.opcodes.FINALIZE_STREAM:
                                   var endTime = _wsUtils.decoders.finalizeStream(arrayBuffer);this.finalizeStream(endTime);break;case _wsUtils.opcodes.PROCESS_FRAME:
                                   var frameSize = this.streamParams.frameSize;var frame = _wsUtils.decoders.processFrame(arrayBuffer, frameSize);this.processFrame(frame);break;}
                    } }]);return SocketReceive;
          }(_BaseLfo3.default);exports.default = SocketReceive;
     }, { "../../common/utils/wsUtils": 181, "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/core-js/promise": 12, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 148: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _EventIn = require('../../common/source/EventIn');var _EventIn2 = _interopRequireDefault(_EventIn);var _AudioInBuffer = require('./AudioInBuffer');var _AudioInBuffer2 = _interopRequireDefault(_AudioInBuffer);var _AudioInNode = require('./AudioInNode');var _AudioInNode2 = _interopRequireDefault(_AudioInNode);var _SocketReceive = require('./SocketReceive');var _SocketReceive2 = _interopRequireDefault(_SocketReceive);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          } // common
          exports.default = { EventIn: _EventIn2.default, AudioInBuffer: _AudioInBuffer2.default, AudioInNode: _AudioInNode2.default, SocketReceive: _SocketReceive2.default }; // client only
     }, { "../../common/source/EventIn": 179, "./AudioInBuffer": 145, "./AudioInNode": 146, "./SocketReceive": 147 }], 149: [function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require("babel-runtime/helpers/createClass");var _createClass3 = _interopRequireDefault(_createClass2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          } /**
            * Synchronize several display sinks to a common time.
            *
            * @param {...BaseDisplay} views - List of the display to synchronize.
            *
            * @memberof module:client.utils
            *
            * @example
            * import * as lfo from 'waves-lfo/client';
            *
            * const eventIn1 = new lfo.source.EventIn({
            *   frameType: 'scalar',
            *   frameSize: 1,
            * });
            *
            * const bpf1 = new lfo.sink.BpfDisplay({
            *   canvas: '#bpf-1',
            *   duration: 2,
            *   startTime: 0,
            *   min: 0,
            *   colors: ['steelblue'],
            * });
            *
            * eventIn1.connect(bpf1);
            *
            * const eventIn2 = new lfo.source.EventIn({
            *   frameType: 'scalar',
            *   frameSize: 1,
            * });
            *
            * const bpf2 = new lfo.sink.BpfDisplay({
            *   canvas: '#bpf-2',
            *   duration: 2,
            *   startTime: 7,
            *   min: 0,
            *   colors: ['orange'],
            * });
            *
            * const displaySync = new lfo.utils.DisplaySync(bpf1, bpf2);
            *
            * eventIn2.connect(bpf2);
            *
            * eventIn1.start();
            * eventIn2.start();
            *
            * let time = 0;
            * const period = 0.4;
            * const offset = 7.2;
            *
            * (function generateData() {
            *   const v = Math.random();
            *
            *   eventIn1.process(time, v);
            *   eventIn2.process(time + offset, v);
            *
            *   time += period;
            *
            *   setTimeout(generateData, period * 1000);
            * }());
            */var DisplaySync = function () {
               function DisplaySync() {
                    (0, _classCallCheck3.default)(this, DisplaySync);this.views = [];this.add.apply(this, arguments);
               } /** @private */(0, _createClass3.default)(DisplaySync, [{ key: "add", value: function add() {
                         var _this = this;for (var _len = arguments.length, views = Array(_len), _key = 0; _key < _len; _key++) {
                              views[_key] = arguments[_key];
                         }views.forEach(function (view) {
                              return _this.install(view);
                         });
                    } /** @private */ }, { key: "install", value: function install(view) {
                         this.views.push(view);view.displaySync = this;
                    } /** @private */ }, { key: "shiftSiblings", value: function shiftSiblings(iShift, time, view) {
                         this.views.forEach(function (display) {
                              if (display !== view) display.shiftCanvas(iShift, time);
                         });
                    } }]);return DisplaySync;
          }();exports.default = DisplaySync;
     }, { "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16 }], 150: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _DisplaySync = require('./DisplaySync');var _DisplaySync2 = _interopRequireDefault(_DisplaySync);var _windows = require('../../common/utils/windows');var _windows2 = _interopRequireDefault(_windows);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }exports.default = { DisplaySync: _DisplaySync2.default, initWindows: _windows2.default };
     }, { "../../common/utils/windows": 180, "./DisplaySync": 149 }], 151: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var colors = ['#4682B4', '#ffa500', '#00e600', '#ff0000', '#800080', '#224153'];var getColors = exports.getColors = function getColors(type, nbr) {
               switch (type) {case 'signal':
                         return colors[0]; // steelblue
                         break;case 'bpf':
                         if (nbr <= colors.length) {
                              return colors.slice(0, nbr);
                         } else {
                              var _colors = colors.slice(0);while (_colors.length < nbr) {
                                   _colors.push(getRandomColor());
                              }return _colors;
                         }break;case 'waveform':
                         return [colors[0], colors[5]]; // steelblue / darkblue
                         break;case 'marker':
                         return colors[3]; // red
                         break;case 'spectrum':
                         return colors[2]; // green
                         break;case 'trace':
                         return colors[1]; // orange
                         break;case 'bar-chart':
                         return colors;break;}
          }; // http://stackoverflow.com/questions/1484506/random-color-generator-in-javascript
          var getRandomColor = exports.getRandomColor = function getRandomColor() {
               var letters = '0123456789ABCDEF'.split('');var color = '#';for (var i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
               }return color;
          }; // scale from domain [0, 1] to range [270, 0] to consume in
          // hsl(x, 100%, 50%) color scheme
          var getHue = exports.getHue = function getHue(x) {
               var domainMin = 0;var domainMax = 1;var rangeMin = 270;var rangeMax = 0;return (rangeMax - rangeMin) * (x - domainMin) / (domainMax - domainMin) + rangeMin;
          };var hexToRGB = exports.hexToRGB = function hexToRGB(hex) {
               hex = hex.substring(1, 7);var r = parseInt(hex.substring(0, 2), 16);var g = parseInt(hex.substring(2, 4), 16);var b = parseInt(hex.substring(4, 6), 16);return [r, g, b];
          };
     }, {}], 152: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var sin = Math.sin;var cos = Math.cos;var sqrt = Math.sqrt;var pow = Math.pow;var _2PI = Math.PI * 2; // plot (from http://www.earlevel.com/scripts/widgets/20131013/biquads2.js)
          // var len = 512;
          // var magPlot = [];
          // for (var idx = 0; idx < len; idx++) {
          //   var w;
          //   if (plotType == "linear")
          //     w = idx / (len - 1) * Math.PI;  // 0 to pi, linear scale
          //   else
          //     w = Math.exp(Math.log(1 / 0.001) * idx / (len - 1)) * 0.001 * Math.PI;  // 0.001 to 1, times pi, log scale
          //   var phi = Math.pow(Math.sin(w/2), 2);
          //   var y = Math.log(Math.pow(a0+a1+a2, 2) - 4*(a0*a1 + 4*a0*a2 + a1*a2)*phi + 16*a0*a2*phi*phi) - Math.log(Math.pow(1+b1+b2, 2) - 4*(b1 + 4*b2 + b1*b2)*phi + 16*b2*phi*phi);
          //   y = y * 10 / Math.LN10
          //   if (y == -Infinity)
          //     y = -200;
          //   if (plotType == "linear")
          //     magPlot.push([idx / (len - 1) * Fs / 2, y]);
          //   else
          //     magPlot.push([idx / (len - 1) / 2, y]);
          //   if (idx == 0)
          //     minVal = maxVal = y;
          //   else if (y < minVal)
          //     minVal = y;
          //   else if (y > maxVal)
          //     maxVal = y;
          // }
          var definitions = { type: { type: 'enum', default: 'lowpass', list: ['lowpass', 'highpass', 'bandpass_constant_skirt', 'bandpass', 'bandpass_constant_peak', 'notch', 'allpass', 'peaking', 'lowshelf', 'highshelf'], metas: { kind: 'dyanmic' } }, f0: { type: 'float', default: 1, metas: { kind: 'dyanmic' } }, gain: { type: 'float', default: 1, min: 0, metas: { kind: 'dyanmic' } }, q: { type: 'float', default: 1, min: 0.001, // PIPO_BIQUAD_MIN_Q
                    // max: 1,
                    metas: { kind: 'dyanmic' // bandwidth: {
                         //   type: 'float',
                         //   default: null,
                         //   nullable: true,
                         //   metas: { kind: 'dyanmic' },
                         // },
                         /**
                            * Biquad filter (Direct form I). If input is of type `vector` the filter is
                            * applied on each dimension i parallel.
                            *
                            * Based on the ["Cookbook formulae for audio EQ biquad filter coefficients"](http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt)
                            * by Robert Bristow-Johnson.
                            *
                            * @memberof module:common.operator
                            *
                            * @param {Object} options - Override default values.
                            * @param {String} [options.type='lowpass'] - Type of the filter. Available
                            *  filters: 'lowpass', 'highpass', 'bandpass_constant_skirt', 'bandpass_constant_peak'
                            *  (alias 'bandpass'), 'notch', 'allpass', 'peaking', 'lowshelf', 'highshelf'.
                            * @param {Number} [options.f0=1] - Cutoff or center frequency of the filter
                            *  according to its type.
                            * @param {Number} [options.gain=1] - Gain of the filter (in dB).
                            * @param {Number} [options.q=1] - Quality factor of the filter.
                            *
                            * @example
                            * import * as lfo from 'waves-lfo/client';
                            *
                            * const audioInBuffer = new lfo.source.AudioInBuffer({
                            *   audioBuffer: buffer,
                            * });
                            *
                            * const biquad = new lfo.operator.Biquad({
                            *   type: 'lowpass',
                            *   f0: 2000,
                            *   gain: 3,
                            *   q: 12,
                            * });
                            *
                            * const spectrumDisplay = new lfo.sink.SpectrumDisplay({
                            *   canvas: '#spectrum',
                            * });
                            *
                            * audioInBuffer.connect(biquad);
                            * biquad.connect(spectrumDisplay);
                            *
                            * audioInBuffer.start();
                            */ } } };var Biquad = function (_BaseLfo) {
               (0, _inherits3.default)(Biquad, _BaseLfo);function Biquad() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Biquad);return (0, _possibleConstructorReturn3.default)(this, (Biquad.__proto__ || (0, _getPrototypeOf2.default)(Biquad)).call(this, definitions, options));
               }(0, _createClass3.default)(Biquad, [{ key: 'onParamUpdate', value: function onParamUpdate(name, value, metas) {
                         this._calculateCoefs();
                    } }, { key: '_calculateCoefs', value: function _calculateCoefs() {
                         var sampleRate = this.streamParams.sourceSampleRate;var frameType = this.streamParams.frameType;var frameSize = this.streamParams.frameSize;var type = this.params.get('type');var f0 = this.params.get('f0');var gain = this.params.get('gain');var q = this.params.get('q'); // const bandwidth = this.params.get('bandwidth');
                         var bandwidth = null;var b0 = 0,
                             b1 = 0,
                             b2 = 0,
                             a0 = 0,
                             a1 = 0,
                             a2 = 0;var A = pow(10, gain / 40);var w0 = _2PI * f0 / sampleRate;var cosW0 = cos(w0);var sinW0 = sin(w0);var alpha = void 0; // depend of the filter type
                         var _2RootAAlpha = void 0; // intermediate value for lowshelf and highshelf
                         switch (type) {// H(s) = 1 / (s^2 + s/Q + 1)
                              case 'lowpass':
                                   alpha = sinW0 / (2 * q);b0 = (1 - cosW0) / 2;b1 = 1 - cosW0;b2 = b0;a0 = 1 + alpha;a1 = -2 * cosW0;a2 = 1 - alpha;break; // H(s) = s^2 / (s^2 + s/Q + 1)
                              case 'highpass':
                                   alpha = sinW0 / (2 * q);b0 = (1 + cosW0) / 2;b1 = -(1 + cosW0);b2 = b0;a0 = 1 + alpha;a1 = -2 * cosW0;a2 = 1 - alpha;break; // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
                              case 'bandpass_constant_skirt':
                                   if (bandwidth) {// sin(w0)*sinh( ln(2)/2 * BW * w0/sin(w0) )           (case: BW)
                                   } else {
                                        alpha = sinW0 / (2 * q);
                                   }b0 = sinW0 / 2;b1 = 0;b2 = -b0;a0 = 1 + alpha;a1 = -2 * cosW0;a2 = 1 - alpha;break; // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
                              case 'bandpass': // looks like what is gnerally considered as a bandpass
                              case 'bandpass_constant_peak':
                                   if (bandwidth) {// sin(w0)*sinh( ln(2)/2 * BW * w0/sin(w0) )           (case: BW)
                                   } else {
                                        alpha = sinW0 / (2 * q);
                                   }b0 = alpha;b1 = 0;b2 = -alpha;a0 = 1 + alpha;a1 = -2 * cosW0;a2 = 1 - alpha;break; // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
                              case 'notch':
                                   alpha = sinW0 / (2 * q);b0 = 1;b1 = -2 * cosW0;b2 = 1;a0 = 1 + alpha;a1 = b1;a2 = 1 - alpha;break; // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
                              case 'allpass':
                                   alpha = sinW0 / (2 * q);b0 = 1 - alpha;b1 = -2 * cosW0;b2 = 1 + alpha;a0 = b2;a1 = b1;a2 = b0;break; // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
                              case 'peaking':
                                   if (bandwidth) {// sin(w0)*sinh( ln(2)/2 * BW * w0/sin(w0) )           (case: BW)
                                   } else {
                                        alpha = sinW0 / (2 * q);
                                   }b0 = 1 + alpha * A;b1 = -2 * cosW0;b2 = 1 - alpha * A;a0 = 1 + alpha / A;a1 = b1;a2 = 1 - alpha / A;break; // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
                              case 'lowshelf':
                                   alpha = sinW0 / (2 * q);_2RootAAlpha = 2 * sqrt(A) * alpha;b0 = A * (A + 1 - (A - 1) * cosW0 + _2RootAAlpha);b1 = 2 * A * (A - 1 - (A + 1) * cosW0);b2 = A * (A + 1 - (A - 1) * cosW0 - _2RootAAlpha);a0 = A + 1 + (A - 1) * cosW0 + _2RootAAlpha;a1 = -2 * (A - 1 + (A + 1) * cosW0);a2 = A + 1 + (A - 1) * cosW0 - _2RootAAlpha;break; // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)
                              case 'highshelf':
                                   alpha = sinW0 / (2 * q);_2RootAAlpha = 2 * sqrt(A) * alpha;b0 = A * (A + 1 + (A - 1) * cosW0 + _2RootAAlpha);b1 = -2 * A * (A - 1 + (A + 1) * cosW0);b2 = A * (A + 1 + (A - 1) * cosW0 - _2RootAAlpha);a0 = A + 1 - (A - 1) * cosW0 + _2RootAAlpha;a1 = 2 * (A - 1 - (A + 1) * cosW0);a2 = A + 1 - (A - 1) * cosW0 - _2RootAAlpha;break;}this.coefs = { b0: b0 / a0, b1: b1 / a0, b2: b2 / a0, a1: a1 / a0, a2: a2 / a0 }; // reset state
                         if (frameType === 'signal') {
                              this.state = { x1: 0, x2: 0, y1: 0, y2: 0 };
                         } else {
                              this.state = { x1: new Float32Array(frameSize), x2: new Float32Array(frameSize), y1: new Float32Array(frameSize), y2: new Float32Array(frameSize) };
                         }
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams); // if no `sampleRate` or `sampleRate` is 0 we shall halt!
                         var sampleRate = this.streamParams.sourceSampleRate;if (!sampleRate || sampleRate <= 0) throw new Error('Invalid sampleRate value (0) for biquad');this._calculateCoefs();this.propagateStreamParams();
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         var frameSize = this.streamParams.frameSize;var outData = this.frame.data;var inData = frame.data;var state = this.state;var coefs = this.coefs;for (var i = 0; i < frameSize; i++) {
                              var x = inData[i];var y = coefs.b0 * x + coefs.b1 * state.x1[i] + coefs.b2 * state.x2[i] - coefs.a1 * state.y1[i] - coefs.a2 * state.y2[i];outData[i] = y; // update states
                              state.x2[i] = state.x1[i];state.x1[i] = x;state.y2[i] = state.y1[i];state.y1[i] = y;
                         }
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         var frameSize = this.streamParams.frameSize;var outData = this.frame.data;var inData = frame.data;var state = this.state;var coefs = this.coefs;for (var i = 0; i < frameSize; i++) {
                              var x = inData[i];var y = coefs.b0 * x + coefs.b1 * state.x1 + coefs.b2 * state.x2 - coefs.a1 * state.y1 - coefs.a2 * state.y2;outData[i] = y; // update states
                              state.x2 = state.x1;state.x1 = x;state.y2 = state.y1;state.y1 = y;
                         }
                    } }]);return Biquad;
          }(_BaseLfo3.default);exports.default = Biquad;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 153: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { min: { type: 'float', default: 0, min: -Infinity, max: +Infinity }, max: { type: 'float', default: 1, min: -Infinity, max: +Infinity } }; /**
                                                                                                                                                                         * Clip incomming according to given `min` and `max` parameters
                                                                                                                                                                         *
                                                                                                                                                                         * @param {Object} options - Override default paramters
                                                                                                                                                                         * @param {Number} [options.min=0] - Minimum value
                                                                                                                                                                         * @param {Number} [options.max=1] - Maximum value
                                                                                                                                                                         */var Clip = function (_BaseLfo) {
               (0, _inherits3.default)(Clip, _BaseLfo);function Clip(options) {
                    (0, _classCallCheck3.default)(this, Clip);return (0, _possibleConstructorReturn3.default)(this, (Clip.__proto__ || (0, _getPrototypeOf2.default)(Clip)).call(this, definitions, options));
               }(0, _createClass3.default)(Clip, [{ key: 'inputVector', value: function inputVector(data) {
                         var min = this.params.get('min');var max = this.params.get('max');var frameSize = this.streamParams.frameSize;var outData = this.frame.data; // @todo - could handle vector as min and max
                         for (var i = 0; i < frameSize; i++) {
                              outData[i] = Math.min(max, Math.max(min, data[i]));
                         }return outData;
                    } }, { key: 'processVector', value: function processVector(frame) {
                         this.frame.data = this.inputVector(frame.data);
                    } }, { key: 'inputSignal', value: function inputSignal(data) {
                         var min = this.params.get('min');var max = this.params.get('max');var frameSize = this.streamParams.frameSize;var outData = this.frame.data;for (var i = 0; i < frameSize; i++) {
                              outData[i] = Math.min(max, Math.max(min, data[i]));
                         }return outData;
                    } }, { key: 'processSignal', value: function processSignal(frame) {
                         this.frame.data = this.inputSignal(frame.data);
                    } }]);return Clip;
          }(_BaseLfo3.default);exports.default = Clip;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 154: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var sqrt = Math.sqrt;var cos = Math.cos;var PI = Math.PI; // Dct Type 2 - orthogonal matrix scaling
          function getDctWeights(order, N) {
               var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'htk';var weights = new Float32Array(N * order);var piOverN = PI / N;var scale0 = 1 / sqrt(2);var scale = sqrt(2 / N);for (var k = 0; k < order; k++) {
                    var s = k === 0 ? scale0 * scale : scale; // const s = scale; // rta doesn't apply k=0 scaling
                    for (var n = 0; n < N; n++) {
                         weights[k * N + n] = s * cos(k * (n + 0.5) * piOverN);
                    }
               }return weights;
          }var definitions = { order: { type: 'integer', default: 12, metas: { kind: 'static' } } }; /**
                                                                                                     * Compute the Discrete Cosine Transform of an input `signal` or `vector`.
                                                                                                     * (HTK style weighting).
                                                                                                     *
                                                                                                     * _support `standalone` usage_
                                                                                                     *
                                                                                                     * @memberof module:common.operator
                                                                                                     *
                                                                                                     * @param {Object} options - Override default parameters.
                                                                                                     * @param {Number} [options.order=12] - Number of computed bins.
                                                                                                     *
                                                                                                     * @example
                                                                                                     * import * as lfo from 'waves-lfo/client';
                                                                                                     *
                                                                                                     * // assuming some audio buffer
                                                                                                     * const source = new AudioInBuffer({
                                                                                                     *   audioBuffer: audioBuffer,
                                                                                                     *   useWorker: false,
                                                                                                     * });
                                                                                                     *
                                                                                                     * const slicer = new Slicer({
                                                                                                     *   frameSize: 512,
                                                                                                     *   hopSize: 512,
                                                                                                     * });
                                                                                                     *
                                                                                                     * const dct = new Dct({
                                                                                                     *   order: 12,
                                                                                                     * });
                                                                                                     *
                                                                                                     * const logger = new lfo.sink.Logger({ data: true });
                                                                                                     *
                                                                                                     * source.connect(slicer);
                                                                                                     * slicer.connect(dct);
                                                                                                     * dct.connect(logger);
                                                                                                     *
                                                                                                     * source.start();
                                                                                                     */var Dct = function (_BaseLfo) {
               (0, _inherits3.default)(Dct, _BaseLfo);function Dct() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Dct);return (0, _possibleConstructorReturn3.default)(this, (Dct.__proto__ || (0, _getPrototypeOf2.default)(Dct)).call(this, definitions, options));
               } /** @private */(0, _createClass3.default)(Dct, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);var order = this.params.get('order');var inFrameSize = prevStreamParams.frameSize;this.streamParams.frameSize = order;this.streamParams.frameType = 'vector';this.streamParams.description = [];this.weightMatrix = getDctWeights(order, inFrameSize);this.propagateStreamParams();
                    } /**
                      * Use the `Dct` operator in `standalone` mode (i.e. outside of a graph).
                      *
                      * @param {Array} values - Input values.
                      * @return {Array} - Dct of the input array.
                      *
                      * @example
                      * const dct = new lfo.operator.Dct({ order: 12 });
                      * // mandatory for use in standalone mode
                      * dct.initStream({ frameSize: 512, frameType: 'signal' });
                      * dct.inputSignal(data);
                      */ }, { key: 'inputSignal', value: function inputSignal(values) {
                         var order = this.params.get('order');var frameSize = values.length;var outFrame = this.frame.data;var weights = this.weightMatrix;for (var k = 0; k < order; k++) {
                              var offset = k * frameSize;outFrame[k] = 0;for (var n = 0; n < frameSize; n++) {
                                   outFrame[k] += values[n] * weights[offset + n];
                              }
                         }return outFrame;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.inputSignal(frame.data);
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.inputSignal(frame.data);
                    } }]);return Dct;
          }(_BaseLfo3.default);exports.default = Dct;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 155: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }function simpleLinearRegression(values, dt) {
               // means
               var xSum = 0;var ySum = 0;var length = values.length;for (var i = 0; i < length; i++) {
                    xSum += i * dt;ySum += values[i];
               }var xMean = xSum / length;var yMean = ySum / length;var sumDiffXMeanSquared = 0; // sum[ pow((x - xMean), 2) ]
               var sumDiffYMeanSquared = 0; // sum[ pow((y - yMean), 2) ]
               var sumDiffXYMean = 0; // sum[ (x - xMean)(y - yMean) ]
               for (var _i = 0; _i < length; _i++) {
                    var diffXMean = dt * _i - xMean;var diffYMean = values[_i] - yMean;var diffXMeanSquared = diffXMean * diffXMean;var diffYMeanSquared = diffYMean * diffYMean;var diffXYMean = diffXMean * diffYMean;sumDiffXMeanSquared += diffXMeanSquared;sumDiffYMeanSquared += diffYMeanSquared;sumDiffXYMean += diffXYMean;
               } // horizontal line, all y on same line
               if (sumDiffYMeanSquared === 0) return 0; // Pearson correlation coefficient:
               // cf. https://www.youtube.com/watch?v=2SCg8Kuh0tE
               //
               //                  [ (x - xMean)(y - yMean) ]
               // r = ------------------------------------------------------
               //     sqrt( [ pow((x - xMean), 2), pow((y - yMean), 2) ] )
               //
               //
               var r = sumDiffXYMean / Math.sqrt(sumDiffXMeanSquared * sumDiffYMeanSquared); // then we have:
               // cf. https://www.youtube.com/watch?v=GhrxgbQnEEU
               //
               // y = a + bx
               // where:
               //         Sy
               // b = r * --
               //         Sx
               //
               // a = yMean - b * xMean
               //
               // S for standard deviation
               //             [ pow((x - xMean), 2) ]
               // Sx = sqrt( -------------------------  )
               //                      N - 1
               var Sx = Math.sqrt(sumDiffXMeanSquared / (length - 1));var Sy = Math.sqrt(sumDiffYMeanSquared / (length - 1));var b = r * (Sy / Sx);return b;
          }var definitions = { size: { type: 'integer', min: 2, max: +Infinity, default: 3 }, useFrameRate: { type: 'integer', min: 0, max: +Infinity, default: null, nullable: true } }; /**
                                                                                                                                                                                          * Returns the simple derivative of successive value using
                                                                                                                                                                                          * simple linear regression.
                                                                                                                                                                                          * The current implementation assumes a fixed `frameRate` (`frame.time` is ignored)
                                                                                                                                                                                          *
                                                                                                                                                                                          * Before the module is filled, it outputs a value of 0.
                                                                                                                                                                                          *
                                                                                                                                                                                          * @param {Object} options - Override default parameters
                                                                                                                                                                                          * @param {Number} [options.size=3] - Size of the window
                                                                                                                                                                                          * @param {Number} [options.useFrameRate=null] - Override stream frame rate for
                                                                                                                                                                                          *  the regression
                                                                                                                                                                                          */var Delta = function (_BaseLfo) {
               (0, _inherits3.default)(Delta, _BaseLfo);function Delta() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Delta);var _this = (0, _possibleConstructorReturn3.default)(this, (Delta.__proto__ || (0, _getPrototypeOf2.default)(Delta)).call(this, definitions, options));_this.buffers = null;_this.ringIndex = 0;_this.frameRate = null;return _this;
               } /** @private */(0, _createClass3.default)(Delta, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);var frameSize = this.streamParams.frameSize;var size = this.params.get('size');var bufferSize = frameSize * size;this.buffers = []; // counter before the operator starts outputing frames
                         this.ringIndex = 0;this.frameRate = this.params.get('useFrameRate') === null ? this.streamParams.frameRate : this.params.get('useFrameRate');for (var i = 0; i < frameSize; i++) {
                              this.buffers[i] = new Float32Array(size);
                         }this.propagateStreamParams();
                    } /** @private */ }, { key: 'resetStream', value: function resetStream() {
                         (0, _get3.default)(Delta.prototype.__proto__ || (0, _getPrototypeOf2.default)(Delta.prototype), 'resetStream', this).call(this);var frameSize = this.streamParams.frameSize;var size = this.params.get('size');var buffers = this.buffers;for (var i = 0; i < frameSize; i++) {
                              for (var j = 0; j < size; j++) {
                                   buffers[i][j] = 0;
                              }
                         }this.ringIndex = 0;
                    } /**
                      * Assume a stream of vector at a fixed `frameRate`.
                      */ }, { key: 'inputVector', value: function inputVector(data) {
                         var size = this.params.get('size');var outData = this.frame.data;var frameSize = this.streamParams.frameSize; // const frameRate = this.streamParams.frameRate;
                         var buffers = this.buffers;var dt = 1 / this.frameRate; // console.log(dt);
                         if (this.ringIndex < size) this.ringIndex += 1; // copy incomming data into buffer
                         for (var i = 0; i < frameSize; i++) {
                              var buffer = buffers[i]; // we need to keep the order of the incomming frames
                              // so we have to shift all the values in the buffers
                              for (var j = 1; j < size; j++) {
                                   buffer[j - 1] = buffer[j];
                              }buffer[size - 1] = data[i];if (this.ringIndex >= size) outData[i] = simpleLinearRegression(buffer, dt);else outData[i] = 0;
                         }return outData;
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.frame.data = this.inputVector(frame.data); // center time according to delta size
                         var size = this.params.get('size');var frameRate = this.streamParams.frameRate;this.frame.time -= 0.5 * (size - 1) / frameRate;
                    } }]);return Delta;
          }(_BaseLfo3.default);exports.default = Delta;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 156: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);var _windows = require('../utils/windows');var _windows2 = _interopRequireDefault(_windows);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          } // https://code.soundsoftware.ac.uk/projects/js-dsp-test/repository/entry/fft/nayuki-obj/fft.js
          /*
           * Free Fft and convolution (JavaScript)
           *
           * Copyright (c) 2014 Project Nayuki
           * http://www.nayuki.io/page/free-small-fft-in-multiple-languages
           *
           * (MIT License)
           * Permission is hereby granted, free of charge, to any person obtaining a copy of
           * this software and associated documentation files (the "Software"), to deal in
           * the Software without restriction, including without limitation the rights to
           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
           * the Software, and to permit persons to whom the Software is furnished to do so,
           * subject to the following conditions:
           * - The above copyright notice and this permission notice shall be included in
           *   all copies or substantial portions of the Software.
           * - The Software is provided "as is", without warranty of any kind, express or
           *   implied, including but not limited to the warranties of merchantability,
           *   fitness for a particular purpose and noninfringement. In no event shall the
           *   authors or copyright holders be liable for any claim, damages or other
           *   liability, whether in an action of contract, tort or otherwise, arising from,
           *   out of or in connection with the Software or the use or other dealings in the
           *   Software.
           *
           * Slightly restructured by Chris Cannam, cannam@all-day-breakfast.com
           *
           * @private
           */ /*
              * Construct an object for calculating the discrete Fourier transform (DFT) of
              * size n, where n is a power of 2.
              *
              * @private
              */function FftNayuki(n) {
               this.n = n;this.levels = -1;for (var i = 0; i < 32; i++) {
                    if (1 << i == n) {
                         this.levels = i; // Equal to log2(n)
                    }
               }if (this.levels == -1) {
                    throw "Length is not a power of 2";
               }this.cosTable = new Array(n / 2);this.sinTable = new Array(n / 2);for (var i = 0; i < n / 2; i++) {
                    this.cosTable[i] = Math.cos(2 * Math.PI * i / n);this.sinTable[i] = Math.sin(2 * Math.PI * i / n);
               } /*
                 * Computes the discrete Fourier transform (DFT) of the given complex vector,
                 * storing the result back into the vector.
                 * The vector's length must be equal to the size n that was passed to the
                 * object constructor, and this must be a power of 2. Uses the Cooley-Tukey
                 * decimation-in-time radix-2 algorithm.
                 *
                 * @private
                 */this.forward = function (real, imag) {
                    var n = this.n; // Bit-reversed addressing permutation
                    for (var i = 0; i < n; i++) {
                         var j = reverseBits(i, this.levels);if (j > i) {
                              var temp = real[i];real[i] = real[j];real[j] = temp;temp = imag[i];imag[i] = imag[j];imag[j] = temp;
                         }
                    } // Cooley-Tukey decimation-in-time radix-2 Fft
                    for (var size = 2; size <= n; size *= 2) {
                         var halfsize = size / 2;var tablestep = n / size;for (var i = 0; i < n; i += size) {
                              for (var j = i, k = 0; j < i + halfsize; j++, k += tablestep) {
                                   var tpre = real[j + halfsize] * this.cosTable[k] + imag[j + halfsize] * this.sinTable[k];var tpim = -real[j + halfsize] * this.sinTable[k] + imag[j + halfsize] * this.cosTable[k];real[j + halfsize] = real[j] - tpre;imag[j + halfsize] = imag[j] - tpim;real[j] += tpre;imag[j] += tpim;
                              }
                         }
                    } // Returns the integer whose value is the reverse of the lowest 'bits'
                    // bits of the integer 'x'.
                    function reverseBits(x, bits) {
                         var y = 0;for (var i = 0; i < bits; i++) {
                              y = y << 1 | x & 1;x >>>= 1;
                         }return y;
                    }
               }; /*
                  * Computes the inverse discrete Fourier transform (IDFT) of the given complex
                  * vector, storing the result back into the vector.
                  * The vector's length must be equal to the size n that was passed to the
                  * object constructor, and this must be a power of 2. This is a wrapper
                  * function. This transform does not perform scaling, so the inverse is not
                  * a true inverse.
                  *
                  * @private
                  */this.inverse = function (real, imag) {
                    forward(imag, real);
               };
          }var sqrt = Math.sqrt;var isPowerOfTwo = function isPowerOfTwo(number) {
               while (number % 2 === 0 && number > 1) {
                    number = number / 2;
               }return number === 1;
          };var definitions = { size: { type: 'integer', default: 1024, metas: { kind: 'static' } }, window: { type: 'enum', list: ['none', 'hann', 'hanning', 'hamming', 'blackman', 'blackmanharris', 'sine', 'rectangle'], default: 'none', metas: { kind: 'static' } }, mode: { type: 'enum', list: ['magnitude', 'power'], // add complex output
                    default: 'magnitude' }, norm: { type: 'enum', default: 'auto', list: ['auto', 'none', 'linear', 'power'] /**
                                                                                                                             * Compute the Fast Fourier Transform of an incomming `signal`.
                                                                                                                             *
                                                                                                                             * Fft implementation by [Nayuki](https://code.soundsoftware.ac.uk/projects/js-dsp-test/repository/entry/fft/nayuki-obj/fft.js).
                                                                                                                             *
                                                                                                                             * _support `standalone` usage_
                                                                                                                             *
                                                                                                                             * @memberof module:common.operator
                                                                                                                             *
                                                                                                                             * @param {Object} options - Override default parameters.
                                                                                                                             * @param {Number} [options.size=1024] - Size of the fft, should be a power of 2.
                                                                                                                             *  If the frame size of the incomming signal is lower than this value,
                                                                                                                             *  it is zero padded to match the fft size.
                                                                                                                             * @param {String} [options.window='none'] - Name of the window applied on the
                                                                                                                             *  incomming signal. Available windows are: 'none', 'hann', 'hanning',
                                                                                                                             *  'hamming', 'blackman', 'blackmanharris', 'sine', 'rectangle'.
                                                                                                                             * @param {String} [options.mode='magnitude'] - Type of the output (`magnitude`
                                                                                                                             *  or `power`)
                                                                                                                             * @param {String} [options.norm='auto'] - Type of normalization applied on the
                                                                                                                             *  output. Possible values are 'auto', 'none', 'linear', 'power'. When set to
                                                                                                                             *  `auto`, a `linear` normalization is applied on the magnitude spectrum, while
                                                                                                                             *  a `power` normalization is applied on the power spectrum.
                                                                                                                             *
                                                                                                                             * @example
                                                                                                                             * import * as lfo from 'waves-lfo/client';
                                                                                                                             *
                                                                                                                             * // assuming an `audioBuffer` exists
                                                                                                                             * const source = new lfo.source.AudioInBuffer({ audioBuffer });
                                                                                                                             *
                                                                                                                             * const slicer = new lfo.operator.Slicer({
                                                                                                                             *   frameSize: 256,
                                                                                                                             * });
                                                                                                                             *
                                                                                                                             * const fft = new lfo.operator.Fft({
                                                                                                                             *   mode: 'power',
                                                                                                                             *   window: 'hann',
                                                                                                                             *   norm: 'power',
                                                                                                                             *   size: 256,
                                                                                                                             * });
                                                                                                                             *
                                                                                                                             * source.connect(slicer);
                                                                                                                             * slicer.connect(fft);
                                                                                                                             * source.start();
                                                                                                                             *
                                                                                                                             * // > outputs 129 bins containing the values of the power spectrum (including
                                                                                                                             * // > DC and Nyuist frequencies).
                                                                                                                             *
                                                                                                                             * @todo - check if 'rectangle' and 'none' windows are not redondant.
                                                                                                                             * @todo - check default values for all params.
                                                                                                                             */ } };var Fft = function (_BaseLfo) {
               (0, _inherits3.default)(Fft, _BaseLfo);function Fft() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Fft);var _this = (0, _possibleConstructorReturn3.default)(this, (Fft.__proto__ || (0, _getPrototypeOf2.default)(Fft)).call(this, definitions, options));_this.windowSize = null;_this.normalizeCoefs = null;_this.window = null;_this.real = null;_this.imag = null;_this.fft = null;if (!isPowerOfTwo(_this.params.get('size'))) throw new Error('fftSize must be a power of two');return _this;
               } /** @private */(0, _createClass3.default)(Fft, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams); // set the output frame size
                         var inFrameSize = prevStreamParams.frameSize;var fftSize = this.params.get('size');var mode = this.params.get('mode');var norm = this.params.get('norm');var windowName = this.params.get('window'); // window `none` and `rectangle` are aliases
                         if (windowName === 'none') windowName = 'rectangle';this.streamParams.frameSize = fftSize / 2 + 1;this.streamParams.frameType = 'vector';this.streamParams.description = []; // size of the window to apply on the input frame
                         this.windowSize = inFrameSize < fftSize ? inFrameSize : fftSize; // references to populate in the window functions (cf. `initWindow`)
                         this.normalizeCoefs = { linear: 0, power: 0 };this.window = new Float32Array(this.windowSize);(0, _windows2.default)(windowName, // name of the window
                         this.window, // buffer populated with the window signal
                         this.windowSize, // size of the window
                         this.normalizeCoefs // object populated with the normalization coefs
                         );var _normalizeCoefs = this.normalizeCoefs,
                             linear = _normalizeCoefs.linear,
                             power = _normalizeCoefs.power;switch (norm) {case 'none':
                                   this.windowNorm = 1;break;case 'linear':
                                   this.windowNorm = linear;break;case 'power':
                                   this.windowNorm = power;break;case 'auto':
                                   if (mode === 'magnitude') this.windowNorm = linear;else if (mode === 'power') this.windowNorm = power;break;}this.real = new Float32Array(fftSize);this.imag = new Float32Array(fftSize);this.fft = new FftNayuki(fftSize);this.propagateStreamParams();
                    } /**
                      * Use the `Fft` operator in `standalone` mode (i.e. outside of a graph).
                      *
                      * @param {Array} signal - Input values.
                      * @return {Array} - Fft of the input signal.
                      *
                      * @example
                      * const fft = new lfo.operator.Fft({ size: 512, window: 'hann' });
                      * // mandatory for use in standalone mode
                      * fft.initStream({ frameSize: 256, frameType: 'signal' });
                      * fft.inputSignal(signal);
                      */ }, { key: 'inputSignal', value: function inputSignal(signal) {
                         var mode = this.params.get('mode');var windowSize = this.windowSize;var frameSize = this.streamParams.frameSize;var fftSize = this.params.get('size');var outData = this.frame.data; // apply window on the input signal and reset imag buffer
                         for (var i = 0; i < windowSize; i++) {
                              this.real[i] = signal[i] * this.window[i] * this.windowNorm;this.imag[i] = 0;
                         } // if real is bigger than input signal, fill with zeros
                         for (var _i = windowSize; _i < fftSize; _i++) {
                              this.real[_i] = 0;this.imag[_i] = 0;
                         }this.fft.forward(this.real, this.imag);if (mode === 'magnitude') {
                              var norm = 1 / fftSize; // DC index
                              var realDc = this.real[0];var imagDc = this.imag[0];outData[0] = sqrt(realDc * realDc + imagDc * imagDc) * norm; // Nquyst index
                              var realNy = this.real[fftSize / 2];var imagNy = this.imag[fftSize / 2];outData[fftSize / 2] = sqrt(realNy * realNy + imagNy * imagNy) * norm; // power spectrum
                              for (var _i2 = 1, j = fftSize - 1; _i2 < fftSize / 2; _i2++, j--) {
                                   var real = 0.5 * (this.real[_i2] + this.real[j]);var imag = 0.5 * (this.imag[_i2] - this.imag[j]);outData[_i2] = 2 * sqrt(real * real + imag * imag) * norm;
                              }
                         } else if (mode === 'power') {
                              var _norm = 1 / (fftSize * fftSize); // DC index
                              var _realDc = this.real[0];var _imagDc = this.imag[0];outData[0] = (_realDc * _realDc + _imagDc * _imagDc) * _norm; // Nquyst index
                              var _realNy = this.real[fftSize / 2];var _imagNy = this.imag[fftSize / 2];outData[fftSize / 2] = (_realNy * _realNy + _imagNy * _imagNy) * _norm; // power spectrum
                              for (var _i3 = 1, _j = fftSize - 1; _i3 < fftSize / 2; _i3++, _j--) {
                                   var _real = 0.5 * (this.real[_i3] + this.real[_j]);var _imag = 0.5 * (this.imag[_i3] - this.imag[_j]);outData[_i3] = 4 * (_real * _real + _imag * _imag) * _norm;
                              }
                         }return outData;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.inputSignal(frame.data);
                    } }]);return Fft;
          }(_BaseLfo3.default);exports.default = Fft;
     }, { "../../core/BaseLfo": 182, "../utils/windows": 180, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 157: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var sqrt = Math.sqrt;var definitions = { normalize: { type: 'boolean', default: true, metas: { kind: 'dynamic' } }, power: { type: 'boolean', default: false, metas: { kind: 'dynamic' /**
                                                                                                                                                                                                  * Compute the magnitude of a `vector` input.
                                                                                                                                                                                                  *
                                                                                                                                                                                                  * _support `standalone` usage_
                                                                                                                                                                                                  *
                                                                                                                                                                                                  * @param {Object} options - Override default parameters.
                                                                                                                                                                                                  * @param {Boolean} [options.normalize=true] - Normalize output according to
                                                                                                                                                                                                  *  the vector size.
                                                                                                                                                                                                  * @param {Boolean} [options.power=false] - If true, returns the squared
                                                                                                                                                                                                  *  magnitude (power).
                                                                                                                                                                                                  *
                                                                                                                                                                                                  * @memberof module:common.operator
                                                                                                                                                                                                  *
                                                                                                                                                                                                  * @example
                                                                                                                                                                                                  * import * as lfo from 'waves-lfo/common';
                                                                                                                                                                                                  *
                                                                                                                                                                                                  * const eventIn = new lfo.source.EventIn({ frameSize: 2, frameType: 'vector' });
                                                                                                                                                                                                  * const magnitude = new lfo.operator.Magnitude();
                                                                                                                                                                                                  * const logger = new lfo.sink.Logger({ outFrame: true });
                                                                                                                                                                                                  *
                                                                                                                                                                                                  * eventIn.connect(magnitude);
                                                                                                                                                                                                  * magnitude.connect(logger);
                                                                                                                                                                                                  * eventIn.start();
                                                                                                                                                                                                  *
                                                                                                                                                                                                  * eventIn.process(null, [1, 1]);
                                                                                                                                                                                                  * > [1]
                                                                                                                                                                                                  * eventIn.process(null, [2, 2]);
                                                                                                                                                                                                  * > [2.82842712475]
                                                                                                                                                                                                  * eventIn.process(null, [3, 3]);
                                                                                                                                                                                                  * > [4.24264068712]
                                                                                                                                                                                                  */ } } };var Magnitude = function (_BaseLfo) {
               (0, _inherits3.default)(Magnitude, _BaseLfo);function Magnitude() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Magnitude);var _this = (0, _possibleConstructorReturn3.default)(this, (Magnitude.__proto__ || (0, _getPrototypeOf2.default)(Magnitude)).call(this, definitions, options));_this._normalize = _this.params.get('normalize');_this._power = _this.params.get('power');return _this;
               } /** @private */(0, _createClass3.default)(Magnitude, [{ key: 'onParamUpdate', value: function onParamUpdate(name, value, metas) {
                         (0, _get3.default)(Magnitude.prototype.__proto__ || (0, _getPrototypeOf2.default)(Magnitude.prototype), 'onParamUpdate', this).call(this, name, value, metas);switch (name) {case 'normalize':
                                   this._normalize = value;break;case 'power':
                                   this._power = value;break;}
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.streamParams.frameSize = 1;this.streamParams.frameType = 'scalar';this.streamParams.description = ['magnitude'];this.propagateStreamParams();
                    } /**
                      * Use the `Magnitude` operator in `standalone` mode (i.e. outside of a graph).
                      *
                      * @param {Array|Float32Array} values - Values to process.
                      * @return {Number} - Magnitude value.
                      *
                      * @example
                      * import * as lfo from 'waves-lfo/client';
                      *
                      * const magnitude = new lfo.operator.Magnitude({ power: true });
                      * magnitude.initStream({ frameType: 'vector', frameSize: 3 });
                      * magnitude.inputVector([3, 3]);
                      * > 4.24264068712
                      */ }, { key: 'inputVector', value: function inputVector(values) {
                         var length = values.length;var sum = 0;for (var i = 0; i < length; i++) {
                              sum += values[i] * values[i];
                         }var mag = sum;if (this._normalize) mag /= length;if (!this._power) mag = sqrt(mag);return mag;
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.frame.data[0] = this.inputVector(frame.data);
                    } }]);return Magnitude;
          }(_BaseLfo3.default);exports.default = Magnitude;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 158: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var sqrt = Math.sqrt; /**
                                 * Compute mean and standard deviation of a given `signal`.
                                 *
                                 * _support `standalone` usage_
                                 *
                                 * @memberof module:common.operator
                                 *
                                 * @example
                                 * import * as lfo from 'waves-lfo/client';
                                 *
                                 * const audioContext = new AudioContext();
                                 *
                                 * navigator.mediaDevices
                                 *   .getUserMedia({ audio: true })
                                 *   .then(init)
                                 *   .catch((err) => console.error(err.stack));
                                 *
                                 * function init(stream) {
                                 *   const source = audioContext.createMediaStreamSource(stream);
                                 *
                                 *   const audioInNode = new lfo.source.AudioInNode({
                                 *     sourceNode: source,
                                 *     audioContext: audioContext,
                                 *   });
                                 *
                                 *   const meanStddev = new lfo.operator.MeanStddev();
                                 *
                                 *   const traceDisplay = new lfo.sink.TraceDisplay({
                                 *     canvas: '#trace',
                                 *   });
                                 *
                                 *   audioInNode.connect(meanStddev);
                                 *   meanStddev.connect(traceDisplay);
                                 *   audioInNode.start();
                                 * }
                                 */var MeanStddev = function (_BaseLfo) {
               (0, _inherits3.default)(MeanStddev, _BaseLfo);function MeanStddev() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, MeanStddev); // no options available, just throw an error if some param try to be set.
                    return (0, _possibleConstructorReturn3.default)(this, (MeanStddev.__proto__ || (0, _getPrototypeOf2.default)(MeanStddev)).call(this, {}, options));
               } /** @private */(0, _createClass3.default)(MeanStddev, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.streamParams.frameType = 'vector';this.streamParams.frameSize = 2;this.streamParams.description = ['mean', 'stddev'];this.propagateStreamParams();
                    } /**
                      * Use the `MeanStddev` operator in `standalone` mode (i.e. outside of a graph).
                      *
                      * @param {Array|Float32Array} values - Values to process.
                      * @return {Array} - Mean and standart deviation of the input values.
                      *
                      * @example
                      * import * as lfo from 'waves-lfo/client';
                      *
                      * const meanStddev = new lfo.operator.MeanStddev();
                      * meanStddev.initStream({ frameType: 'vector', frameSize: 1024 });
                      * meanStddev.inputVector(someSineSignal);
                      * > [0, 0.7071]
                      */ }, { key: 'inputSignal', value: function inputSignal(values) {
                         var outData = this.frame.data;var length = values.length;var mean = 0;var m2 = 0; // compute mean and variance with Welford algorithm
                         // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
                         for (var i = 0; i < length; i++) {
                              var x = values[i];var delta = x - mean;mean += delta / (i + 1);m2 += delta * (x - mean);
                         }var variance = m2 / (length - 1);var stddev = sqrt(variance);outData[0] = mean;outData[1] = stddev;return outData;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.inputSignal(frame.data);
                    } }]);return MeanStddev;
          }(_BaseLfo3.default);exports.default = MeanStddev;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 159: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _log = require('babel-runtime/core-js/math/log10');var _log2 = _interopRequireDefault(_log);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var min = Math.min;var max = Math.max;var pow = Math.pow;var log10 = _log2.default;function hertzToMelHtk(freqHz) {
               return 2595 * (0, _log2.default)(1 + freqHz / 700);
          }function melToHertzHtk(freqMel) {
               return 700 * (Math.pow(10, freqMel / 2595) - 1);
          } /**
            * Returns a description of the weights to apply on the fft bins for each
            * Mel band filter.
            * @note - adapted from imtr-tools/rta
            *
            * @param {Number} nbrBins - Number of fft bins.
            * @param {Number} nbrFilter - Number of mel filters.
            * @param {Number} sampleRate - Sample Rate of the signal.
            * @param {Number} minFreq - Minimum Frequency to be considerered.
            * @param {Number} maxFreq - Maximum frequency to consider.
            * @return {Array<Object>} - Description of the weights to apply on the bins for
            *  each mel filter. Each description has the following structure:
            *  { startIndex: binIndex, centerFreq: binCenterFrequency, weights: [] }
            *
            * @private
            */function getMelBandWeights(nbrBins, nbrBands, sampleRate, minFreq, maxFreq) {
               var type = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'htk';var hertzToMel = null;var melToHertz = null;var minMel = void 0;var maxMel = void 0;if (type === 'htk') {
                    hertzToMel = hertzToMelHtk;melToHertz = melToHertzHtk;minMel = hertzToMel(minFreq);maxMel = hertzToMel(maxFreq);
               } else {
                    throw new Error('Invalid mel band type: "' + type + '"');
               }var melBandDescriptions = new Array(nbrBands); // center frequencies of Fft bins
               var fftFreqs = new Float32Array(nbrBins); // center frequencies of mel bands - uniformly spaced in mel domain between
               // limits, there are 2 more frequencies than the actual number of filters in
               // order to calculate the slopes
               var filterFreqs = new Float32Array(nbrBands + 2);var fftSize = (nbrBins - 1) * 2; // compute bins center frequencies
               for (var i = 0; i < nbrBins; i++) {
                    fftFreqs[i] = sampleRate * i / fftSize;
               }for (var _i = 0; _i < nbrBands + 2; _i++) {
                    filterFreqs[_i] = melToHertz(minMel + _i / (nbrBands + 1) * (maxMel - minMel));
               } // loop throught filters
               for (var _i2 = 0; _i2 < nbrBands; _i2++) {
                    var minWeightIndexDefined = 0;var description = { startIndex: null, centerFreq: null, weights: [] // define contribution of each bin for the filter at index (i + 1)
                         // do not process the last spectrum component (Nyquist)
                    };for (var j = 0; j < nbrBins - 1; j++) {
                         var posSlopeContrib = (fftFreqs[j] - filterFreqs[_i2]) / (filterFreqs[_i2 + 1] - filterFreqs[_i2]);var negSlopeContrib = (filterFreqs[_i2 + 2] - fftFreqs[j]) / (filterFreqs[_i2 + 2] - filterFreqs[_i2 + 1]); // lowerSlope and upper slope intersect at zero and with each other
                         var contribution = max(0, min(posSlopeContrib, negSlopeContrib));if (contribution > 0) {
                              if (description.startIndex === null) {
                                   description.startIndex = j;description.centerFreq = filterFreqs[_i2 + 1];
                              }description.weights.push(contribution);
                         }
                    } // empty filter
                    if (description.startIndex === null) {
                         description.startIndex = 0;description.centerFreq = 0;
                    } // @todo - do some scaling for Slaney-style mel
                    melBandDescriptions[_i2] = description;
               }return melBandDescriptions;
          }var definitions = { log: { type: 'boolean', default: false, metas: { kind: 'static' } }, nbrBands: { type: 'integer', default: 24, metas: { kind: 'static' } }, minFreq: { type: 'float', default: 0, metas: { kind: 'static' } }, maxFreq: { type: 'float', default: null, nullable: true, metas: { kind: 'static' } }, power: { type: 'integer', default: 1, metas: { kind: 'dynamic' } } }; /**
                                                                                                                                                                                                                                                                                                                                                                                                          * Compute the mel bands spectrum from a given spectrum (`vector` type).
                                                                                                                                                                                                                                                                                                                                                                                                          * _Implement the `htk` mel band style._
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * _support `standalone` usage_
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * @memberof module:common.operator
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                                                                                                          * @param {Boolean} [options.log=false] - Apply a logarithmic scale on the output.
                                                                                                                                                                                                                                                                                                                                                                                                          * @param {Number} [options.nbrBands=24] - Number of filters defining the mel
                                                                                                                                                                                                                                                                                                                                                                                                          *  bands.
                                                                                                                                                                                                                                                                                                                                                                                                          * @param {Number} [options.minFreq=0] - Minimum frequency to consider.
                                                                                                                                                                                                                                                                                                                                                                                                          * @param {Number} [options.maxFreq=null] - Maximum frequency to consider.
                                                                                                                                                                                                                                                                                                                                                                                                          *  If `null`, is set to Nyquist frequency.
                                                                                                                                                                                                                                                                                                                                                                                                          * @param {Number} [options.power=1] - Apply a power scaling on each mel band.
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * @todo - implement Slaney style mel bands
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * @example
                                                                                                                                                                                                                                                                                                                                                                                                          * import lfo from 'waves-lfo/node'
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * // read a file from path (node only source)
                                                                                                                                                                                                                                                                                                                                                                                                          * const audioInFile = new lfo.source.AudioInFile({
                                                                                                                                                                                                                                                                                                                                                                                                          *   filename: 'path/to/file',
                                                                                                                                                                                                                                                                                                                                                                                                          *   frameSize: 512,
                                                                                                                                                                                                                                                                                                                                                                                                          * });
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * const slicer = new lfo.operator.Slicer({
                                                                                                                                                                                                                                                                                                                                                                                                          *   frameSize: 256,
                                                                                                                                                                                                                                                                                                                                                                                                          *   hopSize: 256,
                                                                                                                                                                                                                                                                                                                                                                                                          * });
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * const fft = new lfo.operator.Fft({
                                                                                                                                                                                                                                                                                                                                                                                                          *   size: 1024,
                                                                                                                                                                                                                                                                                                                                                                                                          *   window: 'hann',
                                                                                                                                                                                                                                                                                                                                                                                                          *   mode: 'power',
                                                                                                                                                                                                                                                                                                                                                                                                          *   norm: 'power',
                                                                                                                                                                                                                                                                                                                                                                                                          * });
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * const mel = new lfo.operator.Mel({
                                                                                                                                                                                                                                                                                                                                                                                                          *   log: true,
                                                                                                                                                                                                                                                                                                                                                                                                          *   nbrBands: 24,
                                                                                                                                                                                                                                                                                                                                                                                                          * });
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * const logger = new lfo.sink.Logger({ data: true });
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * audioInFile.connect(slicer);
                                                                                                                                                                                                                                                                                                                                                                                                          * slicer.connect(fft);
                                                                                                                                                                                                                                                                                                                                                                                                          * fft.connect(mel);
                                                                                                                                                                                                                                                                                                                                                                                                          * mel.connect(logger);
                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                          * audioInFile.start();
                                                                                                                                                                                                                                                                                                                                                                                                          */var Mel = function (_BaseLfo) {
               (0, _inherits3.default)(Mel, _BaseLfo);function Mel() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Mel);return (0, _possibleConstructorReturn3.default)(this, (Mel.__proto__ || (0, _getPrototypeOf2.default)(Mel)).call(this, definitions, options));
               } /** @private */(0, _createClass3.default)(Mel, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);var nbrBins = prevStreamParams.frameSize;var nbrBands = this.params.get('nbrBands');var sampleRate = this.streamParams.sourceSampleRate;var minFreq = this.params.get('minFreq');var maxFreq = this.params.get('maxFreq'); //
                         this.streamParams.frameSize = nbrBands;this.streamParams.frameType = 'vector';this.streamParams.description = [];if (maxFreq === null) maxFreq = this.streamParams.sourceSampleRate / 2;this.melBandDescriptions = getMelBandWeights(nbrBins, nbrBands, sampleRate, minFreq, maxFreq);this.propagateStreamParams();
                    } /**
                      * Use the `Mel` operator in `standalone` mode (i.e. outside of a graph).
                      *
                      * @param {Array} spectrum - Fft bins.
                      * @return {Array} - Mel bands.
                      *
                      * @example
                      * const mel = new lfo.operator.Mel({ nbrBands: 24 });
                      * // mandatory for use in standalone mode
                      * mel.initStream({ frameSize: 256, frameType: 'vector', sourceSampleRate: 44100 });
                      * mel.inputVector(fftBins);
                      */ }, { key: 'inputVector', value: function inputVector(bins) {
                         var power = this.params.get('power');var log = this.params.get('log');var melBands = this.frame.data;var nbrBands = this.streamParams.frameSize;var scale = 1;var minLogValue = 1e-48;var minLog = -480;if (log) scale *= nbrBands;for (var i = 0; i < nbrBands; i++) {
                              var _melBandDescriptions$ = this.melBandDescriptions[i],
                                  startIndex = _melBandDescriptions$.startIndex,
                                  weights = _melBandDescriptions$.weights;var value = 0;for (var j = 0; j < weights.length; j++) {
                                   value += weights[j] * bins[startIndex + j];
                              } // apply same logic as in PiPoBands
                              if (scale !== 1) value *= scale;if (log) {
                                   if (value > minLogValue) value = 10 * log10(value);else value = minLog;
                              }if (power !== 1) value = pow(value, power);melBands[i] = value;
                         }return melBands;
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.inputVector(frame.data);
                    } }]);return Mel;
          }(_BaseLfo3.default);exports.default = Mel;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/math/log10": 4, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 160: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { // array defining the frameSizes of the input streamss
               // e.g. if [3, 2, 1], we wait for 3 different sources of respective 3, 2, 1 frameSizes
               frameSizes: { type: 'any', default: null, constant: true /**
                                                                        * Merge multiple vector frames. The order of execution depends on the
                                                                        * order the branching was initially made. The first branche is master
                                                                        * on the time and trigger the output of the frame.
                                                                        *
                                                                        * @memberof module:common.operator
                                                                        *
                                                                        * @param {Object} options - Override default parameters
                                                                        * @param {Array} [options.frameSizes=null] - Array that defines the number
                                                                        *  of values to pick from each incomming vectors.
                                                                        *
                                                                        * @example
                                                                        * import * as lfo from 'waves-lfo/comon'
                                                                        *
                                                                        * const eventIn = new lfo.operator.EventIn({
                                                                        *   type: 'vector',
                                                                        *   frameSize: 4,
                                                                        *   frameRate: 0,
                                                                        * });
                                                                        *
                                                                        * const minMax = new lfo.operator.MinMax();
                                                                        * const magnitude = new lfo.operator.Magnitude();
                                                                        *
                                                                        * // take the first 2 values of the first branch and 1 value from the second branch
                                                                        * const merge = new lfo.operator.Merger({ frameSizes: [2, 1] });
                                                                        *
                                                                        * // this defines the order in which Merger will be called
                                                                        * eventIn.connect(minMax);
                                                                        * eventIn.connect(magnitude);
                                                                        *
                                                                        * minMax.connect(merger);
                                                                        * magnitude.connect(merger);
                                                                        */ } };var Merger = function (_BaseLfo) {
               (0, _inherits3.default)(Merger, _BaseLfo);function Merger(options) {
                    (0, _classCallCheck3.default)(this, Merger);return (0, _possibleConstructorReturn3.default)(this, (Merger.__proto__ || (0, _getPrototypeOf2.default)(Merger)).call(this, definitions, options));
               }(0, _createClass3.default)(Merger, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams); // ...
                         var frameSizes = this.params.get('frameSizes');var numSources = frameSizes.length;var frameSize = 0;for (var i = 0; i < numSources; i++) {
                              frameSize += frameSizes[i];
                         }this.streamParams.frameSize = frameSize;this.numSources = numSources;this.sourceIndex = 0;this.propagateStreamParams();
                    } }, { key: 'processVector', value: function processVector() {} // processSignal() {} // makes no sens to merge signals (maybe MUX / DEMUX)
               }, { key: 'processFrame', value: function processFrame(frame) {
                         var currentIndex = this.sourceIndex;var frameSizes = this.params.get('frameSizes');var numSources = frameSizes.length;var input = frame.data;var output = this.frame.data; // first source define time
                         if (currentIndex === 0) this.frame.time = frame.time;var currentFrameSize = frameSizes[currentIndex];var offset = 0;for (var i = 0; i < currentIndex; i++) {
                              offset += frameSizes[i];
                         } // copy data
                         for (var _i = 0; _i < currentFrameSize; _i++) {
                              output[offset + _i] = input[_i];
                         }this.sourceIndex = (this.sourceIndex + 1) % numSources; // we just received the last input, output the frame
                         if (this.sourceIndex === 0) this.propagateFrame();
                    } }]);return Merger;
          }(_BaseLfo3.default);exports.default = Merger;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 161: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);var _Fft = require('./Fft');var _Fft2 = _interopRequireDefault(_Fft);var _Mel = require('./Mel');var _Mel2 = _interopRequireDefault(_Mel);var _Dct = require('./Dct');var _Dct2 = _interopRequireDefault(_Dct);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { nbrBands: { type: 'integer', default: 24, meta: { kind: 'static' } }, nbrCoefs: { type: 'integer', default: 12, meta: { kind: 'static' } }, minFreq: { type: 'float', default: 0, meta: { kind: 'static' } }, maxFreq: { type: 'float', default: null, nullable: true, meta: { kind: 'static' } } }; /**
                                                                                                                                                                                                                                                                                                                                    * Compute the Mfcc of the incomming `signal`. Is basically a wrapper around
                                                                                                                                                                                                                                                                                                                                    * [`Fft`]{@link module:common.operator.Fft}, [`Mel`]{@link module:common.operator.Mel}
                                                                                                                                                                                                                                                                                                                                    * and [`Dct`]{@link module:common.operator.Dct}.
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * _support `standalone` usage_
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * @memberof module:common.operator
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                                    * @param {nbrBands} [options.nbrBands=24] - Number of Mel bands.
                                                                                                                                                                                                                                                                                                                                    * @param {nbrCoefs} [options.nbrCoefs=12] - Number of output coefs.
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * @see {@link module:common.operator.Fft}
                                                                                                                                                                                                                                                                                                                                    * @see {@link module:common.operator.Mel}
                                                                                                                                                                                                                                                                                                                                    * @see {@link module:common.operator.Dct}
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * @example
                                                                                                                                                                                                                                                                                                                                    * import lfo from 'waves-lfo/node'
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * const audioInFile = new lfo.source.AudioInFile({
                                                                                                                                                                                                                                                                                                                                    *   filename: 'path/to/file',
                                                                                                                                                                                                                                                                                                                                    *   frameSize: 512,
                                                                                                                                                                                                                                                                                                                                    * });
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * const slicer = new lfo.operator.Slicer({
                                                                                                                                                                                                                                                                                                                                    *   frameSize: 256,
                                                                                                                                                                                                                                                                                                                                    * });
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * const mfcc = new lfo.operator.Mfcc({
                                                                                                                                                                                                                                                                                                                                    *   nbrBands: 24,
                                                                                                                                                                                                                                                                                                                                    *   nbrCoefs: 12,
                                                                                                                                                                                                                                                                                                                                    * });
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * const logger = new lfo.sink.Logger({ data: true });
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * audioInFile.connect(slicer);
                                                                                                                                                                                                                                                                                                                                    * slicer.connect(mfcc);
                                                                                                                                                                                                                                                                                                                                    * mfcc.connect(logger);
                                                                                                                                                                                                                                                                                                                                    *
                                                                                                                                                                                                                                                                                                                                    * audioInFile.start();
                                                                                                                                                                                                                                                                                                                                    */var Mfcc = function (_BaseLfo) {
               (0, _inherits3.default)(Mfcc, _BaseLfo);function Mfcc(options) {
                    (0, _classCallCheck3.default)(this, Mfcc);return (0, _possibleConstructorReturn3.default)(this, (Mfcc.__proto__ || (0, _getPrototypeOf2.default)(Mfcc)).call(this, definitions, options));
               } /** @private */(0, _createClass3.default)(Mfcc, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);var nbrBands = this.params.get('nbrBands');var nbrCoefs = this.params.get('nbrCoefs');var minFreq = this.params.get('minFreq');var maxFreq = this.params.get('maxFreq');var inputFrameSize = prevStreamParams.frameSize;var inputFrameRate = prevStreamParams.frameRate;var inputSampleRate = prevStreamParams.sourceSampleRate;var nbrBins = inputFrameSize / 2 + 1;this.streamParams.frameSize = nbrCoefs;this.streamParams.frameType = 'vector';this.streamParams.description = [];this.fft = new _Fft2.default({ window: 'hann', mode: 'power', norm: 'power', size: inputFrameSize });this.mel = new _Mel2.default({ nbrBands: nbrBands, log: true, power: 1, minFreq: minFreq, maxFreq: maxFreq });this.dct = new _Dct2.default({ order: nbrCoefs }); // init streams
                         this.fft.initStream({ frameType: 'signal', frameSize: inputFrameSize, frameRate: inputFrameRate, sourceSampleRate: inputSampleRate });this.mel.initStream({ frameType: 'vector', frameSize: nbrBins, frameRate: inputFrameRate, sourceSampleRate: inputSampleRate });this.dct.initStream({ frameType: 'vector', frameSize: nbrBands, frameRate: inputFrameRate, sourceSampleRate: inputSampleRate });this.propagateStreamParams();
                    } /**
                      * Use the `Mfcc` operator in `standalone` mode (i.e. outside of a graph).
                      *
                      * @param {Array} data - Signal chunk to analyse.
                      * @return {Array} - Mfcc coefficients.
                      *
                      * @example
                      * const mfcc = new lfo.operator.Mfcc();
                      * // mandatory for use in standalone mode
                      * mfcc.initStream({ frameSize: 256, frameType: 'vector' });
                      * mfcc.inputSignal(signal);
                      */ }, { key: 'inputSignal', value: function inputSignal(data) {
                         var output = this.frame.data;var nbrCoefs = this.params.get('nbrCoefs');var bins = this.fft.inputSignal(data);var melBands = this.mel.inputVector(bins); // console.log(melBands);
                         var coefs = this.dct.inputSignal(melBands);for (var i = 0; i < nbrCoefs; i++) {
                              output[i] = coefs[i];
                         }return output;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.inputSignal(frame.data);
                    } }]);return Mfcc;
          }(_BaseLfo3.default);exports.default = Mfcc;
     }, { "../../core/BaseLfo": 182, "./Dct": 154, "./Fft": 156, "./Mel": 159, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 162: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          } /**
            * Find minimun and maximum values of a given `signal`.
            *
            * _support `standalone` usage_
            *
            * @memberof module:common.operator
            *
            * @example
            * import * as lfo from 'waves-lfo/common';
            *
            * const eventIn = new lfo.source.EventIn({
            *   frameSize: 512,
            *   frameType: 'signal',
            *   sampleRate: 0,
            * });
            *
            * const minMax = new lfo.operator.MinMax();
            *
            * const logger = new lfo.sink.Logger({ data: true });
            *
            * eventIn.connect(minMax);
            * minMax.connect(logger);
            * eventIn.start()
            *
            * // create a frame
            * const signal = new Float32Array(512);
            * for (let i = 0; i < 512; i++)
            *   signal[i] = i + 1;
            *
            * eventIn.process(null, signal);
            * > [1, 512];
            */var MinMax = function (_BaseLfo) {
               (0, _inherits3.default)(MinMax, _BaseLfo);function MinMax() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, MinMax); // throw errors if options are given
                    return (0, _possibleConstructorReturn3.default)(this, (MinMax.__proto__ || (0, _getPrototypeOf2.default)(MinMax)).call(this, {}, options));
               } /** @private */(0, _createClass3.default)(MinMax, [{ key: 'processStreamParams', value: function processStreamParams() {
                         var prevStreamParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};this.prepareStreamParams(prevStreamParams);this.streamParams.frameType = 'vector';this.streamParams.frameSize = 2;this.streamParams.description = ['min', 'max'];this.propagateStreamParams();
                    } /**
                      * Use the `MinMax` operator in `standalone` mode (i.e. outside of a graph).
                      *
                      * @param {Float32Array|Array} data - Input signal.
                      * @return {Array} - Min and max values.
                      *
                      * @example
                      * const minMax = new MinMax();
                      * minMax.initStream({ frameType: 'signal', frameSize: 10 });
                      *
                      * minMax.inputSignal([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
                      * > [0, 5]
                      */ }, { key: 'inputSignal', value: function inputSignal(data) {
                         var outData = this.frame.data;var min = +Infinity;var max = -Infinity;for (var i = 0, l = data.length; i < l; i++) {
                              var value = data[i];if (value < min) min = value;if (value > max) max = value;
                         }outData[0] = min;outData[1] = max;return outData;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.inputSignal(frame.data);
                    } }]);return MinMax;
          }(_BaseLfo3.default);exports.default = MinMax;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 163: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { order: { type: 'integer', min: 1, max: 1e9, default: 10, metas: { kind: 'dynamic' } }, fill: { type: 'float', min: -Infinity, max: +Infinity, default: 0, metas: { kind: 'dynamic' } } }; /**
                                                                                                                                                                                                                         * Compute a moving average operation on the incomming frames (`scalar` or
                                                                                                                                                                                                                         * `vector` type). If the input is of type vector, the moving average is
                                                                                                                                                                                                                         * computed for each dimension in parallel. If the source sample rate is defined
                                                                                                                                                                                                                         * frame time is shifted to the middle of the window defined by the order.
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * _support `standalone` usage_
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * @memberof module:common.operator
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                         * @param {Number} [options.order=10] - Number of successive values on which
                                                                                                                                                                                                                         *  the average is computed.
                                                                                                                                                                                                                         * @param {Number} [options.fill=0] - Value to fill the ring buffer with before
                                                                                                                                                                                                                         *  the first input frame.
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * @todo - Implement `processSignal` ?
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * @example
                                                                                                                                                                                                                         * import * as lfo from 'waves-lfo/common';
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * const eventIn = new lfo.source.EventIn({
                                                                                                                                                                                                                         *   frameSize: 2,
                                                                                                                                                                                                                         *   frameType: 'vector'
                                                                                                                                                                                                                         * });
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * const movingAverage = new lfo.operator.MovingAverage({
                                                                                                                                                                                                                         *   order: 5,
                                                                                                                                                                                                                         *   fill: 0
                                                                                                                                                                                                                         * });
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * const logger = new lfo.sink.Logger({ data: true });
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * eventIn.connect(movingAverage);
                                                                                                                                                                                                                         * movingAverage.connect(logger);
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * eventIn.start();
                                                                                                                                                                                                                         *
                                                                                                                                                                                                                         * eventIn.process(null, [1, 1]);
                                                                                                                                                                                                                         * > [0.2, 0.2]
                                                                                                                                                                                                                         * eventIn.process(null, [1, 1]);
                                                                                                                                                                                                                         * > [0.4, 0.4]
                                                                                                                                                                                                                         * eventIn.process(null, [1, 1]);
                                                                                                                                                                                                                         * > [0.6, 0.6]
                                                                                                                                                                                                                         * eventIn.process(null, [1, 1]);
                                                                                                                                                                                                                         * > [0.8, 0.8]
                                                                                                                                                                                                                         * eventIn.process(null, [1, 1]);
                                                                                                                                                                                                                         * > [1, 1]
                                                                                                                                                                                                                         */var MovingAverage = function (_BaseLfo) {
               (0, _inherits3.default)(MovingAverage, _BaseLfo);function MovingAverage() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, MovingAverage);var _this = (0, _possibleConstructorReturn3.default)(this, (MovingAverage.__proto__ || (0, _getPrototypeOf2.default)(MovingAverage)).call(this, definitions, options));_this.sum = null;_this.ringBuffer = null;_this.ringIndex = 0;return _this;
               } /** @private */(0, _createClass3.default)(MovingAverage, [{ key: 'onParamUpdate', value: function onParamUpdate(name, value, metas) {
                         (0, _get3.default)(MovingAverage.prototype.__proto__ || (0, _getPrototypeOf2.default)(MovingAverage.prototype), 'onParamUpdate', this).call(this, name, value, metas); // @todo - should be done lazily in process
                         switch (name) {case 'order':
                                   this.processStreamParams();this.resetStream();break;case 'fill':
                                   this.resetStream();break;}
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);var frameSize = this.streamParams.frameSize;var order = this.params.get('order');this.ringBuffer = new Float32Array(order * frameSize);if (frameSize > 1) this.sum = new Float32Array(frameSize);else this.sum = 0;this.propagateStreamParams();
                    } /** @private */ }, { key: 'resetStream', value: function resetStream() {
                         (0, _get3.default)(MovingAverage.prototype.__proto__ || (0, _getPrototypeOf2.default)(MovingAverage.prototype), 'resetStream', this).call(this);var order = this.params.get('order');var fill = this.params.get('fill');var ringBuffer = this.ringBuffer;var ringLength = ringBuffer.length;for (var i = 0; i < ringLength; i++) {
                              ringBuffer[i] = fill;
                         }var fillSum = order * fill;var frameSize = this.streamParams.frameSize;if (frameSize > 1) {
                              for (var _i = 0; _i < frameSize; _i++) {
                                   this.sum[_i] = fillSum;
                              }
                         } else {
                              this.sum = fillSum;
                         }this.ringIndex = 0;
                    } /** @private */ }, { key: 'processScalar', value: function processScalar(frame) {
                         this.frame.data[0] = this.inputScalar(frame.data[0]);
                    } /**
                      * Use the `MovingAverage` operator in `standalone` mode (i.e. outside of a
                      * graph) with a `scalar` input.
                      *
                      * @param {Number} value - Value to feed the moving average with.
                      * @return {Number} - Average value.
                      *
                      * @example
                      * import * as lfo from 'waves-lfo/client';
                      *
                      * const movingAverage = new lfo.operator.MovingAverage({ order: 5 });
                      * movingAverage.initStream({ frameSize: 1, frameType: 'scalar' });
                      *
                      * movingAverage.inputScalar(1);
                      * > 0.2
                      * movingAverage.inputScalar(1);
                      * > 0.4
                      * movingAverage.inputScalar(1);
                      * > 0.6
                      */ }, { key: 'inputScalar', value: function inputScalar(value) {
                         var order = this.params.get('order');var ringIndex = this.ringIndex;var ringBuffer = this.ringBuffer;var sum = this.sum;sum -= ringBuffer[ringIndex];sum += value;this.sum = sum;this.ringBuffer[ringIndex] = value;this.ringIndex = (ringIndex + 1) % order;return sum / order;
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.inputVector(frame.data);
                    } /**
                      * Use the `MovingAverage` operator in `standalone` mode (i.e. outside of a
                      * graph) with a `vector` input.
                      *
                      * @param {Array} values - Values to feed the moving average with.
                      * @return {Float32Array} - Average value for each dimension.
                      *
                      * @example
                      * import * as lfo from 'waves-lfo/client';
                      *
                      * const movingAverage = new lfo.operator.MovingAverage({ order: 5 });
                      * movingAverage.initStream({ frameSize: 2, frameType: 'scalar' });
                      *
                      * movingAverage.inputArray([1, 1]);
                      * > [0.2, 0.2]
                      * movingAverage.inputArray([1, 1]);
                      * > [0.4, 0.4]
                      * movingAverage.inputArray([1, 1]);
                      * > [0.6, 0.6]
                      */ }, { key: 'inputVector', value: function inputVector(values) {
                         var order = this.params.get('order');var outFrame = this.frame.data;var frameSize = this.streamParams.frameSize;var ringIndex = this.ringIndex;var ringOffset = ringIndex * frameSize;var ringBuffer = this.ringBuffer;var sum = this.sum;var scale = 1 / order;for (var i = 0; i < frameSize; i++) {
                              var ringBufferIndex = ringOffset + i;var value = values[i];var localSum = sum[i];localSum -= ringBuffer[ringBufferIndex];localSum += value;this.sum[i] = localSum;outFrame[i] = localSum * scale;ringBuffer[ringBufferIndex] = value;
                         }this.ringIndex = (ringIndex + 1) % order;return outFrame;
                    } /** @private */ }, { key: 'processFrame', value: function processFrame(frame) {
                         this.prepareFrame();this.processFunction(frame);var order = this.params.get('order');var time = frame.time; // shift time to take account of the added latency
                         if (this.streamParams.sourceSampleRate) time -= 0.5 * (order - 1) / this.streamParams.sourceSampleRate;this.frame.time = time;this.frame.metadata = frame.metadata;this.propagateFrame();
                    } }]);return MovingAverage;
          }(_BaseLfo3.default);exports.default = MovingAverage;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 164: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { order: { type: 'integer', min: 1, max: 1e9, default: 9, metas: { kind: 'static' } }, fill: { type: 'float', min: -Infinity, max: +Infinity, default: 0, metas: { kind: 'static' } } }; /**
                                                                                                                                                                                                                      * Compute a moving median operation on the incomming frames (`scalar` or
                                                                                                                                                                                                                      * `vector` type). If the input is of type vector, the moving median is
                                                                                                                                                                                                                      * computed for each dimension in parallel. If the source sample rate is defined
                                                                                                                                                                                                                      * frame time is shifted to the middle of the window defined by the order.
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * _support `standalone` usage_
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * @memberof module:common.operator
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                      * @param {Number} [options.order=9] - Number of successive values in which
                                                                                                                                                                                                                      *  the median is searched. This value must be odd. _dynamic parameter_
                                                                                                                                                                                                                      * @param {Number} [options.fill=0] - Value to fill the ring buffer with before
                                                                                                                                                                                                                      *  the first input frame. _dynamic parameter_
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * @todo - Implement `processSignal`
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * @example
                                                                                                                                                                                                                      * import * as lfo from 'waves-lfo/common';
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * const eventIn = new lfo.source.EventIn({
                                                                                                                                                                                                                      *   frameSize: 2,
                                                                                                                                                                                                                      *   frameType: 'vector',
                                                                                                                                                                                                                      * });
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * const movingMedian = new lfo.operator.MovingMedian({
                                                                                                                                                                                                                      *   order: 5,
                                                                                                                                                                                                                      *   fill: 0,
                                                                                                                                                                                                                      * });
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * const logger = new lfo.sink.Logger({ data: true });
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * eventIn.connect(movingMedian);
                                                                                                                                                                                                                      * movingMedian.connect(logger);
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * eventIn.start();
                                                                                                                                                                                                                      *
                                                                                                                                                                                                                      * eventIn.processFrame(null, [1, 1]);
                                                                                                                                                                                                                      * > [0, 0]
                                                                                                                                                                                                                      * eventIn.processFrame(null, [2, 2]);
                                                                                                                                                                                                                      * > [0, 0]
                                                                                                                                                                                                                      * eventIn.processFrame(null, [3, 3]);
                                                                                                                                                                                                                      * > [1, 1]
                                                                                                                                                                                                                      * eventIn.processFrame(null, [4, 4]);
                                                                                                                                                                                                                      * > [2, 2]
                                                                                                                                                                                                                      * eventIn.processFrame(null, [5, 5]);
                                                                                                                                                                                                                      * > [3, 3]
                                                                                                                                                                                                                      */var MovingMedian = function (_BaseLfo) {
               (0, _inherits3.default)(MovingMedian, _BaseLfo);function MovingMedian() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, MovingMedian);var _this = (0, _possibleConstructorReturn3.default)(this, (MovingMedian.__proto__ || (0, _getPrototypeOf2.default)(MovingMedian)).call(this, definitions, options));_this.ringBuffer = null;_this.sortBuffer = null;_this.ringIndex = 0;_this._ensureOddOrder();return _this;
               } /** @private */(0, _createClass3.default)(MovingMedian, [{ key: '_ensureOddOrder', value: function _ensureOddOrder() {
                         if (this.params.get('order') % 2 === 0) throw new Error('Invalid value ' + order + ' for param "order" - must be odd');
                    } /** @private */ }, { key: 'onParamUpdate', value: function onParamUpdate(name, value, metas) {
                         (0, _get3.default)(MovingMedian.prototype.__proto__ || (0, _getPrototypeOf2.default)(MovingMedian.prototype), 'onParamUpdate', this).call(this, name, value, metas);switch (name) {case 'order':
                                   this._ensureOddOrder();this.processStreamParams();this.resetStream();break;case 'fill':
                                   this.resetStream();break;}
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams); // outType is similar to input type
                         var frameSize = this.streamParams.frameSize;var order = this.params.get('order');this.ringBuffer = new Float32Array(frameSize * order);this.sortBuffer = new Float32Array(frameSize * order);this.minIndices = new Uint32Array(frameSize);this.propagateStreamParams();
                    } /** @private */ }, { key: 'resetStream', value: function resetStream() {
                         (0, _get3.default)(MovingMedian.prototype.__proto__ || (0, _getPrototypeOf2.default)(MovingMedian.prototype), 'resetStream', this).call(this);var fill = this.params.get('fill');var ringBuffer = this.ringBuffer;var ringLength = ringBuffer.length;for (var i = 0; i < ringLength; i++) {
                              this.ringBuffer[i] = fill;
                         }this.ringIndex = 0;
                    } /** @private */ }, { key: 'processScalar', value: function processScalar(frame) {
                         this.frame.data[0] = this.inputScalar(frame.data[0]);
                    } /**
                      * Allows for the use of a `MovingMedian` outside a graph (e.g. inside
                      * another node), in this case `processStreamParams` and `resetStream`
                      * should be called manually on the node.
                      *
                      * @param {Number} value - Value to feed the moving median with.
                      * @return {Number} - Median value.
                      *
                      * @example
                      * import * as lfo from 'waves-lfo/client';
                      *
                      * const movingMedian = new MovingMedian({ order: 5 });
                      * movingMedian.initStream({ frameSize: 1, frameType: 'scalar' });
                      *
                      * movingMedian.inputScalar(1);
                      * > 0
                      * movingMedian.inputScalar(2);
                      * > 0
                      * movingMedian.inputScalar(3);
                      * > 1
                      * movingMedian.inputScalar(4);
                      * > 2
                      */ }, { key: 'inputScalar', value: function inputScalar(value) {
                         var ringIndex = this.ringIndex;var ringBuffer = this.ringBuffer;var sortBuffer = this.sortBuffer;var order = this.params.get('order');var medianIndex = (order - 1) / 2;var startIndex = 0;ringBuffer[ringIndex] = value;for (var i = 0; i <= medianIndex; i++) {
                              var min = +Infinity;var minIndex = null;for (var j = startIndex; j < order; j++) {
                                   if (i === 0) sortBuffer[j] = ringBuffer[j];if (sortBuffer[j] < min) {
                                        min = sortBuffer[j];minIndex = j;
                                   }
                              } // swap minIndex and startIndex
                              var cache = sortBuffer[startIndex];sortBuffer[startIndex] = sortBuffer[minIndex];sortBuffer[minIndex] = cache;startIndex += 1;
                         }var median = sortBuffer[medianIndex];this.ringIndex = (ringIndex + 1) % order;return median;
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.inputVector(frame.data);
                    } /**
                      * Allows for the use of a `MovingMedian` outside a graph (e.g. inside
                      * another node), in this case `processStreamParams` and `resetStream`
                      * should be called manually on the node.
                      *
                      * @param {Array} values - Values to feed the moving median with.
                      * @return {Float32Array} - Median values for each dimension.
                      *
                      * @example
                      * import * as lfo from 'waves-lfo/client';
                      *
                      * const movingMedian = new MovingMedian({ order: 3, fill: 0 });
                      * movingMedian.initStream({ frameSize: 3, frameType: 'vector' });
                      *
                      * movingMedian.inputArray([1, 1]);
                      * > [0, 0]
                      * movingMedian.inputArray([2, 2]);
                      * > [1, 1]
                      * movingMedian.inputArray([3, 3]);
                      * > [2, 2]
                      */ }, { key: 'inputVector', value: function inputVector(values) {
                         var order = this.params.get('order');var ringBuffer = this.ringBuffer;var ringIndex = this.ringIndex;var sortBuffer = this.sortBuffer;var outFrame = this.frame.data;var minIndices = this.minIndices;var frameSize = this.streamParams.frameSize;var medianIndex = Math.floor(order / 2);var startIndex = 0;for (var i = 0; i <= medianIndex; i++) {
                              for (var j = 0; j < frameSize; j++) {
                                   outFrame[j] = +Infinity;minIndices[j] = 0;for (var k = startIndex; k < order; k++) {
                                        var index = k * frameSize + j; // update ring buffer corresponding to current
                                        if (k === ringIndex && i === 0) ringBuffer[index] = values[j]; // copy value in sort buffer on first pass
                                        if (i === 0) sortBuffer[index] = ringBuffer[index]; // find minium in the remaining array
                                        if (sortBuffer[index] < outFrame[j]) {
                                             outFrame[j] = sortBuffer[index];minIndices[j] = index;
                                        }
                                   } // swap minimum and curent index
                                   var swapIndex = startIndex * frameSize + j;var v = sortBuffer[swapIndex];sortBuffer[swapIndex] = sortBuffer[minIndices[j]];sortBuffer[minIndices[j]] = v; // store this minimum value as current result
                                   outFrame[j] = sortBuffer[swapIndex];
                              }startIndex += 1;
                         }this.ringIndex = (ringIndex + 1) % order;return this.frame.data;
                    } /** @private */ }, { key: 'processFrame', value: function processFrame(frame) {
                         this.preprocessFrame();this.processFunction(frame);var order = this.params.get('order');var time = frame.time; // shift time to take account of the added latency
                         if (this.streamParams.sourceSampleRate) time -= 0.5 * (order - 1) / this.streamParams.sourceSampleRate;this.frame.time = time;this.frame.metadata = frame.metadata;this.propagateFrame(time, this.outFrame, metadata);
                    } }]);return MovingMedian;
          }(_BaseLfo3.default);exports.default = MovingMedian;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 165: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { // float or array
               factor: { type: 'any', default: 1 } }; /**
                                                      * Multiply a given signal or vector by a given factor. On vector
                                                      * streams, `factor` can be an array of values to apply on each dimension of the
                                                      * vector frames.
                                                      *
                                                      * _support `standalone` usage_
                                                      *
                                                      * @param {Object} options - override default values
                                                      * @param {Number|Array} [options.factor=1] - factor or array of factor to
                                                      *  apply on the incomming frame. Setting an array is only defined in case of
                                                      *  a vector stream.
                                                      *
                                                      * @memberof module:common.operator
                                                      *
                                                      * @example
                                                      * import * as lfo from 'waves-lfo/common';
                                                      *
                                                      * const eventIn = new lfo.operator.EventIn({
                                                      *   type: 'vector',
                                                      *   frameSize: 2,
                                                      *   frameRate: 0,
                                                      * });
                                                      * const scaler = new lfo.operator.Multiplier({ factor: 0.1 });
                                                      *
                                                      * eventIn.connect(scaler);
                                                      *
                                                      * eventIn.process(null, [2, 3]);
                                                      * > [0.2, 0.3]
                                                      */var Multiplier = function (_BaseLfo) {
               (0, _inherits3.default)(Multiplier, _BaseLfo);function Multiplier(options) {
                    (0, _classCallCheck3.default)(this, Multiplier);return (0, _possibleConstructorReturn3.default)(this, (Multiplier.__proto__ || (0, _getPrototypeOf2.default)(Multiplier)).call(this, definitions, options));
               } /**
                 * Use the `Multiplier` operator in standalone mode.
                 *
                 * @param {Float32Array|Array} data - Input vector
                 * @return {Array} - Scaled values
                 *
                 * @example
                 * const scaler = new Multiplier({ factor: [2, 4] });
                 * scaler.initStream({ frameType: 'vector', frameSize: 2 });
                 *
                 * scaler.inputVector([3, 2]);
                 * > [6, 8]
                 */(0, _createClass3.default)(Multiplier, [{ key: 'inputVector', value: function inputVector(data) {
                         var output = this.frame.data;var frameSize = this.streamParams.frameSize;var factor = this.params.get('factor');if (Array.isArray(factor)) {
                              for (var i = 0; i < frameSize; i++) {
                                   output[i] = data[i] * factor[i];
                              }
                         } else {
                              for (var _i = 0; _i < frameSize; _i++) {
                                   output[_i] = data[_i] * factor;
                              }
                         }return output;
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.frame.data = this.inputVector(frame.data);
                    } /**
                      * Use the `Multiplier` operator in standalone mode.
                      *
                      * @param {Float32Array|Array} data - Input signal.
                      * @return {Array} - Scaled signal.
                      *
                      * @example
                      * const scaler = new Multiplier({ factor: 0.1 });
                      * scaler.initStream({ frameType: 'signal', frameSize: 2 });
                      *
                      * scaler.inputVector([1, 2]);
                      * > [0.1, 0.2]
                      */ }, { key: 'inputSignal', value: function inputSignal(data) {
                         var output = this.frame.data;var frameSize = this.streamParams.frameSize;var factor = this.params.get('factor');for (var i = 0; i < frameSize; i++) {
                              output[i] = data[i] * factor;
                         }return output;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.frame.data = this.inputSignal(frame.data);
                    } }]);return Multiplier;
          }(_BaseLfo3.default);exports.default = Multiplier;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 166: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { state: { type: 'enum', default: 'on', list: ['on', 'off'], metas: { kind: 'dynamic' } } }; /**
                                                                                                                          * The OnOff operator allows to stop the propagation of the stream in a
                                                                                                                          * subgraph. When "on", frames are propagated, when "off" the propagation is
                                                                                                                          * stopped.
                                                                                                                          *
                                                                                                                          * The `streamParams` propagation is never bypassed so the subsequent subgraph
                                                                                                                          * is always ready for incomming frames.
                                                                                                                          *
                                                                                                                          * @memberof module:common.operator
                                                                                                                          *
                                                                                                                          * @param {Object} options - Override default parameters.
                                                                                                                          * @param {String} [options.state='on'] - Default state.
                                                                                                                          *
                                                                                                                          * @example
                                                                                                                          * import * as lfo from 'waves-lfo/common';
                                                                                                                          *
                                                                                                                          * const frames = [
                                                                                                                          *   { time: 0, data: [1, 2] },
                                                                                                                          *   { time: 1, data: [3, 4] },
                                                                                                                          *   { time: 2, data: [5, 6] },
                                                                                                                          * ];
                                                                                                                          *
                                                                                                                          * const eventIn = new EventIn({
                                                                                                                          *   frameSize: 2,
                                                                                                                          *   frameRate: 0,
                                                                                                                          *   frameType: 'vector',
                                                                                                                          * });
                                                                                                                          *
                                                                                                                          * const onOff = new OnOff();
                                                                                                                          *
                                                                                                                          * const logger = new Logger({ data: true });
                                                                                                                          *
                                                                                                                          * eventIn.connect(onOff);
                                                                                                                          * onOff.connect(logger);
                                                                                                                          *
                                                                                                                          * eventIn.start();
                                                                                                                          *
                                                                                                                          * eventIn.processFrame(frames[0]);
                                                                                                                          * > [0, 1]
                                                                                                                          *
                                                                                                                          * // bypass subgraph
                                                                                                                          * onOff.setState('off');
                                                                                                                          * eventIn.processFrame(frames[1]);
                                                                                                                          *
                                                                                                                          * // re-open subgraph
                                                                                                                          * onOff.setState('on');
                                                                                                                          * eventIn.processFrame(frames[2]);
                                                                                                                          * > [5, 6]
                                                                                                                          */var OnOff = function (_BaseLfo) {
               (0, _inherits3.default)(OnOff, _BaseLfo);function OnOff() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, OnOff);var _this = (0, _possibleConstructorReturn3.default)(this, (OnOff.__proto__ || (0, _getPrototypeOf2.default)(OnOff)).call(this, definitions, options));_this.state = _this.params.get('state');return _this;
               } /**
                 * Set the state of the `OnOff`.
                 *
                 * @param {String} state - New state of the operator (`on` or `off`)
                 */(0, _createClass3.default)(OnOff, [{ key: 'setState', value: function setState(state) {
                         if (definitions.state.list.indexOf(state) === -1) throw new Error('Invalid switch state value "' + state + '" [valid values: "on"/"off"]');this.state = state;
                    } // define all possible stream API
                    /** @private */ }, { key: 'processScalar', value: function processScalar() {} /** @private */ }, { key: 'processVector', value: function processVector() {} /** @private */ }, { key: 'processSignal', value: function processSignal() {} /** @private */ }, { key: 'processFrame', value: function processFrame(frame) {
                         if (this.state === 'on') {
                              this.prepareFrame();this.frame.time = frame.time;this.frame.metadata = frame.metadata;this.frame.data = frame.data;this.propagateFrame();
                         }
                    } }]);return OnOff;
          }(_BaseLfo3.default);exports.default = OnOff;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 167: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { exponent: { type: 'float', default: 1 } }; /**
                                                                          * Apply an exponant power to the stream.
                                                                          *
                                                                          * @param {Object} options - Override default parameters
                                                                          * @param {Number} exponent - Exponent
                                                                          */var Power = function (_BaseLfo) {
               (0, _inherits3.default)(Power, _BaseLfo);function Power(options) {
                    (0, _classCallCheck3.default)(this, Power);return (0, _possibleConstructorReturn3.default)(this, (Power.__proto__ || (0, _getPrototypeOf2.default)(Power)).call(this, definitions, options));
               }(0, _createClass3.default)(Power, [{ key: 'inputVector', value: function inputVector(data) {
                         var outData = this.frame.data;var frameSize = this.streamParams.frameSize;var exponent = this.params.get('exponent');for (var i = 0; i < frameSize; i++) {
                              outData[i] = Math.pow(data[i], exponent);
                         }return outData;
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.inputVector(frame.data);
                    } }, { key: 'inputSignal', value: function inputSignal(data) {
                         var outData = this.frame.data;var frameSize = this.streamParams.frameSize;var exponent = this.params.get('exponent');for (var i = 0; i < frameSize; i++) {
                              outData[i] = Math.pow(data[i], exponent);
                         }return outData;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.inputSignal(frame.data);
                    } }]);return Power;
          }(_BaseLfo3.default);exports.default = Power;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 168: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var sqrt = Math.sqrt;var definitions = { power: { type: 'boolean', default: false, metas: { kind: 'dynamic' } } }; /**
                                                                                                                              * Compute the Root Mean Square of a `signal`.
                                                                                                                              *
                                                                                                                              * _support `standalone` usage_
                                                                                                                              *
                                                                                                                              * @memberof module:common.operator
                                                                                                                              *
                                                                                                                              * @param {Object} options - Override default parameters.
                                                                                                                              * @param {Boolean} [options.power=false] - If `true` remove the "R" of the
                                                                                                                              *  "Rms" and return the squared result (i.e. power).
                                                                                                                              *
                                                                                                                              * @example
                                                                                                                              * import * as lfo from 'waves-lfo/client';
                                                                                                                              *
                                                                                                                              * // assuming some `AudioBuffer`
                                                                                                                              * const audioInBuffer = new lfo.source.AudioInBuffer({
                                                                                                                              *   audioBuffer: audioBuffer,
                                                                                                                              *   frameSize: 512,
                                                                                                                              * });
                                                                                                                              *
                                                                                                                              * const rms = new lfo.operator.Rms();
                                                                                                                              * const logger = new lfo.sink.Logger({ data: true });
                                                                                                                              *
                                                                                                                              * audioInBuffer.connect(rms);
                                                                                                                              * rms.connect(logger);
                                                                                                                              *
                                                                                                                              * audioInBuffer.start();
                                                                                                                              */var Rms = function (_BaseLfo) {
               (0, _inherits3.default)(Rms, _BaseLfo);function Rms() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Rms);return (0, _possibleConstructorReturn3.default)(this, (Rms.__proto__ || (0, _getPrototypeOf2.default)(Rms)).call(this, definitions, options));
               } /** @private */(0, _createClass3.default)(Rms, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.streamParams.frameSize = 1;this.streamParams.frameType = 'scalar';this.streamParams.description = ['rms'];this.propagateStreamParams();
                    } /**
                      * Allows for the use of a `Rms` outside a graph (e.g. inside
                      * another node). Return the rms of the given signal block.
                      *
                      * @param {Number} signal - Signal block to be computed.
                      * @return {Number} - rms of the input signal.
                      *
                      * @example
                      * import * as lfo from 'waves-lfo/client';
                      *
                      * const rms = new lfo.operator.Rms();
                      * rms.initStream({ frameType: 'signal', frameSize: 1000 });
                      *
                      * const results = rms.inputSignal([...values]);
                      */ }, { key: 'inputSignal', value: function inputSignal(signal) {
                         var power = this.params.get('power');var length = signal.length;var rms = 0;for (var i = 0; i < length; i++) {
                              rms += signal[i] * signal[i];
                         }rms = rms / length;if (!power) rms = sqrt(rms);return rms;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.frame.data[0] = this.inputSignal(frame.data);
                    } }]);return Rms;
          }(_BaseLfo3.default);exports.default = Rms;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 169: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { type: { type: 'enum', list: ['linear'], default: 'linear', metas: { kind: 'dynamic' } }, inputMin: { type: 'float', default: 0, min: -Infinity, max: +Infinity, metas: { kind: 'dynamic' } }, inputMax: { type: 'float', default: 1, min: -Infinity, max: +Infinity, metas: { kind: 'dynamic' } }, outputMin: { type: 'float', default: 1, min: -Infinity, max: +Infinity, metas: { kind: 'dynamic' } }, outputMax: { type: 'float', default: 1, min: -Infinity, max: +Infinity, metas: { kind: 'dynamic' /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Apply a linear scale on the incomming stream. The output is not clipped.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * @todo - implement log and exp scale
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {Object} options - Override default options
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {Number} [options.inputMin=0] - Input Minimum
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {Number} [options.inputMax=1] - Input Maximum
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {Number} [options.outputMin=0] - Output Minimum
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {Number} [options.outputMax=1] - Output Maximum
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */ } } };var Scale = function (_BaseLfo) {
               (0, _inherits3.default)(Scale, _BaseLfo);function Scale(options) {
                    (0, _classCallCheck3.default)(this, Scale);var _this = (0, _possibleConstructorReturn3.default)(this, (Scale.__proto__ || (0, _getPrototypeOf2.default)(Scale)).call(this, definitions, options));_this.scale = null;return _this;
               } /** @private */(0, _createClass3.default)(Scale, [{ key: '_setScaleFunction', value: function _setScaleFunction() {
                         var inputMin = this.params.get('inputMin');var inputMax = this.params.get('inputMax');var outputMin = this.params.get('outputMin');var outputMax = this.params.get('outputMax');var a = (outputMax - outputMin) / (inputMax - inputMin);var b = outputMin - a * inputMin;this.scale = function (x) {
                              return a * x + b;
                         };
                    } /** @private */ }, { key: 'onParamUpdate', value: function onParamUpdate(name, value, metas) {
                         (0, _get3.default)(Scale.prototype.__proto__ || (0, _getPrototypeOf2.default)(Scale.prototype), 'onParamUpdate', this).call(this, name, value, metas);if (name !== 'type') this._setScaleFunction();
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this._setScaleFunction();this.propagateStreamParams();
                    } }, { key: 'inputVector', value: function inputVector(data) {
                         var outData = this.frame.data;var frameSize = this.streamParams.frameSize;var scale = this.scale;for (var i = 0; i < frameSize; i++) {
                              outData[i] = scale(data[i]);
                         }return outData;
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         this.frame.data = this.inputVector(frame.data);
                    } }, { key: 'inputSignal', value: function inputSignal(data) {
                         var outData = this.frame.data;var frameSize = this.streamParams.frameSize;var scale = this.scale;for (var i = 0; i < frameSize; i++) {
                              outData[i] = scale(data[i]);
                         }return outData;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.frame.data = this.inputVector(frame.data);
                    } }]);return Scale;
          }(_BaseLfo3.default);exports.default = Scale;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 170: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);var _MovingAverage = require('./MovingAverage');var _MovingAverage2 = _interopRequireDefault(_MovingAverage);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var min = Math.min;var max = Math.max;var definitions = { logInput: { type: 'boolean', default: false, metas: { kind: 'dyanmic' } }, minInput: { type: 'float', default: 0.000000000001, metas: { kind: 'dyanmic' } }, filterOrder: { type: 'integer', default: 5, metas: { kind: 'dyanmic' } }, threshold: { type: 'float', default: 3, metas: { kind: 'dyanmic' } }, offThreshold: { type: 'float', default: -Infinity, metas: { kind: 'dyanmic' } }, minInter: { type: 'float', default: 0.050, metas: { kind: 'dyanmic' } }, maxDuration: { type: 'float', default: Infinity, metas: { kind: 'dyanmic' /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Create segments based on attacks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @memberof module:common.operator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param {Boolean} [options.logInput=false] - Apply log on the input.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param {Number} [options.minInput=0.000000000001] - Minimum value to use as
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  input.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param {Number} [options.filterOrder=5] - Order of the internally used moving
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  average.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param {Number} [options.threshold=3] - Threshold that triggers a segment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  start.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param {Number} [options.offThreshold=-Infinity] - Threshold that triggers
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  a segment end.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param {Number} [options.minInter=0.050] - Minimum delay between two semgents.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param {Number} [options.maxDuration=Infinity] - Maximum duration of a segment.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @example
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * // assuming a stream from the microphone
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * const source = audioContext.createMediaStreamSource(stream);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * const audioInNode = new lfo.source.AudioInNode({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   sourceNode: source,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   audioContext: audioContext,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * const slicer = new lfo.operator.Slicer({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   frameSize: frameSize,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   hopSize: hopSize,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   centeredTimeTags: true
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * const power = new lfo.operator.RMS({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   power: true,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * const segmenter = new lfo.operator.Segmenter({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   logInput: true,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   filterOrder: 5,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   threshold: 3,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   offThreshold: -Infinity,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   minInter: 0.050,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   maxDuration: 0.050,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * const logger = new lfo.sink.Logger({ time: true });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * audioInNode.connect(slicer);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * slicer.connect(power);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * power.connect(segmenter);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * segmenter.connect(logger);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * audioInNode.start();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */ } } };var Segmenter = function (_BaseLfo) {
               (0, _inherits3.default)(Segmenter, _BaseLfo);function Segmenter(options) {
                    (0, _classCallCheck3.default)(this, Segmenter);var _this = (0, _possibleConstructorReturn3.default)(this, (Segmenter.__proto__ || (0, _getPrototypeOf2.default)(Segmenter)).call(this, definitions, options));_this.insideSegment = false;_this.onsetTime = -Infinity; // stats
                    _this.min = Infinity;_this.max = -Infinity;_this.sum = 0;_this.sumOfSquares = 0;_this.count = 0;var minInput = _this.params.get('minInput');var fill = minInput;if (_this.params.get('logInput') && minInput > 0) fill = Math.log(minInput);_this.movingAverage = new _MovingAverage2.default({ order: _this.params.get('filterOrder'), fill: fill });_this.lastMvavrg = fill;return _this;
               }(0, _createClass3.default)(Segmenter, [{ key: 'onParamUpdate', value: function onParamUpdate(name, value, metas) {
                         (0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'onParamUpdate', this).call(this, name, value, metas);if (name === 'filterOrder') this.movingAverage.params.set('order', value);
                    } }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.streamParams.frameType = 'vector';this.streamParams.frameSize = 5;this.streamParams.frameRate = 0;this.streamParams.description = ['duration', 'min', 'max', 'mean', 'stddev'];this.movingAverage.initStream(prevStreamParams);this.propagateStreamParams();
                    } }, { key: 'resetStream', value: function resetStream() {
                         (0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'resetStream', this).call(this);this.movingAverage.resetStream();this.resetSegment();
                    } }, { key: 'finalizeStream', value: function finalizeStream(endTime) {
                         if (this.insideSegment) this.outputSegment(endTime);(0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'finalizeStream', this).call(this, endTime);
                    } }, { key: 'resetSegment', value: function resetSegment() {
                         this.insideSegment = false;this.onsetTime = -Infinity; // stats
                         this.min = Infinity;this.max = -Infinity;this.sum = 0;this.sumOfSquares = 0;this.count = 0;
                    } }, { key: 'outputSegment', value: function outputSegment(endTime) {
                         var outData = this.frame.data;outData[0] = endTime - this.onsetTime;outData[1] = this.min;outData[2] = this.max;var norm = 1 / this.count;var mean = this.sum * norm;var meanOfSquare = this.sumOfSquares * norm;var squareOfmean = mean * mean;outData[3] = mean;outData[4] = 0;if (meanOfSquare > squareOfmean) outData[4] = Math.sqrt(meanOfSquare - squareOfmean);this.frame.time = this.onsetTime;this.propagateFrame();
                    } }, { key: 'processSignal', value: function processSignal(frame) {
                         var logInput = this.params.get('logInput');var minInput = this.params.get('minInput');var threshold = this.params.get('threshold');var minInter = this.params.get('minInter');var maxDuration = this.params.get('maxDuration');var offThreshold = this.params.get('offThreshold');var rawValue = frame.data[0];var time = frame.time;var value = Math.max(rawValue, minInput);if (logInput) value = Math.log(value);var diff = value - this.lastMvavrg;this.lastMvavrg = this.movingAverage.inputScalar(value); // update frame metadata
                         this.frame.metadata = frame.metadata;if (diff > threshold && time - this.onsetTime > minInter) {
                              if (this.insideSegment) this.outputSegment(time); // start segment
                              this.insideSegment = true;this.onsetTime = time;this.max = -Infinity;
                         }if (this.insideSegment) {
                              this.min = min(this.min, rawValue);this.max = max(this.max, rawValue);this.sum += rawValue;this.sumOfSquares += rawValue * rawValue;this.count++;if (time - this.onsetTime >= maxDuration || value <= offThreshold) {
                                   this.outputSegment(time);this.insideSegment = false;
                              }
                         }
                    } }, { key: 'processFrame', value: function processFrame(frame) {
                         this.prepareFrame();this.processFunction(frame); // do not propagate here as the frameRate is now zero
                    } }]);return Segmenter;
          }(_BaseLfo3.default);exports.default = Segmenter;
     }, { "../../core/BaseLfo": 182, "./MovingAverage": 163, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 171: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { index: { type: 'integer', default: 0, metas: { kind: 'static' } }, indexes: { type: 'any', default: null, nullable: true, metas: { kind: 'dynamic' } } }; /**
                                                                                                                                                                                         * Select one or several indexes from a `vector` input. If only one index is
                                                                                                                                                                                         * selected, the output will be of type `scalar`, otherwise the output will
                                                                                                                                                                                         * be a vector containing the selected indexes.
                                                                                                                                                                                         *
                                                                                                                                                                                         * @memberof module:common.operator
                                                                                                                                                                                         *
                                                                                                                                                                                         * @param {Object} options - Override default values.
                                                                                                                                                                                         * @param {Number} options.index - Index to select from the input frame.
                                                                                                                                                                                         * @param {Array<Number>} options.indexes - Indices to select from the input
                                                                                                                                                                                         *  frame, if defined, take precedance over `option.index`.
                                                                                                                                                                                         *
                                                                                                                                                                                         * @example
                                                                                                                                                                                         * import * as lfo from 'waves-lfo/common';
                                                                                                                                                                                         *
                                                                                                                                                                                         * const eventIn = new lfo.source.EventIn({
                                                                                                                                                                                         *   frameType: 'vector',
                                                                                                                                                                                         *   frameSize: 3,
                                                                                                                                                                                         * });
                                                                                                                                                                                         *
                                                                                                                                                                                         * const select = new lfo.operator.Select({
                                                                                                                                                                                         *   indexes: [2, 0],
                                                                                                                                                                                         * });
                                                                                                                                                                                         *
                                                                                                                                                                                         * eventIn.start();
                                                                                                                                                                                         * eventIn.process(0, [0, 2, 4]);
                                                                                                                                                                                         * > [4, 0]
                                                                                                                                                                                         * eventIn.process(0, [1, 3, 5]);
                                                                                                                                                                                         * > [5, 1]
                                                                                                                                                                                         */var Select = function (_BaseLfo) {
               (0, _inherits3.default)(Select, _BaseLfo);function Select() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Select);return (0, _possibleConstructorReturn3.default)(this, (Select.__proto__ || (0, _getPrototypeOf2.default)(Select)).call(this, definitions, options));
               } /** @private */(0, _createClass3.default)(Select, [{ key: 'onParamUpdate', value: function onParamUpdate(name, value) {
                         var metas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};(0, _get3.default)(Select.prototype.__proto__ || (0, _getPrototypeOf2.default)(Select.prototype), 'onParamUpdate', this).call(this, name, value, metas);var index = this.params.get('index');var indexes = this.params.get('indexes');this.select = indexes !== null ? indexes : [index];
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         var _this2 = this;this.prepareStreamParams(prevStreamParams);var index = this.params.get('index');var indexes = this.params.get('indexes');var max = indexes !== null ? Math.max.apply(null, indexes) : index;if (max >= prevStreamParams.frameSize) throw new Error('Invalid select index "' + max + '"');this.streamParams.frameType = indexes !== null ? 'vector' : 'scalar';this.streamParams.frameSize = indexes !== null ? indexes.length : 1;this.select = indexes !== null ? indexes : [index]; // steal description() from parent
                         if (prevStreamParams.description) {
                              this.select.forEach(function (val, index) {
                                   _this2.streamParams.description[index] = prevStreamParams.description[val];
                              });
                         }this.propagateStreamParams();
                    } /** @private */ }, { key: 'processVector', value: function processVector(frame) {
                         var data = frame.data;var outData = this.frame.data;var select = this.select;for (var i = 0; i < select.length; i++) {
                              outData[i] = data[select[i]];
                         }
                    } }]);return Select;
          }(_BaseLfo3.default);exports.default = Select;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 172: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _get2 = require('babel-runtime/helpers/get');var _get3 = _interopRequireDefault(_get2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { frameSize: { type: 'integer', default: 512, metas: { kind: 'static' } }, hopSize: { // should be nullable
                    type: 'integer', default: null, nullable: true, metas: { kind: 'static' } }, centeredTimeTags: { type: 'boolean', default: false /**
                                                                                                                                                     * Change the `frameSize` and `hopSize` of a `signal` input according to
                                                                                                                                                     * the given options.
                                                                                                                                                     * This operator updates the stream parameters according to its configuration.
                                                                                                                                                     *
                                                                                                                                                     * @memberof module:common.operator
                                                                                                                                                     *
                                                                                                                                                     * @param {Object} options - Override default parameters.
                                                                                                                                                     * @param {Number} [options.frameSize=512] - Frame size of the output signal.
                                                                                                                                                     * @param {Number} [options.hopSize=null] - Number of samples between two
                                                                                                                                                     *  consecutive frames. If null, `hopSize` is set to `frameSize`.
                                                                                                                                                     * @param {Boolean} [options.centeredTimeTags] - Move the time tag to the middle
                                                                                                                                                     *  of the frame.
                                                                                                                                                     *
                                                                                                                                                     * @example
                                                                                                                                                     * import * as lfo from 'waves-lfo/common';
                                                                                                                                                     *
                                                                                                                                                     * const eventIn = new lfo.source.EventIn({
                                                                                                                                                     *   frameType: 'signal',
                                                                                                                                                     *   frameSize: 10,
                                                                                                                                                     *   sampleRate: 2,
                                                                                                                                                     * });
                                                                                                                                                     *
                                                                                                                                                     * const slicer = new lfo.operator.Slicer({
                                                                                                                                                     *   frameSize: 4,
                                                                                                                                                     *   hopSize: 2
                                                                                                                                                     * });
                                                                                                                                                     *
                                                                                                                                                     * const logger = new lfo.sink.Logger({ time: true, data: true });
                                                                                                                                                     *
                                                                                                                                                     * eventIn.connect(slicer);
                                                                                                                                                     * slicer.connect(logger);
                                                                                                                                                     * eventIn.start();
                                                                                                                                                     *
                                                                                                                                                     * eventIn.process(0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
                                                                                                                                                     * > { time: 0, data: [0, 1, 2, 3] }
                                                                                                                                                     * > { time: 1, data: [2, 3, 4, 5] }
                                                                                                                                                     * > { time: 2, data: [4, 5, 6, 7] }
                                                                                                                                                     * > { time: 3, data: [6, 7, 8, 9] }
                                                                                                                                                     */ } };var Slicer = function (_BaseLfo) {
               (0, _inherits3.default)(Slicer, _BaseLfo);function Slicer() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Slicer);var _this = (0, _possibleConstructorReturn3.default)(this, (Slicer.__proto__ || (0, _getPrototypeOf2.default)(Slicer)).call(this, definitions, options));var hopSize = _this.params.get('hopSize');var frameSize = _this.params.get('frameSize');if (!hopSize) _this.params.set('hopSize', frameSize);_this.params.addListener(_this.onParamUpdate.bind(_this));_this.frameIndex = 0;return _this;
               } /** @private */(0, _createClass3.default)(Slicer, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);var hopSize = this.params.get('hopSize');var frameSize = this.params.get('frameSize');this.streamParams.frameSize = frameSize;this.streamParams.frameRate = prevStreamParams.sourceSampleRate / hopSize;if (this.streamParams.frameSize === 1) this.streamParams.frameType = 'scalar';else this.streamParams.frameType = 'signal';this.propagateStreamParams();
                    } /** @private */ }, { key: 'resetStream', value: function resetStream() {
                         (0, _get3.default)(Slicer.prototype.__proto__ || (0, _getPrototypeOf2.default)(Slicer.prototype), 'resetStream', this).call(this);this.frameIndex = 0;
                    } /** @private */ }, { key: 'finalizeStream', value: function finalizeStream(endTime) {
                         if (this.frameIndex > 0) {
                              var frameRate = this.streamParams.frameRate;var frameSize = this.streamParams.frameSize;var data = this.frame.data; // set the time of the last frame
                              this.frame.time += 1 / frameRate;for (var i = this.frameIndex; i < frameSize; i++) {
                                   data[i] = 0;
                              }this.propagateFrame();
                         }(0, _get3.default)(Slicer.prototype.__proto__ || (0, _getPrototypeOf2.default)(Slicer.prototype), 'finalizeStream', this).call(this, endTime);
                    } /** @private */ }, { key: 'processFrame', value: function processFrame(frame) {
                         this.prepareFrame();this.processFunction(frame);
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         var time = frame.time;var block = frame.data;var metadata = frame.metadata;var centeredTimeTags = this.params.get('centeredTimeTags');var hopSize = this.params.get('hopSize');var outFrame = this.frame.data;var frameSize = this.streamParams.frameSize;var sampleRate = this.streamParams.sourceSampleRate;var samplePeriod = 1 / sampleRate;var blockSize = block.length;var frameIndex = this.frameIndex;var blockIndex = 0;while (blockIndex < blockSize) {
                              var numSkip = 0; // skip block samples for negative frameIndex (frameSize < hopSize)
                              if (frameIndex < 0) {
                                   numSkip = -frameIndex;frameIndex = 0; // reset `frameIndex`
                              }if (numSkip < blockSize) {
                                   blockIndex += numSkip; // skip block segment
                                   // can copy all the rest of the incoming block
                                   var numCopy = blockSize - blockIndex; // connot copy more than what fits into the frame
                                   var maxCopy = frameSize - frameIndex;if (numCopy >= maxCopy) numCopy = maxCopy; // copy block segment into frame
                                   var copy = block.subarray(blockIndex, blockIndex + numCopy);outFrame.set(copy, frameIndex); // advance block and frame index
                                   blockIndex += numCopy;frameIndex += numCopy; // send frame when completed
                                   if (frameIndex === frameSize) {
                                        // define time tag for the outFrame according to configuration
                                        if (centeredTimeTags) this.frame.time = time + (blockIndex - frameSize / 2) * samplePeriod;else this.frame.time = time + (blockIndex - frameSize) * samplePeriod;this.frame.metadata = metadata; // forward to next nodes
                                        this.propagateFrame(); // shift frame left
                                        if (hopSize < frameSize) outFrame.set(outFrame.subarray(hopSize, frameSize), 0);frameIndex -= hopSize; // hop forward
                                   }
                              } else {
                                   // skip entire block
                                   var blockRest = blockSize - blockIndex;frameIndex += blockRest;blockIndex += blockRest;
                              }
                         }this.frameIndex = frameIndex;
                    } }]);return Slicer;
          }(_BaseLfo3.default);exports.default = Slicer;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/get": 18, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 173: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var ceil = Math.ceil; /**
                                 * paper: http://recherche.ircam.fr/equipes/pcm/cheveign/pss/2002_JASA_YIN.pdf
                                 * implementation based on https://github.com/ashokfernandez/Yin-Pitch-Tracking
                                 * @private
                                 */var definitions = { threshold: { type: 'float', default: 0.1, // default from paper
                    metas: { kind: 'static' } }, downSamplingExp: { // downsampling factor
                    type: 'integer', default: 2, min: 0, max: 3, metas: { kind: 'static' } }, minFreq: { //
                    type: 'float', default: 60, // mean 735 samples
                    min: 0, metas: { kind: 'static' /**
                                                    * Yin fundamental frequency estimator, based on algorithm described in
                                                    * [YIN, a fundamental frequency estimator for speech and music](http://recherche.ircam.fr/equipes/pcm/cheveign/pss/2002_JASA_YIN.pdf)
                                                    * by Cheveigne and Kawahara.
                                                    * On each frame, this operator propagate a vector containing the following
                                                    * values: `frequency`, `probability`.
                                                    *
                                                    * For good results the input frame size should be large (1024 or 2048).
                                                    *
                                                    * _support `standalone` usage_
                                                    *
                                                    * @note - In node for a frame of 2048 samples, average computation time is:
                                                    *         0.00016742283339993389 second.
                                                    *
                                                    * @memberof module:common.operator
                                                    *
                                                    * @param {Object} options - Override default parameters.
                                                    * @param {Number} [options.threshold=0.1] - Absolute threshold to test the
                                                    *  normalized difference (see paper for more informations).
                                                    * @param {Number} [options.downSamplingExp=2] - Down sample the input frame by
                                                    *  a factor of 2 at the power of `downSamplingExp` (min=0 and max=3) for
                                                    *  performance improvements.
                                                    * @param {Number} [options.minFreq=60] - Minimum frequency the operator can
                                                    *  search for. This parameter defines the size of the autocorrelation performed
                                                    *  on the signal, the input frame size should be around 2 time this size for
                                                    *  good results (i.e. `inputFrameSize  2 * (samplingRate / minFreq)`).
                                                    *
                                                    * @example
                                                    * import * as lfo from 'waves-lfo/client';
                                                    *
                                                    * // assuming some AudioBuffer
                                                    * const source = new lfo.source.AudioInBuffer({
                                                    *   audioBuffer: audioBuffer,
                                                    * });
                                                    *
                                                    * const slicer = new lfo.operator.Slicer({
                                                    *   frameSize: 2048,
                                                    * });
                                                    *
                                                    * const yin = new lfo.operator.Yin();
                                                    * const logger = new lfo.sink.Logger({ data: true });
                                                    *
                                                    * source.connect(slicer);
                                                    * slicer.connect(yin);
                                                    * yin.connect(logger);
                                                    *
                                                    * source.start();
                                                    */ } } };var Yin = function (_BaseLfo) {
               (0, _inherits3.default)(Yin, _BaseLfo);function Yin(options) {
                    (0, _classCallCheck3.default)(this, Yin);var _this = (0, _possibleConstructorReturn3.default)(this, (Yin.__proto__ || (0, _getPrototypeOf2.default)(Yin)).call(this, definitions, options));_this.probability = 0;_this.pitch = -1;_this.test = 0;return _this;
               } /** @private */(0, _createClass3.default)(Yin, [{ key: '_downsample', value: function _downsample(input, size, output, downSamplingExp) {
                         var outputSize = size >> downSamplingExp;var i = void 0,
                             j = void 0;switch (downSamplingExp) {case 0:
                                   // no down sampling
                                   for (i = 0; i < size; i++) {
                                        output[i] = input[i];
                                   }break;case 1:
                                   for (i = 0, j = 0; i < outputSize; i++, j += 2) {
                                        output[i] = 0.5 * (input[j] + input[j + 1]);
                                   }break;case 2:
                                   for (i = 0, j = 0; i < outputSize; i++, j += 4) {
                                        output[i] = 0.25 * (input[j] + input[j + 1] + input[j + 2] + input[j + 3]);
                                   }break;case 3:
                                   for (i = 0, j = 0; i < outputSize; i++, j += 8) {
                                        output[i] = 0.125 * (input[j] + input[j + 1] + input[j + 2] + input[j + 3] + input[j + 4] + input[j + 5] + input[j + 6] + input[j + 7]);
                                   }break;}return outputSize;
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this.streamParams.frameType = 'vector';this.streamParams.frameSize = 2;this.streamParams.description = ['frequency', 'confidence'];this.inputFrameSize = prevStreamParams.frameSize; // handle params
                         var sourceSampleRate = this.streamParams.sourceSampleRate;var downSamplingExp = this.params.get('downSamplingExp');var downFactor = 1 << downSamplingExp; // 2^n
                         var downSR = sourceSampleRate / downFactor;var downFrameSize = this.inputFrameSize / downFactor; // n_tick_down // 1 / 2^n
                         var minFreq = this.params.get('minFreq'); // limit min freq, cf. paper IV. sensitivity to parameters
                         var minFreqNbrSamples = downSR / minFreq; // const bufferSize = prevStreamParams.frameSize;
                         this.halfBufferSize = downFrameSize / 2; // minimum error to not crash but not enought to have results
                         if (minFreqNbrSamples > this.halfBufferSize) throw new Error('Invalid input frame size, too small for given "minFreq"');this.downSamplingExp = downSamplingExp;this.downSamplingRate = downSR;this.downFrameSize = downFrameSize;this.buffer = new Float32Array(downFrameSize); // autocorrelation buffer
                         this.yinBuffer = new Float32Array(this.halfBufferSize);this.propagateStreamParams();
                    } /** @private */ }, { key: '_downsample', value: function _downsample(input, size, output, downSamplingExp) {
                         var outputSize = size >> downSamplingExp;var i = void 0,
                             j = void 0;switch (downSamplingExp) {case 0:
                                   // no down sampling
                                   for (i = 0; i < size; i++) {
                                        output[i] = input[i];
                                   }break;case 1:
                                   for (i = 0, j = 0; i < outputSize; i++, j += 2) {
                                        output[i] = 0.5 * (input[j] + input[j + 1]);
                                   }break;case 2:
                                   for (i = 0, j = 0; i < outputSize; i++, j += 4) {
                                        output[i] = 0.25 * (input[j] + input[j + 1] + input[j + 2] + input[j + 3]);
                                   }break;case 3:
                                   for (i = 0, j = 0; i < outputSize; i++, j += 8) {
                                        output[i] = 0.125 * (input[j] + input[j + 1] + input[j + 2] + input[j + 3] + input[j + 4] + input[j + 5] + input[j + 6] + input[j + 7]);
                                   }break;}return outputSize;
                    } /**
                      * Step 1, 2 and 3 - Squared difference of the shifted signal with itself.
                      * cumulative mean normalized difference.
                      *
                      * @private
                      */ }, { key: '_normalizedDifference', value: function _normalizedDifference(buffer) {
                         var halfBufferSize = this.halfBufferSize;var yinBuffer = this.yinBuffer;var sum = 0; // difference for different shift values (tau)
                         for (var tau = 0; tau < halfBufferSize; tau++) {
                              var squaredDifference = 0; // reset buffer
                              // take difference of the signal with a shifted version of itself then
                              // sqaure the result
                              for (var i = 0; i < halfBufferSize; i++) {
                                   var delta = buffer[i] - buffer[i + tau];squaredDifference += delta * delta;
                              } // step 3 - normalize yinBuffer
                              if (tau > 0) {
                                   sum += squaredDifference;yinBuffer[tau] = squaredDifference * (tau / sum);
                              }
                         }yinBuffer[0] = 1;
                    } /**
                      * Step 4 - find first best tau that is under the thresold.
                      *
                      * @private
                      */ }, { key: '_absoluteThreshold', value: function _absoluteThreshold() {
                         var threshold = this.params.get('threshold');var yinBuffer = this.yinBuffer;var halfBufferSize = this.halfBufferSize;var tau = void 0;for (tau = 1; tau < halfBufferSize; tau++) {
                              if (yinBuffer[tau] < threshold) {
                                   // keep increasing tau if next value is better
                                   while (tau + 1 < halfBufferSize && yinBuffer[tau + 1] < yinBuffer[tau]) {
                                        tau += 1;
                                   } // best tau found , yinBuffer[tau] can be seen as an estimation of
                                   // aperiodicity then: periodicity = 1 - aperiodicity
                                   this.probability = 1 - yinBuffer[tau];break;
                              }
                         } // return -1 if not match found
                         return tau === halfBufferSize ? -1 : tau;
                    } /**
                      * Step 5 - Find a better fractionnal approximate of tau.
                      * this can probably be simplified...
                      *
                      * @private
                      */ }, { key: '_parabolicInterpolation', value: function _parabolicInterpolation(tauEstimate) {
                         var halfBufferSize = this.halfBufferSize;var yinBuffer = this.yinBuffer;var betterTau = void 0; // @note - tauEstimate cannot be zero as the loop start at 1 in step 4
                         var x0 = tauEstimate - 1;var x2 = tauEstimate < halfBufferSize - 1 ? tauEstimate + 1 : tauEstimate; // if `tauEstimate` is last index, we can't interpolate
                         if (x2 === tauEstimate) {
                              betterTau = tauEstimate;
                         } else {
                              var s0 = yinBuffer[x0];var s1 = yinBuffer[tauEstimate];var s2 = yinBuffer[x2]; // @note - don't fully understand this formula neither...
                              betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
                         }return betterTau;
                    } /**
                      * Use the `Yin` operator in `standalone` mode (i.e. outside of a graph).
                      *
                      * @param {Array|Float32Array} input - The signal fragment to process.
                      * @return {Array} - Array containing the `frequency`, `energy`, `periodicity`
                      *  and `AC1`
                      *
                      * @example
                      * import * as lfo from 'waves-lfo/client';
                      *
                      * const yin = new lfo.operator.Yin();
                      * yin.initStream({
                      *   frameSize: 2048,
                      *   frameType: 'signal',
                      *   sourceSampleRate: 44100
                      * });
                      *
                      * const results = yin.inputSignal(signal);
                      */ }, { key: 'inputSignal', value: function inputSignal(input) {
                         this.pitch = -1;this.probability = 0;var buffer = this.buffer;var inputFrameSize = this.inputFrameSize;var downSamplingExp = this.downSamplingExp;var sampleRate = this.downSamplingRate;var outData = this.frame.data;var tauEstimate = -1; // subsampling
                         this._downsample(input, inputFrameSize, buffer, downSamplingExp); // step 1, 2, 3 - normalized squared difference of the signal with a
                         // shifted version of itself
                         this._normalizedDifference(buffer); // step 4 - find first best tau estimate that is over the threshold
                         tauEstimate = this._absoluteThreshold();if (tauEstimate !== -1) {
                              // step 5 - so far tau is an integer shift of the signal, check if
                              // there is a better fractionnal value around
                              tauEstimate = this._parabolicInterpolation(tauEstimate);this.pitch = sampleRate / tauEstimate;
                         }outData[0] = this.pitch;outData[1] = this.probability;return outData;
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         this.inputSignal(frame.data);
                    } }]);return Yin;
          }(_BaseLfo3.default);exports.default = Yin;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 174: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _Biquad = require('./Biquad');var _Biquad2 = _interopRequireDefault(_Biquad);var _Clip = require('./Clip');var _Clip2 = _interopRequireDefault(_Clip);var _Dct = require('./Dct');var _Dct2 = _interopRequireDefault(_Dct);var _Delta = require('./Delta');var _Delta2 = _interopRequireDefault(_Delta);var _Fft = require('./Fft');var _Fft2 = _interopRequireDefault(_Fft);var _Magnitude = require('./Magnitude');var _Magnitude2 = _interopRequireDefault(_Magnitude);var _MeanStddev = require('./MeanStddev');var _MeanStddev2 = _interopRequireDefault(_MeanStddev);var _Mel = require('./Mel');var _Mel2 = _interopRequireDefault(_Mel);var _Merger = require('./Merger');var _Merger2 = _interopRequireDefault(_Merger);var _Mfcc = require('./Mfcc');var _Mfcc2 = _interopRequireDefault(_Mfcc);var _MinMax = require('./MinMax');var _MinMax2 = _interopRequireDefault(_MinMax);var _MovingAverage = require('./MovingAverage');var _MovingAverage2 = _interopRequireDefault(_MovingAverage);var _MovingMedian = require('./MovingMedian');var _MovingMedian2 = _interopRequireDefault(_MovingMedian);var _OnOff = require('./OnOff');var _OnOff2 = _interopRequireDefault(_OnOff);var _Power = require('./Power');var _Power2 = _interopRequireDefault(_Power);var _Rms = require('./Rms');var _Rms2 = _interopRequireDefault(_Rms);var _Multiplier = require('./Multiplier');var _Multiplier2 = _interopRequireDefault(_Multiplier);var _Scale = require('./Scale');var _Scale2 = _interopRequireDefault(_Scale);var _Segmenter = require('./Segmenter');var _Segmenter2 = _interopRequireDefault(_Segmenter);var _Select = require('./Select');var _Select2 = _interopRequireDefault(_Select);var _Slicer = require('./Slicer');var _Slicer2 = _interopRequireDefault(_Slicer);var _Yin = require('./Yin');var _Yin2 = _interopRequireDefault(_Yin);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }exports.default = { Biquad: _Biquad2.default, Clip: _Clip2.default, Dct: _Dct2.default, Delta: _Delta2.default, Fft: _Fft2.default, Magnitude: _Magnitude2.default, MeanStddev: _MeanStddev2.default, Mel: _Mel2.default, Merger: _Merger2.default, Mfcc: _Mfcc2.default, MinMax: _MinMax2.default, MovingAverage: _MovingAverage2.default, MovingMedian: _MovingMedian2.default, OnOff: _OnOff2.default, Power: _Power2.default, Rms: _Rms2.default, Multiplier: _Multiplier2.default, Scale: _Scale2.default, Segmenter: _Segmenter2.default, Select: _Select2.default, Slicer: _Slicer2.default, Yin: _Yin2.default };
     }, { "./Biquad": 152, "./Clip": 153, "./Dct": 154, "./Delta": 155, "./Fft": 156, "./Magnitude": 157, "./MeanStddev": 158, "./Mel": 159, "./Merger": 160, "./Mfcc": 161, "./MinMax": 162, "./MovingAverage": 163, "./MovingMedian": 164, "./Multiplier": 165, "./OnOff": 166, "./Power": 167, "./Rms": 168, "./Scale": 169, "./Segmenter": 170, "./Select": 171, "./Slicer": 172, "./Yin": 173 }], 175: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { processStreamParams: { type: 'any', default: null, nullable: true, metas: { kind: 'dynamic' } }, processFrame: { type: 'any', default: null, nullable: true, metas: { kind: 'dynamic' } }, finalizeStream: { type: 'any', default: null, nullable: true, metas: { kind: 'dynamic' } } }; /**
                                                                                                                                                                                                                                                                                                                        * Create a bridge between the graph and application logic. Handle `push`
                                                                                                                                                                                                                                                                                                                        * and `pull` paradigms.
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * This sink can handle any type of input (`signal`, `vector`, `scalar`)
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * @memberof module:common.sink
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                        * @param {Function} [options.processFrame=null] - Callback executed on each
                                                                                                                                                                                                                                                                                                                        *  `processFrame` call.
                                                                                                                                                                                                                                                                                                                        * @param {Function} [options.finalizeStream=null] - Callback executed on each
                                                                                                                                                                                                                                                                                                                        *  `finalizeStream` call.
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * @see {@link module:core.BaseLfo#processFrame}
                                                                                                                                                                                                                                                                                                                        * @see {@link module:core.BaseLfo#processStreamParams}
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * @example
                                                                                                                                                                                                                                                                                                                        * import * as lfo from 'waves-lfo/common';
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * const frames = [
                                                                                                                                                                                                                                                                                                                        *  { time: 0, data: [0, 1] },
                                                                                                                                                                                                                                                                                                                        *  { time: 1, data: [1, 2] },
                                                                                                                                                                                                                                                                                                                        * ];
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * const eventIn = new EventIn({
                                                                                                                                                                                                                                                                                                                        *   frameType: 'vector',
                                                                                                                                                                                                                                                                                                                        *   frameSize: 2,
                                                                                                                                                                                                                                                                                                                        *   frameRate: 1,
                                                                                                                                                                                                                                                                                                                        * });
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * const bridge = new Bridge({
                                                                                                                                                                                                                                                                                                                        *   processFrame: (frame) => console.log(frame),
                                                                                                                                                                                                                                                                                                                        * });
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * eventIn.connect(bridge);
                                                                                                                                                                                                                                                                                                                        * eventIn.start();
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * // callback executed on each frame
                                                                                                                                                                                                                                                                                                                        * eventIn.processFrame(frame[0]);
                                                                                                                                                                                                                                                                                                                        * > { time: 0, data: [0, 1] }
                                                                                                                                                                                                                                                                                                                        * eventIn.processFrame(frame[1]);
                                                                                                                                                                                                                                                                                                                        * > { time: 1, data: [1, 2] }
                                                                                                                                                                                                                                                                                                                        *
                                                                                                                                                                                                                                                                                                                        * // pull current frame when needed
                                                                                                                                                                                                                                                                                                                        * console.log(bridge.frame);
                                                                                                                                                                                                                                                                                                                        * > { time: 1, data: [1, 2] }
                                                                                                                                                                                                                                                                                                                        */var Bridge = function (_BaseLfo) {
               (0, _inherits3.default)(Bridge, _BaseLfo);function Bridge() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, Bridge);return (0, _possibleConstructorReturn3.default)(this, (Bridge.__proto__ || (0, _getPrototypeOf2.default)(Bridge)).call(this, definitions, options));
               } /** @private */(0, _createClass3.default)(Bridge, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);var processStreamParamsCallback = this.params.get('processStreamParams');if (processStreamParamsCallback !== null) processStreamParamsCallback(this.streamParams);this.propagateStreamParams();
                    } /** @private */ }, { key: 'finalizeStream', value: function finalizeStream(endTime) {
                         var finalizeStreamCallback = this.params.get('finalizeStream');if (finalizeStreamCallback !== null) finalizeStreamCallback(endTime);
                    } // process any type
                    /** @private */ }, { key: 'processScalar', value: function processScalar() {} /** @private */ }, { key: 'processVector', value: function processVector() {} /** @private */ }, { key: 'processSignal', value: function processSignal() {} /** @private */ }, { key: 'processFrame', value: function processFrame(frame) {
                         this.prepareFrame();var processFrameCallback = this.params.get('processFrame');var output = this.frame;output.data = new Float32Array(this.streamParams.frameSize); // pull interface (we copy data since we don't know what could
                         // be done outside the graph)
                         for (var i = 0; i < this.streamParams.frameSize; i++) {
                              output.data[i] = frame.data[i];
                         }output.time = frame.time;output.metadata = frame.metadata; // `push` interface
                         if (processFrameCallback !== null) processFrameCallback(output);
                    } }]);return Bridge;
          }(_BaseLfo3.default);exports.default = Bridge;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 176: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { separateArrays: { type: 'boolean', default: false, constant: true }, callback: { type: 'any', default: null, nullable: true, metas: { kind: 'dynamic' } } }; /**
                                                                                                                                                                                            * Record input frames from a graph. This sink can handle `signal`, `vector`
                                                                                                                                                                                            * or `scalar` inputs.
                                                                                                                                                                                            *
                                                                                                                                                                                            * When the recording is stopped (either by calling `stop` on the node or when
                                                                                                                                                                                            * the stream is finalized), the callback given as parameter is executed with
                                                                                                                                                                                            * the recorder data as argument.
                                                                                                                                                                                            *
                                                                                                                                                                                            *
                                                                                                                                                                                            * @param {Object} options - Override default parameters.
                                                                                                                                                                                            * @param {Boolean} [options.separateArrays=false] - Format of the retrieved
                                                                                                                                                                                            *  values:
                                                                                                                                                                                            *  - when `false`, format is [{ time, data }, { time, data }, ...]
                                                                                                                                                                                            *  - when `true`, format is { time: [...], data: [...] }
                                                                                                                                                                                            * @param {Function} [options.callback] - Callback to execute when a new record
                                                                                                                                                                                            *  is ended. This can happen when:
                                                                                                                                                                                            *  - `stop` is called on the recorder
                                                                                                                                                                                            *  - `stop` is called on the source.
                                                                                                                                                                                            *
                                                                                                                                                                                            * @todo - Add auto record param.
                                                                                                                                                                                            *
                                                                                                                                                                                            * @memberof module:common.sink
                                                                                                                                                                                            *
                                                                                                                                                                                            * @example
                                                                                                                                                                                            * import * as lfo from 'waves-lfo/common';
                                                                                                                                                                                            *
                                                                                                                                                                                            * const eventIn = new lfo.source.EventIn({
                                                                                                                                                                                            *  frameType: 'vector',
                                                                                                                                                                                            *  frameSize: 2,
                                                                                                                                                                                            *  frameRate: 0,
                                                                                                                                                                                            * });
                                                                                                                                                                                            *
                                                                                                                                                                                            * const recorder = new lfo.sink.DataRecorder({
                                                                                                                                                                                            *   callback: (data) => console.log(data),
                                                                                                                                                                                            * });
                                                                                                                                                                                            *
                                                                                                                                                                                            * eventIn.connect(recorder);
                                                                                                                                                                                            * eventIn.start();
                                                                                                                                                                                            * recorder.start();
                                                                                                                                                                                            *
                                                                                                                                                                                            * eventIn.process(0, [0, 1]);
                                                                                                                                                                                            * eventIn.process(1, [1, 2]);
                                                                                                                                                                                            *
                                                                                                                                                                                            * recorder.stop();
                                                                                                                                                                                            * > [{ time: 0, data: [0, 1] }, { time: 1, data: [1, 2] }];
                                                                                                                                                                                            */var DataRecorder = function (_BaseLfo) {
               (0, _inherits3.default)(DataRecorder, _BaseLfo);function DataRecorder() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, DataRecorder); /**
                                                                                                                                                            * Define if the node is currently recording.
                                                                                                                                                            *
                                                                                                                                                            * @type {Boolean}
                                                                                                                                                            * @name isRecording
                                                                                                                                                            * @instance
                                                                                                                                                            * @memberof module:sink.SignalRecorder
                                                                                                                                                            */var _this = (0, _possibleConstructorReturn3.default)(this, (DataRecorder.__proto__ || (0, _getPrototypeOf2.default)(DataRecorder)).call(this, definitions, options));_this.isRecording = false;return _this;
               } /** @private */(0, _createClass3.default)(DataRecorder, [{ key: '_initStore', value: function _initStore() {
                         var separateArrays = this.params.get('separateArrays');if (separateArrays) this._store = { time: [], data: [] };else this._store = [];
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);this._initStore();this.propagateStreamParams();
                    } /**
                      * Start recording.
                      *
                      * @see {@link module:client.sink.DataRecorder#stop}
                      */ }, { key: 'start', value: function start() {
                         this.isRecording = true;
                    } /**
                      * Stop recording and execute the callback defined in parameters.
                      *
                      * @see {@link module:client.sink.DataRecorder#start}
                      */ }, { key: 'stop', value: function stop() {
                         if (this.isRecording) {
                              this.isRecording = false;var callback = this.params.get('callback');if (callback !== null) callback(this._store);this._initStore();
                         }
                    } /** @private */ }, { key: 'finalizeStream', value: function finalizeStream() {
                         this.stop();
                    } // handle any input types
                    /** @private */ }, { key: 'processScalar', value: function processScalar(frame) {} /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {} /** @private */ }, { key: 'processVector', value: function processVector(frame) {} }, { key: 'processFrame', value: function processFrame(frame) {
                         if (this.isRecording) {
                              this.prepareFrame(frame);var separateArrays = this.params.get('separateArrays');var entry = { time: frame.time, data: new Float32Array(frame.data) };if (!separateArrays) {
                                   this._store.push(entry);
                              } else {
                                   this._store.time.push(entry.time);this._store.data.push(entry.data);
                              }
                         }
                    } }]);return DataRecorder;
          }(_BaseLfo3.default);exports.default = DataRecorder;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 177: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { time: { type: 'boolean', default: false, metas: { kind: 'dynamic' } }, data: { type: 'boolean', default: false, metas: { kind: 'dynamic' } }, metadata: { type: 'boolean', default: false, metas: { kind: 'dynamic' } }, streamParams: { type: 'boolean', default: false, metas: { kind: 'dynamic' } }, frameIndex: { type: 'boolean', default: false, metas: { kind: 'dynamic' /**
                                                                                                                                                                                                                                                                                                                                                                                                               * Log `frame.time`, `frame.data`, `frame.metadata` and/or
                                                                                                                                                                                                                                                                                                                                                                                                               * `streamAttributes` of any node in the console.
                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                               * This sink can handle any type if input (`signal`, `vector`, `scalar`)
                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Object} options - Override parameters default values.
                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Boolean} [options.time=false] - Log incomming `frame.time` if `true`.
                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Boolean} [options.data=false] - Log incomming `frame.data` if `true`.
                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Boolean} [options.metadata=false] - Log incomming `frame.metadata`
                                                                                                                                                                                                                                                                                                                                                                                                               *  if `true`.
                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Boolean} [options.streamParams=false] - Log `streamParams` of the
                                                                                                                                                                                                                                                                                                                                                                                                               *  previous node when graph is started.
                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Boolean} [options.frameIndex=false] - Log index of the incomming
                                                                                                                                                                                                                                                                                                                                                                                                               *  `frame`.
                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                               * @memberof module:common.sink
                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                               * @example
                                                                                                                                                                                                                                                                                                                                                                                                               * import * as lfo from 'waves-lfo/common';
                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                               * const logger = new lfo.sink.Logger({ data: true });
                                                                                                                                                                                                                                                                                                                                                                                                               * whateverOperator.connect(logger);
                                                                                                                                                                                                                                                                                                                                                                                                               */ } } };var Logger = function (_BaseLfo) {
               (0, _inherits3.default)(Logger, _BaseLfo);function Logger(options) {
                    (0, _classCallCheck3.default)(this, Logger);return (0, _possibleConstructorReturn3.default)(this, (Logger.__proto__ || (0, _getPrototypeOf2.default)(Logger)).call(this, definitions, options));
               } /** @private */(0, _createClass3.default)(Logger, [{ key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         if (this.params.get('streamParams') === true) console.log(prevStreamParams);this.frameIndex = 0;
                    } /** @private */ }, { key: 'processFunction', value: function processFunction(frame) {
                         if (this.params.get('frameIndex') === true) console.log(this.frameIndex++);if (this.params.get('time') === true) console.log(frame.time);if (this.params.get('data') === true) console.log(frame.data);if (this.params.get('metadata') === true) console.log(frame.metadata);
                    } }]);return Logger;
          }(_BaseLfo3.default);exports.default = Logger;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 178: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo2 = require('../../core/BaseLfo');var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var definitions = { duration: { type: 'float', default: 10, min: 0, metas: { kind: 'static' } }, callback: { type: 'any', default: null, nullable: true, metas: { kind: 'dynamic' } }, ignoreLeadingZeros: { type: 'boolean', default: true, metas: { kind: 'static' } }, retrieveAudioBuffer: { type: 'boolean', default: false, constant: true }, audioContext: { type: 'any', default: null, nullable: true } }; /**
                                                                                                                                                                                                                                                                                                                                                                                                                               * Record an `signal` input stream of arbitrary duration and retrieve it
                                                                                                                                                                                                                                                                                                                                                                                                                               * when done.
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               * When recording is stopped (either when the `stop` method is called, the
                                                                                                                                                                                                                                                                                                                                                                                                                               * defined duration has been recorded, or the source of the graph finalized
                                                                                                                                                                                                                                                                                                                                                                                                                               * the stream), the callback given as parameter is executed  with the
                                                                                                                                                                                                                                                                                                                                                                                                                               * `AudioBuffer` or `Float32Array` containing the recorded signal as argument.
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               * @todo - add option to return only the Float32Array and not an audio buffer
                                                                                                                                                                                                                                                                                                                                                                                                                               *  (node compliant) `retrieveAudioBuffer: false`
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Object} options - Override default parameters.
                                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.duration=10] - Maximum duration of the recording.
                                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Number} [options.callback] - Callback to execute when a new record is
                                                                                                                                                                                                                                                                                                                                                                                                                               *  ended. This can happen: `stop` is called on the recorder, `stop` is called
                                                                                                                                                                                                                                                                                                                                                                                                                               *  on the source or when the buffer is full according to the given `duration`.
                                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Object} [options.ignoreLeadingZeros=true] - Start the effective
                                                                                                                                                                                                                                                                                                                                                                                                                               *  recording on the first non-zero value.
                                                                                                                                                                                                                                                                                                                                                                                                                               * @param {Boolean} [options.retrieveAudioBuffer=false] - Define if an `AudioBuffer`
                                                                                                                                                                                                                                                                                                                                                                                                                               *  should be retrieved or only the raw Float32Array of data.
                                                                                                                                                                                                                                                                                                                                                                                                                               *  (works only in browser)
                                                                                                                                                                                                                                                                                                                                                                                                                               * @param {AudioContext} [options.audioContext=null] - If
                                                                                                                                                                                                                                                                                                                                                                                                                               *  `retrieveAudioBuffer` is set to `true`, audio context to be used
                                                                                                                                                                                                                                                                                                                                                                                                                               *  in order to create the final audio buffer.
                                                                                                                                                                                                                                                                                                                                                                                                                               *  (works only in browser)
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               * @memberof module:common.sink
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               * @example
                                                                                                                                                                                                                                                                                                                                                                                                                               * import * as lfo from 'waves-lfo/client';
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               * const audioContext = new AudioContext();
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               * navigator.mediaDevices
                                                                                                                                                                                                                                                                                                                                                                                                                               *   .getUserMedia({ audio: true })
                                                                                                                                                                                                                                                                                                                                                                                                                               *   .then(init)
                                                                                                                                                                                                                                                                                                                                                                                                                               *   .catch((err) => console.error(err.stack));
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               * function init(stream) {
                                                                                                                                                                                                                                                                                                                                                                                                                               *   const source = audioContext.createMediaStreamSource(stream);
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               *   const audioInNode = new lfo.source.AudioInNode({
                                                                                                                                                                                                                                                                                                                                                                                                                               *     sourceNode: source,
                                                                                                                                                                                                                                                                                                                                                                                                                               *     audioContext: audioContext,
                                                                                                                                                                                                                                                                                                                                                                                                                               *   });
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               *   const signalRecorder = new lfo.sink.SignalRecorder({
                                                                                                                                                                                                                                                                                                                                                                                                                               *     duration: 6,
                                                                                                                                                                                                                                                                                                                                                                                                                               *     retrieveAudioBuffer: true,
                                                                                                                                                                                                                                                                                                                                                                                                                               *     audioContext: audioContext,
                                                                                                                                                                                                                                                                                                                                                                                                                               *     callback: (buffer) => {
                                                                                                                                                                                                                                                                                                                                                                                                                               *       const bufferSource = audioContext.createBufferSource();
                                                                                                                                                                                                                                                                                                                                                                                                                               *       bufferSource.buffer = buffer;
                                                                                                                                                                                                                                                                                                                                                                                                                               *       bufferSource.connect(audioContext.destination);
                                                                                                                                                                                                                                                                                                                                                                                                                               *       bufferSource.start();
                                                                                                                                                                                                                                                                                                                                                                                                                               *     }
                                                                                                                                                                                                                                                                                                                                                                                                                               *   });
                                                                                                                                                                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                                                                                                                                                                               *   audioInNode.connect(signalRecorder);
                                                                                                                                                                                                                                                                                                                                                                                                                               *   audioInNode.start();
                                                                                                                                                                                                                                                                                                                                                                                                                               *   signalRecorder.start();
                                                                                                                                                                                                                                                                                                                                                                                                                               * });
                                                                                                                                                                                                                                                                                                                                                                                                                               */var SignalRecorder = function (_BaseLfo) {
               (0, _inherits3.default)(SignalRecorder, _BaseLfo);function SignalRecorder() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, SignalRecorder); /**
                                                                                                                                                              * Define is the node is currently recording or not.
                                                                                                                                                              *
                                                                                                                                                              * @type {Boolean}
                                                                                                                                                              * @name isRecording
                                                                                                                                                              * @instance
                                                                                                                                                              * @memberof module:client.sink.SignalRecorder
                                                                                                                                                              */var _this = (0, _possibleConstructorReturn3.default)(this, (SignalRecorder.__proto__ || (0, _getPrototypeOf2.default)(SignalRecorder)).call(this, definitions, options));_this.isRecording = false;var retrieveAudioBuffer = _this.params.get('retrieveAudioBuffer');var audioContext = _this.params.get('audioContext'); // needed to retrieve an AudioBuffer
                    if (retrieveAudioBuffer && audioContext === null) throw new Error('Invalid parameter "audioContext": an AudioContext must be provided when `retrieveAudioBuffer` is set to `true`');_this._audioContext = audioContext;_this._ignoreZeros = false;_this._isInfiniteBuffer = false;_this._stack = [];_this._buffer = null;_this._bufferLength = null;_this._currentIndex = null;return _this;
               }(0, _createClass3.default)(SignalRecorder, [{ key: '_initBuffer', value: function _initBuffer() {
                         this._buffer = new Float32Array(this._bufferLength);this._stack.length = 0;this._currentIndex = 0;
                    } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams(prevStreamParams) {
                         this.prepareStreamParams(prevStreamParams);var duration = this.params.get('duration');var sampleRate = this.streamParams.sourceSampleRate;if (isFinite(duration)) {
                              this._isInfiniteBuffer = false;this._bufferLength = sampleRate * duration;
                         } else {
                              this._isInfiniteBuffer = true;this._bufferLength = sampleRate * 10;
                         }this._initBuffer();this.propagateStreamParams();
                    } /**
                      * Start recording.
                      */ }, { key: 'start', value: function start() {
                         this.isRecording = true;this._ignoreZeros = this.params.get('ignoreLeadingZeros');
                    } /**
                      * Stop recording and execute the callback defined in parameters.
                      */ }, { key: 'stop', value: function stop() {
                         if (this.isRecording) {
                              // ignore next incomming frame
                              this.isRecording = false;var retrieveAudioBuffer = this.params.get('retrieveAudioBuffer');var callback = this.params.get('callback');var currentIndex = this._currentIndex;var buffer = this._buffer;var output = void 0;if (!this._isInfiniteBuffer) {
                                   output = new Float32Array(currentIndex);output.set(buffer.subarray(0, currentIndex), 0);
                              } else {
                                   var bufferLength = this._bufferLength;var stack = this._stack;output = new Float32Array(stack.length * bufferLength + currentIndex); // copy all stacked buffers
                                   for (var i = 0; i < stack.length; i++) {
                                        var stackedBuffer = stack[i];output.set(stackedBuffer, bufferLength * i);
                                   }; // copy data contained in current buffer
                                   output.set(buffer.subarray(0, currentIndex), stack.length * bufferLength);
                              }if (retrieveAudioBuffer && this._audioContext) {
                                   var length = output.length;var sampleRate = this.streamParams.sourceSampleRate;var audioBuffer = this._audioContext.createBuffer(1, length, sampleRate);var channelData = audioBuffer.getChannelData(0);channelData.set(output, 0);callback(audioBuffer);
                              } else {
                                   callback(output);
                              } // reinit buffer, stack, and currentIndex
                              this._initBuffer();
                         }
                    } /** @private */ }, { key: 'finalizeStream', value: function finalizeStream(endTime) {
                         this.stop();
                    } /** @private */ }, { key: 'processSignal', value: function processSignal(frame) {
                         if (!this.isRecording) return;var block = null;var input = frame.data;var bufferLength = this._bufferLength;var buffer = this._buffer;if (this._ignoreZeros === false) {
                              block = new Float32Array(input);
                         } else if (input[input.length - 1] !== 0) {
                              // find first index where value !== 0
                              var i = void 0;for (i = 0; i < input.length; i++) {
                                   if (input[i] !== 0) break;
                              } // copy non zero segment
                              block = new Float32Array(input.subarray(i)); // don't repeat this logic once a non-zero value has been found
                              this._ignoreZeros = false;
                         }if (block !== null) {
                              var availableSpace = bufferLength - this._currentIndex;var currentBlock = void 0;if (availableSpace < block.length) currentBlock = block.subarray(0, availableSpace);else currentBlock = block;buffer.set(currentBlock, this._currentIndex);this._currentIndex += currentBlock.length;if (this._isInfiniteBuffer && this._currentIndex === bufferLength) {
                                   this._stack.push(buffer);currentBlock = block.subarray(availableSpace);this._buffer = new Float32Array(bufferLength);this._buffer.set(currentBlock, 0);this._currentIndex = currentBlock.length;
                              } //  stop if the buffer is finite and full
                              if (!this._isInfiniteBuffer && this._currentIndex === bufferLength) this.stop();
                         }
                    } }]);return SignalRecorder;
          }(_BaseLfo3.default);exports.default = SignalRecorder;
     }, { "../../core/BaseLfo": 182, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 179: [function (require, module, exports) {
          (function (process) {
               'use strict';
               Object.defineProperty(exports, "__esModule", { value: true });var _isFinite = require('babel-runtime/core-js/number/is-finite');var _isFinite2 = _interopRequireDefault(_isFinite);var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require('babel-runtime/helpers/inherits');var _inherits3 = _interopRequireDefault(_inherits2);var _BaseLfo = require('../../core/BaseLfo');var _BaseLfo2 = _interopRequireDefault(_BaseLfo);var _SourceMixin2 = require('../../core/SourceMixin');var _SourceMixin3 = _interopRequireDefault(_SourceMixin2);function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : { default: obj };
               } // http://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser
               var isNode = new Function('try { return this === global; } catch(e) { return false }'); /**
                                                                                                       * Create a function that returns time in seconds according to the current
                                                                                                       * environnement (node or browser).
                                                                                                       * If running in node the time rely on `process.hrtime`, while if in the browser
                                                                                                       * it is provided by the `currentTime` of an `AudioContext`, this context can
                                                                                                       * optionnaly be provided to keep time consistency between several `EventIn`
                                                                                                       * nodes.
                                                                                                       *
                                                                                                       * @param {AudioContext} [audioContext=null] - Optionnal audio context.
                                                                                                       * @return {Function}
                                                                                                       * @private
                                                                                                       */function getTimeFunction() {
                    var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;if (isNode()) {
                         return function () {
                              var t = process.hrtime();return t[0] + t[1] * 1e-9;
                         };
                    } else {
                         return function () {
                              return performance.now() / 1000;
                         };
                    }
               }var definitions = { absoluteTime: { type: 'boolean', default: false, constant: true }, audioContext: { type: 'any', default: null, constant: true, nullable: true }, frameType: { type: 'enum', list: ['signal', 'vector', 'scalar'], default: 'signal', constant: true }, frameSize: { type: 'integer', default: 1, min: 1, max: +Infinity, // not recommended...
                         metas: { kind: 'static' } }, sampleRate: { type: 'float', default: null, min: 0, max: +Infinity, // same here
                         nullable: true, metas: { kind: 'static' } }, frameRate: { type: 'float', default: null, min: 0, max: +Infinity, // same here
                         nullable: true, metas: { kind: 'static' } }, description: { type: 'any', default: null, constant: true } }; /**
                                                                                                                                     * The `EventIn` operator allows to manually create a stream of data or to feed
                                                                                                                                     * a stream from another source (e.g. sensors) into a processing graph.
                                                                                                                                     *
                                                                                                                                     * @param {Object} options - Override parameters' default values.
                                                                                                                                     * @param {String} [options.frameType='signal'] - Type of the input - allowed
                                                                                                                                     * values: `signal`,  `vector` or `scalar`.
                                                                                                                                     * @param {Number} [options.frameSize=1] - Size of the output frame.
                                                                                                                                     * @param {Number} [options.sampleRate=null] - Sample rate of the source stream,
                                                                                                                                     *  if of type `signal`.
                                                                                                                                     * @param {Number} [options.frameRate=null] - Rate of the source stream, if of
                                                                                                                                     *  type `vector`.
                                                                                                                                     * @param {Array|String} [options.description] - Optionnal description
                                                                                                                                     *  describing the dimensions of the output frame
                                                                                                                                     * @param {Boolean} [options.absoluteTime=false] - Define if time should be used
                                                                                                                                     *  as forwarded as given in the process method, or relatively to the time of
                                                                                                                                     *  the first `process` call after start.
                                                                                                                                     *
                                                                                                                                     * @memberof module:common.source
                                                                                                                                     *
                                                                                                                                     * @todo - Add a `logicalTime` parameter to tag frame according to frame rate.
                                                                                                                                     *
                                                                                                                                     * @example
                                                                                                                                     * import * as lfo from 'waves-lfo/client';
                                                                                                                                     *
                                                                                                                                     * const eventIn = new lfo.source.EventIn({
                                                                                                                                     *   frameType: 'vector',
                                                                                                                                     *   frameSize: 3,
                                                                                                                                     *   frameRate: 1 / 50,
                                                                                                                                     *   description: ['alpha', 'beta', 'gamma'],
                                                                                                                                     * });
                                                                                                                                     *
                                                                                                                                     * // connect source to operators and sink(s)
                                                                                                                                     *
                                                                                                                                     * // initialize and start the graph
                                                                                                                                     * eventIn.start();
                                                                                                                                     *
                                                                                                                                     * // feed `deviceorientation` data into the graph
                                                                                                                                     * window.addEventListener('deviceorientation', (e) => {
                                                                                                                                     *   const frame = {
                                                                                                                                     *     time: window.performace.now() / 1000,
                                                                                                                                     *     data: [e.alpha, e.beta, e.gamma],
                                                                                                                                     *   };
                                                                                                                                     *
                                                                                                                                     *   eventIn.processFrame(frame);
                                                                                                                                     * }, false);
                                                                                                                                     */var EventIn = function (_SourceMixin) {
                    (0, _inherits3.default)(EventIn, _SourceMixin);function EventIn() {
                         var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _classCallCheck3.default)(this, EventIn);var _this = (0, _possibleConstructorReturn3.default)(this, (EventIn.__proto__ || (0, _getPrototypeOf2.default)(EventIn)).call(this, definitions, options));var audioContext = _this.params.get('audioContext');_this._getTime = getTimeFunction(audioContext);_this._startTime = null;_this._systemTime = null;_this._absoluteTime = _this.params.get('absoluteTime');return _this;
                    } /**
                      * Propagate the `streamParams` in the graph and allow to push frames into
                      * the graph. Any call to `process` or `processFrame` before `start` will be
                      * ignored.
                      *
                      * @see {@link module:core.BaseLfo#processStreamParams}
                      * @see {@link module:core.BaseLfo#resetStream}
                      * @see {@link module:common.source.EventIn#stop}
                      */(0, _createClass3.default)(EventIn, [{ key: 'start', value: function start() {
                              var _this2 = this;var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;if (this.initialized === false) {
                                   if (this.initPromise === null) // init has not yet been called
                                        this.initPromise = this.init();return this.initPromise.then(function () {
                                        return _this2.start(startTime);
                                   });
                              }this._startTime = startTime;this._systemTime = null; // value set in the first `process` call
                              this.started = true;
                         } /**
                           * Finalize the stream and stop the whole graph. Any call to `process` or
                           * `processFrame` after `stop` will be ignored.
                           *
                           * @see {@link module:core.BaseLfo#finalizeStream}
                           * @see {@link module:common.source.EventIn#start}
                           */ }, { key: 'stop', value: function stop() {
                              if (this.started && this._startTime !== null) {
                                   var currentTime = this._getTime();var endTime = this.frame.time + (currentTime - this._systemTime);this.finalizeStream(endTime);this.started = false;
                              }
                         } /** @private */ }, { key: 'processStreamParams', value: function processStreamParams() {
                              var frameSize = this.params.get('frameSize');var frameType = this.params.get('frameType');var sampleRate = this.params.get('sampleRate');var frameRate = this.params.get('frameRate');var description = this.params.get('description'); // init operator's stream params
                              this.streamParams.frameSize = frameType === 'scalar' ? 1 : frameSize;this.streamParams.frameType = frameType;this.streamParams.description = description;if (frameType === 'signal') {
                                   if (sampleRate === null) throw new Error('Undefined "sampleRate" for "signal" stream');this.streamParams.sourceSampleRate = sampleRate;this.streamParams.frameRate = sampleRate / frameSize;this.streamParams.sourceSampleCount = frameSize;
                              } else if (frameType === 'vector' || frameType === 'scalar') {
                                   if (frameRate === null) throw new Error('Undefined "frameRate" for "' + frameType + '" stream');this.streamParams.frameRate = frameRate;this.streamParams.sourceSampleRate = frameRate;this.streamParams.sourceSampleCount = 1;
                              }this.propagateStreamParams();
                         } /** @private */ }, { key: 'processFunction', value: function processFunction(frame) {
                              var currentTime = this._getTime();var inData = frame.data.length ? frame.data : [frame.data];var outData = this.frame.data; // if no time provided, use system time
                              var time = (0, _isFinite2.default)(frame.time) ? frame.time : currentTime;if (this._startTime === null) this._startTime = time;if (this._absoluteTime === false) time = time - this._startTime;for (var i = 0, l = this.streamParams.frameSize; i < l; i++) {
                                   outData[i] = inData[i];
                              }this.frame.time = time;this.frame.metadata = frame.metadata; // store current time to compute `endTime` on stop
                              this._systemTime = currentTime;
                         } /**
                           * Alternative interface to propagate a frame in the graph. Pack `time`,
                           * `data` and `metadata` in a frame object.
                           *
                           * @param {Number} time - Frame time.
                           * @param {Float32Array|Array} data - Frame data.
                           * @param {Object} metadata - Optionnal frame metadata.
                           *
                           * @example
                           * eventIn.process(1, [0, 1, 2]);
                           * // is equivalent to
                           * eventIn.processFrame({ time: 1, data: [0, 1, 2] });
                           */ }, { key: 'process', value: function process(time, data) {
                              var metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;this.processFrame({ time: time, data: data, metadata: metadata });
                         } /**
                           * Propagate a frame object in the graph.
                           *
                           * @param {Object} frame - Input frame.
                           * @param {Number} frame.time - Frame time.
                           * @param {Float32Array|Array} frame.data - Frame data.
                           * @param {Object} [frame.metadata=undefined] - Optionnal frame metadata.
                           *
                           * @example
                           * eventIn.processFrame({ time: 1, data: [0, 1, 2] });
                           */ }, { key: 'processFrame', value: function processFrame(frame) {
                              if (!this.started) return;this.prepareFrame();this.processFunction(frame);this.propagateFrame();
                         } }]);return EventIn;
               }((0, _SourceMixin3.default)(_BaseLfo2.default));exports.default = EventIn;
          }).call(this, require('_process'));
     }, { "../../core/BaseLfo": 182, "../../core/SourceMixin": 183, "_process": 188, "babel-runtime/core-js/number/is-finite": 5, "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 180: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true }); // shortcuts / helpers
          var PI = Math.PI;var cos = Math.cos;var sin = Math.sin;var sqrt = Math.sqrt; // window creation functions
          function initHannWindow(buffer, size, normCoefs) {
               var linSum = 0;var powSum = 0;var step = 2 * PI / size;for (var i = 0; i < size; i++) {
                    var phi = i * step;var value = 0.5 - 0.5 * cos(phi);buffer[i] = value;linSum += value;powSum += value * value;
               }normCoefs.linear = size / linSum;normCoefs.power = sqrt(size / powSum);
          }function initHammingWindow(buffer, size, normCoefs) {
               var linSum = 0;var powSum = 0;var step = 2 * PI / size;for (var i = 0; i < size; i++) {
                    var phi = i * step;var value = 0.54 - 0.46 * cos(phi);buffer[i] = value;linSum += value;powSum += value * value;
               }normCoefs.linear = size / linSum;normCoefs.power = sqrt(size / powSum);
          }function initBlackmanWindow(buffer, size, normCoefs) {
               var linSum = 0;var powSum = 0;var step = 2 * PI / size;for (var i = 0; i < size; i++) {
                    var phi = i * step;var value = 0.42 - 0.5 * cos(phi) + 0.08 * cos(2 * phi);buffer[i] = value;linSum += value;powSum += value * value;
               }normCoefs.linear = size / linSum;normCoefs.power = sqrt(size / powSum);
          }function initBlackmanHarrisWindow(buffer, size, normCoefs) {
               var linSum = 0;var powSum = 0;var a0 = 0.35875;var a1 = 0.48829;var a2 = 0.14128;var a3 = 0.01168;var step = 2 * PI / size;for (var i = 0; i < size; i++) {
                    var phi = i * step;var value = a0 - a1 * cos(phi) + a2 * cos(2 * phi);-a3 * cos(3 * phi);buffer[i] = value;linSum += value;powSum += value * value;
               }normCoefs.linear = size / linSum;normCoefs.power = sqrt(size / powSum);
          }function initSineWindow(buffer, size, normCoefs) {
               var linSum = 0;var powSum = 0;var step = PI / size;for (var i = 0; i < size; i++) {
                    var phi = i * step;var value = sin(phi);buffer[i] = value;linSum += value;powSum += value * value;
               }normCoefs.linear = size / linSum;normCoefs.power = sqrt(size / powSum);
          }function initRectangleWindow(buffer, size, normCoefs) {
               for (var i = 0; i < size; i++) {
                    buffer[i] = 1;
               } // @todo - check if these are proper values
               normCoefs.linear = 1;normCoefs.power = 1;
          } /**
            * Create a buffer with window signal.
            *
            * @memberof module:common.utils
            *
            * @param {String} name - Name of the window.
            * @param {Float32Array} buffer - Buffer to be populated with the window signal.
            * @param {Number} size - Size of the buffer.
            * @param {Object} normCoefs - Object to be populated with the normailzation
            *  coefficients.
            */function initWindow(name, buffer, size, normCoefs) {
               name = name.toLowerCase();switch (name) {case 'hann':case 'hanning':
                         initHannWindow(buffer, size, normCoefs);break;case 'hamming':
                         initHammingWindow(buffer, size, normCoefs);break;case 'blackman':
                         initBlackmanWindow(buffer, size, normCoefs);break;case 'blackmanharris':
                         initBlackmanHarrisWindow(buffer, size, normCoefs);break;case 'sine':
                         initSineWindow(buffer, size, normCoefs);break;case 'rectangle':
                         initRectangleWindow(buffer, size, normCoefs);break;}
          }exports.default = initWindow;
     }, {}], 181: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });exports.decoders = exports.encoders = exports.opcodes = undefined;var _stringify = require('babel-runtime/core-js/json/stringify');var _stringify2 = _interopRequireDefault(_stringify);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          } //http://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer
          // converts a nodejs Buffer to ArrayBuffer
          // export function bufferToArrayBuffer(buffer) {
          //   const ab = new ArrayBuffer(buffer.length);
          //   const view = new Uint8Array(ab);
          //   for (let i = 0; i < buffer.length; ++i)
          //     view[i] = buffer[i];
          //   return ab;
          // }
          // export function arrayBufferToBuffer(arrayBuffer) {
          //   const buffer = new Buffer(arrayBuffer.byteLength);
          //   const view = new Uint8Array(arrayBuffer);
          //   for (let i = 0; i < buffer.length; ++i)
          //     buffer[i] = view[i];
          //   return buffer;
          // }
          // http://updates.html5rocks.com/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
          function Uint16Array2json(arr) {
               var str = String.fromCharCode.apply(null, arr);return JSON.parse(str.replace(/\u0000/g, ''));
          }function json2Uint16Array(json) {
               var str = (0, _stringify2.default)(json);var buffer = new ArrayBuffer(str.length * 2); // 2 bytes for each char
               var bufferView = new Uint16Array(buffer);for (var i = 0, l = str.length; i < l; i++) {
                    bufferView[i] = str.charCodeAt(i);
               }return bufferView;
          }var opcodes = exports.opcodes = { INIT_MODULE_REQ: 10, INIT_MODULE_ACK: 11, PROCESS_STREAM_PARAMS: 12, RESET_STREAM: 13, FINALIZE_STREAM: 14, PROCESS_FRAME: 15 //
          };var encoders = exports.encoders = { opcode: function opcode(name) {
                    var opcode = opcodes[name];var buffer = new Uint16Array(1);buffer[0] = opcode;return buffer;
               }, // `opcode`    2 bytes (Uint16) |
               initModuleReq: function initModuleReq() {
                    var payload = encoders.opcode('INIT_MODULE_REQ');return payload.buffer;
               }, // `opcode`    2 bytes (Uint16) |
               initModuleAck: function initModuleAck() {
                    var payload = encoders.opcode('INIT_MODULE_ACK');return payload.buffer;
               }, // `opcode`    2 bytes (Uint16) |
               // `streamParams`  n bytes (Uint16)
               streamParams: function streamParams(_streamParams) {
                    var opcode = encoders.opcode('PROCESS_STREAM_PARAMS');var streamParamsBuffer = json2Uint16Array(_streamParams);var payload = new Uint16Array(1 + streamParamsBuffer.length);payload.set(opcode, 0);payload.set(streamParamsBuffer, 1);return payload.buffer;
               }, // `opcode`    2 bytes (Uint16) |
               resetStream: function resetStream() {
                    var payload = encoders.opcode('RESET_STREAM');return payload.buffer;
               }, // `opcode`    2 bytes (Uint16) |
               // `endTime`   8 bytes (Float64)
               finalizeStream: function finalizeStream(endTime) {
                    var opcode = encoders.opcode('RESET_STREAM');var endTimeBuffer = new Float64Array(1);endTimeBuffer[0] = endTime;var payload = new Uint16Array(1 + 4);payload.set(opcode, 0);payload.set(new Uint16Array(endTimeBuffer.buffer), 1);return payload.buffer;
               }, // `opcode`    2 bytes (Uint16) |
               // `time`      8 bytes (Float64) |
               // `data`      frameSize * 4 (Float32) |
               // `metadata`  n bytes (Uint16)
               processFrame: function processFrame(frame, frameSize) {
                    var opcode = encoders.opcode('PROCESS_FRAME');var time = new Float64Array(1);time[0] = frame.time;var data = new Float32Array(frameSize);for (var i = 0; i < frameSize; i++) {
                         data[i] = frame.data[i];
                    }var metadata = json2Uint16Array(frame.metadata);var length = 1 + 4 + 2 * frameSize + metadata.length;var payload = new Uint16Array(length);payload.set(opcode, 0);payload.set(new Uint16Array(time.buffer), 1);payload.set(new Uint16Array(data.buffer), 1 + 4);payload.set(metadata, 1 + 4 + 2 * frameSize);return payload.buffer;
               } };var decoders = exports.decoders = { opcode: function opcode(arrayBuffer) {
                    return new Uint16Array(arrayBuffer)[0];
               }, // `opcode`    2 bytes (Uint16) |
               // `streamParams`  n bytes (Uint16)
               streamParams: function streamParams(arrayBuffer) {
                    var payload = new Uint16Array(arrayBuffer.slice(2));var prevStreamParams = Uint16Array2json(payload);return prevStreamParams;
               }, // `opcode`    2 bytes (Uint16) |
               // `endTime`   8 bytes (Float64)
               finalizeStream: function finalizeStream(arrayBuffer) {
                    return new Float64Array(arrayBuffer.slice(2))[0];
               }, // `opcode`    2 bytes (Uint16) |
               // `time`      8 bytes (Float64) |
               // `data`      frameSize * 4 (Float32) |
               // `metadata`  n bytes (Uint16)
               processFrame: function processFrame(arrayBuffer, frameSize) {
                    // 1 * 8 bytes
                    var timeStart = 2;var timeEnd = timeStart + 8;var time = new Float64Array(arrayBuffer.slice(timeStart, timeEnd))[0]; // frameSize * 4 bytes
                    var dataStart = timeEnd;var dataEnd = dataStart + 4 * frameSize;var data = new Float32Array(arrayBuffer.slice(dataStart, dataEnd)); // rest of payload
                    var metaStart = dataEnd;var metaBuffer = new Uint16Array(arrayBuffer.slice(metaStart));var metadata = Uint16Array2json(metaBuffer);return { time: time, data: data, metadata: metadata };
               } };
     }, { "babel-runtime/core-js/json/stringify": 3 }], 182: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _assign = require('babel-runtime/core-js/object/assign');var _assign2 = _interopRequireDefault(_assign);var _promise = require('babel-runtime/core-js/promise');var _promise2 = _interopRequireDefault(_promise);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _parameters = require('@ircam/parameters');var _parameters2 = _interopRequireDefault(_parameters);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var id = 0; /**
                       * Base `lfo` class to be extended in order to create new nodes.
                       *
                       * Nodes are divided in 3 categories:
                       * - **`source`** are responsible for acquering a signal and its properties
                       *   (frameRate, frameSize, etc.)
                       * - **`sink`** are endpoints of the graph, such nodes can be recorders,
                       *   visualizers, etc.
                       * - **`operator`** are used to make computation on the input signal and
                       *   forward the results below in the graph.
                       *
                       * In most cases the methods to override / extend are:
                       * - the **`constructor`** to define the parameters of the new lfo node.
                       * - the **`processStreamParams`** method to define how the node modify the
                       *   stream attributes (e.g. by changing the frame size)
                       * - the **`process{FrameType}`** method to define the operations that the
                       *   node apply on the stream. The type of input a node can handle is defined
                       *   by its implemented interface, if it implements `processSignal`, a stream
                       *   of type `signal` can be processed, `processVector` to handle
                       *   an input of type `vector`.
                       *
                       * <span class="warning">_This class should be considered abstract and only
                       * be used as a base class to extend._</span>
                       *
                       * #### overview of the interface
                       *
                       * **initModule**
                       *
                       * Returns a Promise that resolves when the module is initialized. Is
                       * especially important for modules that rely on asynchronous underlying APIs.
                       *
                       * **processStreamParams(prevStreamParams)**
                       *
                       * `base` class (default implementation)
                       * - call `prepareStreamParams`
                       * - call `propagateStreamParams`
                       *
                       * `child` class
                       * - override some of the inherited `streamParams`
                       * - creates the any related logic buffers
                       * - call `propagateStreamParams`
                       *
                       * _should not call `super.processStreamParams`_
                       *
                       * **prepareStreamParams()**
                       *
                       * - assign prevStreamParams to this.streamParams
                       * - check if the class implements the correct `processInput` method
                       *
                       * _shouldn't be extended, only consumed in `processStreamParams`_
                       *
                       * **propagateStreamParams()**
                       *
                       * - creates the `frameData` buffer
                       * - propagate `streamParams` to children
                       *
                       * _shouldn't be extended, only consumed in `processStreamParams`_
                       *
                       * **processFrame()**
                       *
                       * `base` class (default implementation)
                       * - call `prepareFrame`
                       * - assign frameTime and frameMetadata to identity
                       * - call the proper function according to inputType
                       * - call `propagateFrame`
                       *
                       * `child` class
                       * - call `prepareFrame`
                       * - do whatever you want with incomming frame
                       * - call `propagateFrame`
                       *
                       * _should not call `super.processFrame`_
                       *
                       * **prepareFrame()**
                       *
                       * - if `reinit` and trigger `processStreamParams` if needed
                       *
                       * _shouldn't be extended, only consumed in `processFrame`_
                       *
                       * **propagateFrame()**
                       *
                       * - propagate frame to children
                       *
                       * _shouldn't be extended, only consumed in `processFrame`_
                       *
                       * @memberof module:core
                       */var BaseLfo = function () {
               function BaseLfo() {
                    var definitions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};(0, _classCallCheck3.default)(this, BaseLfo);this.cid = id++; /**
                                                                                                                                                                                                                                                                * Parameter bag containing parameter instances.
                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                * @type {Object}
                                                                                                                                                                                                                                                                * @name params
                                                                                                                                                                                                                                                                * @instance
                                                                                                                                                                                                                                                                * @memberof module:core.BaseLfo
                                                                                                                                                                                                                                                                */this.params = (0, _parameters2.default)(definitions, options); // listen for param updates
                    this.params.addListener(this.onParamUpdate.bind(this)); /**
                                                                            * Description of the stream output of the node.
                                                                            * Set to `null` when the node is destroyed.
                                                                            *
                                                                            * @type {Object}
                                                                            * @property {Number} frameSize - Frame size at the output of the node.
                                                                            * @property {Number} frameRate - Frame rate at the output of the node.
                                                                            * @property {String} frameType - Frame type at the output of the node,
                                                                            *  possible values are `signal`, `vector` or `scalar`.
                                                                            * @property {Array|String} description - If type is `vector`, describe
                                                                            *  the dimension(s) of output stream.
                                                                            * @property {Number} sourceSampleRate - Sample rate of the source of the
                                                                            *  graph. _The value should be defined by sources and never modified_.
                                                                            * @property {Number} sourceSampleCount - Number of consecutive discrete
                                                                            *  time values contained in the data frame output by the source.
                                                                            *  _The value should be defined by sources and never modified_.
                                                                            *
                                                                            * @name streamParams
                                                                            * @instance
                                                                            * @memberof module:core.BaseLfo
                                                                            */this.streamParams = { frameType: null, frameSize: 1, frameRate: 0, description: null, sourceSampleRate: 0, sourceSampleCount: null }; /**
                                                                                                                                                                                                                    * Current frame. This object and its data are updated at each incomming
                                                                                                                                                                                                                    * frame without reallocating memory.
                                                                                                                                                                                                                    *
                                                                                                                                                                                                                    * @type {Object}
                                                                                                                                                                                                                    * @name frame
                                                                                                                                                                                                                    * @property {Number} time - Time of the current frame.
                                                                                                                                                                                                                    * @property {Float32Array} data - Data of the current frame.
                                                                                                                                                                                                                    * @property {Object} metadata - Metadata associted to the current frame.
                                                                                                                                                                                                                    * @instance
                                                                                                                                                                                                                    * @memberof module:core.BaseLfo
                                                                                                                                                                                                                    */this.frame = { time: 0, data: null, metadata: {} }; /**
                                                                                                                                                                                                                                                                          * List of nodes connected to the ouput of the node (lower in the graph).
                                                                                                                                                                                                                                                                          * At each frame, the node forward its `frame` to to all its `nextModules`.
                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                          * @type {Array<BaseLfo>}
                                                                                                                                                                                                                                                                          * @name nextModules
                                                                                                                                                                                                                                                                          * @instance
                                                                                                                                                                                                                                                                          * @memberof module:core.BaseLfo
                                                                                                                                                                                                                                                                          * @see {@link module:core.BaseLfo#connect}
                                                                                                                                                                                                                                                                          * @see {@link module:core.BaseLfo#disconnect}
                                                                                                                                                                                                                                                                          */this.nextModules = []; /**
                                                                                                                                                                                                                                                                                                   * The node from which the node receive the frames (upper in the graph).
                                                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                                                   * @type {BaseLfo}
                                                                                                                                                                                                                                                                                                   * @name prevModule
                                                                                                                                                                                                                                                                                                   * @instance
                                                                                                                                                                                                                                                                                                   * @memberof module:core.BaseLfo
                                                                                                                                                                                                                                                                                                   * @see {@link module:core.BaseLfo#connect}
                                                                                                                                                                                                                                                                                                   * @see {@link module:core.BaseLfo#disconnect}
                                                                                                                                                                                                                                                                                                   */this.prevModule = null; /**
                                                                                                                                                                                                                                                                                                                             * Is set to true when a static parameter is updated. On the next input
                                                                                                                                                                                                                                                                                                                             * frame all the subgraph streamParams starting from this node will be
                                                                                                                                                                                                                                                                                                                             * updated.
                                                                                                                                                                                                                                                                                                                             *
                                                                                                                                                                                                                                                                                                                             * @type {Boolean}
                                                                                                                                                                                                                                                                                                                             * @name _reinit
                                                                                                                                                                                                                                                                                                                             * @instance
                                                                                                                                                                                                                                                                                                                             * @memberof module:core.BaseLfo
                                                                                                                                                                                                                                                                                                                             * @private
                                                                                                                                                                                                                                                                                                                             */this._reinit = false;
               } /**
                 * Returns an object describing each available parameter of the node.
                 *
                 * @return {Object}
                 */(0, _createClass3.default)(BaseLfo, [{ key: 'getParamsDescription', value: function getParamsDescription() {
                         return this.params.getDefinitions();
                    } /**
                      * Reset all parameters to their initial value (as defined on instantication)
                      *
                      * @see {@link module:core.BaseLfo#streamParams}
                      */ }, { key: 'resetParams', value: function resetParams() {
                         this.params.reset();
                    } /**
                      * Function called when a param is updated. By default set the `_reinit`
                      * flag to `true` if the param is `static` one. This method should be
                      * extended to handle particular logic bound to a specific parameter.
                      *
                      * @param {String} name - Name of the parameter.
                      * @param {Mixed} value - Value of the parameter.
                      * @param {Object} metas - Metadata associated to the parameter.
                      */ }, { key: 'onParamUpdate', value: function onParamUpdate(name, value) {
                         var metas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};if (metas.kind === 'static') this._reinit = true;
                    } /**
                      * Connect the current node (`prevModule`) to another node (`nextOp`).
                      * A given node can be connected to several operators and propagate frames
                      * to each of them.
                      *
                      * @param {BaseLfo} next - Next operator in the graph.
                      * @see {@link module:core.BaseLfo#processFrame}
                      * @see {@link module:core.BaseLfo#disconnect}
                      */ }, { key: 'connect', value: function connect(next) {
                         var _this = this;if (this.streamParams === null || next.streamParams === null) throw new Error('Invalid connection: cannot connect a dead node');if (this.streamParams.frameType !== null) {
                              // graph has already been started
                              // next.processStreamParams(this.streamParams);
                              next.initModule().then(function () {
                                   next.processStreamParams(_this.streamParams); // we can forward frame from now
                                   _this.nextModules.push(next);next.prevModule = _this;
                              });
                         } else {
                              this.nextModules.push(next);next.prevModule = this;
                         }
                    } /**
                      * Remove the given operator from its previous operators' `nextModules`.
                      *
                      * @param {BaseLfo} [next=null] - The operator to disconnect from the current
                      *  operator. If `null` disconnect all the next operators.
                      */ }, { key: 'disconnect', value: function disconnect() {
                         var _this2 = this;var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;if (next === null) {
                              this.nextModules.forEach(function (next) {
                                   return _this2.disconnect(next);
                              });
                         } else {
                              var index = this.nextModules.indexOf(this);this.nextModules.splice(index, 1);next.prevModule = null;
                         }
                    } /**
                      * Destroy all the nodes in the sub-graph starting from the current node.
                      * When detroyed, the `streamParams` of the node are set to `null`, the
                      * operator is then considered as `dead` and cannot be reconnected.
                      *
                      * @see {@link module:core.BaseLfo#connect}
                      */ }, { key: 'destroy', value: function destroy() {
                         // destroy all chidren
                         var index = this.nextModules.length;while (index--) {
                              this.nextModules[index].destroy();
                         } // disconnect itself from the previous operator
                         if (this.prevModule) this.prevModule.disconnect(this); // mark the object as dead
                         this.streamParams = null;
                    } /**
                      * Return a `Promise` that resolve when the module is ready to be consumed.
                      * Some modules relies on asynchronous APIs at initialization and thus could
                      * be not ready to be consumed when the graph starts.
                      * A module should be consider as initialized when all next modules (children)
                      * are themselves initialized. The event bubbles up from sinks to sources.
                      * When all its next operators are ready, a source can consider the whole graph
                      * as ready and then start to produce frames.
                      * The default implementation resolves when all next operators are resolved
                      * themselves.
                      * An operator relying on external async API must override this method to
                      * resolve only when its dependecy is ready.
                      *
                      * @return Promise
                      * @todo - Handle dynamic connections
                      */ }, { key: 'initModule', value: function initModule() {
                         var nextPromises = this.nextModules.map(function (module) {
                              return module.initModule();
                         });return _promise2.default.all(nextPromises);
                    } /**
                      * Helper to initialize the stream in standalone mode.
                      *
                      * @param {Object} [streamParams={}] - Parameters of the stream.
                      *
                      * @see {@link module:core.BaseLfo#processStreamParams}
                      * @see {@link module:core.BaseLfo#resetStream}
                      */ }, { key: 'initStream', value: function initStream() {
                         var streamParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};this.processStreamParams(streamParams);this.resetStream();
                    } /**
                      * Reset the `frame.data` buffer by setting all its values to 0.
                      * A source operator should call `processStreamParams` and `resetStream` when
                      * started, each of these method propagate through the graph automaticaly.
                      *
                      * @see {@link module:core.BaseLfo#processStreamParams}
                      */ }, { key: 'resetStream', value: function resetStream() {
                         // buttom up
                         for (var i = 0, l = this.nextModules.length; i < l; i++) {
                              this.nextModules[i].resetStream();
                         } // no buffer for `scalar` type or sink node
                         // @note - this should be reviewed
                         if (this.streamParams.frameType !== 'scalar' && this.frame.data !== null) {
                              var frameSize = this.streamParams.frameSize;var data = this.frame.data;for (var _i = 0; _i < frameSize; _i++) {
                                   data[_i] = 0;
                              }
                         }
                    } /**
                      * Finalize the stream. A source node should call this method when stopped,
                      * `finalizeStream` is automatically propagated throught the graph.
                      *
                      * @param {Number} endTime - Logical time at which the graph is stopped.
                      */ }, { key: 'finalizeStream', value: function finalizeStream(endTime) {
                         for (var i = 0, l = this.nextModules.length; i < l; i++) {
                              this.nextModules[i].finalizeStream(endTime);
                         }
                    } /**
                      * Initialize or update the operator's `streamParams` according to the
                      * previous operators `streamParams` values.
                      *
                      * When implementing a new operator this method should:
                      * 1. call `this.prepareStreamParams` with the given `prevStreamParams`
                      * 2. optionnally change values to `this.streamParams` according to the
                      *    logic performed by the operator.
                      * 3. optionnally allocate memory for ring buffers, etc.
                      * 4. call `this.propagateStreamParams` to trigger the method on the next
                      *    operators in the graph.
                      *
                      * @param {Object} prevStreamParams - `streamParams` of the previous operator.
                      *
                      * @see {@link module:core.BaseLfo#prepareStreamParams}
                      * @see {@link module:core.BaseLfo#propagateStreamParams}
                      */ }, { key: 'processStreamParams', value: function processStreamParams() {
                         var prevStreamParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};this.prepareStreamParams(prevStreamParams);this.propagateStreamParams();
                    } /**
                      * Common logic to do at the beginning of the `processStreamParam`, must be
                      * called at the beginning of any `processStreamParam` implementation.
                      *
                      * The method mainly check if the current node implement the interface to
                      * handle the type of frame propagated by it's parent:
                      * - to handle a `vector` frame type, the class must implement `processVector`
                      * - to handle a `signal` frame type, the class must implement `processSignal`
                      * - in case of a 'scalar' frame type, the class can implement any of the
                      * following by order of preference: `processScalar`, `processVector`,
                      * `processSignal`.
                      *
                      * @param {Object} prevStreamParams - `streamParams` of the previous operator.
                      *
                      * @see {@link module:core.BaseLfo#processStreamParams}
                      * @see {@link module:core.BaseLfo#propagateStreamParams}
                      */ }, { key: 'prepareStreamParams', value: function prepareStreamParams() {
                         var prevStreamParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};(0, _assign2.default)(this.streamParams, prevStreamParams);var prevFrameType = prevStreamParams.frameType;switch (prevFrameType) {case 'scalar':
                                   if (this.processScalar) this.processFunction = this.processScalar;else if (this.processVector) this.processFunction = this.processVector;else if (this.processSignal) this.processFunction = this.processSignal;else throw new Error(this.constructor.name + ' - no "process" function found');break;case 'vector':
                                   if (!('processVector' in this)) throw new Error(this.constructor.name + ' - "processVector" is not defined');this.processFunction = this.processVector;break;case 'signal':
                                   if (!('processSignal' in this)) throw new Error(this.constructor.name + ' - "processSignal" is not defined');this.processFunction = this.processSignal;break;default:
                                   // defaults to processFunction
                                   break;}
                    } /**
                      * Create the `this.frame.data` buffer and forward the operator's `streamParam`
                      * to all its next operators, must be called at the end of any
                      * `processStreamParams` implementation.
                      *
                      * @see {@link module:core.BaseLfo#processStreamParams}
                      * @see {@link module:core.BaseLfo#prepareStreamParams}
                      */ }, { key: 'propagateStreamParams', value: function propagateStreamParams() {
                         this.frame.data = new Float32Array(this.streamParams.frameSize);for (var i = 0, l = this.nextModules.length; i < l; i++) {
                              this.nextModules[i].processStreamParams(this.streamParams);
                         }
                    } /**
                      * Define the particular logic the operator applies to the stream.
                      * According to the frame type of the previous node, the method calls one
                      * of the following method `processVector`, `processSignal` or `processScalar`
                      *
                      * @param {Object} frame - Frame (time, data, and metadata) as given by the
                      *  previous operator. The incomming frame should never be modified by
                      *  the operator.
                      *
                      * @see {@link module:core.BaseLfo#prepareFrame}
                      * @see {@link module:core.BaseLfo#propagateFrame}
                      * @see {@link module:core.BaseLfo#processStreamParams}
                      */ }, { key: 'processFrame', value: function processFrame(frame) {
                         this.prepareFrame(); // frameTime and frameMetadata defaults to identity
                         this.frame.time = frame.time;this.frame.metadata = frame.metadata;this.processFunction(frame);this.propagateFrame();
                    } /**
                      * Pointer to the method called in `processFrame` according to the
                      * frame type of the previous operator. Is dynamically assigned in
                      * `prepareStreamParams`.
                      *
                      * @see {@link module:core.BaseLfo#prepareStreamParams}
                      * @see {@link module:core.BaseLfo#processFrame}
                      */ }, { key: 'processFunction', value: function processFunction(frame) {
                         this.frame = frame;
                    } /**
                      * Common logic to perform at the beginning of the `processFrame`.
                      *
                      * @see {@link module:core.BaseLfo#processFrame}
                      */ }, { key: 'prepareFrame', value: function prepareFrame() {
                         if (this._reinit === true) {
                              var streamParams = this.prevModule !== null ? this.prevModule.streamParams : {};this.initStream(streamParams);this._reinit = false;
                         }
                    } /**
                      * Forward the current `frame` to the next operators, is called at the end of
                      * `processFrame`.
                      *
                      * @see {@link module:core.BaseLfo#processFrame}
                      */ }, { key: 'propagateFrame', value: function propagateFrame() {
                         for (var i = 0, l = this.nextModules.length; i < l; i++) {
                              this.nextModules[i].processFrame(this.frame);
                         }
                    } }]);return BaseLfo;
          }();exports.default = BaseLfo;
     }, { "@ircam/parameters": 2, "babel-runtime/core-js/object/assign": 6, "babel-runtime/core-js/promise": 12, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16 }], 183: [function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });var _promise = require("babel-runtime/core-js/promise");var _promise2 = _interopRequireDefault(_promise);var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require("babel-runtime/helpers/createClass");var _createClass3 = _interopRequireDefault(_createClass2);var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);var _inherits2 = require("babel-runtime/helpers/inherits");var _inherits3 = _interopRequireDefault(_inherits2);function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          } /**
            * Interface added to `LfoCore to implement source
            *
            * Source have some responsability on graph as they mostly control its whole
            * lifecycle. They must implement the start and stop method in order to
            * make sure the graph is initialized and set `started` to true.
            * A source should never accept and propagate incomming frames until `started`
            * is set to `true`.
            *
            * @name SourceMixin
            * @memberof module:core
            * @mixin
            *
            * @example
            * class MySource extends SourceMixin(BaseLfo) {}
            */var SourceMixin = function SourceMixin(superclass) {
               return function (_superclass) {
                    (0, _inherits3.default)(_class, _superclass);function _class() {
                         var _ref;(0, _classCallCheck3.default)(this, _class);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                              args[_key] = arguments[_key];
                         }var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = _class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call.apply(_ref, [this].concat(args)));_this.initialized = false;_this.initPromise = null;_this.started = false;_this.start = _this.start.bind(_this);_this.stop = _this.stop.bind(_this);return _this;
                    } /**
                      * Initialize the graph by calling `initModule`. When the returned `Promise`
                      * fulfills, the graph can be considered as initialized and `start` can be
                      * called safely. If `start` is called whithout explicit `init`, `init` is
                      * made internally, actual start of the graph is then not garanteed to be
                      * synchronous.
                      *
                      * @memberof module:core.SourceMixin
                      * @instance
                      * @name init
                      *
                      * @return Promise
                      *
                      * @example
                      * // safe initialization and start
                      * source.init().then(() => source.start())
                      * // safe initialization and start
                      * source.start();
                      */(0, _createClass3.default)(_class, [{ key: "init", value: function init() {
                              var _this2 = this;this.initPromise = this.initModule().then(function () {
                                   _this2.initStream(); // this is synchronous
                                   _this2.initialized = true;return _promise2.default.resolve(true);
                              });return this.initPromise;
                         } /**
                           * Interface method to implement that starts the graph.
                           *
                           * The method main purpose is to make sure take verify initialization step and
                           * set `started` to `true` when done.
                           * Should behave synchronously when called inside `init().then()` and async
                           * if called without init step.
                           *
                           * @memberof module:core.SourceMixin
                           * @instance
                           * @name start
                           *
                           * @example
                           * // basic `start` implementation
                           * start() {
                           *   if (this.initialized === false) {
                           *     if (this.initPromise === null) // init has not yet been called
                           *       this.initPromise = this.init();
                           *
                           *     this.initPromise.then(this.start);
                           *     return;
                           *   }
                           *
                           *   this.started = true;
                           * }
                           */ }, { key: "start", value: function start() {} /**
                                                                            * Interface method to implement that stops the graph.
                                                                            *
                                                                            * @memberof module:core.SourceMixin
                                                                            * @instance
                                                                            * @name stop
                                                                            *
                                                                            * @example
                                                                            * // basic `stop` implementation
                                                                            * stop() {
                                                                            *   this.started = false;
                                                                            * }
                                                                            */ }, { key: "stop", value: function stop() {} /**
                                                                                                                           * The implementation should never allow incomming frames
                                                                                                                           * if `this.started` is not `true`.
                                                                                                                           *
                                                                                                                           * @memberof module:core.SourceMixin
                                                                                                                           * @instance
                                                                                                                           * @name processFrame
                                                                                                                           *
                                                                                                                           * @param {Object} frame
                                                                                                                           *
                                                                                                                           * @example
                                                                                                                           * // basic `processFrame` implementation
                                                                                                                           * processFrame(frame) {
                                                                                                                           *   if (this.started === true) {
                                                                                                                           *     this.prepareFrame();
                                                                                                                           *     this.processFunction(frame);
                                                                                                                           *     this.propagateFrame();
                                                                                                                           *   }
                                                                                                                           * }
                                                                                                                           */ }, { key: "processFrame", value: function processFrame(frame) {} }]);return _class;
               }(superclass);
          };exports.default = SourceMixin;
     }, { "babel-runtime/core-js/object/get-prototype-of": 10, "babel-runtime/core-js/promise": 12, "babel-runtime/helpers/classCallCheck": 15, "babel-runtime/helpers/createClass": 16, "babel-runtime/helpers/inherits": 19, "babel-runtime/helpers/possibleConstructorReturn": 20 }], 184: [function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, "__esModule", { value: true });var _BaseLfo = require('./BaseLfo');Object.defineProperty(exports, 'BaseLfo', { enumerable: true, get: function get() {
                    return _interopRequireDefault(_BaseLfo).default;
               } });var _SourceMixin = require('./SourceMixin');Object.defineProperty(exports, 'SourceMixin', { enumerable: true, get: function get() {
                    return _interopRequireDefault(_SourceMixin).default;
               } });function _interopRequireDefault(obj) {
               return obj && obj.__esModule ? obj : { default: obj };
          }var version = exports.version = '1.1.6';
     }, { "./BaseLfo": 182, "./SourceMixin": 183 }], 185: [function (require, module, exports) {
          (function () {
               var Socket,
                   myoList = {};if (typeof window !== 'undefined') {
                    if (!("WebSocket" in window)) throw "MYO: Websockets are not supported by your browser :(";Socket = WebSocket;
               }var Myo = { defaults: { api_version: 3, socket_url: "ws://127.0.0.1:10138/myo/", app_id: 'com.myojs.default' }, lockingPolicy: 'standard', events: [], myos: [], onError: function onError() {
                         throw 'MYO: Error with the socket connection. Myo Connect might not be running. If it is, double check the API version.';
                    }, setLockingPolicy: function setLockingPolicy(policy) {
                         Myo.socket.send(JSON.stringify(['command', { "command": "set_locking_policy", "type": policy }]));Myo.lockingPolicy = policy;return Myo;
                    }, trigger: function trigger(eventName) {
                         var args = Array.prototype.slice.apply(arguments).slice(1);emitter.trigger.call(Myo, Myo.events, eventName, args);return Myo;
                    }, on: function on(eventName, fn) {
                         return emitter.on(Myo.events, eventName, fn);
                    }, off: function off(eventName) {
                         Myo.events = emitter.off(Myo.events, eventName);return Myo;
                    }, connect: function connect(appId, socketLib) {
                         if (socketLib) Socket = socketLib;if (!Socket) throw "MYO: Must provide a socket library to use. Try 'Myo.setSocketLib('id', require('ws'))' before you connect.";if (appId) {
                              Myo.defaults.app_id = appId;
                         }Myo.socket = new Socket(Myo.defaults.socket_url + Myo.defaults.api_version + '?appid=' + Myo.defaults.app_id);Myo.socket.onmessage = Myo.handleMessage;Myo.socket.onopen = Myo.trigger.bind(Myo, 'ready');Myo.socket.onclose = Myo.trigger.bind(Myo, 'socket_closed');Myo.socket.onerror = Myo.onError;
                    }, disconnect: function disconnect() {
                         Myo.socket.close();
                    }, handleMessage: function handleMessage(msg) {
                         var data = JSON.parse(msg.data)[1];if (!data.type || typeof data.myo === 'undefined') return;if (data.type == 'paired') {
                              var exists = Myo.myos.some(function (myo) {
                                   return myo.macAddress == data.mac_address;
                              });if (!exists) {
                                   Myo.myos.push(Myo.create({ macAddress: data.mac_address, name: data.name, connectIndex: data.myo }));
                              }
                         }Myo.myos.map(function (myo) {
                              if (myo.connectIndex === data.myo) {
                                   var isStatusEvent = true;if (eventTable[data.type]) {
                                        isStatusEvent = eventTable[data.type](myo, data);
                                   }if (!eventTable[data.type] || isStatusEvent) {
                                        myo.trigger(data.type, data, data.timestamp);myo.trigger('status', data, data.timestamp);
                                   }
                              }
                         });
                    }, create: function create(props) {
                         var myoProps = utils.merge({ macAddress: undefined, name: undefined, connectIndex: undefined, locked: true, connected: false, synced: false, batteryLevel: 0, lastIMU: undefined, arm: undefined, direction: undefined, warmupState: undefined, orientationOffset: { x: 0, y: 0, z: 0, w: 1 }, events: [] }, props || {});return utils.merge(Object.create(Myo.methods), myoProps);
                    }, methods: { trigger: function trigger(eventName) {
                              var args = Array.prototype.slice.apply(arguments).slice(1);emitter.trigger.call(this, Myo.events, eventName, args);emitter.trigger.call(this, this.events, eventName, args);return this;
                         }, _trigger: function _trigger(eventName) {
                              var args = Array.prototype.slice.apply(arguments).slice(1);emitter.trigger.call(this, this.events, eventName, args);return this;
                         }, on: function on(eventName, fn) {
                              return emitter.on(this.events, eventName, fn);
                         }, off: function off(eventName) {
                              this.events = emitter.off(this.events, eventName);return this;
                         }, lock: function lock() {
                              Myo.socket.send(JSON.stringify(["command", { "command": "lock", "myo": this.connectIndex }]));return this;
                         }, unlock: function unlock(hold) {
                              Myo.socket.send(JSON.stringify(["command", { "command": "unlock", "myo": this.connectIndex, "type": hold ? "hold" : "timed" }]));return this;
                         }, zeroOrientation: function zeroOrientation() {
                              this.orientationOffset = utils.quatInverse(this.lastQuant);this.trigger('zero_orientation');return this;
                         }, vibrate: function vibrate(intensity) {
                              intensity = intensity || 'medium';Myo.socket.send(JSON.stringify(['command', { "command": "vibrate", "myo": this.connectIndex, "type": intensity }]));return this;
                         }, requestBluetoothStrength: function requestBluetoothStrength() {
                              Myo.socket.send(JSON.stringify(['command', { "command": "request_rssi", "myo": this.connectIndex }]));return this;
                         }, requestBatteryLevel: function requestBatteryLevel() {
                              Myo.socket.send(JSON.stringify(['command', { "command": "request_battery_level", "myo": this.connectIndex }]));return this;
                         }, streamEMG: function streamEMG(enabled) {
                              Myo.socket.send(JSON.stringify(['command', { "command": "set_stream_emg", "myo": this.connectIndex, "type": enabled ? 'enabled' : 'disabled' }]));return this;
                         } } };var eventTable = { //Stream Events
                    'pose': function pose(myo, data) {
                         if (myo.lastPose) {
                              myo.trigger(myo.lastPose + '_off');myo.trigger('pose_off', myo.lastPose);
                         }if (data.pose == 'rest') {
                              myo.trigger('rest');myo.lastPose = null;if (Myo.lockingPolicy === 'standard') myo.unlock();
                         } else {
                              myo.trigger(data.pose);myo.trigger('pose', data.pose);myo.lastPose = data.pose;if (Myo.lockingPolicy === 'standard') myo.unlock(true);
                         }
                    }, 'orientation': function orientation(myo, data) {
                         myo.lastQuant = data.orientation;var ori = utils.quatRotate(myo.orientationOffset, data.orientation);var imu_data = { orientation: ori, accelerometer: { x: data.accelerometer[0], y: data.accelerometer[1], z: data.accelerometer[2] }, gyroscope: { x: data.gyroscope[0], y: data.gyroscope[1], z: data.gyroscope[2] } };if (!myo.lastIMU) myo.lastIMU = imu_data;myo.trigger('orientation', imu_data.orientation, data.timestamp);myo.trigger('accelerometer', imu_data.accelerometer, data.timestamp);myo.trigger('gyroscope', imu_data.gyroscope, data.timestamp);myo.trigger('imu', imu_data, data.timestamp);myo.lastIMU = imu_data;
                    }, 'emg': function emg(myo, data) {
                         myo.trigger(data.type, data.emg, data.timestamp);
                    }, //Status Events
                    'arm_synced': function arm_synced(myo, data) {
                         myo.arm = data.arm;myo.direction = data.x_direction;myo.warmupState = data.warmup_state;myo.synced = true;return true;
                    }, 'arm_unsynced': function arm_unsynced(myo, data) {
                         myo.arm = undefined;myo.direction = undefined;myo.warmupState = undefined;myo.synced = false;return true;
                    }, 'connected': function connected(myo, data) {
                         myo.connectVersion = data.version.join('.');myo.connected = true;return true;
                    }, 'disconnected': function disconnected(myo, data) {
                         myo.connected = false;return true;
                    }, 'locked': function locked(myo, data) {
                         myo.locked = true;return true;
                    }, 'unlocked': function unlocked(myo, data) {
                         myo.locked = false;return true;
                    }, 'warmup_completed': function warmup_completed(myo, data) {
                         myo.warmupState = 'warm';return true;
                    }, 'rssi': function rssi(myo, data) {
                         data.bluetooth_strength = utils.getStrengthFromRssi(data.rssi);myo.trigger('bluetooth_strength', data.bluetooth_strength, data.timestamp);myo.trigger('rssi', data.rssi, data.timestamp);myo.trigger('status', data, data.timestamp);
                    }, 'battery_level': function battery_level(myo, data) {
                         myo.batteryLevel = data.battery_level;myo.trigger('battery_level', data.battery_level, data.timestamp);myo.trigger('status', data, data.timestamp);
                    } };var emitter = { eventCounter: 0, trigger: function trigger(events, eventName, args) {
                         var self = this;events.map(function (event) {
                              if (event.name == eventName) event.fn.apply(self, args);if (event.name == '*') {
                                   var args_temp = args.slice(0);args_temp.unshift(eventName);event.fn.apply(self, args_temp);
                              }
                         });return this;
                    }, on: function on(events, name, fn) {
                         var id = new Date().getTime() + "" + emitter.eventCounter++;events.push({ id: id, name: name, fn: fn });return id;
                    }, off: function off(events, name) {
                         events = events.reduce(function (result, event) {
                              if (event.name == name || event.id == name || !name) {
                                   return result;
                              }result.push(event);return result;
                         }, []);return events;
                    } };var utils = { merge: function merge(obj1, obj2) {
                         for (var attrname in obj2) {
                              obj1[attrname] = obj2[attrname];
                         }return obj1;
                    }, quatInverse: function quatInverse(q) {
                         var len = Math.sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);return { w: q.w / len, x: -q.x / len, y: -q.y / len, z: -q.z / len };
                    }, quatRotate: function quatRotate(q, r) {
                         return { w: q.w * r.w - q.x * r.x - q.y * r.y - q.z * r.z, x: q.w * r.x + q.x * r.w + q.y * r.z - q.z * r.y, y: q.w * r.y - q.x * r.z + q.y * r.w + q.z * r.x, z: q.w * r.z + q.x * r.y - q.y * r.x + q.z * r.w };
                    }, getStrengthFromRssi: function getStrengthFromRssi(rssi) {
                         var min = -95;var max = -40;rssi = rssi < min ? min : rssi;rssi = rssi > max ? max : rssi;return Math.round((rssi - min) * 100 / (max - min) * 100) / 100;
                    } };if (typeof window !== 'undefined') window.Myo = Myo;if (typeof module !== 'undefined') module.exports = Myo;
          })();
     }, {}], 186: [function (require, module, exports) {
          /*import * as lfo  from 'waves-lfo/client';
          import * as Myo from 'dist/client/js/myo';
          import * as SG from 'ml-savitzky-golay';
          import * as config from '../../config/default';*/var lfo = require('waves-lfo/client');var Myo = require('./myo');var SG = require('ml-savitzky-golay');var config = require('../../config/default'); //Gravity constant
          var g = 9.81; //Constant for window Length used
          var EMGWindowLength = 500;var acceleroWindowLength = 30; //Modification en direct
          var speedRateWindowLength = 10;var amplitudeWindowLength = 10;var SGWindowLength = 22; //Time for the bpfDisplay
          var time = 0;var dt = 0.01;var timeEMG = 0;var dtEMG = 0.01; //Socked to send data to node
          var socketSendJerkiness = new lfo.sink.SocketSend({ port: config.socketClientToServer.port }); //Starting myo
          Myo.connect('com.stolksdorf.myAwesomeApp');var myMyo = void 0; //Creation of graph
          var eventInAccelero = new lfo.source.EventIn({ frameType: 'vector', frameSize: 3, frameRate: 0.01, description: ['acceleroX', 'acceleroY', 'acceleroZ'] });var eventInSmoothness = new lfo.source.EventIn({ frameType: 'vector', frameSize: 1, frameRate: 0.01, description: ['smoothX', 'smoothY', 'smoothZ'] });var eventInGyro = new lfo.source.EventIn({ frameType: 'vector', frameSize: 3, frameRate: 0.01, description: ['gyroX', 'gyroY', 'gyroZ'] });var eventInEMG = new lfo.source.EventIn({ frameType: 'vector', frameSize: 8, frameRate: 0.01, description: ['emg', 'emg', 'emg', 'emg', 'emg', 'emg', 'emg', 'emg'] });var eventInEMGSliding = new lfo.source.EventIn({ frameType: 'vector', frameSize: 1, frameRate: 0.01, description: ['emgSliding'] });var eventInSmoothnessRecorded = new lfo.source.EventIn({ frameType: 'vector', frameSize: 1, frameRate: 0.01, description: ['smoothX'] }); // initialize and start the different graph used
          function initGraph() {
               //eventInAccelero.start();
               //eventInGyro.start();
               //eventInEMGSliding.start();
               //eventInEMG.start();
               eventInSmoothnessRecorded.start();eventInSmoothness.start();console.log("event in started"); /*ACCELERO*/ //eventInAccelero.connect(bpfDisplayAccelero);
               /*JERKINESS RATE*/ //eventInSmoothness.connect(bpfDisplayJerkiness);
               eventInSmoothness.connect(socketSendJerkiness); /*EMG*/ //eventInEMG.connect(bpfDisplayEMG);
               /*EMGS SLIDING WINDOW*/ //eventInEMGSliding.connect(bpfDisplayEMGSlinding);
          } /*MYO starting event handler*/Myo.onError = function () {
               console.log("Couldn't connect to Myo Connect");
          };Myo.on('connected', function () {
               myMyo = this; //myMyo.setLockingPolicy("Manual");
               addEvents(myMyo);
          });var addEvents = function addEvents(myo) {
               myMyo.streamEMG(true);Myo.on('emg', function (data) {//displayEMGWindow(EMGWindowLength,data);
               });var bpfDisplayAccelero = new lfo.sink.BpfDisplay({ canvas: '#canvasBPFAccelero', width: 400, height: 250, duration: 5, max: 9, min: -9 });var bpfDisplayJerkiness = new lfo.sink.BpfDisplay({ canvas: '#bpfDisplayJerkiness', width: 400, height: 250, duration: 5, max: 1, min: -1 });var bpfDisplayEMG = new lfo.sink.BpfDisplay({ canvas: '#canvasEMG1', width: 400, height: 250, duration: 5, max: 128, min: -128 });var bpfDisplayEMGSlinding = new lfo.sink.BpfDisplay({ canvas: '#canvasEMG2', width: 400, height: 250, duration: 5, max: 1, min: -1 }); //Le low pass ne marche pas et je ne sais toujours pas pourquoi. Probleme de config?
               var biquad = new lfo.operator.Biquad({ type: 'lowpass', f0: 50, gain: 3, q: 12 });var biquad2 = new lfo.operator.Biquad({ type: 'lowpass', f0: 500, gain: 3, q: 12 });var movingAverage = new lfo.operator.MovingAverage({ order: 5, fill: 0 }); //Init the different graph used and choose wich one to display
               initGraph();Myo.on('imu', function (data) {
                    myMyo.lock();displayWindow(data);
               });
          };function displayWindow(data) {
               //displayAcceleroWindowSpeed(acceleroWindowLength,data);
               displaySmoothness(SGWindowLength, data); //displayEMGWindow(SGWindowLength,data);
          } /*Method sliding window computation, require less computation than the naive one*/var ansX = [];var ansY = [];var ansZ = [];var computedSpeedRate = 0;var sumLastElem = 0;var sumFirstElem = 0;function computeSpeedRateAdaptativeWindow(windowLength, newX, newY, newZ) {
               if (ansX.length >= windowLength) {
                    var firstElementX = ansX.shift();var firstElementY = ansY.shift();var firstElementZ = ansZ.shift();sumFirstElem = firstElementX + firstElementY + firstElementZ;
               }var x = Math.abs(newX / g); // let x = (newX/g);
               ansX.push(x);var y = Math.abs(newY / g); // let y = (newY/g);
               ansY.push(y);var z = Math.abs(newZ / g); //let z = (newZ/g);
               ansZ.push(z);sumLastElem = x + y + z;computedSpeedRate = computedSpeedRate - sumFirstElem + sumLastElem;return computedSpeedRate;
          } //Algorithm de calcul naif de la vitesse selon une fenetre: retourne le meme resultat que l'algorithme evolu
          var ansXNaif = [];var ansYNaif = [];var ansZNaif = [];function computeSpeedRateAdaptativeWindowNaif(windowLength, x, y, z) {
               console.log("The function computeSpeedRateAdaptativeWindowNaif is deprecated, use computeSpeedRateAdaptativeWindow instead.");if (ansXNaif.length >= windowLength) {
                    ansXNaif.shift();ansYNaif.shift();ansZNaif.shift();
               }ansXNaif.push(x / g);ansYNaif.push(y / g);ansZNaif.push(z / g);var speedRate = 0;for (var _i4 = 0; _i4 < windowLength; _i4++) {
                    speedRate += ansXNaif[_i4] + ansYNaif[_i4] + ansZNaif[_i4]; //speedRate += Math.abs(ansX[i]/g)+ Math.abs(ansY[i]/g) +  Math.abs(ansZ[i]/g);
                    // speedRate +=Math.sqrt(Math.pow( Math.abs(ansX[i]/g) ,2)+ Math.pow(  Math.abs(ansY[i]/g),2) + Math.pow( Math.abs(ansZ[i]/g),2));
               }return speedRate;
          }function displayAcceleroWindowSpeed(windowLength, data) {
               time += dt;var speedRate = computeSpeedRateAdaptativeWindow(windowLength, data.accelerometer.x, data.accelerometer.y, data.accelerometer.z);var frameAccelero = { time: time, data: [data.accelerometer.x * speedRate, data.accelerometer.y * speedRate, data.accelerometer.z * speedRate], metadata: true };eventInAccelero.processFrame(frameAccelero);
          } //For the sliding window of kinestetic awareness replication
          var slidingWindow = [];function displayEMGWindow(windowLength, data) {
               timeEMG += dtEMG; //Slinding window of EMG
               if (slidingWindow.length > windowLength) {
                    slidingWindow.shift();
               }slidingWindow.push(Math.max.apply(Math, _toConsumableArray(data)));var maxSliding = Math.max.apply(Math, slidingWindow);var frameEMGSliding = { time: timeEMG, data: slidingWindow[slidingWindow.length - 1] / maxSliding };var frameEMG = { time: timeEMG, data: data };eventInEMGSliding.processFrame(frameEMGSliding);eventInEMG.processFrame(frameEMG);
          } //variables for the savitzky-golay filter
          var arrayFilteringX = [];var arrayFilteringY = [];var arrayFilteringZ = [];var ansx = [];var ansy = [];var ansz = [];var options = { derivative: 1, windowSize: SGWindowLength - 1 };var optionsGolayLowPass = { derivative: 0 };function displaySmoothness(windowLengthSG, data) {
               //Calculing smoothness
               arrayFilteringX.push(data.accelerometer.x);arrayFilteringY.push(data.accelerometer.y);arrayFilteringZ.push(data.accelerometer.z); //taille de la fenetre de calcule de l'algorithme
               if (arrayFilteringZ.length >= windowLengthSG) {
                    arrayFilteringX.shift();arrayFilteringY.shift();arrayFilteringZ.shift(); //apllication de savitzky-golay filter
                    ansx = SG(arrayFilteringX, 1, options);ansy = SG(arrayFilteringY, 1, options);ansz = SG(arrayFilteringZ, 1, options); //normalising data
                    var normaliseData = Math.sqrt(Math.pow(ansx[ansx.length - 1], 2) + Math.pow(ansy[ansy.length - 1], 2) + Math.pow(ansz[ansz.length - 1], 2));var amplitudeData = computeAmplitudeWindow(amplitudeWindowLength, normaliseData);var speedRate = computeSpeedRateAdaptativeWindow(speedRateWindowLength, data.accelerometer.x, data.accelerometer.y, data.accelerometer.z); // console.log("speedRate : " + speedRate);
                    if (recording) {
                         arrayRecorded.push(normaliseData);console.log("arrayRecorded : " + arrayRecorded.length);
                    }var frameSmoothness = { time: time, data: amplitudeData, //data: normaliseData,
                         metadata: null };eventInSmoothness.processFrame(frameSmoothness);
               }
          } //version naive de l'algorithme, le for peut etre remplac comme dans la fonction: computeSpeedRateAdaptativeWindow
          //Moyenne des donnes du jerk normalis
          var arrayAmplitude = [];function computeAmplitudeWindow(windowLength, data) {
               var amplitudeRate = 0;if (arrayAmplitude.length > windowLength) {
                    arrayAmplitude.shift();
               }arrayAmplitude.push(data);for (var _i5 = 0; _i5 < windowLength; _i5++) {
                    amplitudeRate += arrayAmplitude[_i5];
               }amplitudeRate /= windowLength; // console.log("amplitudeRate : " + amplitudeRate );
               return amplitudeRate;
          }window.setSGWindowLength = function (newValue) {
               //console.log("new value SG : " + newValue);
               SGWindowLength = newValue;options = { derivative: 1, windowSize: SGWindowLength - 1 };arrayFilteringX = [];arrayFilteringY = [];arrayFilteringZ = [];ansX = [];ansY = [];ansZ = [];
          };window.setAmplitudeWindowLength = function (newValue) {
               amplitudeWindowLength = newValue;
          };var arrayRecorded = [];var recording = false; /*Button function*/window.startRecord = function () {
               console.log("recording");eventInSmoothness.stop();StreamOnOff("off");arrayRecorded = [];recording = true;
          };window.stopRecord = function () {
               eventInSmoothness.start();recording = false;
          };var i = 0;var timer;window.playRecorded = function () {
               timer = setInterval(playingRecord, 20);eventInSmoothnessRecorded.connect(socketSendJerkiness);eventInSmoothnessRecorded.start();eventInSmoothness.stop();function playingRecord() {
                    if (i < arrayRecorded.length) {
                         var frameSmoothness = { time: i, data: arrayRecorded[i], //data: normaliseData,
                              metadata: null };eventInSmoothnessRecorded.processFrame(frameSmoothness);
                    } else {
                         clearTimeout(timer);eventInSmoothnessRecorded.stop();eventInSmoothness.start();i = 0;
                    }i++;
               }
          };window.stopingRecorded = function () {
               clearTimeout(timer);eventInSmoothnessRecorded.stop();eventInSmoothness.start();StreamOnOff("on");i = 0;
          }; //2000 = on, 1000 = off
          var onOff = 1000;window.StreamOnOff = function (value) {
               if (value === "on") {
                    onOff = 1000;eventInSmoothness.start();
               } else if (value === "off") {
                    onOff = 2000; //eventInSmoothness.stop();
               } else {
                    if (onOff === 1000) {
                         console.log("on : " + onOff);eventInSmoothness.start();onOff = 2000;
                    } else {
                         console.log("off  : " + onOff);onOff = 1000; //eventInSmoothness.stop();
                    }
               }var frameSmoothnessOnOFF = { time: i, data: onOff, //data: normaliseData,
                    metadata: null };eventInSmoothness.processFrame(frameSmoothnessOnOFF);
          };
     }, { "../../config/default": 187, "./myo": 185, "ml-savitzky-golay": 132, "waves-lfo/client": 133 }], 187: [function (require, module, exports) {
          //import path from 'path';
          //const cwd = process.cwd();
          // Configuration of the application.
          // Other entries can be added (as long as their name doesn't conflict with
          // existing ones) to define global parameters of the application (e.g. BPM,
          // synth parameters) that can then be shared easily among all clients using
          // the `shared-config` service.
          var config = { // name of the application, used in the `.ejs` template and by default in
               // the `platform` service to populate its view
               appName: 'ToolBox - MoveOn: A technology probe', // name of the environnement ('production' enable cache in express application)
               env: 'development', // version of application, can be used to force reload css and js files
               // from server (cf. `html/default.ejs`)
               version: '0.0.1', // define from where the assets (static files) should be loaded, these value
               // could also refer to a separate server for scalability reasons. This value
               // should also be used client-side to configure the `audio-buffer-manager` service.
               assetsDomain: '/', // port used to open the http server, in production this value is typically 80
               portServer: 8000, //Port used by the myo
               myoPort: 10138, // location of the public directory (accessible through http(s) requests)
               //  publicDirectory: path.join(cwd, 'public'),
               // configuration of the `osc` service
               osc: { // IP of the currently running node server
                    receiveAddress: '127.0.0.1', // port listening for incomming messages
                    receivePort: 57121, // IP of the remote application
                    sendAddress: '127.0.0.1', // port where the remote application is listening for messages
                    sendPort: 57120 }, // configuration of the `raw-socket` service
               socketServerToClient: { // port used for socket connection with the client
                    port: 9002 }, // configuration of the `raw-socket` service
               socketClientToServer: { // port used for socket connection with the client
                    port: 9001 } };module.exports = config;
     }, {}], 188: [function (require, module, exports) {
          // shim for using process in browser
          var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
          // don't break things.  But we need to wrap it in a try catch in case it is
          // wrapped in strict mode code which doesn't define any globals.  It's inside a
          // function because try/catches deoptimize in certain engines.
          var cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout() {
               throw new Error('setTimeout has not been defined');
          }function defaultClearTimeout() {
               throw new Error('clearTimeout has not been defined');
          }(function () {
               try {
                    if (typeof setTimeout === 'function') {
                         cachedSetTimeout = setTimeout;
                    } else {
                         cachedSetTimeout = defaultSetTimout;
                    }
               } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
               }try {
                    if (typeof clearTimeout === 'function') {
                         cachedClearTimeout = clearTimeout;
                    } else {
                         cachedClearTimeout = defaultClearTimeout;
                    }
               } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
               }
          })();function runTimeout(fun) {
               if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
               } // if setTimeout wasn't available but was latter defined
               if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;return setTimeout(fun, 0);
               }try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
               } catch (e) {
                    try {
                         // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                         return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                         // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                         return cachedSetTimeout.call(this, fun, 0);
                    }
               }
          }function runClearTimeout(marker) {
               if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
               } // if clearTimeout wasn't available but was latter defined
               if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;return clearTimeout(marker);
               }try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
               } catch (e) {
                    try {
                         // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                         return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                         // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                         // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                         return cachedClearTimeout.call(this, marker);
                    }
               }
          }var queue = [];var draining = false;var currentQueue;var queueIndex = -1;function cleanUpNextTick() {
               if (!draining || !currentQueue) {
                    return;
               }draining = false;if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
               } else {
                    queueIndex = -1;
               }if (queue.length) {
                    drainQueue();
               }
          }function drainQueue() {
               if (draining) {
                    return;
               }var timeout = runTimeout(cleanUpNextTick);draining = true;var len = queue.length;while (len) {
                    currentQueue = queue;queue = [];while (++queueIndex < len) {
                         if (currentQueue) {
                              currentQueue[queueIndex].run();
                         }
                    }queueIndex = -1;len = queue.length;
               }currentQueue = null;draining = false;runClearTimeout(timeout);
          }process.nextTick = function (fun) {
               var args = new Array(arguments.length - 1);if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                         args[i - 1] = arguments[i];
                    }
               }queue.push(new Item(fun, args));if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
               }
          }; // v8 likes predictible objects
          function Item(fun, array) {
               this.fun = fun;this.array = array;
          }Item.prototype.run = function () {
               this.fun.apply(null, this.array);
          };process.title = 'browser';process.browser = true;process.env = {};process.argv = [];process.version = ''; // empty string to avoid regexp issues
          process.versions = {};function noop() {}process.on = noop;process.addListener = noop;process.once = noop;process.off = noop;process.removeListener = noop;process.removeAllListeners = noop;process.emit = noop;process.prependListener = noop;process.prependOnceListener = noop;process.listeners = function (name) {
               return [];
          };process.binding = function (name) {
               throw new Error('process.binding is not supported');
          };process.cwd = function () {
               return '/';
          };process.chdir = function (dir) {
               throw new Error('process.chdir is not supported');
          };process.umask = function () {
               return 0;
          };
     }, {}] }, {}, [186]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNlbnNvclNjcmlwdC5kaXN0LmpzIl0sIm5hbWVzIjpbInIiLCJlIiwibiIsInQiLCJvIiwiaSIsImYiLCJjIiwicmVxdWlyZSIsInUiLCJhIiwiRXJyb3IiLCJjb2RlIiwicCIsImV4cG9ydHMiLCJjYWxsIiwibGVuZ3RoIiwibW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIm1pbiIsIk1hdGgiLCJtYXgiLCJjbGlwIiwibG93ZXIiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJJbmZpbml0eSIsInVwcGVyIiwiZGVmYXVsdCIsImJvb2xlYW4iLCJkZWZpbml0aW9uVGVtcGxhdGUiLCJ0eXBlQ2hlY2tGdW5jdGlvbiIsImRlZmluaXRpb24iLCJuYW1lIiwiaW50ZWdlciIsImZsb29yIiwiZmxvYXQiLCJzdHJpbmciLCJlbnVtIiwibGlzdCIsImluZGV4T2YiLCJhbnkiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwia2V5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJfcGFyYW1UZW1wbGF0ZXMiLCJfcGFyYW1UZW1wbGF0ZXMyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIlR5cGVFcnJvciIsIlBhcmFtIiwiZm9yRWFjaCIsImhhc093blByb3BlcnR5IiwidHlwZSIsIm51bGxhYmxlIiwiX3R5cGVDaGVja0Z1bmN0aW9uIiwiZ2V0VmFsdWUiLCJzZXRWYWx1ZSIsImNvbnN0YW50IiwiUGFyYW1ldGVyQmFnIiwicGFyYW1zIiwiZGVmaW5pdGlvbnMiLCJfcGFyYW1zIiwiX2RlZmluaXRpb25zIiwiX2dsb2JhbExpc3RlbmVycyIsIlNldCIsIl9wYXJhbXNMaXN0ZW5lcnMiLCJnZXREZWZpbml0aW9ucyIsImdldCIsInNldCIsInBhcmFtIiwidXBkYXRlZCIsIm1ldGFzIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zdGVwIiwibmV4dCIsImRvbmUiLCJsaXN0ZW5lciIsImVyciIsInJldHVybiIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yIiwiX2RpZEl0ZXJhdG9yRXJyb3IyIiwiX2l0ZXJhdG9yRXJyb3IyIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsIl9saXN0ZW5lciIsImhhcyIsInJlc2V0IiwiX3RoaXMiLCJpbml0VmFsdWUiLCJrZXlzIiwiYWRkTGlzdGVuZXIiLCJjYWxsYmFjayIsImFkZCIsInJlbW92ZUxpc3RlbmVyIiwiY2xlYXIiLCJkZWxldGUiLCJhZGRQYXJhbUxpc3RlbmVyIiwidHJpZ2dlciIsIl9wYXJhbSIsInJlbW92ZVBhcmFtTGlzdGVuZXIiLCJwYXJhbWV0ZXJzIiwidmFsdWVzIiwiX25hbWUiLCJfcGFyYW1UZW1wbGF0ZXMkZGVmaW4iLCJkZWZpbmVUeXBlIiwidHlwZU5hbWUiLCJwYXJhbWV0ZXJEZWZpbml0aW9uIiwiX2RlZmluZVByb3BlcnR5IiwiX2RlZmluZVByb3BlcnR5MiIsIl9nZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZjIiLCJfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInJlY2VpdmVyIiwiRnVuY3Rpb24iLCJkZXNjIiwicGFyZW50IiwiZ2V0dGVyIiwiX3NldFByb3RvdHlwZU9mIiwiX3NldFByb3RvdHlwZU9mMiIsIl9jcmVhdGUiLCJfY3JlYXRlMiIsIl90eXBlb2YyIiwiX3R5cGVvZjMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjb25zdHJ1Y3RvciIsIl9fcHJvdG9fXyIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9zeW1ib2wiLCJfc3ltYm9sMiIsIl90eXBlb2YiLCJjb3JlIiwiJEpTT04iLCJKU09OIiwic3RyaW5naWZ5IiwiaXQiLCJhcHBseSIsImxvZzEwIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJhc3NpZ24iLCIkT2JqZWN0IiwiY3JlYXRlIiwiUCIsIkQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRQcm90b3R5cGVPZiIsInNldFByb3RvdHlwZU9mIiwiUHJvbWlzZSIsImZvcmJpZGRlbkZpZWxkIiwiaXNPYmplY3QiLCJ0b0lPYmplY3QiLCJ0b0xlbmd0aCIsInRvQWJzb2x1dGVJbmRleCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJlbCIsImZyb21JbmRleCIsIk8iLCJpbmRleCIsImNvZiIsIlRBRyIsIkFSRyIsInRyeUdldCIsIlQiLCJCIiwiY2FsbGVlIiwidG9TdHJpbmciLCJzbGljZSIsInZlcnNpb24iLCJfX2UiLCJhRnVuY3Rpb24iLCJmbiIsInRoYXQiLCJiIiwiZG9jdW1lbnQiLCJpcyIsImNyZWF0ZUVsZW1lbnQiLCJzcGxpdCIsImdldEtleXMiLCJnT1BTIiwicElFIiwicmVzdWx0IiwiZ2V0U3ltYm9scyIsInN5bWJvbHMiLCJpc0VudW0iLCJwdXNoIiwiZ2xvYmFsIiwiY3R4IiwiaGlkZSIsIlBST1RPVFlQRSIsIiRleHBvcnQiLCJzb3VyY2UiLCJJU19GT1JDRUQiLCJGIiwiSVNfR0xPQkFMIiwiRyIsIklTX1NUQVRJQyIsIlMiLCJJU19QUk9UTyIsIklTX0JJTkQiLCJJU19XUkFQIiwiVyIsImV4cFByb3RvIiwib3duIiwib3V0IiwiQyIsInZpcnR1YWwiLCJSIiwiVSIsImV4ZWMiLCJpc0FycmF5SXRlciIsImFuT2JqZWN0IiwiZ2V0SXRlckZuIiwiQlJFQUsiLCJSRVRVUk4iLCJpdGVyYWJsZSIsImVudHJpZXMiLCJJVEVSQVRPUiIsIml0ZXJGbiIsInN0ZXAiLCJ3aW5kb3ciLCJfX2ciLCJkUCIsImNyZWF0ZURlc2MiLCJkb2N1bWVudEVsZW1lbnQiLCJhcmdzIiwidW4iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkl0ZXJhdG9ycyIsIkFycmF5UHJvdG8iLCJBcnJheSIsImlzQXJyYXkiLCJhcmciLCJyZXQiLCJzZXRUb1N0cmluZ1RhZyIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiTkFNRSIsIkxJQlJBUlkiLCJyZWRlZmluZSIsIiRpdGVyQ3JlYXRlIiwiQlVHR1kiLCJGRl9JVEVSQVRPUiIsIktFWVMiLCJWQUxVRVMiLCJyZXR1cm5UaGlzIiwiQmFzZSIsIkRFRkFVTFQiLCJJU19TRVQiLCJGT1JDRUQiLCJnZXRNZXRob2QiLCJraW5kIiwicHJvdG8iLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIm1ldGhvZHMiLCJTQUZFX0NMT1NJTkciLCJyaXRlciIsImZyb20iLCJza2lwQ2xvc2luZyIsInNhZmUiLCJhcnIiLCJpdGVyIiwiTUVUQSIsInNldERlc2MiLCJpZCIsImlzRXh0ZW5zaWJsZSIsIkZSRUVaRSIsInByZXZlbnRFeHRlbnNpb25zIiwic2V0TWV0YSIsInciLCJmYXN0S2V5IiwiZ2V0V2VhayIsIm9uRnJlZXplIiwibWV0YSIsIk5FRUQiLCJLRVkiLCJtYWNyb3Rhc2siLCJPYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwicHJvY2VzcyIsImlzTm9kZSIsImhlYWQiLCJsYXN0Iiwibm90aWZ5IiwiZmx1c2giLCJkb21haW4iLCJleGl0IiwiZW50ZXIiLCJuZXh0VGljayIsIm5hdmlnYXRvciIsInN0YW5kYWxvbmUiLCJ0b2dnbGUiLCJub2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsImRhdGEiLCJyZXNvbHZlIiwicHJvbWlzZSIsInRoZW4iLCJ0YXNrIiwiUHJvbWlzZUNhcGFiaWxpdHkiLCJyZWplY3QiLCIkJHJlc29sdmUiLCIkJHJlamVjdCIsInRvT2JqZWN0IiwiSU9iamVjdCIsIiRhc3NpZ24iLCJBIiwiSyIsImsiLCJqb2luIiwiYUxlbiIsImNvbmNhdCIsImoiLCJkUHMiLCJlbnVtQnVnS2V5cyIsIklFX1BST1RPIiwiRW1wdHkiLCJjcmVhdGVEaWN0IiwiaWZyYW1lIiwibHQiLCJndCIsImlmcmFtZURvY3VtZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJzcmMiLCJjb250ZW50V2luZG93Iiwib3BlbiIsIndyaXRlIiwiY2xvc2UiLCJQcm9wZXJ0aWVzIiwiSUU4X0RPTV9ERUZJTkUiLCJ0b1ByaW1pdGl2ZSIsIkF0dHJpYnV0ZXMiLCJnT1BEIiwiZ09QTiIsIndpbmRvd05hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldFdpbmRvd05hbWVzIiwiJGtleXMiLCJoaWRkZW5LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiT2JqZWN0UHJvdG8iLCJhcnJheUluZGV4T2YiLCJuYW1lcyIsImZhaWxzIiwiZXhwIiwidiIsIm5ld1Byb21pc2VDYXBhYmlsaXR5IiwieCIsInByb21pc2VDYXBhYmlsaXR5IiwiYml0bWFwIiwiY2hlY2siLCJ0ZXN0IiwiYnVnZ3kiLCJERVNDUklQVE9SUyIsIlNQRUNJRVMiLCJkZWYiLCJ0YWciLCJzdGF0Iiwic2hhcmVkIiwidWlkIiwiU0hBUkVEIiwic3RvcmUiLCJ0b0ludGVnZXIiLCJkZWZpbmVkIiwiVE9fU1RSSU5HIiwicG9zIiwicyIsIlN0cmluZyIsImwiLCJjaGFyQ29kZUF0IiwiY2hhckF0IiwiaW52b2tlIiwiaHRtbCIsImNlbCIsInNldFRhc2siLCJzZXRJbW1lZGlhdGUiLCJjbGVhclRhc2siLCJjbGVhckltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiRGlzcGF0Y2giLCJjb3VudGVyIiwicXVldWUiLCJPTlJFQURZU1RBVEVDSEFOR0UiLCJkZWZlciIsImNoYW5uZWwiLCJwb3J0IiwicnVuIiwiZXZlbnQiLCJub3ciLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsInJlbW92ZUNoaWxkIiwic2V0VGltZW91dCIsImNlaWwiLCJpc05hTiIsInZhbCIsInZhbHVlT2YiLCJweCIsInJhbmRvbSIsIndrc0V4dCIsIiRTeW1ib2wiLCJVU0VfU1lNQk9MIiwiJGV4cG9ydHMiLCJjbGFzc29mIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJhZGRUb1Vuc2NvcGFibGVzIiwiaXRlcmF0ZWQiLCJfdCIsIl9pIiwiX2siLCJBcmd1bWVudHMiLCJsb2ciLCJMT0cxMEUiLCJfaXNGaW5pdGUiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiJGdldFByb3RvdHlwZU9mIiwiYW5JbnN0YW5jZSIsImZvck9mIiwic3BlY2llc0NvbnN0cnVjdG9yIiwibWljcm90YXNrIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUiLCJwZXJmb3JtIiwicHJvbWlzZVJlc29sdmUiLCJQUk9NSVNFIiwiJFByb21pc2UiLCJlbXB0eSIsIkludGVybmFsIiwibmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5IiwiT3duUHJvbWlzZUNhcGFiaWxpdHkiLCJXcmFwcGVyIiwiVVNFX05BVElWRSIsIkZha2VQcm9taXNlIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwiaXNUaGVuYWJsZSIsImlzUmVqZWN0IiwiX24iLCJjaGFpbiIsIl9jIiwiX3YiLCJvayIsIl9zIiwicmVhY3Rpb24iLCJoYW5kbGVyIiwiZmFpbCIsImV4aXRlZCIsIl9oIiwib25IYW5kbGVVbmhhbmRsZWQiLCJvblVuaGFuZGxlZCIsInVuaGFuZGxlZCIsImlzVW5oYW5kbGVkIiwiY29uc29sZSIsImVtaXQiLCJvbnVuaGFuZGxlZHJlamVjdGlvbiIsInJlYXNvbiIsImVycm9yIiwiX2EiLCJvbnJlamVjdGlvbmhhbmRsZWQiLCIkcmVqZWN0IiwiX2QiLCJfdyIsIiRyZXNvbHZlIiwid3JhcHBlciIsImV4ZWN1dG9yIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiY2FwYWJpbGl0eSIsImFsbCIsInJlbWFpbmluZyIsIiRpbmRleCIsImFscmVhZHlDYWxsZWQiLCJyYWNlIiwiJGF0IiwicG9pbnQiLCIkZmFpbHMiLCJ3a3MiLCJ3a3NEZWZpbmUiLCJlbnVtS2V5cyIsImdPUE5FeHQiLCIkR09QRCIsIiREUCIsIl9zdHJpbmdpZnkiLCJISURERU4iLCJUT19QUklNSVRJVkUiLCJTeW1ib2xSZWdpc3RyeSIsIkFsbFN5bWJvbHMiLCJPUFN5bWJvbHMiLCJRT2JqZWN0Iiwic2V0dGVyIiwiZmluZENoaWxkIiwic2V0U3ltYm9sRGVzYyIsInByb3RvRGVzYyIsIndyYXAiLCJzeW0iLCJpc1N5bWJvbCIsIiRkZWZpbmVQcm9wZXJ0eSIsIiRkZWZpbmVQcm9wZXJ0aWVzIiwiJGNyZWF0ZSIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkUiLCIkZ2V0T3duUHJvcGVydHlOYW1lcyIsIiRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJJU19PUCIsIiRzZXQiLCJlczZTeW1ib2xzIiwid2VsbEtub3duU3ltYm9scyIsImtleUZvciIsInVzZVNldHRlciIsInVzZVNpbXBsZSIsInJlcGxhY2VyIiwiJHJlcGxhY2VyIiwib25GaW5hbGx5IiwiaXNGdW5jdGlvbiIsImNhbGxiYWNrZm4iLCJUT19TVFJJTkdfVEFHIiwiRE9NSXRlcmFibGVzIiwiQ29sbGVjdGlvbiIsImhhc093biIsInRvU3RyIiwiaXNQbGFpbk9iamVjdCIsImhhc093bkNvbnN0cnVjdG9yIiwiaGFzSXNQcm90b3R5cGVPZiIsImV4dGVuZCIsIm9wdGlvbnMiLCJjb3B5IiwiY29weUlzQXJyYXkiLCJjbG9uZSIsImRlZXAiLCJpbnB1dCIsIl9pbnRlcm9wRGVmYXVsdCIsImV4IiwicmVzY2FsZSIsIm91dHB1dCIsImN1cnJlbnRNaW4iLCJjdXJyZW50TWF4IiwiUmFuZ2VFcnJvciIsIm1pblZhbHVlIiwiYXV0b01pbk1heCIsIm1heFZhbHVlIiwiZmFjdG9yIiwic3BlY2llcyIsImZvciIsIkx1RGVjb21wb3NpdGlvbiQkMSIsIm1hdHJpeCIsIldyYXBwZXJNYXRyaXgyRCIsImNoZWNrTWF0cml4IiwibHUiLCJyb3dzIiwiY29sdW1ucyIsInBpdm90VmVjdG9yIiwicGl2b3RTaWduIiwiTFVjb2xqIiwia21heCIsImFicyIsIkxVIiwiY29sIiwiTWF0cml4IiwiaXNTaW5ndWxhciIsImNvdW50IiwiWCIsInN1Yk1hdHJpeFJvdyIsImlzU3F1YXJlIiwiZGV0ZXJtaW5hbnQiLCJoeXBvdGVudXNlIiwic3FydCIsImdldEZpbGxlZDJEQXJyYXkiLCJhcnJheSIsIlNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uJCQxIiwibSIsIm51IiwiY29tcHV0ZUxlZnRTaW5ndWxhclZlY3RvcnMiLCJjb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnMiLCJhdXRvVHJhbnNwb3NlIiwid2FudHUiLCJCb29sZWFuIiwid2FudHYiLCJzd2FwcGVkIiwid2FybiIsInRyYW5zcG9zZSIsImF1eCIsIlYiLCJ3b3JrIiwibmN0IiwibnJ0Iiwia3MiLCJjcyIsInNuIiwia2FzZSIsInNjYWxlIiwic3AiLCJzcG0xIiwiZXBtMSIsInNrIiwiZWsiLCJzaGlmdCIsImciLCJwcCIsImVwcyIsIkVQU0lMT04iLCJ0bXAiLCJZIiwidGhyZXNob2xkIiwic2NvbHMiLCJMcyIsInplcm9zIiwicmlnaHRTaW5ndWxhclZlY3RvcnMiLCJWTCIsIm1tdWwiLCJ2cm93cyIsInVyb3dzIiwiVkxVIiwic3VtIiwic29sdmUiLCJkaWFnIiwidmNvbHMiLCJ1Y29scyIsInRvbCIsImlpIiwiaXNNYXRyaXgiLCJjaGVja1Jvd0luZGV4Iiwib3V0ZXIiLCJjaGVja0NvbHVtbkluZGV4IiwiY2hlY2tSb3dWZWN0b3IiLCJ2ZWN0b3IiLCJ0bzFEQXJyYXkiLCJjaGVja0NvbHVtblZlY3RvciIsImNoZWNrSW5kaWNlcyIsInJvd0luZGljZXMiLCJjb2x1bW5JbmRpY2VzIiwicm93IiwiY2hlY2tSb3dJbmRpY2VzIiwiY29sdW1uIiwiY2hlY2tDb2x1bW5JbmRpY2VzIiwicm93T3V0Iiwic29tZSIsImNvbHVtbk91dCIsImNoZWNrUmFuZ2UiLCJzdGFydFJvdyIsImVuZFJvdyIsInN0YXJ0Q29sdW1uIiwiZW5kQ29sdW1uIiwibm90QWxsTnVtYmVycyIsInN1bUJ5Um93Iiwic3VtQnlDb2x1bW4iLCJzdW1BbGwiLCJCYXNlVmlldyIsIkFic3RyYWN0TWF0cml4IiwiTWF0cml4VHJhbnNwb3NlVmlldyIsInJvd0luZGV4IiwiY29sdW1uSW5kZXgiLCJNYXRyaXhSb3dWaWV3IiwiTWF0cml4U3ViVmlldyIsIk1hdHJpeFNlbGVjdGlvblZpZXciLCJpbmRpY2VzIiwiTWF0cml4Um93U2VsZWN0aW9uVmlldyIsIk1hdHJpeENvbHVtblNlbGVjdGlvblZpZXciLCJNYXRyaXhDb2x1bW5WaWV3IiwiTWF0cml4RmxpcFJvd1ZpZXciLCJNYXRyaXhGbGlwQ29sdW1uVmlldyIsInN1cGVyQ3RvciIsImpqIiwic2l6ZSIsInJvd1JlcCIsImNvbFJlcCIsInNldFN1Yk1hdHJpeCIsIm11bFMiLCJyb3dWZWN0b3IiLCJnZXRSb3ciLCJyb3cxIiwicm93MiIsInRlbXAiLCJjb2x1bW5WZWN0b3IiLCJnZXRDb2x1bW4iLCJjb2x1bW4xIiwiY29sdW1uMiIsImlkeCIsImJ5IiwicHJvZCIsInZlY3RvcjIiLCJ2ZWN0b3IxIiwiZG90Iiwib3RoZXIiLCJCY29saiIsImExMSIsImIxMSIsImExMiIsImIxMiIsImEyMSIsImIyMSIsImEyMiIsImIyMiIsIm0xIiwibTIiLCJtMyIsIm00IiwibTUiLCJtNiIsIm03IiwiYzAwIiwiYzAxIiwiYzEwIiwiYzExIiwiYTAwIiwiYTAxIiwiYTAyIiwiYTEwIiwiYTIwIiwiYjAwIiwiYjAxIiwiYjAyIiwiYjEwIiwiYjIwIiwibTgiLCJtOSIsIm0xMCIsIm0xMSIsIm0xMiIsIm0xMyIsIm0xNCIsIm0xNSIsIm0xNiIsIm0xNyIsIm0xOCIsIm0xOSIsIm0yMCIsIm0yMSIsIm0yMiIsIm0yMyIsImMwMiIsImMxMiIsImMyMCIsImMyMSIsImMyMiIsInkiLCJyMSIsImMxIiwicjIiLCJjMiIsImVtYmVkIiwibWF0IiwiY29scyIsInJlc3VsdGF0IiwiYmxvY2tNdWx0IiwiaGFsZlJvd3MiLCJwYXJzZUludCIsImhhbGZDb2xzIiwic3ViTWF0cml4Iiwic3ViIiwibmV3TWF0cml4Iiwic2NhbGVkIiwic2V0Um93Iiwic2V0Q29sdW1uIiwicSIsImNvbXBhcmVGdW5jdGlvbiIsImNvbXBhcmVOdW1iZXJzIiwic29ydCIsInRyYWNlIiwiZCIsInN1Yk1hdHJpeDAiLCJzdWJNYXRyaXgxIiwic3ViTWF0cml4MiIsInNlbGVjdGlvblZpZXciLCJkZXQiLCJzdmRTb2x1dGlvbiIsImxlZnRTaW5ndWxhclZlY3RvcnMiLCJkaWFnb25hbCIsInRyYW5zcG9zZVZpZXciLCJuZXdSb3dzIiwibmV3Q29sdW1ucyIsIm5ld0RhdGEiLCJmaWxsIiwicm5nIiwibWF0cml4MSIsIm1hdHJpeDIiLCJrbGFzcyIsInJhbmQiLCJpZGVudGl0eSIsImV5ZSIsIm5lZ2F0ZSIsIm5lZyIsInRlbnNvclByb2R1Y3QiLCJrcm9uZWNrZXJQcm9kdWN0IiwiaW5wbGFjZU9wZXJhdG9yIiwiaW5wbGFjZU9wZXJhdG9yU2NhbGFyIiwiaW5wbGFjZU9wZXJhdG9yTWF0cml4Iiwic3RhdGljT3BlcmF0b3IiLCJpbnBsYWNlTWV0aG9kIiwic3RhdGljTWV0aG9kIiwiaW5wbGFjZU1ldGhvZFdpdGhBcmdzIiwic3RhdGljTWV0aG9kV2l0aEFyZ3MiLCJpbnBsYWNlTWV0aG9kV2l0aE9uZUFyZ1NjYWxhciIsImlucGxhY2VNZXRob2RXaXRoT25lQXJnTWF0cml4IiwiaW5wbGFjZU1ldGhvZFdpdGhPbmVBcmciLCJzdGF0aWNNZXRob2RXaXRoT25lQXJnIiwib3BlcmF0b3JzIiwiZXZhbDIiLCJldmFsIiwib3BlcmF0b3IiLCJpbnBsYWNlT3AiLCJmaWxsVGVtcGxhdGVGdW5jdGlvbiIsIm9wIiwiaW5wbGFjZU9wUyIsImlucGxhY2VPcE0iLCJzdGF0aWNPcCIsIm1hdGhNZXRob2QiLCJtZXRob2QiLCJpbnBsYWNlTWV0aCIsInN0YXRpY01ldGgiLCJtZXRob2RzV2l0aEFyZ3MiLCJtZXRob2RXaXRoQXJnIiwiaW5wbGFjZU1ldGhXaXRoQXJncyIsInN0YXRpY01ldGhXaXRoQXJncyIsInRtcGxWYXIiLCJpbnBsYWNlTWV0aG9kMiIsImlucGxhY2VNZXRob2RTIiwiaW5wbGFjZU1ldGhvZE0iLCJzdGF0aWNNZXRob2QyIiwidGVtcGxhdGUiLCJyZXBsYWNlIiwiUmVnRXhwIiwiblJvd3MiLCJuQ29sdW1ucyIsImlzSW50ZWdlciIsInNwbGljZSIsIldyYXBwZXJNYXRyaXgxRCIsIl9jYWxjdWxhdGVJbmRleCIsIlFyRGVjb21wb3NpdGlvbiQkMSIsInFyIiwicmRpYWciLCJucm0iLCJRUiIsIlJkaWFnIiwiaXNGdWxsUmFuayIsImludmVyc2UkJDEiLCJ1c2VTVkQiLCJpbnZlcnNlIiwic29sdmUkJDEiLCJsZWZ0SGFuZFNpZGUiLCJyaWdodEhhbmRTaWRlIiwiRWlnZW52YWx1ZURlY29tcG9zaXRpb24kJDEiLCJhc3N1bWVTeW1tZXRyaWMiLCJpc1N5bW1ldHJpYyIsInRyZWQyIiwidHFsMiIsIkgiLCJvcnQiLCJvcnRoZXMiLCJocXIyIiwiaCIsImhoIiwiZGwxIiwiYzMiLCJlbDEiLCJzMiIsInRzdDEiLCJsb3ciLCJoaWdoIiwibm4iLCJleHNoaWZ0Iiwibm9ybSIsInoiLCJyYSIsInNhIiwidnIiLCJ2aSIsIm5vdGxhc3QiLCJjZGl2cmVzIiwiY2RpdiIsInhyIiwieGkiLCJ5ciIsInlpIiwiQ2hvbGVza3lEZWNvbXBvc2l0aW9uJCQxIiwiZGltZW5zaW9uIiwicG9zaXRpdmVEZWZpbml0ZSIsIkxyb3dqIiwiTHJvd2siLCJMIiwiYWJzdHJhY3RNYXRyaXgiLCJTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbiIsIlNWRCIsIkVpZ2VudmFsdWVEZWNvbXBvc2l0aW9uIiwiRVZEIiwiQ2hvbGVza3lEZWNvbXBvc2l0aW9uIiwiQ0hPIiwiTHVEZWNvbXBvc2l0aW9uIiwiUXJEZWNvbXBvc2l0aW9uIiwiZGVmYXVsdE9wdGlvbnMiLCJhcnJheUNhc2UiLCJsZW4iLCJjb25kIiwibWF0cml4Q2FzZSIsInBhZEFycmF5IiwibWF0cml4TGliIiwid2luZG93U2l6ZSIsImRlcml2YXRpdmUiLCJwb2x5bm9taWFsIiwicGFkIiwicGFkVmFsdWUiLCJTYXZpdHpreUdvbGF5IiwiYW5zIiwiSiIsIm9uZXMiLCJpbmljIiwicG93IiwiSnRyYW5zcG9zZSIsIkppbnYiLCJzaW5rIiwidXRpbHMiLCJfbmFtZXNwYWNlIiwiX25hbWVzcGFjZTIiLCJfbmFtZXNwYWNlMyIsIl9uYW1lc3BhY2U0IiwiX2NvcmUyIiwiX2NvcmUiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIm5ld09iaiIsIl9jbGFzc0NhbGxDaGVjazIiLCJfY2xhc3NDYWxsQ2hlY2szIiwiX2NyZWF0ZUNsYXNzMiIsIl9jcmVhdGVDbGFzczMiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMiLCJfaW5oZXJpdHMyIiwiX2luaGVyaXRzMyIsIl9CYXNlRGlzcGxheTIiLCJfQmFzZURpc3BsYXkzIiwiX0ZmdCIsIl9GZnQyIiwiX2Rpc3BsYXlVdGlscyIsImNvbG9ycyIsImdldENvbG9ycyIsIkJhckNoYXJ0RGlzcGxheSIsIl9CYXNlRGlzcGxheSIsInByb2Nlc3NTdHJlYW1QYXJhbXMiLCJwcmV2U3RyZWFtUGFyYW1zIiwicHJlcGFyZVN0cmVhbVBhcmFtcyIsInByb3BhZ2F0ZVN0cmVhbVBhcmFtcyIsInByb2Nlc3NWZWN0b3IiLCJmcmFtZSIsImZyYW1lU2l6ZSIsInN0cmVhbVBhcmFtcyIsIndpZHRoIiwiY2FudmFzV2lkdGgiLCJoZWlnaHQiLCJjYW52YXNIZWlnaHQiLCJiYXJXaWR0aCIsIngxRmxvYXQiLCJ4MUludCIsInJvdW5kIiwieDJGbG9hdCIsIngySW50IiwiX3dpZHRoIiwiZ2V0WVBvc2l0aW9uIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJfYXNzaWduIiwiX2Fzc2lnbjIiLCJfZ2V0MiIsIl9nZXQzIiwiX0Jhc2VMZm8yIiwiX0Jhc2VMZm8zIiwiY29tbW9uRGVmaW5pdGlvbnMiLCJjb250YWluZXIiLCJjYW52YXMiLCJoYXNEdXJhdGlvbkRlZmluaXRpb25zIiwiZHVyYXRpb24iLCJyZWZlcmVuY2VUaW1lIiwiQmFzZURpc3BsYXkiLCJfQmFzZUxmbyIsImRlZnMiLCJoYXNEdXJhdGlvbiIsImNvbW1vbkRlZnMiLCJjYW52YXNQYXJhbSIsImNvbnRhaW5lclBhcmFtIiwicXVlcnlTZWxlY3RvciIsImdldENvbnRleHQiLCJjYWNoZWRDYW52YXMiLCJjYWNoZWRDdHgiLCJwcmV2aW91c0ZyYW1lIiwiY3VycmVudFRpbWUiLCJkaXNwbGF5U3luYyIsIl9zdGFjayIsIl9yYWZJZCIsInJlbmRlclN0YWNrIiwiYmluZCIsInNoaWZ0RXJyb3IiLCJfcmVzaXplIiwiZFBSIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJQUiIsIndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwibXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwib0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJiYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwicGl4ZWxSYXRpbyIsImxhc3RXaWR0aCIsImxhc3RIZWlnaHQiLCJkcmF3SW1hZ2UiLCJfc2V0WVNjYWxlIiwiZ2V0TWluaW11bUZyYW1lV2lkdGgiLCJvblBhcmFtVXBkYXRlIiwicmVzZXRTdHJlYW0iLCJjbGVhclJlY3QiLCJmaW5hbGl6ZVN0cmVhbSIsImVuZFRpbWUiLCJwcm9jZXNzRnJhbWUiLCJGbG9hdDMyQXJyYXkiLCJ0aW1lIiwibWV0YWRhdGEiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzY3JvbGxNb2RlRHJhdyIsInByb2Nlc3NGdW5jdGlvbiIsImZyYW1lVHlwZSIsImZyYW1lUmF0ZSIsInNvdXJjZVNhbXBsZVJhdGUiLCJjYW52YXNEdXJhdGlvbiIsImZyYW1lU3RhcnRUaW1lIiwibGFzdEZyYW1lVGltZSIsImxhc3RGcmFtZUR1cmF0aW9uIiwiZnJhbWVEdXJhdGlvbiIsInBpeGVsRHVyYXRpb24iLCJmcmFtZUVuZFRpbWUiLCJzaGlmdFRpbWUiLCJmU2hpZnQiLCJpU2hpZnQiLCJfY3VycmVudFRpbWUiLCJzaGlmdENhbnZhcyIsInNoaWZ0U2libGluZ3MiLCJmbG9hdEZyYW1lV2lkdGgiLCJmcmFtZVdpZHRoIiwiY2FudmFzU3RhcnRUaW1lIiwic3RhcnRUaW1lUmF0aW8iLCJzdGFydFRpbWVQb3NpdGlvbiIsInBpeGVsc1NpbmNlTGFzdEZyYW1lIiwibGFzdEZyYW1lV2lkdGgiLCJmcmFtZUludGVydmFsIiwic2F2ZSIsInRyYW5zbGF0ZSIsInJlc3RvcmUiLCJjYWNoZSIsImNyb3BwZWRXaWR0aCIsInJhZGl1cyIsImxpbmUiLCJCcGZEaXNwbGF5IiwicHJldkZyYW1lIiwiZHJhd0xpbmUiLCJwcmV2RGF0YSIsInBvc1kiLCJjb2xvciIsInN0cm9rZVN0eWxlIiwibGFzdFBvc1kiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJjbG9zZVBhdGgiLCJhcmMiLCJQSSIsInRocmVzaG9sZEluZGV4IiwiTWFya2VyRGlzcGxheSIsInlNaW4iLCJ5TWF4IiwiZG93blNhbXBsZSIsInRhcmdldExlbmd0aCIsImhvcCIsInBoYXNlIiwicHJldiIsIlNpZ25hbERpc3BsYXkiLCJwcm9jZXNzU2lnbmFsIiwiaG9wWCIsInBvc1giLCJsYXN0WSIsIl9wcm9taXNlIiwiX3Byb21pc2UyIiwiX3dzVXRpbHMiLCJ1cmwiLCJTb2NrZXRTZW5kIiwicHJvdG9jb2wiLCJsb2NhdGlvbiIsImFkZHJlc3MiLCJob3N0bmFtZSIsInNvY2tldEFkZHJlc3MiLCJzb2NrZXQiLCJXZWJTb2NrZXQiLCJiaW5hcnlUeXBlIiwib3BlbmVkUHJvbWlzZSIsIm9ub3BlbiIsIm9uZXJyb3IiLCJzdGFjayIsImluaXRNb2R1bGUiLCJfdGhpczIiLCJvcGNvZGUiLCJkZWNvZGVycyIsIm9wY29kZXMiLCJJTklUX01PRFVMRV9BQ0siLCJidWZmZXIiLCJlbmNvZGVycyIsImluaXRNb2R1bGVSZXEiLCJzZW5kIiwicHJvY2Vzc1NjYWxhciIsIl9sb2ciLCJfbG9nMiIsIlNwZWN0cnVtRGlzcGxheSIsImZmdCIsImluaXRTdHJlYW0iLCJiaW5zIiwiaW5wdXRTaWduYWwiLCJuYnJCaW5zIiwiYmluV2lkdGgiLCJkYiIsImNvbG9yU2NoZW1lIiwiVHJhY2VEaXNwbGF5IiwiaGFsZlJhbmdlIiwibWVhbiIsInByZXZIYWxmUmFuZ2UiLCJwcmV2TWVhbiIsInByZXZNaW4iLCJwcmV2TWF4IiwiZ3JhZGllbnQiLCJyZ2IiLCJoZXhUb1JHQiIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiZ2V0SHVlIiwiX1JtcyIsIl9SbXMyIiwib2Zmc2V0IiwiVnVNZXRlckRpc3BsYXkiLCJybXNPcGVyYXRvciIsImxhc3REQiIsInBlYWsiLCJwZWFrTGlmZXRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsInJlZCIsInllbGxvdyIsImdyZWVuIiwicm1zIiwiZEIiLCJ5MCIsInlQZWFrIiwiX01pbk1heCIsIl9NaW5NYXgyIiwiV2F2ZWZvcm1EaXNwbGF5IiwibWluTWF4T3BlcmF0b3IiLCJzaG93Um1zIiwiaVNhbXBsZXNQZXJQaXhlbHMiLCJzdGFydCIsImVuZCIsInN1YmFycmF5IiwibWluTWF4IiwibWluWSIsIm1heFkiLCJybXNNYXhZIiwicm1zTWluWSIsIl9CcmlkZ2UiLCJfQnJpZGdlMiIsIl9Mb2dnZXIiLCJfTG9nZ2VyMiIsIl9EYXRhUmVjb3JkZXIiLCJfRGF0YVJlY29yZGVyMiIsIl9TaWduYWxSZWNvcmRlciIsIl9TaWduYWxSZWNvcmRlcjIiLCJfQmFyQ2hhcnREaXNwbGF5IiwiX0JhckNoYXJ0RGlzcGxheTIiLCJfQnBmRGlzcGxheSIsIl9CcGZEaXNwbGF5MiIsIl9NYXJrZXJEaXNwbGF5IiwiX01hcmtlckRpc3BsYXkyIiwiX1NpZ25hbERpc3BsYXkiLCJfU2lnbmFsRGlzcGxheTIiLCJfU29ja2V0U2VuZCIsIl9Tb2NrZXRTZW5kMiIsIl9TcGVjdHJ1bURpc3BsYXkiLCJfU3BlY3RydW1EaXNwbGF5MiIsIl9UcmFjZURpc3BsYXkiLCJfVHJhY2VEaXNwbGF5MiIsIl9WdU1ldGVyRGlzcGxheSIsIl9WdU1ldGVyRGlzcGxheTIiLCJfV2F2ZWZvcm1EaXNwbGF5IiwiX1dhdmVmb3JtRGlzcGxheTIiLCJCcmlkZ2UiLCJMb2dnZXIiLCJEYXRhUmVjb3JkZXIiLCJTaWduYWxSZWNvcmRlciIsIl9kZWZpbmVQcm9wZXJ0eTMiLCJfU291cmNlTWl4aW4yIiwiX1NvdXJjZU1peGluMyIsImF1ZGlvQnVmZmVyIiwicHJvZ3Jlc3NDYWxsYmFjayIsIm5vb3AiLCJBdWRpb0luQnVmZmVyIiwiX1NvdXJjZU1peGluIiwiaW5pdGlhbGl6ZWQiLCJpbml0UHJvbWlzZSIsImluaXQiLCJnZXRDaGFubmVsRGF0YSIsInN0YXJ0ZWQiLCJzdG9wIiwic2FtcGxlUmF0ZSIsInNvdXJjZVNhbXBsZUNvdW50IiwiYXN5bmMiLCJuYnJGcmFtZXMiLCJuYnJDb3B5IiwicHJvcGFnYXRlRnJhbWUiLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJzb3VyY2VOb2RlIiwiYXVkaW9Db250ZXh0IiwiQXVkaW9Jbk5vZGUiLCJBdWRpb05vZGUiLCJfY2hhbm5lbCIsIl9ibG9ja0R1cmF0aW9uIiwic2NyaXB0UHJvY2Vzc29yIiwiY3JlYXRlU2NyaXB0UHJvY2Vzc29yIiwib25hdWRpb3Byb2Nlc3MiLCJjb25uZWN0IiwiZGVzdGluYXRpb24iLCJkaXNjb25uZWN0IiwiaW5wdXRCdWZmZXIiLCJTb2NrZXRSZWNlaXZlIiwiX2Rpc3BhdGNoIiwicHJvbWlzZXMiLCJuZXh0TW9kdWxlcyIsIm1hcCIsIm1vZCIsImluaXRNb2R1bGVBY2siLCJwcmVwYXJlRnJhbWUiLCJhcnJheUJ1ZmZlciIsIklOSVRfTU9EVUxFX1JFUSIsIlBST0NFU1NfU1RSRUFNX1BBUkFNUyIsIlJFU0VUX1NUUkVBTSIsIkZJTkFMSVpFX1NUUkVBTSIsIlBST0NFU1NfRlJBTUUiLCJfRXZlbnRJbiIsIl9FdmVudEluMiIsIl9BdWRpb0luQnVmZmVyIiwiX0F1ZGlvSW5CdWZmZXIyIiwiX0F1ZGlvSW5Ob2RlIiwiX0F1ZGlvSW5Ob2RlMiIsIl9Tb2NrZXRSZWNlaXZlIiwiX1NvY2tldFJlY2VpdmUyIiwiRXZlbnRJbiIsIkRpc3BsYXlTeW5jIiwidmlld3MiLCJfbGVuIiwiX2tleSIsInZpZXciLCJpbnN0YWxsIiwiX0Rpc3BsYXlTeW5jIiwiX0Rpc3BsYXlTeW5jMiIsIl93aW5kb3dzIiwiX3dpbmRvd3MyIiwiaW5pdFdpbmRvd3MiLCJuYnIiLCJfY29sb3JzIiwiZ2V0UmFuZG9tQ29sb3IiLCJsZXR0ZXJzIiwiZG9tYWluTWluIiwiZG9tYWluTWF4IiwicmFuZ2VNaW4iLCJyYW5nZU1heCIsImhleCIsInN1YnN0cmluZyIsInNpbiIsImNvcyIsIl8yUEkiLCJmMCIsImdhaW4iLCJCaXF1YWQiLCJfY2FsY3VsYXRlQ29lZnMiLCJiYW5kd2lkdGgiLCJiMCIsImIxIiwiYjIiLCJhMCIsImExIiwiYTIiLCJ3MCIsImNvc1cwIiwic2luVzAiLCJhbHBoYSIsIl8yUm9vdEFBbHBoYSIsImNvZWZzIiwic3RhdGUiLCJ4MSIsIngyIiwieTEiLCJ5MiIsIm91dERhdGEiLCJpbkRhdGEiLCJDbGlwIiwiaW5wdXRWZWN0b3IiLCJnZXREY3RXZWlnaHRzIiwib3JkZXIiLCJOIiwid2VpZ2h0cyIsInBpT3Zlck4iLCJzY2FsZTAiLCJEY3QiLCJpbkZyYW1lU2l6ZSIsImRlc2NyaXB0aW9uIiwid2VpZ2h0TWF0cml4Iiwib3V0RnJhbWUiLCJzaW1wbGVMaW5lYXJSZWdyZXNzaW9uIiwiZHQiLCJ4U3VtIiwieVN1bSIsInhNZWFuIiwieU1lYW4iLCJzdW1EaWZmWE1lYW5TcXVhcmVkIiwic3VtRGlmZllNZWFuU3F1YXJlZCIsInN1bURpZmZYWU1lYW4iLCJkaWZmWE1lYW4iLCJkaWZmWU1lYW4iLCJkaWZmWE1lYW5TcXVhcmVkIiwiZGlmZllNZWFuU3F1YXJlZCIsImRpZmZYWU1lYW4iLCJTeCIsIlN5IiwidXNlRnJhbWVSYXRlIiwiRGVsdGEiLCJidWZmZXJzIiwicmluZ0luZGV4IiwiYnVmZmVyU2l6ZSIsIkZmdE5heXVraSIsImxldmVscyIsImNvc1RhYmxlIiwic2luVGFibGUiLCJmb3J3YXJkIiwicmVhbCIsImltYWciLCJyZXZlcnNlQml0cyIsImhhbGZzaXplIiwidGFibGVzdGVwIiwidHByZSIsInRwaW0iLCJiaXRzIiwiaXNQb3dlck9mVHdvIiwibnVtYmVyIiwibW9kZSIsIkZmdCIsIm5vcm1hbGl6ZUNvZWZzIiwiZmZ0U2l6ZSIsIndpbmRvd05hbWUiLCJsaW5lYXIiLCJwb3dlciIsIl9ub3JtYWxpemVDb2VmcyIsIndpbmRvd05vcm0iLCJzaWduYWwiLCJyZWFsRGMiLCJpbWFnRGMiLCJyZWFsTnkiLCJpbWFnTnkiLCJfaTIiLCJfbm9ybSIsIl9yZWFsRGMiLCJfaW1hZ0RjIiwiX3JlYWxOeSIsIl9pbWFnTnkiLCJfaTMiLCJfaiIsIl9yZWFsIiwiX2ltYWciLCJub3JtYWxpemUiLCJNYWduaXR1ZGUiLCJfbm9ybWFsaXplIiwiX3Bvd2VyIiwibWFnIiwiTWVhblN0ZGRldiIsImRlbHRhIiwidmFyaWFuY2UiLCJzdGRkZXYiLCJoZXJ0elRvTWVsSHRrIiwiZnJlcUh6IiwibWVsVG9IZXJ0ekh0ayIsImZyZXFNZWwiLCJnZXRNZWxCYW5kV2VpZ2h0cyIsIm5ickJhbmRzIiwibWluRnJlcSIsIm1heEZyZXEiLCJoZXJ0elRvTWVsIiwibWVsVG9IZXJ0eiIsIm1pbk1lbCIsIm1heE1lbCIsIm1lbEJhbmREZXNjcmlwdGlvbnMiLCJmZnRGcmVxcyIsImZpbHRlckZyZXFzIiwibWluV2VpZ2h0SW5kZXhEZWZpbmVkIiwic3RhcnRJbmRleCIsImNlbnRlckZyZXEiLCJwb3NTbG9wZUNvbnRyaWIiLCJuZWdTbG9wZUNvbnRyaWIiLCJjb250cmlidXRpb24iLCJNZWwiLCJtZWxCYW5kcyIsIm1pbkxvZ1ZhbHVlIiwibWluTG9nIiwiX21lbEJhbmREZXNjcmlwdGlvbnMkIiwiZnJhbWVTaXplcyIsIk1lcmdlciIsIm51bVNvdXJjZXMiLCJzb3VyY2VJbmRleCIsImN1cnJlbnRJbmRleCIsImN1cnJlbnRGcmFtZVNpemUiLCJfTWVsIiwiX01lbDIiLCJfRGN0IiwiX0RjdDIiLCJuYnJDb2VmcyIsIk1mY2MiLCJpbnB1dEZyYW1lU2l6ZSIsImlucHV0RnJhbWVSYXRlIiwiaW5wdXRTYW1wbGVSYXRlIiwibWVsIiwiZGN0IiwiTWluTWF4IiwiTW92aW5nQXZlcmFnZSIsInJpbmdCdWZmZXIiLCJyaW5nTGVuZ3RoIiwiZmlsbFN1bSIsImlucHV0U2NhbGFyIiwicmluZ09mZnNldCIsInJpbmdCdWZmZXJJbmRleCIsImxvY2FsU3VtIiwiTW92aW5nTWVkaWFuIiwic29ydEJ1ZmZlciIsIl9lbnN1cmVPZGRPcmRlciIsIm1pbkluZGljZXMiLCJVaW50MzJBcnJheSIsIm1lZGlhbkluZGV4IiwibWluSW5kZXgiLCJtZWRpYW4iLCJzd2FwSW5kZXgiLCJwcmVwcm9jZXNzRnJhbWUiLCJNdWx0aXBsaWVyIiwiT25PZmYiLCJzZXRTdGF0ZSIsImV4cG9uZW50IiwiUG93ZXIiLCJSbXMiLCJpbnB1dE1pbiIsImlucHV0TWF4Iiwib3V0cHV0TWluIiwib3V0cHV0TWF4IiwiU2NhbGUiLCJfc2V0U2NhbGVGdW5jdGlvbiIsIl9Nb3ZpbmdBdmVyYWdlIiwiX01vdmluZ0F2ZXJhZ2UyIiwibG9nSW5wdXQiLCJtaW5JbnB1dCIsImZpbHRlck9yZGVyIiwib2ZmVGhyZXNob2xkIiwibWluSW50ZXIiLCJtYXhEdXJhdGlvbiIsIlNlZ21lbnRlciIsImluc2lkZVNlZ21lbnQiLCJvbnNldFRpbWUiLCJzdW1PZlNxdWFyZXMiLCJtb3ZpbmdBdmVyYWdlIiwibGFzdE12YXZyZyIsInJlc2V0U2VnbWVudCIsIm91dHB1dFNlZ21lbnQiLCJtZWFuT2ZTcXVhcmUiLCJzcXVhcmVPZm1lYW4iLCJyYXdWYWx1ZSIsImRpZmYiLCJpbmRleGVzIiwiU2VsZWN0Iiwic2VsZWN0IiwiaG9wU2l6ZSIsImNlbnRlcmVkVGltZVRhZ3MiLCJTbGljZXIiLCJmcmFtZUluZGV4IiwiYmxvY2siLCJzYW1wbGVQZXJpb2QiLCJibG9ja1NpemUiLCJibG9ja0luZGV4IiwibnVtU2tpcCIsIm51bUNvcHkiLCJtYXhDb3B5IiwiYmxvY2tSZXN0IiwiZG93blNhbXBsaW5nRXhwIiwiWWluIiwicHJvYmFiaWxpdHkiLCJwaXRjaCIsIl9kb3duc2FtcGxlIiwib3V0cHV0U2l6ZSIsImRvd25GYWN0b3IiLCJkb3duU1IiLCJkb3duRnJhbWVTaXplIiwibWluRnJlcU5iclNhbXBsZXMiLCJoYWxmQnVmZmVyU2l6ZSIsImRvd25TYW1wbGluZ1JhdGUiLCJ5aW5CdWZmZXIiLCJfbm9ybWFsaXplZERpZmZlcmVuY2UiLCJ0YXUiLCJzcXVhcmVkRGlmZmVyZW5jZSIsIl9hYnNvbHV0ZVRocmVzaG9sZCIsIl9wYXJhYm9saWNJbnRlcnBvbGF0aW9uIiwidGF1RXN0aW1hdGUiLCJiZXR0ZXJUYXUiLCJ4MCIsInMwIiwiczEiLCJfQmlxdWFkIiwiX0JpcXVhZDIiLCJfQ2xpcCIsIl9DbGlwMiIsIl9EZWx0YSIsIl9EZWx0YTIiLCJfTWFnbml0dWRlIiwiX01hZ25pdHVkZTIiLCJfTWVhblN0ZGRldiIsIl9NZWFuU3RkZGV2MiIsIl9NZXJnZXIiLCJfTWVyZ2VyMiIsIl9NZmNjIiwiX01mY2MyIiwiX01vdmluZ01lZGlhbiIsIl9Nb3ZpbmdNZWRpYW4yIiwiX09uT2ZmIiwiX09uT2ZmMiIsIl9Qb3dlciIsIl9Qb3dlcjIiLCJfTXVsdGlwbGllciIsIl9NdWx0aXBsaWVyMiIsIl9TY2FsZSIsIl9TY2FsZTIiLCJfU2VnbWVudGVyIiwiX1NlZ21lbnRlcjIiLCJfU2VsZWN0IiwiX1NlbGVjdDIiLCJfU2xpY2VyIiwiX1NsaWNlcjIiLCJfWWluIiwiX1lpbjIiLCJwcm9jZXNzU3RyZWFtUGFyYW1zQ2FsbGJhY2siLCJmaW5hbGl6ZVN0cmVhbUNhbGxiYWNrIiwicHJvY2Vzc0ZyYW1lQ2FsbGJhY2siLCJzZXBhcmF0ZUFycmF5cyIsImlzUmVjb3JkaW5nIiwiX2luaXRTdG9yZSIsIl9zdG9yZSIsImVudHJ5IiwiaWdub3JlTGVhZGluZ1plcm9zIiwicmV0cmlldmVBdWRpb0J1ZmZlciIsIl9hdWRpb0NvbnRleHQiLCJfaWdub3JlWmVyb3MiLCJfaXNJbmZpbml0ZUJ1ZmZlciIsIl9idWZmZXIiLCJfYnVmZmVyTGVuZ3RoIiwiX2N1cnJlbnRJbmRleCIsIl9pbml0QnVmZmVyIiwiYnVmZmVyTGVuZ3RoIiwic3RhY2tlZEJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImNoYW5uZWxEYXRhIiwiYXZhaWxhYmxlU3BhY2UiLCJjdXJyZW50QmxvY2siLCJfaXNGaW5pdGUyIiwiZ2V0VGltZUZ1bmN0aW9uIiwiaHJ0aW1lIiwicGVyZm9ybWFuY2UiLCJhYnNvbHV0ZVRpbWUiLCJfZ2V0VGltZSIsIl9zdGFydFRpbWUiLCJfc3lzdGVtVGltZSIsIl9hYnNvbHV0ZVRpbWUiLCJzdGFydFRpbWUiLCJpbml0SGFubldpbmRvdyIsIm5vcm1Db2VmcyIsImxpblN1bSIsInBvd1N1bSIsInBoaSIsImluaXRIYW1taW5nV2luZG93IiwiaW5pdEJsYWNrbWFuV2luZG93IiwiaW5pdEJsYWNrbWFuSGFycmlzV2luZG93IiwiYTMiLCJpbml0U2luZVdpbmRvdyIsImluaXRSZWN0YW5nbGVXaW5kb3ciLCJpbml0V2luZG93IiwidG9Mb3dlckNhc2UiLCJfc3RyaW5naWZ5MiIsIlVpbnQxNkFycmF5Mmpzb24iLCJzdHIiLCJmcm9tQ2hhckNvZGUiLCJwYXJzZSIsImpzb24yVWludDE2QXJyYXkiLCJqc29uIiwiQXJyYXlCdWZmZXIiLCJidWZmZXJWaWV3IiwiVWludDE2QXJyYXkiLCJwYXlsb2FkIiwiX3N0cmVhbVBhcmFtcyIsInN0cmVhbVBhcmFtc0J1ZmZlciIsImVuZFRpbWVCdWZmZXIiLCJGbG9hdDY0QXJyYXkiLCJ0aW1lU3RhcnQiLCJ0aW1lRW5kIiwiZGF0YVN0YXJ0IiwiZGF0YUVuZCIsIm1ldGFTdGFydCIsIm1ldGFCdWZmZXIiLCJfcGFyYW1ldGVycyIsIl9wYXJhbWV0ZXJzMiIsIkJhc2VMZm8iLCJjaWQiLCJwcmV2TW9kdWxlIiwiX3JlaW5pdCIsImdldFBhcmFtc0Rlc2NyaXB0aW9uIiwicmVzZXRQYXJhbXMiLCJkZXN0cm95IiwibmV4dFByb21pc2VzIiwicHJldkZyYW1lVHlwZSIsIlNvdXJjZU1peGluIiwic3VwZXJjbGFzcyIsIl9zdXBlcmNsYXNzIiwiX2NsYXNzIiwiX3JlZiIsIlNvY2tldCIsIm15b0xpc3QiLCJNeW8iLCJkZWZhdWx0cyIsImFwaV92ZXJzaW9uIiwic29ja2V0X3VybCIsImFwcF9pZCIsImxvY2tpbmdQb2xpY3kiLCJldmVudHMiLCJteW9zIiwib25FcnJvciIsInNldExvY2tpbmdQb2xpY3kiLCJwb2xpY3kiLCJldmVudE5hbWUiLCJlbWl0dGVyIiwib24iLCJvZmYiLCJhcHBJZCIsInNvY2tldExpYiIsImhhbmRsZU1lc3NhZ2UiLCJvbmNsb3NlIiwibXNnIiwibXlvIiwiZXhpc3RzIiwibWFjQWRkcmVzcyIsIm1hY19hZGRyZXNzIiwiY29ubmVjdEluZGV4IiwiaXNTdGF0dXNFdmVudCIsImV2ZW50VGFibGUiLCJ0aW1lc3RhbXAiLCJteW9Qcm9wcyIsIm1lcmdlIiwibG9ja2VkIiwiY29ubmVjdGVkIiwic3luY2VkIiwiYmF0dGVyeUxldmVsIiwibGFzdElNVSIsImFybSIsImRpcmVjdGlvbiIsIndhcm11cFN0YXRlIiwib3JpZW50YXRpb25PZmZzZXQiLCJfdHJpZ2dlciIsImxvY2siLCJ1bmxvY2siLCJob2xkIiwiemVyb09yaWVudGF0aW9uIiwicXVhdEludmVyc2UiLCJsYXN0UXVhbnQiLCJ2aWJyYXRlIiwiaW50ZW5zaXR5IiwicmVxdWVzdEJsdWV0b290aFN0cmVuZ3RoIiwicmVxdWVzdEJhdHRlcnlMZXZlbCIsInN0cmVhbUVNRyIsImVuYWJsZWQiLCJsYXN0UG9zZSIsInBvc2UiLCJvcmllbnRhdGlvbiIsIm9yaSIsInF1YXRSb3RhdGUiLCJpbXVfZGF0YSIsImFjY2VsZXJvbWV0ZXIiLCJneXJvc2NvcGUiLCJlbWciLCJ4X2RpcmVjdGlvbiIsIndhcm11cF9zdGF0ZSIsImNvbm5lY3RWZXJzaW9uIiwiYmx1ZXRvb3RoX3N0cmVuZ3RoIiwiZ2V0U3RyZW5ndGhGcm9tUnNzaSIsInJzc2kiLCJiYXR0ZXJ5X2xldmVsIiwiZXZlbnRDb3VudGVyIiwiYXJnc190ZW1wIiwidW5zaGlmdCIsInJlZHVjZSIsIm9iajEiLCJvYmoyIiwiYXR0cm5hbWUiLCJsZm8iLCJTRyIsImNvbmZpZyIsIkVNR1dpbmRvd0xlbmd0aCIsImFjY2VsZXJvV2luZG93TGVuZ3RoIiwic3BlZWRSYXRlV2luZG93TGVuZ3RoIiwiYW1wbGl0dWRlV2luZG93TGVuZ3RoIiwiU0dXaW5kb3dMZW5ndGgiLCJ0aW1lRU1HIiwiZHRFTUciLCJzb2NrZXRTZW5kSmVya2luZXNzIiwic29ja2V0Q2xpZW50VG9TZXJ2ZXIiLCJteU15byIsImV2ZW50SW5BY2NlbGVybyIsImV2ZW50SW5TbW9vdGhuZXNzIiwiZXZlbnRJbkd5cm8iLCJldmVudEluRU1HIiwiZXZlbnRJbkVNR1NsaWRpbmciLCJldmVudEluU21vb3RobmVzc1JlY29yZGVkIiwiaW5pdEdyYXBoIiwiYWRkRXZlbnRzIiwiYnBmRGlzcGxheUFjY2VsZXJvIiwiYnBmRGlzcGxheUplcmtpbmVzcyIsImJwZkRpc3BsYXlFTUciLCJicGZEaXNwbGF5RU1HU2xpbmRpbmciLCJiaXF1YWQiLCJiaXF1YWQyIiwiZGlzcGxheVdpbmRvdyIsImRpc3BsYXlTbW9vdGhuZXNzIiwiYW5zWCIsImFuc1kiLCJhbnNaIiwiY29tcHV0ZWRTcGVlZFJhdGUiLCJzdW1MYXN0RWxlbSIsInN1bUZpcnN0RWxlbSIsImNvbXB1dGVTcGVlZFJhdGVBZGFwdGF0aXZlV2luZG93Iiwid2luZG93TGVuZ3RoIiwibmV3WCIsIm5ld1kiLCJuZXdaIiwiZmlyc3RFbGVtZW50WCIsImZpcnN0RWxlbWVudFkiLCJmaXJzdEVsZW1lbnRaIiwiYW5zWE5haWYiLCJhbnNZTmFpZiIsImFuc1pOYWlmIiwiY29tcHV0ZVNwZWVkUmF0ZUFkYXB0YXRpdmVXaW5kb3dOYWlmIiwic3BlZWRSYXRlIiwiZGlzcGxheUFjY2VsZXJvV2luZG93U3BlZWQiLCJmcmFtZUFjY2VsZXJvIiwic2xpZGluZ1dpbmRvdyIsImRpc3BsYXlFTUdXaW5kb3ciLCJtYXhTbGlkaW5nIiwiZnJhbWVFTUdTbGlkaW5nIiwiZnJhbWVFTUciLCJhcnJheUZpbHRlcmluZ1giLCJhcnJheUZpbHRlcmluZ1kiLCJhcnJheUZpbHRlcmluZ1oiLCJhbnN4IiwiYW5zeSIsImFuc3oiLCJvcHRpb25zR29sYXlMb3dQYXNzIiwid2luZG93TGVuZ3RoU0ciLCJub3JtYWxpc2VEYXRhIiwiYW1wbGl0dWRlRGF0YSIsImNvbXB1dGVBbXBsaXR1ZGVXaW5kb3ciLCJyZWNvcmRpbmciLCJhcnJheVJlY29yZGVkIiwiZnJhbWVTbW9vdGhuZXNzIiwiYXJyYXlBbXBsaXR1ZGUiLCJhbXBsaXR1ZGVSYXRlIiwic2V0U0dXaW5kb3dMZW5ndGgiLCJuZXdWYWx1ZSIsInNldEFtcGxpdHVkZVdpbmRvd0xlbmd0aCIsInN0YXJ0UmVjb3JkIiwiU3RyZWFtT25PZmYiLCJzdG9wUmVjb3JkIiwidGltZXIiLCJwbGF5UmVjb3JkZWQiLCJzZXRJbnRlcnZhbCIsInBsYXlpbmdSZWNvcmQiLCJjbGVhclRpbWVvdXQiLCJzdG9waW5nUmVjb3JkZWQiLCJvbk9mZiIsImZyYW1lU21vb3RobmVzc09uT0ZGIiwiYXBwTmFtZSIsImVudiIsImFzc2V0c0RvbWFpbiIsInBvcnRTZXJ2ZXIiLCJteW9Qb3J0Iiwib3NjIiwicmVjZWl2ZUFkZHJlc3MiLCJyZWNlaXZlUG9ydCIsInNlbmRBZGRyZXNzIiwic2VuZFBvcnQiLCJzb2NrZXRTZXJ2ZXJUb0NsaWVudCIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbnMiLCJvbmNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxFQUFDLFlBQVU7QUFBQyxBQUFTLGNBQVQsRUFBQSxBQUFXLEdBQVgsQUFBYSxHQUFiLEFBQWUsR0FBRTtBQUFDLEFBQVMsbUJBQVQsRUFBQSxBQUFXLEdBQVgsQUFBYSxHQUFFO0FBQUMsbUJBQUcsQ0FBQyxFQUFKLEFBQUksQUFBRSxJQUFHO0FBQUMsd0JBQUcsQ0FBQyxFQUFKLEFBQUksQUFBRSxJQUFHO0FBQUMsQUFBSSxpQ0FBRSxjQUFZLEFBQU8sT0FBbkIsV0FBTixBQUFrQyxRQUFRLElBQUcsQ0FBQSxBQUFDLEtBQUosQUFBTyxHQUFFLEFBQU8sU0FBQSxBQUFFLEdBQUUsQ0FBWCxBQUFPLEFBQUssR0FBRyxJQUFBLEFBQUcsR0FBRSxBQUFPLFNBQUEsQUFBRSxHQUFFLENBQVgsQUFBTyxBQUFLLEdBQUcsQUFBSSxRQUFFLEFBQUksSUFBSixNQUFVLHlCQUFBLEFBQXVCLElBQXZDLEFBQU0sQUFBbUMsS0FBSyxBQUFNLFFBQUEsQUFBRSxPQUFGLEFBQU8sb0JBQWIsQUFBZ0MsQUFBRTtBQUFJLDZCQUFFLEVBQUEsQUFBRSxLQUFHLEVBQUMsU0FBWixBQUFXLEFBQVMsT0FBSSxBQUFFLEdBQUYsQUFBSyxHQUFMLEFBQVEsS0FBSyxFQUFiLEFBQWUsU0FBUSxVQUFBLEFBQVMsR0FBRTtBQUFDLEFBQUksaUNBQUUs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LEFBb2tsQmxjLEFBMExSLE9BOXZsQkYsQUE4dmxCTyxJQUFHLENBOXZsQlYsQUE4dmxCVSxBQUFDIiwiZmlsZSI6InNlbnNvclNjcmlwdC5kaXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbmZ1bmN0aW9uIGNsaXAodmFsdWUpIHtcbiAgdmFyIGxvd2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAtSW5maW5pdHk7XG4gIHZhciB1cHBlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogK0luZmluaXR5O1xuXG4gIHJldHVybiBtYXgobG93ZXIsIG1pbih1cHBlciwgdmFsdWUpKTtcbn1cblxuLyoqXG4gKiBEaWN0aW9ubmFyeSBvZiB0aGUgYXZhaWxhYmxlIHR5cGVzLiBFYWNoIGtleSBjb3JyZXNwb25kIHRvIHRoZSB0eXBlIG9mIHRoZVxuICogaW1wbGVtZW50ZWQgcGFyYW0gd2hpbGUgdGhlIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHZhbHVlIHNob3VsZCB0aGVcbiAqIHtAbGluayBgcGFyYW1EZWZpbml0aW9uYH0gb2YgdGhlIGRlZmluZWQgdHlwZS5cbiAqXG4gKiB0eXBlZGVmIHtPYmplY3R9IHBhcmFtVGVtcGxhdGVzXG4gKiBAdHlwZSB7T2JqZWN0PFN0cmluZywgcGFyYW1UZW1wbGF0ZT59XG4gKi9cblxuLyoqXG4gKiBEZWZpbml0aW9uIG9mIGEgcGFyYW1ldGVyLiBUaGUgZGVmaW5pdGlvbiBzaG91bGQgYXQgbGVhc3QgY29udGFpbiB0aGUgZW50cmllc1xuICogYHR5cGVgIGFuZCBgZGVmYXVsdGAuIEV2ZXJ5IHBhcmFtZXRlciBjYW4gYWxzbyBhY2NlcHQgb3B0aW9ubmFsIGNvbmZpZ3VyYXRpb25cbiAqIGVudHJpZXMgYGNvbnN0YW50YCBhbmQgYG1ldGFzYC5cbiAqIEF2YWlsYWJsZSBkZWZpbml0aW9ucyBhcmU6XG4gKiAtIHtAbGluayBib29sZWFuRGVmaW5pdGlvbn1cbiAqIC0ge0BsaW5rIGludGVnZXJEZWZpbml0aW9ufVxuICogLSB7QGxpbmsgZmxvYXREZWZpbml0aW9ufVxuICogLSB7QGxpbmsgc3RyaW5nRGVmaW5pdGlvbn1cbiAqIC0ge0BsaW5rIGVudW1EZWZpbml0aW9ufVxuICpcbiAqIHR5cGVkZWYge09iamVjdH0gcGFyYW1EZWZpbml0aW9uXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSAtIFR5cGUgb2YgdGhlIHBhcmFtZXRlci5cbiAqIEBwcm9wZXJ0eSB7TWl4ZWR9IGRlZmF1bHQgLSBEZWZhdWx0IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgaWYgbm9cbiAqICBpbml0aWFsaXphdGlvbiB2YWx1ZSBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0YW50PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGNhbiBiZSBjaGFuZ2VcbiAqICBhZnRlciBpdHMgaW5pdGlhbGl6YXRpb24uXG4gKiBAcHJvcGVydHkge09iamVjdH0gW21ldGFzPW51bGxdIC0gQW55IHVzZXIgZGVmaW5lZCBkYXRhIGFzc29jaWF0ZWQgdG8gdGhlXG4gKiAgcGFyYW1ldGVyIHRoYXQgY291bHMgYmUgdXNlZnVsbCBpbiB0aGUgYXBwbGljYXRpb24uXG4gKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gYm9vbGVhbkRlZmluaXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0eXBlPSdib29sZWFuJ10gLSBEZWZpbmUgYSBib29sZWFuIHBhcmFtZXRlci5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0IC0gRGVmYXVsdCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjb25zdGFudD1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBjb25zdGFudC5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbnVsbGFibGU9ZmFsc2VdIC0gRGVmaW5lIGlmIHRoZSBwYXJhbWV0ZXIgaXMgbnVsbGFibGUuXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbWV0YXM9e31dIC0gT3B0aW9ubmFsIG1ldGFkYXRhIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqL1xuICBib29sZWFuOiB7XG4gICAgZGVmaW5pdGlvblRlbXBsYXRlOiBbJ2RlZmF1bHQnXSxcbiAgICB0eXBlQ2hlY2tGdW5jdGlvbjogZnVuY3Rpb24gdHlwZUNoZWNrRnVuY3Rpb24odmFsdWUsIGRlZmluaXRpb24sIG5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBib29sZWFuIHBhcmFtIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWx1ZSk7XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IGludGVnZXJEZWZpbml0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdHlwZT0naW50ZWdlciddIC0gRGVmaW5lIGEgYm9vbGVhbiBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TWl4ZWR9IGRlZmF1bHQgLSBEZWZhdWx0IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWluPS1JbmZpbml0eV0gLSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWF4PStJbmZpbml0eV0gLSBNYXhpbXVtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0YW50PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIGNvbnN0YW50LlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtudWxsYWJsZT1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBudWxsYWJsZS5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFttZXRhcz17fV0gLSBPcHRpb25uYWwgbWV0YWRhdGEgb2YgdGhlIHBhcmFtZXRlci5cbiAgICovXG4gIGludGVnZXI6IHtcbiAgICBkZWZpbml0aW9uVGVtcGxhdGU6IFsnZGVmYXVsdCddLFxuICAgIHR5cGVDaGVja0Z1bmN0aW9uOiBmdW5jdGlvbiB0eXBlQ2hlY2tGdW5jdGlvbih2YWx1ZSwgZGVmaW5pdGlvbiwgbmFtZSkge1xuICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIGludGVnZXIgcGFyYW0gXCInICsgbmFtZSArICdcIjogJyArIHZhbHVlKTtcblxuICAgICAgcmV0dXJuIGNsaXAodmFsdWUsIGRlZmluaXRpb24ubWluLCBkZWZpbml0aW9uLm1heCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBmbG9hdERlZmluaXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0eXBlPSdmbG9hdCddIC0gRGVmaW5lIGEgYm9vbGVhbiBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TWl4ZWR9IGRlZmF1bHQgLSBEZWZhdWx0IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWluPS1JbmZpbml0eV0gLSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWF4PStJbmZpbml0eV0gLSBNYXhpbXVtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0YW50PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIGNvbnN0YW50LlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtudWxsYWJsZT1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBudWxsYWJsZS5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFttZXRhcz17fV0gLSBPcHRpb25uYWwgbWV0YWRhdGEgb2YgdGhlIHBhcmFtZXRlci5cbiAgICovXG4gIGZsb2F0OiB7XG4gICAgZGVmaW5pdGlvblRlbXBsYXRlOiBbJ2RlZmF1bHQnXSxcbiAgICB0eXBlQ2hlY2tGdW5jdGlvbjogZnVuY3Rpb24gdHlwZUNoZWNrRnVuY3Rpb24odmFsdWUsIGRlZmluaXRpb24sIG5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICE9PSB2YWx1ZSkgLy8gcmVqZWN0IE5hTlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIGZsb2F0IHBhcmFtIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWx1ZSk7XG5cbiAgICAgIHJldHVybiBjbGlwKHZhbHVlLCBkZWZpbml0aW9uLm1pbiwgZGVmaW5pdGlvbi5tYXgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gc3RyaW5nRGVmaW5pdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3R5cGU9J3N0cmluZyddIC0gRGVmaW5lIGEgYm9vbGVhbiBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TWl4ZWR9IGRlZmF1bHQgLSBEZWZhdWx0IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0YW50PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIGNvbnN0YW50LlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtudWxsYWJsZT1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBudWxsYWJsZS5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFttZXRhcz17fV0gLSBPcHRpb25uYWwgbWV0YWRhdGEgb2YgdGhlIHBhcmFtZXRlci5cbiAgICovXG4gIHN0cmluZzoge1xuICAgIGRlZmluaXRpb25UZW1wbGF0ZTogWydkZWZhdWx0J10sXG4gICAgdHlwZUNoZWNrRnVuY3Rpb246IGZ1bmN0aW9uIHR5cGVDaGVja0Z1bmN0aW9uKHZhbHVlLCBkZWZpbml0aW9uLCBuYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBzdHJpbmcgcGFyYW0gXCInICsgbmFtZSArICdcIjogJyArIHZhbHVlKTtcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gZW51bURlZmluaXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0eXBlPSdlbnVtJ10gLSBEZWZpbmUgYSBib29sZWFuIHBhcmFtZXRlci5cbiAgICogQHByb3BlcnR5IHtNaXhlZH0gZGVmYXVsdCAtIERlZmF1bHQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHByb3BlcnR5IHtBcnJheX0gbGlzdCAtIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjb25zdGFudD1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBjb25zdGFudC5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbnVsbGFibGU9ZmFsc2VdIC0gRGVmaW5lIGlmIHRoZSBwYXJhbWV0ZXIgaXMgbnVsbGFibGUuXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbWV0YXM9e31dIC0gT3B0aW9ubmFsIG1ldGFkYXRhIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqL1xuICBlbnVtOiB7XG4gICAgZGVmaW5pdGlvblRlbXBsYXRlOiBbJ2RlZmF1bHQnLCAnbGlzdCddLFxuICAgIHR5cGVDaGVja0Z1bmN0aW9uOiBmdW5jdGlvbiB0eXBlQ2hlY2tGdW5jdGlvbih2YWx1ZSwgZGVmaW5pdGlvbiwgbmFtZSkge1xuICAgICAgaWYgKGRlZmluaXRpb24ubGlzdC5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgZW51bSBwYXJhbSBcIicgKyBuYW1lICsgJ1wiOiAnICsgdmFsdWUpO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBhbnlEZWZpbml0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdHlwZT0nZW51bSddIC0gRGVmaW5lIGEgcGFyYW1ldGVyIG9mIGFueSB0eXBlLlxuICAgKiBAcHJvcGVydHkge01peGVkfSBkZWZhdWx0IC0gRGVmYXVsdCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjb25zdGFudD1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBjb25zdGFudC5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbnVsbGFibGU9ZmFsc2VdIC0gRGVmaW5lIGlmIHRoZSBwYXJhbWV0ZXIgaXMgbnVsbGFibGUuXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbWV0YXM9e31dIC0gT3B0aW9ubmFsIG1ldGFkYXRhIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqL1xuICBhbnk6IHtcbiAgICBkZWZpbml0aW9uVGVtcGxhdGU6IFsnZGVmYXVsdCddLFxuICAgIHR5cGVDaGVja0Z1bmN0aW9uOiBmdW5jdGlvbiB0eXBlQ2hlY2tGdW5jdGlvbih2YWx1ZSwgZGVmaW5pdGlvbiwgbmFtZSkge1xuICAgICAgLy8gbm8gY2hlY2sgYXMgaXQgY2FuIGhhdmUgYW55IHR5cGUuLi5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3BhcmFtVGVtcGxhdGVzID0gcmVxdWlyZSgnLi9wYXJhbVRlbXBsYXRlcycpO1xuXG52YXIgX3BhcmFtVGVtcGxhdGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmFtVGVtcGxhdGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBHZW5lcmljIGNsYXNzIGZvciB0eXBlZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtBcnJheX0gZGVmaW5pdGlvblRlbXBsYXRlIC0gTGlzdCBvZiBtYW5kYXRvcnkga2V5cyBpbiB0aGUgcGFyYW1cbiAqICBkZWZpbml0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZUNoZWNrRnVuY3Rpb24gLSBGdW5jdGlvbiB0byBiZSB1c2VkIGluIG9yZGVyIHRvIGNoZWNrXG4gKiAgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHBhcmFtIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiAtIERlZmluaXRpb24gb2YgdGhlIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBQYXJhbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFyYW0obmFtZSwgZGVmaW5pdGlvblRlbXBsYXRlLCB0eXBlQ2hlY2tGdW5jdGlvbiwgZGVmaW5pdGlvbiwgdmFsdWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyYW0pO1xuXG4gICAgZGVmaW5pdGlvblRlbXBsYXRlLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGRlZmluaXRpb24uaGFzT3duUHJvcGVydHkoa2V5KSA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZWZpbml0aW9uIGZvciBwYXJhbSBcIicgKyBuYW1lICsgJ1wiLCAnICsga2V5ICsgJyBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSBkZWZpbml0aW9uLnR5cGU7XG4gICAgdGhpcy5kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblxuICAgIGlmICh0aGlzLmRlZmluaXRpb24ubnVsbGFibGUgPT09IHRydWUgJiYgdmFsdWUgPT09IG51bGwpIHRoaXMudmFsdWUgPSBudWxsO2Vsc2UgdGhpcy52YWx1ZSA9IHR5cGVDaGVja0Z1bmN0aW9uKHZhbHVlLCBkZWZpbml0aW9uLCBuYW1lKTtcbiAgICB0aGlzLl90eXBlQ2hlY2tGdW5jdGlvbiA9IHR5cGVDaGVja0Z1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqIEByZXR1cm4ge01peGVkfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQYXJhbSwgW3tcbiAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gTmV3IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBgdHJ1ZWAgaWYgdGhlIHBhcmFtIGhhcyBiZWVuIHVwZGF0ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqICAoZS5nLiBpZiB0aGUgcGFyYW1ldGVyIGFscmVhZHkgaGFkIHRoaXMgdmFsdWUpLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5kZWZpbml0aW9uLmNvbnN0YW50ID09PSB0cnVlKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzaWduZW1lbnQgdG8gY29uc3RhbnQgcGFyYW0gXCInICsgdGhpcy5uYW1lICsgJ1wiJyk7XG5cbiAgICAgIGlmICghKHRoaXMuZGVmaW5pdGlvbi5udWxsYWJsZSA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PT0gbnVsbCkpIHZhbHVlID0gdGhpcy5fdHlwZUNoZWNrRnVuY3Rpb24odmFsdWUsIHRoaXMuZGVmaW5pdGlvbiwgdGhpcy5uYW1lKTtcblxuICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFyYW07XG59KCk7XG5cbi8qKlxuICogQmFnIG9mIHBhcmFtZXRlcnMuIE1haW4gaW50ZXJmYWNlIG9mIHRoZSBsaWJyYXJ5XG4gKi9cblxuXG52YXIgUGFyYW1ldGVyQmFnID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJhbWV0ZXJCYWcocGFyYW1zLCBkZWZpbml0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJhbWV0ZXJCYWcpO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxTdHJpbmcsIFBhcmFtPn1cbiAgICAgKiBAbmFtZSBfcGFyYW1zXG4gICAgICogQG1lbWJlcm9mIFBhcmFtZXRlckJhZ1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBkZWZpbml0aW9ucyB3aXRoIGluaXQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxTdHJpbmcsIHBhcmFtRGVmaW5pdGlvbj59XG4gICAgICogQG5hbWUgX2RlZmluaXRpb25zXG4gICAgICogQG1lbWJlcm9mIFBhcmFtZXRlckJhZ1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgZ2xvYmFsIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICogQG5hbWUgX2dsb2JhbExpc3RlbmVyc1xuICAgICAqIEBtZW1iZXJvZiBQYXJhbWV0ZXJCYWdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dsb2JhbExpc3RlbmVycyA9IG5ldyBTZXQoKTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcGFyYW1zIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBTZXQ+fVxuICAgICAqIEBuYW1lIF9wYXJhbXNMaXN0ZW5lcnNcbiAgICAgKiBAbWVtYmVyb2YgUGFyYW1ldGVyQmFnXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnMgPSB7fTtcblxuICAgIC8vIGluaXRpYWxpemUgZW1wdHkgU2V0IGZvciBlYWNoIHBhcmFtXG4gICAgZm9yICh2YXIgbmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHRoaXMuX3BhcmFtc0xpc3RlbmVyc1tuYW1lXSA9IG5ldyBTZXQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBnaXZlbiBkZWZpbml0aW9ucyBhbG9uZyB3aXRoIHRoZSBpbml0aWFsaXphdGlvbiB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUGFyYW1ldGVyQmFnLCBbe1xuICAgIGtleTogJ2dldERlZmluaXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbnMoKSB7XG4gICAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHJldHVybiB0aGlzLl9kZWZpbml0aW9uc1tuYW1lXTtlbHNlIHJldHVybiB0aGlzLl9kZWZpbml0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJuIHtNaXhlZH0gLSBWYWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgaWYgKCF0aGlzLl9wYXJhbXNbbmFtZV0pIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgcHJvcGVydHkgdmFsdWUgb2YgdW5kZWZpbmVkIHBhcmFtZXRlciBcIicgKyBuYW1lICsgJ1wiJyk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9wYXJhbXNbbmFtZV0udmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhIHBhcmFtZXRlci4gSWYgdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgaXMgdXBkYXRlZFxuICAgICAqIChha2EgaWYgcHJldmlvdXMgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gbmV3IHZhbHVlKSBhbGwgcmVnaXN0ZXJlZFxuICAgICAqIGNhbGxiYWNrcyBhcmUgcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJuIHtNaXhlZH0gLSBOZXcgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgcGFyYW0gPSB0aGlzLl9wYXJhbXNbbmFtZV07XG4gICAgICB2YXIgdXBkYXRlZCA9IHBhcmFtLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gcGFyYW0uZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgdmFyIG1ldGFzID0gcGFyYW0uZGVmaW5pdGlvbi5tZXRhcztcbiAgICAgICAgLy8gdHJpZ2dlciBnbG9iYWwgbGlzdGVuZXJzXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuX2dsb2JhbExpc3RlbmVyc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBsaXN0ZW5lcihuYW1lLCB2YWx1ZSwgbWV0YXMpO1xuICAgICAgICAgIH0gLy8gdHJpZ2dlciBwYXJhbSBsaXN0ZW5lcnNcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdGhpcy5fcGFyYW1zTGlzdGVuZXJzW25hbWVdW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2xpc3RlbmVyID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICBfbGlzdGVuZXIodmFsdWUsIG1ldGFzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIGlmIHRoZSBgbmFtZWAgcGFyYW1ldGVyIGV4aXN0cyBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtc1tuYW1lXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBhIHBhcmFtZXRlciB0byBpdHMgaW5pdCB2YWx1ZS4gUmVzZXQgYWxsIHBhcmFtZXRlcnMgaWYgbm8gYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9bnVsbF0gLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIgdG8gcmVzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHRoaXMuc2V0KG5hbWUsIHBhcmFtLmRlZmluaXRpb24uaW5pdFZhbHVlKTtlbHNlIE9iamVjdC5rZXlzKHRoaXMuX3BhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVzZXQobmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY2FsbGJhY2sgUGFyYW1ldGVyQmFnfmxpc3RlbmVyQ2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVXBkYXRlZCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbWV0YT1dIC0gR2l2ZW4gbWV0YSBkYXRhIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGlzdGVuZXIgdG8gYWxsIHBhcmFtIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtZXRlckJhZ35saXN0ZW5lckNhbGxhY2t9IGNhbGxiYWNrIC0gTGlzdGVuZXIgdG8gcmVnaXN0ZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZExpc3RlbmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX2dsb2JhbExpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBsaXN0ZW5lciBmcm9tIGFsbCBwYXJhbSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbWV0ZXJCYWd+bGlzdGVuZXJDYWxsYWNrfSBjYWxsYmFjayAtIExpc3RlbmVyIHRvIHJlbW92ZS4gSWZcbiAgICAgKiAgYG51bGxgIHJlbW92ZSBhbGwgbGlzdGVuZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVMaXN0ZW5lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwpIHRoaXMuX2dsb2JhbExpc3RlbmVycy5jbGVhcigpO2Vsc2UgdGhpcy5fZ2xvYmFsTGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNhbGxiYWNrIFBhcmFtZXRlckJhZ35wYXJhbUxpc3RlbmVyQ2FsbGFja1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVXBkYXRlZCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbWV0YT1dIC0gR2l2ZW4gbWV0YSBkYXRhIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGlzdGVuZXIgdG8gYSBnaXZlbiBwYXJhbSB1cGRhdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBQYXJhbWV0ZXIgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1BhcmFtZXRlckJhZ35wYXJhbUxpc3RlbmVyQ2FsbGFja30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBhcHBseVxuICAgICAqICB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdHJpZ2dlcj1mYWxzZV0gLSBFeGVjdXRlIHRoZSBjYWxsYmFjayBpbW1lZGlhdGVseSB3aXRoXG4gICAgICogIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRQYXJhbUxpc3RlbmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUGFyYW1MaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHRyaWdnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnNbbmFtZV0uYWRkKGNhbGxiYWNrKTtcblxuICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgdmFyIF9wYXJhbSA9IHRoaXMuX3BhcmFtc1tuYW1lXTtcbiAgICAgICAgdmFyIHZhbHVlID0gX3BhcmFtLmdldFZhbHVlKCk7XG4gICAgICAgIHZhciBtZXRhcyA9IF9wYXJhbS5kZWZpbml0aW9uLm1ldGFzO1xuICAgICAgICBjYWxsYmFjayh2YWx1ZSwgbWV0YXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBsaXN0ZW5lciBmcm9tIGEgZ2l2ZW4gcGFyYW0gdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gUGFyYW1ldGVyIG5hbWUuXG4gICAgICogQHBhcmFtIHtQYXJhbWV0ZXJCYWd+cGFyYW1MaXN0ZW5lckNhbGxhY2t9IGNhbGxiYWNrIC0gTGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgICAqICBJZiBgbnVsbGAgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZVBhcmFtTGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVQYXJhbUxpc3RlbmVyKG5hbWUpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrID09PSBudWxsKSB0aGlzLl9wYXJhbXNMaXN0ZW5lcnNbbmFtZV0uY2xlYXIoKTtlbHNlIHRoaXMuX3BhcmFtc0xpc3RlbmVyc1tuYW1lXS5kZWxldGUoY2FsbGJhY2spO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXJhbWV0ZXJCYWc7XG59KCk7XG5cbi8qKlxuICogRmFjdG9yeSBmb3IgdGhlIGBQYXJhbWV0ZXJCYWdgIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PFN0cmluZywgcGFyYW1EZWZpbml0aW9uPn0gZGVmaW5pdGlvbnMgLSBPYmplY3QgZGVzY3JpYmluZyB0aGVcbiAqICBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtPYmplY3Q8U3RyaW5nLCBNaXhlZD59IHZhbHVlcyAtIEluaXRpYWxpemF0aW9uIHZhbHVlcyBmb3IgdGhlXG4gKiAgcGFyYW1ldGVycy5cbiAqIEByZXR1cm4ge1BhcmFtZXRlckJhZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnMoZGVmaW5pdGlvbnMpIHtcbiAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gdmFsdWVzKSB7XG4gICAgaWYgKGRlZmluaXRpb25zLmhhc093blByb3BlcnR5KG5hbWUpID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBhcmFtIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgfVxuXG4gIGZvciAodmFyIF9uYW1lIGluIGRlZmluaXRpb25zKSB7XG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShfbmFtZSkgPT09IHRydWUpIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIFwiJyArIF9uYW1lICsgJ1wiIGFscmVhZHkgZGVmaW5lZCcpO1xuXG4gICAgdmFyIGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tfbmFtZV07XG5cbiAgICBpZiAoIV9wYXJhbVRlbXBsYXRlczIuZGVmYXVsdFtkZWZpbml0aW9uLnR5cGVdKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGFyYW0gdHlwZSBcIicgKyBkZWZpbml0aW9uLnR5cGUgKyAnXCInKTtcblxuICAgIHZhciBfcGFyYW1UZW1wbGF0ZXMkZGVmaW4gPSBfcGFyYW1UZW1wbGF0ZXMyLmRlZmF1bHRbZGVmaW5pdGlvbi50eXBlXSxcbiAgICAgICAgZGVmaW5pdGlvblRlbXBsYXRlID0gX3BhcmFtVGVtcGxhdGVzJGRlZmluLmRlZmluaXRpb25UZW1wbGF0ZSxcbiAgICAgICAgdHlwZUNoZWNrRnVuY3Rpb24gPSBfcGFyYW1UZW1wbGF0ZXMkZGVmaW4udHlwZUNoZWNrRnVuY3Rpb247XG5cblxuICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcblxuICAgIGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoX25hbWUpID09PSB0cnVlKSB2YWx1ZSA9IHZhbHVlc1tfbmFtZV07ZWxzZSB2YWx1ZSA9IGRlZmluaXRpb24uZGVmYXVsdDtcblxuICAgIC8vIHN0b3JlIGluaXQgdmFsdWUgaW4gZGVmaW5pdGlvblxuICAgIGRlZmluaXRpb24uaW5pdFZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoIXR5cGVDaGVja0Z1bmN0aW9uIHx8ICFkZWZpbml0aW9uVGVtcGxhdGUpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbSB0eXBlIGRlZmluaXRpb24gXCInICsgZGVmaW5pdGlvbi50eXBlICsgJ1wiJyk7XG5cbiAgICBwYXJhbXNbX25hbWVdID0gbmV3IFBhcmFtKF9uYW1lLCBkZWZpbml0aW9uVGVtcGxhdGUsIHR5cGVDaGVja0Z1bmN0aW9uLCBkZWZpbml0aW9uLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFBhcmFtZXRlckJhZyhwYXJhbXMsIGRlZmluaXRpb25zKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyB0eXBlIGZvciB0aGUgYHBhcmFtZXRlcnNgIGZhY3RvcnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZU5hbWUgLSBWYWx1ZSB0aGF0IHdpbGwgYmUgYXZhaWxhYmxlIGFzIHRoZSBgdHlwZWAgb2YgYVxuICogIHBhcmFtIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge3BhcmFtZXRlckRlZmluaXRpb259IHBhcmFtZXRlckRlZmluaXRpb24gLSBPYmplY3QgZGVzY3JpYmluZyB0aGVcbiAqICBwYXJhbWV0ZXIuXG4gKi9cbnBhcmFtZXRlcnMuZGVmaW5lVHlwZSA9IGZ1bmN0aW9uICh0eXBlTmFtZSwgcGFyYW1ldGVyRGVmaW5pdGlvbikge1xuICBfcGFyYW1UZW1wbGF0ZXMyLmRlZmF1bHRbdHlwZU5hbWVdID0gcGFyYW1ldGVyRGVmaW5pdGlvbjtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcmFtZXRlcnM7XG5cbn0se1wiLi9wYXJhbVRlbXBsYXRlc1wiOjF9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSx7XCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIjoyMn1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvbG9nMTBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvbG9nMTBcIjoyM31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1maW5pdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1maW5pdGVcIjoyNH1dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIjoyNX1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIjoyNn1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIjoyN31dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjoyOH1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSx7XCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoyOX1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSx7XCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIjozMH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59LHtcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCI6MzF9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59LHtcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIjozMn1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiOjMzfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG59LHtcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiOjh9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbn0se1wiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCI6OH1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIik7XG5cbnZhciBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE93blByb3BlcnR5RGVzY3JpcHRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gKDAsIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IyLmRlZmF1bHQpKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xufSx7XCIuLi9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIjo5LFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwfV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG59LHtcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiOjcsXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6MTEsXCIuLi9oZWxwZXJzL3R5cGVvZlwiOjIxfV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcbn0se1wiLi4vaGVscGVycy90eXBlb2ZcIjoyMX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59O1xufSx7XCIuLi9jb3JlLWpzL3N5bWJvbFwiOjEzLFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIjoxNH1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpO1xudmFyICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7IHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnkgfSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xuXG59LHtcIi4uLy4uL21vZHVsZXMvX2NvcmVcIjo0MX1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk1hdGgubG9nMTA7XG5cbn0se1wiLi4vLi4vbW9kdWxlcy9fY29yZVwiOjQxLFwiLi4vLi4vbW9kdWxlcy9lczYubWF0aC5sb2cxMFwiOjEwOX1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk51bWJlci5pc0Zpbml0ZTtcblxufSx7XCIuLi8uLi9tb2R1bGVzL19jb3JlXCI6NDEsXCIuLi8uLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlXCI6MTEwfV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxufSx7XCIuLi8uLi9tb2R1bGVzL19jb3JlXCI6NDEsXCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduXCI6MTExfV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG59LHtcIi4uLy4uL21vZHVsZXMvX2NvcmVcIjo0MSxcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGVcIjoxMTJ9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuXG59LHtcIi4uLy4uL21vZHVsZXMvX2NvcmVcIjo0MSxcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHlcIjoxMTN9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIHJldHVybiAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbn07XG5cbn0se1wiLi4vLi4vbW9kdWxlcy9fY29yZVwiOjQxLFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiOjExNH1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbn0se1wiLi4vLi4vbW9kdWxlcy9fY29yZVwiOjQxLFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIjoxMTV9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG59LHtcIi4uLy4uL21vZHVsZXMvX2NvcmVcIjo0MSxcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mXCI6MTE2fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG5cbn0se1wiLi4vbW9kdWxlcy9fY29yZVwiOjQxLFwiLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZ1wiOjExNyxcIi4uL21vZHVsZXMvZXM2LnByb21pc2VcIjoxMTgsXCIuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3JcIjoxMTksXCIuLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHlcIjoxMjEsXCIuLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeVwiOjEyMixcIi4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZVwiOjEyNX1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuXG59LHtcIi4uLy4uL21vZHVsZXMvX2NvcmVcIjo0MSxcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmdcIjoxMTcsXCIuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2xcIjoxMjAsXCIuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3JcIjoxMjMsXCIuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZVwiOjEyNH1dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG59LHtcIi4uLy4uL21vZHVsZXMvX3drcy1leHRcIjoxMDUsXCIuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3JcIjoxMTksXCIuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGVcIjoxMjV9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cbn0se31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG59LHt9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxufSx7fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG59LHtcIi4vX2lzLW9iamVjdFwiOjYwfV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbn0se1wiLi9fdG8tYWJzb2x1dGUtaW5kZXhcIjo5NyxcIi4vX3RvLWlvYmplY3RcIjo5OSxcIi4vX3RvLWxlbmd0aFwiOjEwMH1dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxufSx7XCIuL19jb2ZcIjo0MCxcIi4vX3drc1wiOjEwNn1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxufSx7fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS41JyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxufSx7fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG59LHtcIi4vX2EtZnVuY3Rpb25cIjozNH1dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG59LHtcIi4vX2ZhaWxzXCI6NDl9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxufSx7XCIuL19nbG9iYWxcIjo1MSxcIi4vX2lzLW9iamVjdFwiOjYwfV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cbn0se31dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbn0se1wiLi9fb2JqZWN0LWdvcHNcIjo3OCxcIi4vX29iamVjdC1rZXlzXCI6ODEsXCIuL19vYmplY3QtcGllXCI6ODJ9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxufSx7XCIuL19jb3JlXCI6NDEsXCIuL19jdHhcIjo0MixcIi4vX2dsb2JhbFwiOjUxLFwiLi9faGFzXCI6NTIsXCIuL19oaWRlXCI6NTN9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cbn0se1wiLi9fYW4tb2JqZWN0XCI6MzcsXCIuL19jdHhcIjo0MixcIi4vX2lzLWFycmF5LWl0ZXJcIjo1OCxcIi4vX2l0ZXItY2FsbFwiOjYxLFwiLi9fdG8tbGVuZ3RoXCI6MTAwLFwiLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2RcIjoxMDd9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbn0se31dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cbn0se31dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxufSx7XCIuL19kZXNjcmlwdG9yc1wiOjQ0LFwiLi9fb2JqZWN0LWRwXCI6NzMsXCIuL19wcm9wZXJ0eS1kZXNjXCI6ODZ9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG59LHtcIi4vX2dsb2JhbFwiOjUxfV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxufSx7XCIuL19kZXNjcmlwdG9yc1wiOjQ0LFwiLi9fZG9tLWNyZWF0ZVwiOjQ1LFwiLi9fZmFpbHNcIjo0OX1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxufSx7fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxufSx7XCIuL19jb2ZcIjo0MH1dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG59LHtcIi4vX2l0ZXJhdG9yc1wiOjY2LFwiLi9fd2tzXCI6MTA2fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cbn0se1wiLi9fY29mXCI6NDB9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxufSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbn0se1wiLi9fYW4tb2JqZWN0XCI6Mzd9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxufSx7XCIuL19oaWRlXCI6NTMsXCIuL19vYmplY3QtY3JlYXRlXCI6NzIsXCIuL19wcm9wZXJ0eS1kZXNjXCI6ODYsXCIuL19zZXQtdG8tc3RyaW5nLXRhZ1wiOjkxLFwiLi9fd2tzXCI6MTA2fV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxufSx7XCIuL19leHBvcnRcIjo0OCxcIi4vX2hpZGVcIjo1MyxcIi4vX2l0ZXItY3JlYXRlXCI6NjIsXCIuL19pdGVyYXRvcnNcIjo2NixcIi4vX2xpYnJhcnlcIjo2NyxcIi4vX29iamVjdC1ncG9cIjo3OSxcIi4vX3JlZGVmaW5lXCI6ODgsXCIuL19zZXQtdG8tc3RyaW5nLXRhZ1wiOjkxLFwiLi9fd2tzXCI6MTA2fV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxufSx7XCIuL193a3NcIjoxMDZ9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcblxufSx7fV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxufSx7fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG59LHt9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cbn0se1wiLi9fZmFpbHNcIjo0OSxcIi4vX2hhc1wiOjUyLFwiLi9faXMtb2JqZWN0XCI6NjAsXCIuL19vYmplY3QtZHBcIjo3MyxcIi4vX3VpZFwiOjEwM31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxufSx7XCIuL19jb2ZcIjo0MCxcIi4vX2dsb2JhbFwiOjUxLFwiLi9fdGFza1wiOjk2fV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG59LHtcIi4vX2EtZnVuY3Rpb25cIjozNH1dLDcxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG59LHtcIi4vX2ZhaWxzXCI6NDksXCIuL19pb2JqZWN0XCI6NTcsXCIuL19vYmplY3QtZ29wc1wiOjc4LFwiLi9fb2JqZWN0LWtleXNcIjo4MSxcIi4vX29iamVjdC1waWVcIjo4MixcIi4vX3RvLW9iamVjdFwiOjEwMX1dLDcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxufSx7XCIuL19hbi1vYmplY3RcIjozNyxcIi4vX2RvbS1jcmVhdGVcIjo0NSxcIi4vX2VudW0tYnVnLWtleXNcIjo0NixcIi4vX2h0bWxcIjo1NCxcIi4vX29iamVjdC1kcHNcIjo3NCxcIi4vX3NoYXJlZC1rZXlcIjo5Mn1dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbn0se1wiLi9fYW4tb2JqZWN0XCI6MzcsXCIuL19kZXNjcmlwdG9yc1wiOjQ0LFwiLi9faWU4LWRvbS1kZWZpbmVcIjo1NSxcIi4vX3RvLXByaW1pdGl2ZVwiOjEwMn1dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxufSx7XCIuL19hbi1vYmplY3RcIjozNyxcIi4vX2Rlc2NyaXB0b3JzXCI6NDQsXCIuL19vYmplY3QtZHBcIjo3MyxcIi4vX29iamVjdC1rZXlzXCI6ODF9XSw3NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxufSx7XCIuL19kZXNjcmlwdG9yc1wiOjQ0LFwiLi9faGFzXCI6NTIsXCIuL19pZTgtZG9tLWRlZmluZVwiOjU1LFwiLi9fb2JqZWN0LXBpZVwiOjgyLFwiLi9fcHJvcGVydHktZGVzY1wiOjg2LFwiLi9fdG8taW9iamVjdFwiOjk5LFwiLi9fdG8tcHJpbWl0aXZlXCI6MTAyfV0sNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cbn0se1wiLi9fb2JqZWN0LWdvcG5cIjo3NyxcIi4vX3RvLWlvYmplY3RcIjo5OX1dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cbn0se1wiLi9fZW51bS1idWcta2V5c1wiOjQ2LFwiLi9fb2JqZWN0LWtleXMtaW50ZXJuYWxcIjo4MH1dLDc4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbn0se31dLDc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG59LHtcIi4vX2hhc1wiOjUyLFwiLi9fc2hhcmVkLWtleVwiOjkyLFwiLi9fdG8tb2JqZWN0XCI6MTAxfV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbn0se1wiLi9fYXJyYXktaW5jbHVkZXNcIjozOCxcIi4vX2hhc1wiOjUyLFwiLi9fc2hhcmVkLWtleVwiOjkyLFwiLi9fdG8taW9iamVjdFwiOjk5fV0sODE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxufSx7XCIuL19lbnVtLWJ1Zy1rZXlzXCI6NDYsXCIuL19vYmplY3Qta2V5cy1pbnRlcm5hbFwiOjgwfV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbn0se31dLDgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG59LHtcIi4vX2NvcmVcIjo0MSxcIi4vX2V4cG9ydFwiOjQ4LFwiLi9fZmFpbHNcIjo0OX1dLDg0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG5cbn0se31dLDg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cbn0se1wiLi9fYW4tb2JqZWN0XCI6MzcsXCIuL19pcy1vYmplY3RcIjo2MCxcIi4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHlcIjo3MH1dLDg2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbn0se31dLDg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuXG59LHtcIi4vX2hpZGVcIjo1M31dLDg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG59LHtcIi4vX2hpZGVcIjo1M31dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxufSx7XCIuL19hbi1vYmplY3RcIjozNyxcIi4vX2N0eFwiOjQyLFwiLi9faXMtb2JqZWN0XCI6NjAsXCIuL19vYmplY3QtZ29wZFwiOjc1fV0sOTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cbn0se1wiLi9fY29yZVwiOjQxLFwiLi9fZGVzY3JpcHRvcnNcIjo0NCxcIi4vX2dsb2JhbFwiOjUxLFwiLi9fb2JqZWN0LWRwXCI6NzMsXCIuL193a3NcIjoxMDZ9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxufSx7XCIuL19oYXNcIjo1MixcIi4vX29iamVjdC1kcFwiOjczLFwiLi9fd2tzXCI6MTA2fV0sOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbn0se1wiLi9fc2hhcmVkXCI6OTMsXCIuL191aWRcIjoxMDN9XSw5MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG59LHtcIi4vX2dsb2JhbFwiOjUxfV0sOTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG59LHtcIi4vX2EtZnVuY3Rpb25cIjozNCxcIi4vX2FuLW9iamVjdFwiOjM3LFwiLi9fd2tzXCI6MTA2fV0sOTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxufSx7XCIuL19kZWZpbmVkXCI6NDMsXCIuL190by1pbnRlZ2VyXCI6OTh9XSw5NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG5cbn0se1wiLi9fY29mXCI6NDAsXCIuL19jdHhcIjo0MixcIi4vX2RvbS1jcmVhdGVcIjo0NSxcIi4vX2dsb2JhbFwiOjUxLFwiLi9faHRtbFwiOjU0LFwiLi9faW52b2tlXCI6NTZ9XSw5NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxufSx7XCIuL190by1pbnRlZ2VyXCI6OTh9XSw5ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxufSx7fV0sOTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxufSx7XCIuL19kZWZpbmVkXCI6NDMsXCIuL19pb2JqZWN0XCI6NTd9XSwxMDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbn0se1wiLi9fdG8taW50ZWdlclwiOjk4fV0sMTAxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG59LHtcIi4vX2RlZmluZWRcIjo0M31dLDEwMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbn0se1wiLi9faXMtb2JqZWN0XCI6NjB9XSwxMDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cbn0se31dLDEwNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG5cbn0se1wiLi9fY29yZVwiOjQxLFwiLi9fZ2xvYmFsXCI6NTEsXCIuL19saWJyYXJ5XCI6NjcsXCIuL19vYmplY3QtZHBcIjo3MyxcIi4vX3drcy1leHRcIjoxMDV9XSwxMDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbn0se1wiLi9fd2tzXCI6MTA2fV0sMTA2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxufSx7XCIuL19nbG9iYWxcIjo1MSxcIi4vX3NoYXJlZFwiOjkzLFwiLi9fdWlkXCI6MTAzfV0sMTA3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG59LHtcIi4vX2NsYXNzb2ZcIjozOSxcIi4vX2NvcmVcIjo0MSxcIi4vX2l0ZXJhdG9yc1wiOjY2LFwiLi9fd2tzXCI6MTA2fV0sMTA4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cbn0se1wiLi9fYWRkLXRvLXVuc2NvcGFibGVzXCI6MzUsXCIuL19pdGVyLWRlZmluZVwiOjYzLFwiLi9faXRlci1zdGVwXCI6NjUsXCIuL19pdGVyYXRvcnNcIjo2NixcIi4vX3RvLWlvYmplY3RcIjo5OX1dLDEwOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xuICB9XG59KTtcblxufSx7XCIuL19leHBvcnRcIjo0OH1dLDExMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBfaXNGaW5pdGUgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5pc0Zpbml0ZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzRmluaXRlOiBmdW5jdGlvbiBpc0Zpbml0ZShpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7XG5cbn0se1wiLi9fZXhwb3J0XCI6NDgsXCIuL19nbG9iYWxcIjo1MX1dLDExMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuXG59LHtcIi4vX2V4cG9ydFwiOjQ4LFwiLi9fb2JqZWN0LWFzc2lnblwiOjcxfV0sMTEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcblxufSx7XCIuL19leHBvcnRcIjo0OCxcIi4vX29iamVjdC1jcmVhdGVcIjo3Mn1dLDExMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuXG59LHtcIi4vX2Rlc2NyaXB0b3JzXCI6NDQsXCIuL19leHBvcnRcIjo0OCxcIi4vX29iamVjdC1kcFwiOjczfV0sMTE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxufSx7XCIuL19vYmplY3QtZ29wZFwiOjc1LFwiLi9fb2JqZWN0LXNhcFwiOjgzLFwiLi9fdG8taW9iamVjdFwiOjk5fV0sMTE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxufSx7XCIuL19vYmplY3QtZ3BvXCI6NzksXCIuL19vYmplY3Qtc2FwXCI6ODMsXCIuL190by1vYmplY3RcIjoxMDF9XSwxMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcblxufSx7XCIuL19leHBvcnRcIjo0OCxcIi4vX3NldC1wcm90b1wiOjg5fV0sMTE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxufSx7fV0sMTE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gbWF5IHRocm93XG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICByZXR1cm4gcHJvbWlzZS5faCAhPT0gMSAmJiAocHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jKS5sZW5ndGggPT09IDA7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxufSx7XCIuL19hLWZ1bmN0aW9uXCI6MzQsXCIuL19hbi1pbnN0YW5jZVwiOjM2LFwiLi9fY2xhc3NvZlwiOjM5LFwiLi9fY29yZVwiOjQxLFwiLi9fY3R4XCI6NDIsXCIuL19leHBvcnRcIjo0OCxcIi4vX2Zvci1vZlwiOjUwLFwiLi9fZ2xvYmFsXCI6NTEsXCIuL19pcy1vYmplY3RcIjo2MCxcIi4vX2l0ZXItZGV0ZWN0XCI6NjQsXCIuL19saWJyYXJ5XCI6NjcsXCIuL19taWNyb3Rhc2tcIjo2OSxcIi4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHlcIjo3MCxcIi4vX3BlcmZvcm1cIjo4NCxcIi4vX3Byb21pc2UtcmVzb2x2ZVwiOjg1LFwiLi9fcmVkZWZpbmUtYWxsXCI6ODcsXCIuL19zZXQtc3BlY2llc1wiOjkwLFwiLi9fc2V0LXRvLXN0cmluZy10YWdcIjo5MSxcIi4vX3NwZWNpZXMtY29uc3RydWN0b3JcIjo5NCxcIi4vX3Rhc2tcIjo5NixcIi4vX3drc1wiOjEwNn1dLDExOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxufSx7XCIuL19pdGVyLWRlZmluZVwiOjYzLFwiLi9fc3RyaW5nLWF0XCI6OTV9XSwxMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxufSx7XCIuL19hbi1vYmplY3RcIjozNyxcIi4vX2Rlc2NyaXB0b3JzXCI6NDQsXCIuL19lbnVtLWtleXNcIjo0NyxcIi4vX2V4cG9ydFwiOjQ4LFwiLi9fZmFpbHNcIjo0OSxcIi4vX2dsb2JhbFwiOjUxLFwiLi9faGFzXCI6NTIsXCIuL19oaWRlXCI6NTMsXCIuL19pcy1hcnJheVwiOjU5LFwiLi9faXMtb2JqZWN0XCI6NjAsXCIuL19saWJyYXJ5XCI6NjcsXCIuL19tZXRhXCI6NjgsXCIuL19vYmplY3QtY3JlYXRlXCI6NzIsXCIuL19vYmplY3QtZHBcIjo3MyxcIi4vX29iamVjdC1nb3BkXCI6NzUsXCIuL19vYmplY3QtZ29wblwiOjc3LFwiLi9fb2JqZWN0LWdvcG4tZXh0XCI6NzYsXCIuL19vYmplY3QtZ29wc1wiOjc4LFwiLi9fb2JqZWN0LWtleXNcIjo4MSxcIi4vX29iamVjdC1waWVcIjo4MixcIi4vX3Byb3BlcnR5LWRlc2NcIjo4NixcIi4vX3JlZGVmaW5lXCI6ODgsXCIuL19zZXQtdG8tc3RyaW5nLXRhZ1wiOjkxLFwiLi9fc2hhcmVkXCI6OTMsXCIuL190by1pb2JqZWN0XCI6OTksXCIuL190by1wcmltaXRpdmVcIjoxMDIsXCIuL191aWRcIjoxMDMsXCIuL193a3NcIjoxMDYsXCIuL193a3MtZGVmaW5lXCI6MTA0LFwiLi9fd2tzLWV4dFwiOjEwNX1dLDEyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLWZpbmFsbHlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdQcm9taXNlJywgeyAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKTtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gIHJldHVybiB0aGlzLnRoZW4oXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgfSA6IG9uRmluYWxseSxcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHlcbiAgKTtcbn0gfSk7XG5cbn0se1wiLi9fY29yZVwiOjQxLFwiLi9fZXhwb3J0XCI6NDgsXCIuL19nbG9iYWxcIjo1MSxcIi4vX3Byb21pc2UtcmVzb2x2ZVwiOjg1LFwiLi9fc3BlY2llcy1jb25zdHJ1Y3RvclwiOjk0fV0sMTIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcblxufSx7XCIuL19leHBvcnRcIjo0OCxcIi4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHlcIjo3MCxcIi4vX3BlcmZvcm1cIjo4NH1dLDEyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxufSx7XCIuL193a3MtZGVmaW5lXCI6MTA0fV0sMTI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG59LHtcIi4vX3drcy1kZWZpbmVcIjoxMDR9XSwxMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cblxufSx7XCIuL19nbG9iYWxcIjo1MSxcIi4vX2hpZGVcIjo1MyxcIi4vX2l0ZXJhdG9yc1wiOjY2LFwiLi9fd2tzXCI6MTA2LFwiLi9lczYuYXJyYXkuaXRlcmF0b3JcIjoxMDh9XSwxMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcblx0aWYgKHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKTtcblx0fVxuXG5cdHJldHVybiB0b1N0ci5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG5cdGlmICghb2JqIHx8IHRvU3RyLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgaGFzT3duQ29uc3RydWN0b3IgPSBoYXNPd24uY2FsbChvYmosICdjb25zdHJ1Y3RvcicpO1xuXHR2YXIgaGFzSXNQcm90b3R5cGVPZiA9IG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IucHJvdG90eXBlICYmIGhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJyk7XG5cdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0aWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhaGFzT3duQ29uc3RydWN0b3IgJiYgIWhhc0lzUHJvdG90eXBlT2YpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIG9iaikgeyAvKiovIH1cblxuXHRyZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZTtcblx0dmFyIHRhcmdldCA9IGFyZ3VtZW50c1swXTtcblx0dmFyIGkgPSAxO1xuXHR2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblx0dmFyIGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnYm9vbGVhbicpIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0aSA9IDI7XG5cdH1cblx0aWYgKHRhcmdldCA9PSBudWxsIHx8ICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Zm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbaV07XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmIChvcHRpb25zICE9IG51bGwpIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFtuYW1lXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbbmFtZV07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAodGFyZ2V0ICE9PSBjb3B5KSB7XG5cdFx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdFx0aWYgKGRlZXAgJiYgY29weSAmJiAoaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBpc0FycmF5KGNvcHkpKSkpIHtcblx0XHRcdFx0XHRcdGlmIChjb3B5SXNBcnJheSkge1xuXHRcdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29weSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGNvcHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbn0se31dLDEyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG1heGltdW0gb2YgdGhlIGdpdmVuIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBtYXgoaW5wdXQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgIH1cblxuICAgIHZhciBtYXggPSBpbnB1dFswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnB1dFtpXSA+IG1heCkgbWF4ID0gaW5wdXRbaV07XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF4O1xuXG59LHt9XSwxMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIG9mIHRoZSBnaXZlbiB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gbWluKGlucHV0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICB9XG5cbiAgICB2YXIgbWluID0gaW5wdXRbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRbaV0gPCBtaW4pIG1pbiA9IGlucHV0W2ldO1xuICAgIH1cbiAgICByZXR1cm4gbWluO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbjtcblxufSx7fV0sMTI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBtYXggPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnbWwtYXJyYXktbWF4JykpO1xudmFyIG1pbiA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdtbC1hcnJheS1taW4nKSk7XG5cbmZ1bmN0aW9uIHJlc2NhbGUoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgbGV0IG91dHB1dDtcbiAgICBpZiAob3B0aW9ucy5vdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5vdXRwdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvdXRwdXQgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXkgaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ID0gb3B0aW9ucy5vdXRwdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGlucHV0Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudE1pbiA9IG1pbihpbnB1dCk7XG4gICAgY29uc3QgY3VycmVudE1heCA9IG1heChpbnB1dCk7XG5cbiAgICBpZiAoY3VycmVudE1pbiA9PT0gY3VycmVudE1heCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWluaW11bSBhbmQgbWF4aW11bSBpbnB1dCB2YWx1ZXMgYXJlIGVxdWFsLiBDYW5ub3QgcmVzY2FsZSBhIGNvbnN0YW50IGFycmF5Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgICBtaW46IG1pblZhbHVlID0gb3B0aW9ucy5hdXRvTWluTWF4ID8gY3VycmVudE1pbiA6IDAsXG4gICAgICAgIG1heDogbWF4VmFsdWUgPSBvcHRpb25zLmF1dG9NaW5NYXggPyBjdXJyZW50TWF4IDogMVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKG1pblZhbHVlID49IG1heFZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaW4gb3B0aW9uIG11c3QgYmUgc21hbGxlciB0aGFuIG1heCBvcHRpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBmYWN0b3IgPSAobWF4VmFsdWUgLSBtaW5WYWx1ZSkgLyAoY3VycmVudE1heCAtIGN1cnJlbnRNaW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0W2ldID0gKGlucHV0W2ldIC0gY3VycmVudE1pbikgKiBmYWN0b3IgKyBtaW5WYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc2NhbGU7XG5cbn0se1wibWwtYXJyYXktbWF4XCI6MTI3LFwibWwtYXJyYXktbWluXCI6MTI4fV0sMTMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciByZXNjYWxlID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ21sLWFycmF5LXJlc2NhbGUnKSk7XG5cbmlmICghU3ltYm9sLnNwZWNpZXMpIHtcbiAgICBTeW1ib2wuc3BlY2llcyA9IFN5bWJvbC5mb3IoJ0BAc3BlY2llcycpO1xufVxuXG4vKipcbiAqIEBjbGFzcyBMdURlY29tcG9zaXRpb25cbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sdXR6cm9lZGVyL01hcGFjay9ibG9iL21hc3Rlci9Tb3VyY2UvTHVEZWNvbXBvc2l0aW9uLmNzXG4gKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG4gKi9cbmNsYXNzIEx1RGVjb21wb3NpdGlvbiQkMSB7XG4gICAgY29uc3RydWN0b3IobWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeChtYXRyaXgpO1xuXG4gICAgICAgIHZhciBsdSA9IG1hdHJpeC5jbG9uZSgpO1xuICAgICAgICB2YXIgcm93cyA9IGx1LnJvd3M7XG4gICAgICAgIHZhciBjb2x1bW5zID0gbHUuY29sdW1ucztcbiAgICAgICAgdmFyIHBpdm90VmVjdG9yID0gbmV3IEFycmF5KHJvd3MpO1xuICAgICAgICB2YXIgcGl2b3RTaWduID0gMTtcbiAgICAgICAgdmFyIGksIGosIGssIHAsIHMsIHQsIHY7XG4gICAgICAgIHZhciBMVWNvbGosIGttYXg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgcGl2b3RWZWN0b3JbaV0gPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgTFVjb2xqID0gbmV3IEFycmF5KHJvd3MpO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIExVY29saltpXSA9IGx1LmdldChpLCBqKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGttYXggPSBNYXRoLm1pbihpLCBqKTtcbiAgICAgICAgICAgICAgICBzID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga21heDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gbHUuZ2V0KGksIGspICogTFVjb2xqW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBMVWNvbGpbaV0gLT0gcztcbiAgICAgICAgICAgICAgICBsdS5zZXQoaSwgaiwgTFVjb2xqW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IGo7XG4gICAgICAgICAgICBmb3IgKGkgPSBqICsgMTsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhMVWNvbGpbaV0pID4gTWF0aC5hYnMoTFVjb2xqW3BdKSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvbHVtbnM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbHUuZ2V0KHAsIGspO1xuICAgICAgICAgICAgICAgICAgICBsdS5zZXQocCwgaywgbHUuZ2V0KGosIGspKTtcbiAgICAgICAgICAgICAgICAgICAgbHUuc2V0KGosIGssIHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHYgPSBwaXZvdFZlY3RvcltwXTtcbiAgICAgICAgICAgICAgICBwaXZvdFZlY3RvcltwXSA9IHBpdm90VmVjdG9yW2pdO1xuICAgICAgICAgICAgICAgIHBpdm90VmVjdG9yW2pdID0gdjtcblxuICAgICAgICAgICAgICAgIHBpdm90U2lnbiA9IC1waXZvdFNpZ247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqIDwgcm93cyAmJiBsdS5nZXQoaiwgaikgIT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqICsgMTsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsdS5zZXQoaSwgaiwgbHUuZ2V0KGksIGopIC8gbHUuZ2V0KGosIGopKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLkxVID0gbHU7XG4gICAgICAgIHRoaXMucGl2b3RWZWN0b3IgPSBwaXZvdFZlY3RvcjtcbiAgICAgICAgdGhpcy5waXZvdFNpZ24gPSBwaXZvdFNpZ247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzU2luZ3VsYXIoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5MVTtcbiAgICAgICAgdmFyIGNvbCA9IGRhdGEuY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2w7IGorKykge1xuICAgICAgICAgICAgaWYgKGRhdGFbal1bal0gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICovXG4gICAgc29sdmUodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRyaXguY2hlY2tNYXRyaXgodmFsdWUpO1xuXG4gICAgICAgIHZhciBsdSA9IHRoaXMuTFU7XG4gICAgICAgIHZhciByb3dzID0gbHUucm93cztcblxuICAgICAgICBpZiAocm93cyAhPT0gdmFsdWUucm93cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hdHJpeCBkaW1lbnNpb25zJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTaW5ndWxhcigpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xVIG1hdHJpeCBpcyBzaW5ndWxhcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWUuY29sdW1ucztcbiAgICAgICAgdmFyIFggPSB2YWx1ZS5zdWJNYXRyaXhSb3codGhpcy5waXZvdFZlY3RvciwgMCwgY291bnQgLSAxKTtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBsdS5jb2x1bW5zO1xuICAgICAgICB2YXIgaSwgaiwgaztcblxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29sdW1uczsgaysrKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gLT0gWFtrXVtqXSAqIGx1W2ldW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgPSBjb2x1bW5zIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgWFtrXVtqXSAvPSBsdVtrXVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdIC09IFhba11bal0gKiBsdVtpXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGRldGVybWluYW50KCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuTFU7XG4gICAgICAgIGlmICghZGF0YS5pc1NxdWFyZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXRlcm1pbmFudCA9IHRoaXMucGl2b3RTaWduO1xuICAgICAgICB2YXIgY29sID0gZGF0YS5jb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbDsgaisrKSB7XG4gICAgICAgICAgICBkZXRlcm1pbmFudCAqPSBkYXRhW2pdW2pdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRlcm1pbmFudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgKi9cbiAgICBnZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuTFU7XG4gICAgICAgIHZhciByb3dzID0gZGF0YS5yb3dzO1xuICAgICAgICB2YXIgY29sdW1ucyA9IGRhdGEuY29sdW1ucztcbiAgICAgICAgdmFyIFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSA9IGRhdGFbaV1bal07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgKi9cbiAgICBnZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuTFU7XG4gICAgICAgIHZhciByb3dzID0gZGF0YS5yb3dzO1xuICAgICAgICB2YXIgY29sdW1ucyA9IGRhdGEuY29sdW1ucztcbiAgICAgICAgdmFyIFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgZ2V0IHBpdm90UGVybXV0YXRpb25WZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpdm90VmVjdG9yLnNsaWNlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoeXBvdGVudXNlKGEsIGIpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKE1hdGguYWJzKGEpID4gTWF0aC5hYnMoYikpIHtcbiAgICAgICAgciA9IGIgLyBhO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYSkgKiBNYXRoLnNxcnQoMSArIHIgKiByKTtcbiAgICB9XG4gICAgaWYgKGIgIT09IDApIHtcbiAgICAgICAgciA9IGEgLyBiO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYikgKiBNYXRoLnNxcnQoMSArIHIgKiByKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGxlZDJEQXJyYXkocm93cywgY29sdW1ucywgdmFsdWUpIHtcbiAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkocm93cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBuZXcgQXJyYXkoY29sdW1ucyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICBhcnJheVtpXVtqXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAY2xhc3MgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb25cbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sdXR6cm9lZGVyL01hcGFjay9ibG9iL21hc3Rlci9Tb3VyY2UvU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24uY3NcbiAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb21wdXRlTGVmdFNpbmd1bGFyVmVjdG9ycz10cnVlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnM9dHJ1ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b1RyYW5zcG9zZT1mYWxzZV1cbiAqL1xuY2xhc3MgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24kJDEge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFsdWUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgodmFsdWUpO1xuXG4gICAgICAgIHZhciBtID0gdmFsdWUucm93cztcbiAgICAgICAgdmFyIG4gPSB2YWx1ZS5jb2x1bW5zO1xuICAgICAgICB2YXIgbnUgPSBNYXRoLm1pbihtLCBuKTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb21wdXRlTGVmdFNpbmd1bGFyVmVjdG9ycyA9IHRydWUsXG4gICAgICAgICAgICBjb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnMgPSB0cnVlLFxuICAgICAgICAgICAgYXV0b1RyYW5zcG9zZSA9IGZhbHNlXG4gICAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICAgIHZhciB3YW50dSA9IEJvb2xlYW4oY29tcHV0ZUxlZnRTaW5ndWxhclZlY3RvcnMpO1xuICAgICAgICB2YXIgd2FudHYgPSBCb29sZWFuKGNvbXB1dGVSaWdodFNpbmd1bGFyVmVjdG9ycyk7XG5cbiAgICAgICAgdmFyIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIGlmIChtIDwgbikge1xuICAgICAgICAgICAgaWYgKCFhdXRvVHJhbnNwb3NlKSB7XG4gICAgICAgICAgICAgICAgYSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXB1dGluZyBTVkQgb24gYSBtYXRyaXggd2l0aCBtb3JlIGNvbHVtbnMgdGhhbiByb3dzLiBDb25zaWRlciBlbmFibGluZyBhdXRvVHJhbnNwb3NlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEgPSB2YWx1ZS50cmFuc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBtID0gYS5yb3dzO1xuICAgICAgICAgICAgICAgIG4gPSBhLmNvbHVtbnM7XG4gICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGF1eCA9IHdhbnR1O1xuICAgICAgICAgICAgICAgIHdhbnR1ID0gd2FudHY7XG4gICAgICAgICAgICAgICAgd2FudHYgPSBhdXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzID0gbmV3IEFycmF5KE1hdGgubWluKG0gKyAxLCBuKSk7XG4gICAgICAgIHZhciBVID0gZ2V0RmlsbGVkMkRBcnJheShtLCBudSwgMCk7XG4gICAgICAgIHZhciBWID0gZ2V0RmlsbGVkMkRBcnJheShuLCBuLCAwKTtcbiAgICAgICAgdmFyIGUgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIHZhciB3b3JrID0gbmV3IEFycmF5KG0pO1xuXG4gICAgICAgIHZhciBuY3QgPSBNYXRoLm1pbihtIC0gMSwgbik7XG4gICAgICAgIHZhciBucnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMiwgbSkpO1xuXG4gICAgICAgIHZhciBpLCBqLCBrLCBwLCB0LCBrcywgZiwgY3MsIHNuLCBtYXgsIGthc2UsXG4gICAgICAgICAgICBzY2FsZSwgc3AsIHNwbTEsIGVwbTEsIHNrLCBlaywgYiwgYywgc2hpZnQsIGc7XG5cbiAgICAgICAgZm9yIChrID0gMCwgbWF4ID0gTWF0aC5tYXgobmN0LCBucnQpOyBrIDwgbWF4OyBrKyspIHtcbiAgICAgICAgICAgIGlmIChrIDwgbmN0KSB7XG4gICAgICAgICAgICAgICAgc1trXSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzW2tdID0gaHlwb3RlbnVzZShzW2tdLCBhW2ldW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNba10gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFba11ba10gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzW2tdID0gLXNba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYVtpXVtrXSAvPSBzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFba11ba10gKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc1trXSA9IC1zW2tdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSBrICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgIGlmICgoayA8IG5jdCkgJiYgKHNba10gIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ICs9IGFbaV1ba10gKiBhW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQgPSAtdCAvIGFba11ba107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbaV1bal0gKz0gdCAqIGFbaV1ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZVtqXSA9IGFba11bal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3YW50dSAmJiAoayA8IG5jdCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIFVbaV1ba10gPSBhW2ldW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGsgPCBucnQpIHtcbiAgICAgICAgICAgICAgICBlW2tdID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlW2tdID0gaHlwb3RlbnVzZShlW2tdLCBlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVba10gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbayArIDFdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZVtrXSA9IDAgLSBlW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlW2ldIC89IGVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZVtrICsgMV0gKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZVtrXSA9IC1lW2tdO1xuICAgICAgICAgICAgICAgIGlmICgoayArIDEgPCBtKSAmJiAoZVtrXSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaV0gKz0gZVtqXSAqIGFbaV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAtZVtqXSAvIGVbayArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ldW2pdICs9IHQgKiB3b3JrW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtrXSA9IGVbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gTWF0aC5taW4obiwgbSArIDEpO1xuICAgICAgICBpZiAobmN0IDwgbikge1xuICAgICAgICAgICAgc1tuY3RdID0gYVtuY3RdW25jdF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0gPCBwKSB7XG4gICAgICAgICAgICBzW3AgLSAxXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ydCArIDEgPCBwKSB7XG4gICAgICAgICAgICBlW25ydF0gPSBhW25ydF1bcCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVbcCAtIDFdID0gMDtcblxuICAgICAgICBpZiAod2FudHUpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IG5jdDsgaiA8IG51OyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIFVbaV1bal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBVW2pdW2pdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoayA9IG5jdCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNba10gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBudTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9IFVbaV1ba10gKiBVW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IC10IC8gVVtrXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2pdICs9IHQgKiBVW2ldW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1ba10gPSAtVVtpXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBVW2tdW2tdID0gMSArIFVba11ba107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2tdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1ba10gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFVba11ba10gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgZm9yIChrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKChrIDwgbnJ0KSAmJiAoZVtrXSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9IFZbaV1ba10gKiBWW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IC10IC8gVltrICsgMV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bal0gKz0gdCAqIFZbaV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBWW2ldW2tdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVltrXVtrXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHAgPSBwIC0gMTtcbiAgICAgICAgdmFyIGl0ZXIgPSAwO1xuICAgICAgICB2YXIgZXBzID0gTnVtYmVyLkVQU0lMT047XG4gICAgICAgIHdoaWxlIChwID4gMCkge1xuICAgICAgICAgICAgZm9yIChrID0gcCAtIDI7IGsgPj0gLTE7IGstLSkge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVba10pIDw9IGVwcyAqIChNYXRoLmFicyhzW2tdKSArIE1hdGguYWJzKHNbayArIDFdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSBwIC0gMikge1xuICAgICAgICAgICAgICAgIGthc2UgPSA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGtzID0gcCAtIDE7IGtzID49IGs7IGtzLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtzID09PSBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ID0gKGtzICE9PSBwID8gTWF0aC5hYnMoZVtrc10pIDogMCkgKyAoa3MgIT09IGsgKyAxID8gTWF0aC5hYnMoZVtrcyAtIDFdKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc1trc10pIDw9IGVwcyAqIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNba3NdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrcyA9PT0gaykge1xuICAgICAgICAgICAgICAgICAgICBrYXNlID0gMztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtzID09PSBwIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrYXNlID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrYXNlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgayA9IGtzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaysrO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGthc2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGVbcCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICBlW3AgLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHAgLSAyOyBqID49IGs7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGh5cG90ZW51c2Uoc1tqXSwgZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHNbal0gLyB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc24gPSBmIC8gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNbal0gPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gLXNuICogZVtqIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZVtqIC0gMV0gPSBjcyAqIGVbaiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gY3MgKiBWW2ldW2pdICsgc24gKiBWW2ldW3AgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtwIC0gMV0gPSAtc24gKiBWW2ldW2pdICsgY3MgKiBWW2ldW3AgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtqXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDIgOiB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBlW2sgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgZVtrIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBrOyBqIDwgcDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gaHlwb3RlbnVzZShzW2pdLCBmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gc1tqXSAvIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbiA9IGYgLyB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc1tqXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gLXNuICogZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbal0gPSBjcyAqIGVbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FudHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjcyAqIFVbaV1bal0gKyBzbiAqIFVbaV1bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2sgLSAxXSA9IC1zbiAqIFVbaV1bal0gKyBjcyAqIFVbaV1bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2pdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMyA6IHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBNYXRoLm1heChNYXRoLmFicyhzW3AgLSAxXSksIE1hdGguYWJzKHNbcCAtIDJdKSwgTWF0aC5hYnMoZVtwIC0gMl0pLCBNYXRoLmFicyhzW2tdKSwgTWF0aC5hYnMoZVtrXSkpO1xuICAgICAgICAgICAgICAgICAgICBzcCA9IHNbcCAtIDFdIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHNwbTEgPSBzW3AgLSAyXSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBlcG0xID0gZVtwIC0gMl0gLyBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgc2sgPSBzW2tdIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGVrID0gZVtrXSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBiID0gKChzcG0xICsgc3ApICogKHNwbTEgLSBzcCkgKyBlcG0xICogZXBtMSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBjID0gKHNwICogZXBtMSkgKiAoc3AgKiBlcG0xKTtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGIgIT09IDApIHx8IChjICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBNYXRoLnNxcnQoYiAqIGIgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gLXNoaWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjIC8gKGIgKyBzaGlmdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZiA9IChzayArIHNwKSAqIChzayAtIHNwKSArIHNoaWZ0O1xuICAgICAgICAgICAgICAgICAgICBnID0gc2sgKiBlaztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gazsgaiA8IHAgLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBoeXBvdGVudXNlKGYsIGcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBmIC8gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuID0gZyAvIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbaiAtIDFdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBjcyAqIHNbal0gKyBzbiAqIGVbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBlW2pdID0gY3MgKiBlW2pdIC0gc24gKiBzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHNuICogc1tqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzW2ogKyAxXSA9IGNzICogc1tqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FudHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjcyAqIFZbaV1bal0gKyBzbiAqIFZbaV1baiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2ogKyAxXSA9IC1zbiAqIFZbaV1bal0gKyBjcyAqIFZbaV1baiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2pdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gaHlwb3RlbnVzZShmLCBnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gZiAvIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbiA9IGcgLyB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc1tqXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gY3MgKiBlW2pdICsgc24gKiBzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNbaiArIDFdID0gLXNuICogZVtqXSArIGNzICogc1tqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gc24gKiBlW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbaiArIDFdID0gY3MgKiBlW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YW50dSAmJiAoaiA8IG0gLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNzICogVVtpXVtqXSArIHNuICogVVtpXVtqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1baiArIDFdID0gLXNuICogVVtpXVtqXSArIGNzICogVVtpXVtqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1bal0gPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlW3AgLSAyXSA9IGY7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXIgPSBpdGVyICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc1trXSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzW2tdID0gKHNba10gPCAwID8gLXNba10gOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gcHA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2tdID0gLVZbaV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgcHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzW2tdID49IHNbayArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNba10gPSBzW2sgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNbayArIDFdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YW50diAmJiAoayA8IG4gLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IFZbaV1bayArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2sgKyAxXSA9IFZbaV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1ba10gPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YW50dSAmJiAoayA8IG0gLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IFVbaV1bayArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2sgKyAxXSA9IFVbaV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1ba10gPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdGVyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcC0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3YXBwZWQpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBWO1xuICAgICAgICAgICAgViA9IFU7XG4gICAgICAgICAgICBVID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tID0gbTtcbiAgICAgICAgdGhpcy5uID0gbjtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5VID0gVTtcbiAgICAgICAgdGhpcy5WID0gVjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTb2x2ZSBhIHByb2JsZW0gb2YgbGVhc3Qgc3F1YXJlIChBeD1iKSBieSB1c2luZyB0aGUgU1ZELiBVc2VmdWwgd2hlbiBBIGlzIHNpbmd1bGFyLiBXaGVuIEEgaXMgbm90IHNpbmd1bGFyLCBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gdXNlIHFyLnNvbHZlKHZhbHVlKS5cbiAgICAgKiBFeGFtcGxlIDogV2Ugc2VhcmNoIHRvIGFwcHJveGltYXRlIHgsIHdpdGggQSBtYXRyaXggc2hhcGUgbSpuLCB4IHZlY3RvciBzaXplIG4sIGIgdmVjdG9yIHNpemUgbSAobSA+IG4pLiBXZSB3aWxsIHVzZSA6XG4gICAgICogdmFyIHN2ZCA9IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uKEEpO1xuICAgICAqIHZhciB4ID0gc3ZkLnNvbHZlKGIpO1xuICAgICAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZSAtIE1hdHJpeCAxRCB3aGljaCBpcyB0aGUgdmVjdG9yIGIgKGluIHRoZSBlcXVhdGlvbiBBeCA9IGIpXG4gICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSB2ZWN0b3IgeFxuICAgICAqL1xuICAgIHNvbHZlKHZhbHVlKSB7XG5cbiAgICAgICAgdmFyIFkgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHNjb2xzID0gdGhpcy5zLmxlbmd0aDtcbiAgICAgICAgdmFyIExzID0gTWF0cml4Lnplcm9zKHNjb2xzLCBzY29scyk7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY29sczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zW2ldKSA8PSBlKSB7XG4gICAgICAgICAgICAgICAgTHNbaV1baV0gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBMc1tpXVtpXSA9IDEgLyB0aGlzLnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgVSA9IHRoaXMuVTtcbiAgICAgICAgdmFyIFYgPSB0aGlzLnJpZ2h0U2luZ3VsYXJWZWN0b3JzO1xuXG4gICAgICAgIHZhciBWTCA9IFYubW11bChMcyk7XG4gICAgICAgIHZhciB2cm93cyA9IFYucm93cztcbiAgICAgICAgdmFyIHVyb3dzID0gVS5sZW5ndGg7XG4gICAgICAgIHZhciBWTFUgPSBNYXRyaXguemVyb3ModnJvd3MsIHVyb3dzKTtcbiAgICAgICAgdmFyIGosIGssIHN1bTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdnJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHVyb3dzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBzY29sczsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBWTFtpXVtrXSAqIFVbal1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFZMVVtpXVtqXSA9IHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBWTFUubW11bChZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICovXG4gICAgc29sdmVGb3JEaWFnb25hbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2x2ZShNYXRyaXguZGlhZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW52ZXJzZSBvZiB0aGUgbWF0cml4LiBXZSBjb21wdXRlIHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4IHVzaW5nIFNWRCB3aGVuIHRoaXMgbWF0cml4IGlzIHNpbmd1bGFyIG9yIGlsbC1jb25kaXRpb25lZC4gRXhhbXBsZSA6XG4gICAgICogdmFyIHN2ZCA9IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uKEEpO1xuICAgICAqIHZhciBpbnZlcnNlQSA9IHN2ZC5pbnZlcnNlKCk7XG4gICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBhcHByb3hpbWF0aW9uIG9mIHRoZSBpbnZlcnNlIG9mIHRoZSBtYXRyaXhcbiAgICAgKi9cbiAgICBpbnZlcnNlKCkge1xuICAgICAgICB2YXIgViA9IHRoaXMuVjtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZyb3dzID0gVi5sZW5ndGg7XG4gICAgICAgIHZhciB2Y29scyA9IFZbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgWCA9IG5ldyBNYXRyaXgodnJvd3MsIHRoaXMucy5sZW5ndGgpO1xuICAgICAgICB2YXIgaSwgajtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdnJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHZjb2xzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zW2pdKSA+IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSA9IFZbaV1bal0gLyB0aGlzLnNbal07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFUgPSB0aGlzLlU7XG5cbiAgICAgICAgdmFyIHVyb3dzID0gVS5sZW5ndGg7XG4gICAgICAgIHZhciB1Y29scyA9IFVbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgWSA9IG5ldyBNYXRyaXgodnJvd3MsIHVyb3dzKTtcbiAgICAgICAgdmFyIGssIHN1bTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdnJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHVyb3dzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCB1Y29sczsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBYW2ldW2tdICogVVtqXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgWVtpXVtqXSA9IHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBjb25kaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNbMF0gLyB0aGlzLnNbTWF0aC5taW4odGhpcy5tLCB0aGlzLm4pIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG5vcm0yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCByYW5rKCkge1xuICAgICAgICB2YXIgdG9sID0gTWF0aC5tYXgodGhpcy5tLCB0aGlzLm4pICogdGhpcy5zWzBdICogTnVtYmVyLkVQU0lMT047XG4gICAgICAgIHZhciByID0gMDtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNbaV0gPiB0b2wpIHtcbiAgICAgICAgICAgICAgICByKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIGdldCBkaWFnb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdGhyZXNob2xkKCkge1xuICAgICAgICByZXR1cm4gKE51bWJlci5FUFNJTE9OIC8gMikgKiBNYXRoLm1heCh0aGlzLm0sIHRoaXMubikgKiB0aGlzLnNbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICovXG4gICAgZ2V0IGxlZnRTaW5ndWxhclZlY3RvcnMoKSB7XG4gICAgICAgIGlmICghTWF0cml4LmlzTWF0cml4KHRoaXMuVSkpIHtcbiAgICAgICAgICAgIHRoaXMuVSA9IG5ldyBNYXRyaXgodGhpcy5VKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5VO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybiB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldCByaWdodFNpbmd1bGFyVmVjdG9ycygpIHtcbiAgICAgICAgaWYgKCFNYXRyaXguaXNNYXRyaXgodGhpcy5WKSkge1xuICAgICAgICAgICAgdGhpcy5WID0gbmV3IE1hdHJpeCh0aGlzLlYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLlY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICovXG4gICAgZ2V0IGRpYWdvbmFsTWF0cml4KCkge1xuICAgICAgICByZXR1cm4gTWF0cml4LmRpYWcodGhpcy5zKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRoYXQgYSByb3cgaW5kZXggaXMgbm90IG91dCBvZiBib3VuZHNcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSBbb3V0ZXJdXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUm93SW5kZXgobWF0cml4LCBpbmRleCwgb3V0ZXIpIHtcbiAgICB2YXIgbWF4ID0gb3V0ZXIgPyBtYXRyaXgucm93cyA6IG1hdHJpeC5yb3dzIC0gMTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gbWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdSb3cgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDaGVjayB0aGF0IGEgY29sdW1uIGluZGV4IGlzIG5vdCBvdXQgb2YgYm91bmRzXG4gKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW291dGVyXVxuICovXG5mdW5jdGlvbiBjaGVja0NvbHVtbkluZGV4KG1hdHJpeCwgaW5kZXgsIG91dGVyKSB7XG4gICAgdmFyIG1heCA9IG91dGVyID8gbWF0cml4LmNvbHVtbnMgOiBtYXRyaXguY29sdW1ucyAtIDE7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IG1heCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ29sdW1uIGluZGV4IG91dCBvZiByYW5nZScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ2hlY2sgdGhhdCB0aGUgcHJvdmlkZWQgdmVjdG9yIGlzIGFuIGFycmF5IHdpdGggdGhlIHJpZ2h0IGxlbmd0aFxuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvclxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICovXG5mdW5jdGlvbiBjaGVja1Jvd1ZlY3RvcihtYXRyaXgsIHZlY3Rvcikge1xuICAgIGlmICh2ZWN0b3IudG8xREFycmF5KSB7XG4gICAgICAgIHZlY3RvciA9IHZlY3Rvci50bzFEQXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKHZlY3Rvci5sZW5ndGggIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2ZWN0b3Igc2l6ZSBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucycpO1xuICAgIH1cbiAgICByZXR1cm4gdmVjdG9yO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDaGVjayB0aGF0IHRoZSBwcm92aWRlZCB2ZWN0b3IgaXMgYW4gYXJyYXkgd2l0aCB0aGUgcmlnaHQgbGVuZ3RoXG4gKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG4gKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gdmVjdG9yXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29sdW1uVmVjdG9yKG1hdHJpeCwgdmVjdG9yKSB7XG4gICAgaWYgKHZlY3Rvci50bzFEQXJyYXkpIHtcbiAgICAgICAgdmVjdG9yID0gdmVjdG9yLnRvMURBcnJheSgpO1xuICAgIH1cbiAgICBpZiAodmVjdG9yLmxlbmd0aCAhPT0gbWF0cml4LnJvd3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZlY3RvciBzaXplIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiByb3dzJyk7XG4gICAgfVxuICAgIHJldHVybiB2ZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5kaWNlcyhtYXRyaXgsIHJvd0luZGljZXMsIGNvbHVtbkluZGljZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb3c6IGNoZWNrUm93SW5kaWNlcyhtYXRyaXgsIHJvd0luZGljZXMpLFxuICAgICAgICBjb2x1bW46IGNoZWNrQ29sdW1uSW5kaWNlcyhtYXRyaXgsIGNvbHVtbkluZGljZXMpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tSb3dJbmRpY2VzKG1hdHJpeCwgcm93SW5kaWNlcykge1xuICAgIGlmICh0eXBlb2Ygcm93SW5kaWNlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlIGZvciByb3cgaW5kaWNlcycpO1xuICAgIH1cblxuICAgIHZhciByb3dPdXQgPSByb3dJbmRpY2VzLnNvbWUociA9PiB7XG4gICAgICAgIHJldHVybiByIDwgMCB8fCByID49IG1hdHJpeC5yb3dzO1xuXG4gICAgfSk7XG5cbiAgICBpZiAocm93T3V0KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdyb3cgaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJvd0luZGljZXMpKSByb3dJbmRpY2VzID0gQXJyYXkuZnJvbShyb3dJbmRpY2VzKTtcblxuICAgIHJldHVybiByb3dJbmRpY2VzO1xufVxuXG5mdW5jdGlvbiBjaGVja0NvbHVtbkluZGljZXMobWF0cml4LCBjb2x1bW5JbmRpY2VzKSB7XG4gICAgaWYgKHR5cGVvZiBjb2x1bW5JbmRpY2VzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIHR5cGUgZm9yIGNvbHVtbiBpbmRpY2VzJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbHVtbk91dCA9IGNvbHVtbkluZGljZXMuc29tZShjID0+IHtcbiAgICAgICAgcmV0dXJuIGMgPCAwIHx8IGMgPj0gbWF0cml4LmNvbHVtbnM7XG4gICAgfSk7XG5cbiAgICBpZiAoY29sdW1uT3V0KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjb2x1bW4gaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb2x1bW5JbmRpY2VzKSkgY29sdW1uSW5kaWNlcyA9IEFycmF5LmZyb20oY29sdW1uSW5kaWNlcyk7XG5cbiAgICByZXR1cm4gY29sdW1uSW5kaWNlcztcbn1cblxuZnVuY3Rpb24gY2hlY2tSYW5nZShtYXRyaXgsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCB0eXBlJyk7XG4gICAgdmFyIG5vdEFsbE51bWJlcnMgPSBBcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSkuc29tZShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYXJnICE9PSAnbnVtYmVyJztcbiAgICB9KTtcbiAgICBpZiAobm90QWxsTnVtYmVycykgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCB0eXBlJyk7XG4gICAgaWYgKHN0YXJ0Um93ID4gZW5kUm93IHx8IHN0YXJ0Q29sdW1uID4gZW5kQ29sdW1uIHx8IHN0YXJ0Um93IDwgMCB8fCBzdGFydFJvdyA+PSBtYXRyaXgucm93cyB8fCBlbmRSb3cgPCAwIHx8IGVuZFJvdyA+PSBtYXRyaXgucm93cyB8fCBzdGFydENvbHVtbiA8IDAgfHwgc3RhcnRDb2x1bW4gPj0gbWF0cml4LmNvbHVtbnMgfHwgZW5kQ29sdW1uIDwgMCB8fCBlbmRDb2x1bW4gPj0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1N1Ym1hdHJpeCBpbmRpY2VzIGFyZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiBzdW1CeVJvdyhtYXRyaXgpIHtcbiAgICB2YXIgc3VtID0gTWF0cml4Lnplcm9zKG1hdHJpeC5yb3dzLCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgKytqKSB7XG4gICAgICAgICAgICBzdW0uc2V0KGksIDAsIHN1bS5nZXQoaSwgMCkgKyBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiBzdW1CeUNvbHVtbihtYXRyaXgpIHtcbiAgICB2YXIgc3VtID0gTWF0cml4Lnplcm9zKDEsIG1hdHJpeC5jb2x1bW5zKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgKytqKSB7XG4gICAgICAgICAgICBzdW0uc2V0KDAsIGosIHN1bS5nZXQoMCwgaikgKyBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiBzdW1BbGwobWF0cml4KSB7XG4gICAgdmFyIHYgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIHYgKz0gbWF0cml4LmdldChpLCBqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuY2xhc3MgQmFzZVZpZXcgZXh0ZW5kcyBBYnN0cmFjdE1hdHJpeCgpIHtcbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgICAgICByZXR1cm4gTWF0cml4O1xuICAgIH1cbn1cblxuY2xhc3MgTWF0cml4VHJhbnNwb3NlVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgpIHtcbiAgICAgICAgc3VwZXIobWF0cml4LCBtYXRyaXguY29sdW1ucywgbWF0cml4LnJvd3MpO1xuICAgIH1cblxuICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF0cml4LnNldChjb2x1bW5JbmRleCwgcm93SW5kZXgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KGNvbHVtbkluZGV4LCByb3dJbmRleCk7XG4gICAgfVxufVxuXG5jbGFzcyBNYXRyaXhSb3dWaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgcm93KSB7XG4gICAgICAgIHN1cGVyKG1hdHJpeCwgMSwgbWF0cml4LmNvbHVtbnMpO1xuICAgICAgICB0aGlzLnJvdyA9IHJvdztcbiAgICB9XG5cbiAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hdHJpeC5zZXQodGhpcy5yb3csIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnJvdywgY29sdW1uSW5kZXgpO1xuICAgIH1cbn1cblxuY2xhc3MgTWF0cml4U3ViVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgY2hlY2tSYW5nZShtYXRyaXgsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pO1xuICAgICAgICBzdXBlcihtYXRyaXgsIGVuZFJvdyAtIHN0YXJ0Um93ICsgMSwgZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW4gKyAxKTtcbiAgICAgICAgdGhpcy5zdGFydFJvdyA9IHN0YXJ0Um93O1xuICAgICAgICB0aGlzLnN0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgfVxuXG4gICAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXRyaXguc2V0KHRoaXMuc3RhcnRSb3cgKyByb3dJbmRleCwgdGhpcy5zdGFydENvbHVtbiArIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnN0YXJ0Um93ICsgcm93SW5kZXgsIHRoaXMuc3RhcnRDb2x1bW4gKyBjb2x1bW5JbmRleCk7XG4gICAgfVxufVxuXG5jbGFzcyBNYXRyaXhTZWxlY3Rpb25WaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgcm93SW5kaWNlcywgY29sdW1uSW5kaWNlcykge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IGNoZWNrSW5kaWNlcyhtYXRyaXgsIHJvd0luZGljZXMsIGNvbHVtbkluZGljZXMpO1xuICAgICAgICBzdXBlcihtYXRyaXgsIGluZGljZXMucm93Lmxlbmd0aCwgaW5kaWNlcy5jb2x1bW4ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yb3dJbmRpY2VzID0gaW5kaWNlcy5yb3c7XG4gICAgICAgIHRoaXMuY29sdW1uSW5kaWNlcyA9IGluZGljZXMuY29sdW1uO1xuICAgIH1cblxuICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF0cml4LnNldCh0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLCB0aGlzLmNvbHVtbkluZGljZXNbY29sdW1uSW5kZXhdLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLCB0aGlzLmNvbHVtbkluZGljZXNbY29sdW1uSW5kZXhdKTtcbiAgICB9XG59XG5cbmNsYXNzIE1hdHJpeFJvd1NlbGVjdGlvblZpZXcgZXh0ZW5kcyBCYXNlVmlldyB7XG4gICAgY29uc3RydWN0b3IobWF0cml4LCByb3dJbmRpY2VzKSB7XG4gICAgICAgIHJvd0luZGljZXMgPSBjaGVja1Jvd0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzKTtcbiAgICAgICAgc3VwZXIobWF0cml4LCByb3dJbmRpY2VzLmxlbmd0aCwgbWF0cml4LmNvbHVtbnMpO1xuICAgICAgICB0aGlzLnJvd0luZGljZXMgPSByb3dJbmRpY2VzO1xuICAgIH1cblxuICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF0cml4LnNldCh0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLCBjb2x1bW5JbmRleCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQodGhpcy5yb3dJbmRpY2VzW3Jvd0luZGV4XSwgY29sdW1uSW5kZXgpO1xuICAgIH1cbn1cblxuY2xhc3MgTWF0cml4Q29sdW1uU2VsZWN0aW9uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIGNvbHVtbkluZGljZXMpIHtcbiAgICAgICAgY29sdW1uSW5kaWNlcyA9IGNoZWNrQ29sdW1uSW5kaWNlcyhtYXRyaXgsIGNvbHVtbkluZGljZXMpO1xuICAgICAgICBzdXBlcihtYXRyaXgsIG1hdHJpeC5yb3dzLCBjb2x1bW5JbmRpY2VzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXM7XG4gICAgfVxuXG4gICAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXRyaXguc2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbkluZGljZXNbY29sdW1uSW5kZXhdLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldChyb3dJbmRleCwgdGhpcy5jb2x1bW5JbmRpY2VzW2NvbHVtbkluZGV4XSk7XG4gICAgfVxufVxuXG5jbGFzcyBNYXRyaXhDb2x1bW5WaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgY29sdW1uKSB7XG4gICAgICAgIHN1cGVyKG1hdHJpeCwgbWF0cml4LnJvd3MsIDEpO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB9XG5cbiAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hdHJpeC5zZXQocm93SW5kZXgsIHRoaXMuY29sdW1uLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldChyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbik7XG4gICAgfVxufVxuXG5jbGFzcyBNYXRyaXhGbGlwUm93VmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgpIHtcbiAgICAgICAgc3VwZXIobWF0cml4LCBtYXRyaXgucm93cywgbWF0cml4LmNvbHVtbnMpO1xuICAgIH1cblxuICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF0cml4LnNldCh0aGlzLnJvd3MgLSByb3dJbmRleCAtIDEsIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnJvd3MgLSByb3dJbmRleCAtIDEsIGNvbHVtbkluZGV4KTtcbiAgICB9XG59XG5cbmNsYXNzIE1hdHJpeEZsaXBDb2x1bW5WaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hdHJpeCkge1xuICAgICAgICBzdXBlcihtYXRyaXgsIG1hdHJpeC5yb3dzLCBtYXRyaXguY29sdW1ucyk7XG4gICAgfVxuXG4gICAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXRyaXguc2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbnMgLSBjb2x1bW5JbmRleCAtIDEsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbnMgLSBjb2x1bW5JbmRleCAtIDEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gQWJzdHJhY3RNYXRyaXgoc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3RvciA9PT0gdW5kZWZpbmVkKSBzdXBlckN0b3IgPSBPYmplY3Q7XG5cbiAgICAvKipcbiAgICAgKiBSZWFsIG1hdHJpeFxuICAgICAqIEBjbGFzcyBNYXRyaXhcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheXxNYXRyaXh9IG5Sb3dzIC0gTnVtYmVyIG9mIHJvd3Mgb2YgdGhlIG5ldyBtYXRyaXgsXG4gICAgICogMkQgYXJyYXkgY29udGFpbmluZyB0aGUgZGF0YSBvciBNYXRyaXggaW5zdGFuY2UgdG8gY2xvbmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25Db2x1bW5zXSAtIE51bWJlciBvZiBjb2x1bW5zIG9mIHRoZSBuZXcgbWF0cml4XG4gICAgICovXG4gICAgY2xhc3MgTWF0cml4IGV4dGVuZHMgc3VwZXJDdG9yIHtcbiAgICAgICAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIE1hdHJpeCB3aXRoIHRoZSBjaG9zZW4gZGltZW5zaW9ucyBmcm9tIGEgMUQgYXJyYXlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Jvd3MgLSBOdW1iZXIgb2Ygcm93c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3Q29sdW1ucyAtIE51bWJlciBvZiBjb2x1bW5zXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG5ld0RhdGEgLSBBIDFEIGFycmF5IGNvbnRhaW5pbmcgZGF0YSBmb3IgdGhlIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IC0gVGhlIG5ldyBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tMURBcnJheShuZXdSb3dzLCBuZXdDb2x1bW5zLCBuZXdEYXRhKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbmV3Um93cyAqIG5ld0NvbHVtbnM7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICE9PSBuZXdEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRhIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBnaXZlbiBkaW1lbnNpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3TWF0cml4ID0gbmV3IHRoaXMobmV3Um93cywgbmV3Q29sdW1ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBuZXdSb3dzOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IG5ld0NvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdHJpeC5zZXQocm93LCBjb2x1bW4sIG5ld0RhdGFbcm93ICogbmV3Q29sdW1ucyArIGNvbHVtbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdNYXRyaXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHJvdyB2ZWN0b3IsIGEgbWF0cml4IHdpdGggb25seSBvbmUgcm93LlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBuZXdEYXRhIC0gQSAxRCBhcnJheSBjb250YWluaW5nIGRhdGEgZm9yIHRoZSB2ZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBuZXcgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcm93VmVjdG9yKG5ld0RhdGEpIHtcbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgdGhpcygxLCBuZXdEYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ZWN0b3Iuc2V0KDAsIGksIG5ld0RhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29sdW1uIHZlY3RvciwgYSBtYXRyaXggd2l0aCBvbmx5IG9uZSBjb2x1bW4uXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG5ld0RhdGEgLSBBIDFEIGFycmF5IGNvbnRhaW5pbmcgZGF0YSBmb3IgdGhlIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IC0gVGhlIG5ldyBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb2x1bW5WZWN0b3IobmV3RGF0YSkge1xuICAgICAgICAgICAgdmFyIHZlY3RvciA9IG5ldyB0aGlzKG5ld0RhdGEubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZlY3Rvci5zZXQoaSwgMCwgbmV3RGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmVjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgbWF0cml4IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMuIFZhbHVlcyB3aWxsIGJlIHVuZGVmaW5lZC4gU2FtZSBhcyB1c2luZyBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93cyAtIE51bWJlciBvZiByb3dzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zIC0gTnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBuZXcgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZW1wdHkocm93cywgY29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZGltZW5zaW9ucy4gVmFsdWVzIHdpbGwgYmUgc2V0IHRvIHplcm8uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzIC0gTnVtYmVyIG9mIHJvd3NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnMgLSBOdW1iZXIgb2YgY29sdW1uc1xuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IC0gVGhlIG5ldyBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB6ZXJvcyhyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eShyb3dzLCBjb2x1bW5zKS5maWxsKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZGltZW5zaW9ucy4gVmFsdWVzIHdpbGwgYmUgc2V0IHRvIG9uZS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBOdW1iZXIgb2Ygcm93c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1ucyAtIE51bWJlciBvZiBjb2x1bW5zXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgbmV3IG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG9uZXMocm93cywgY29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHkocm93cywgY29sdW1ucykuZmlsbCgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMuIFZhbHVlcyB3aWxsIGJlIHJhbmRvbWx5IHNldC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBOdW1iZXIgb2Ygcm93c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1ucyAtIE51bWJlciBvZiBjb2x1bW5zXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtybmc9TWF0aC5yYW5kb21dIC0gUmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSBUaGUgbmV3IG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJhbmQocm93cywgY29sdW1ucywgcm5nKSB7XG4gICAgICAgICAgICBpZiAocm5nID09PSB1bmRlZmluZWQpIHJuZyA9IE1hdGgucmFuZG9tO1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuZW1wdHkocm93cywgY29sdW1ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaSwgaiwgcm5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBkaW1lbnNpb25zLiBWYWx1ZXMgd2lsbCBiZSByYW5kb20gaW50ZWdlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzIC0gTnVtYmVyIG9mIHJvd3NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnMgLSBOdW1iZXIgb2YgY29sdW1uc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFZhbHVlPTEwMDBdIC0gTWF4aW11bSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcm5nPU1hdGgucmFuZG9tXSAtIFJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gVGhlIG5ldyBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyByYW5kSW50KHJvd3MsIGNvbHVtbnMsIG1heFZhbHVlLCBybmcpIHtcbiAgICAgICAgICAgIGlmIChtYXhWYWx1ZSA9PT0gdW5kZWZpbmVkKSBtYXhWYWx1ZSA9IDEwMDA7XG4gICAgICAgICAgICBpZiAocm5nID09PSB1bmRlZmluZWQpIHJuZyA9IE1hdGgucmFuZG9tO1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuZW1wdHkocm93cywgY29sdW1ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE1hdGguZmxvb3Iocm5nKCkgKiBtYXhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaSwgaiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZGltZW5zaW9uLiBWYWx1ZXMgb2YgdGhlIGRpYWdvbmFsIHdpbGwgYmUgMSBhbmQgb3RoZXJzIHdpbGwgYmUgMC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBOdW1iZXIgb2Ygcm93c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbHVtbnM9cm93c10gLSBOdW1iZXIgb2YgY29sdW1uc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlPTFdIC0gVmFsdWUgdG8gZmlsbCB0aGUgZGlhZ29uYWwgd2l0aFxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IC0gVGhlIG5ldyBpZGVudGl0eSBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBleWUocm93cywgY29sdW1ucywgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zID09PSB1bmRlZmluZWQpIGNvbHVtbnMgPSByb3dzO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gMTtcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB0aGlzLnplcm9zKHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaSwgaSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgZGlhZ29uYWwgbWF0cml4IGJhc2VkIG9uIHRoZSBnaXZlbiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIEFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgZm9yIHRoZSBkaWFnb25hbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jvd3NdIC0gTnVtYmVyIG9mIHJvd3MgKERlZmF1bHQ6IGRhdGEubGVuZ3RoKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbHVtbnNdIC0gTnVtYmVyIG9mIGNvbHVtbnMgKERlZmF1bHQ6IHJvd3MpXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgbmV3IGRpYWdvbmFsIG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRpYWcoZGF0YSwgcm93cywgY29sdW1ucykge1xuICAgICAgICAgICAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyb3dzID09PSB1bmRlZmluZWQpIHJvd3MgPSBsO1xuICAgICAgICAgICAgaWYgKGNvbHVtbnMgPT09IHVuZGVmaW5lZCkgY29sdW1ucyA9IHJvd3M7XG4gICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4obCwgcm93cywgY29sdW1ucyk7XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy56ZXJvcyhyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGksIGksIGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgbWluaW11bSBiZXR3ZWVuIG1hdHJpeDEgYW5kIG1hdHJpeDJcbiAgICAgICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeDFcbiAgICAgICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeDJcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG1pbihtYXRyaXgxLCBtYXRyaXgyKSB7XG4gICAgICAgICAgICBtYXRyaXgxID0gdGhpcy5jaGVja01hdHJpeChtYXRyaXgxKTtcbiAgICAgICAgICAgIG1hdHJpeDIgPSB0aGlzLmNoZWNrTWF0cml4KG1hdHJpeDIpO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSBtYXRyaXgxLnJvd3M7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IG1hdHJpeDEuY29sdW1ucztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgdGhpcyhyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChpLCBqLCBNYXRoLm1pbihtYXRyaXgxLmdldChpLCBqKSwgbWF0cml4Mi5nZXQoaSwgaikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBtYXRyaXggd2hvc2UgZWxlbWVudHMgYXJlIHRoZSBtYXhpbXVtIGJldHdlZW4gbWF0cml4MSBhbmQgbWF0cml4MlxuICAgICAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4MVxuICAgICAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4MlxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbWF4KG1hdHJpeDEsIG1hdHJpeDIpIHtcbiAgICAgICAgICAgIG1hdHJpeDEgPSB0aGlzLmNoZWNrTWF0cml4KG1hdHJpeDEpO1xuICAgICAgICAgICAgbWF0cml4MiA9IHRoaXMuY2hlY2tNYXRyaXgobWF0cml4Mik7XG4gICAgICAgICAgICB2YXIgcm93cyA9IG1hdHJpeDEucm93cztcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gbWF0cml4MS5jb2x1bW5zO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB0aGlzKHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGksIGosIE1hdGgubWF4KG1hdHJpeDEuZ2V0KGksIGopLCBtYXRyaXgyLmdldChpLCBqKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgdGhhdCB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBNYXRyaXggYW5kIHRyaWVzIHRvIGluc3RhbnRpYXRlIG9uZSBpZiBub3RcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY2hlY2tNYXRyaXgodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRyaXguaXNNYXRyaXgodmFsdWUpID8gdmFsdWUgOiBuZXcgdGhpcyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIE1hdHJpeCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBpc01hdHJpeCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsKSAmJiAodmFsdWUua2xhc3MgPT09ICdNYXRyaXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcCB7bnVtYmVyfSBzaXplIC0gVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWF0cml4LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dzICogdGhpcy5jb2x1bW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgYSBjYWxsYmFjayBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguIFRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgaW4gdGhlIG1hdHJpeCAodGhpcykgY29udGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnMgOiBpIChyb3cpIGFuZCBqIChjb2x1bW4pXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHkoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpaSA9IHRoaXMucm93cztcbiAgICAgICAgICAgIHZhciBqaiA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGksIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgMUQgYXJyYXkgZmlsbGVkIHJvdyBieSByb3cgd2l0aCB0aGUgbWF0cml4IHZhbHVlc1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRvMURBcnJheSgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheSh0aGlzLnNpemUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaSAqIHRoaXMuY29sdW1ucyArIGpdID0gdGhpcy5nZXQoaSwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSAyRCBhcnJheSBjb250YWluaW5nIGEgY29weSBvZiB0aGUgZGF0YVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRvMkRBcnJheSgpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3IEFycmF5KHRoaXMucm93cyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weVtpXSA9IG5ldyBBcnJheSh0aGlzLmNvbHVtbnMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVtpXVtqXSA9IHRoaXMuZ2V0KGksIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1hdHJpeCBoYXMgb25lIHJvd1xuICAgICAgICAgKi9cbiAgICAgICAgaXNSb3dWZWN0b3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dzID09PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1hdHJpeCBoYXMgb25lIGNvbHVtblxuICAgICAgICAgKi9cbiAgICAgICAgaXNDb2x1bW5WZWN0b3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zID09PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1hdHJpeCBoYXMgb25lIHJvdyBvciBvbmUgY29sdW1uXG4gICAgICAgICAqL1xuICAgICAgICBpc1ZlY3RvcigpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5yb3dzID09PSAxKSB8fCAodGhpcy5jb2x1bW5zID09PSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBtYXRyaXggaGFzIHRoZSBzYW1lIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zXG4gICAgICAgICAqL1xuICAgICAgICBpc1NxdWFyZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd3MgPT09IHRoaXMuY29sdW1ucztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBtYXRyaXggaXMgc3F1YXJlIGFuZCBoYXMgdGhlIHNhbWUgdmFsdWVzIG9uIGJvdGggc2lkZXMgb2YgdGhlIGRpYWdvbmFsXG4gICAgICAgICAqL1xuICAgICAgICBpc1N5bW1ldHJpYygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3F1YXJlKCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGopICE9PSB0aGlzLmdldChqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgZ2l2ZW4gZWxlbWVudCBvZiB0aGUgbWF0cml4LiBtYXQuc2V0KDMsNCwxKSBpcyBlcXVpdmFsZW50IHRvIG1hdFszXVs0XT0xXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBJbmRleCBvZiB0aGUgcm93XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIEluZGV4IG9mIHRoZSBjb2x1bW5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGdpdmVuIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC4gbWF0LmdldCgzLDQpIGlzIGVxdWl2YWxlbnQgdG8gbWF0cml4WzNdWzRdXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBJbmRleCBvZiB0aGUgcm93XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIEluZGV4IG9mIHRoZSBjb2x1bW5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgbWF0cml4IHRoYXQgaXMgYSByZXBldGl0aW9uIG9mIHRoZSBjdXJyZW50IG1hdHJpeC4gTmV3IG1hdHJpeCBoYXMgcm93UmVwIHRpbWVzIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICogcm93cyBvZiB0aGUgbWF0cml4LCBhbmQgY29sUmVwIHRpbWVzIHRoZSBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dSZXAgLSBOdW1iZXIgb2YgdGltZXMgdGhlIHJvd3Mgc2hvdWxkIGJlIHJlcGVhdGVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xSZXAgLSBOdW1iZXIgb2YgdGltZXMgdGhlIGNvbHVtbnMgc2hvdWxkIGJlIHJlXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoW1sxLDJdXSk7XG4gICAgICAgICAqIG1hdHJpeC5yZXBlYXQoMik7IC8vIFtbMSwyXSxbMSwyXV1cbiAgICAgICAgICovXG4gICAgICAgIHJlcGVhdChyb3dSZXAsIGNvbFJlcCkge1xuICAgICAgICAgICAgcm93UmVwID0gcm93UmVwIHx8IDE7XG4gICAgICAgICAgICBjb2xSZXAgPSBjb2xSZXAgfHwgMTtcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10odGhpcy5yb3dzICogcm93UmVwLCB0aGlzLmNvbHVtbnMgKiBjb2xSZXApO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dSZXA7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sUmVwOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldFN1Yk1hdHJpeCh0aGlzLCB0aGlzLnJvd3MgKiBpLCB0aGlzLmNvbHVtbnMgKiBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbGxzIHRoZSBtYXRyaXggd2l0aCBhIGdpdmVuIHZhbHVlLiBBbGwgZWxlbWVudHMgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTmV3IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgZmlsbCh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5lZ2F0ZXMgdGhlIG1hdHJpeC4gQWxsIGVsZW1lbnRzIHdpbGwgYmUgbXVsdGlwbGllZCBieSAoLTEpXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgbmVnKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsUygtMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSBmcm9tIHRoZSBnaXZlbiByb3cgaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gUm93IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Um93KGluZGV4KSB7XG4gICAgICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByb3cgPSBuZXcgQXJyYXkodGhpcy5jb2x1bW5zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgICAgICByb3dbaV0gPSB0aGlzLmdldChpbmRleCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgcm93IHZlY3RvciBmcm9tIHRoZSBnaXZlbiByb3cgaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gUm93IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJvd1ZlY3RvcihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iucm93VmVjdG9yKHRoaXMuZ2V0Um93KGluZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIHJvdyBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gUm93IGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSBhcnJheSAtIEFycmF5IG9yIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHNldFJvdyhpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgICAgICAgYXJyYXkgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCBhcnJheSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoaW5kZXgsIGksIGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN3YXBzIHR3byByb3dzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cxIC0gRmlyc3Qgcm93IGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cyIC0gU2Vjb25kIHJvdyBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN3YXBSb3dzKHJvdzEsIHJvdzIpIHtcbiAgICAgICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93MSk7XG4gICAgICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIHJvdzIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5nZXQocm93MSwgaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQocm93MSwgaSwgdGhpcy5nZXQocm93MiwgaSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHJvdzIsIGksIHRlbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSBmcm9tIHRoZSBnaXZlbiBjb2x1bW4gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQ29sdW1uIGluZGV4XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29sdW1uKGluZGV4KSB7XG4gICAgICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBuZXcgQXJyYXkodGhpcy5yb3dzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5baV0gPSB0aGlzLmdldChpLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgY29sdW1uIHZlY3RvciBmcm9tIHRoZSBnaXZlbiBjb2x1bW4gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQ29sdW1uIGluZGV4XG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgICAgICovXG4gICAgICAgIGdldENvbHVtblZlY3RvcihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29sdW1uVmVjdG9yKHRoaXMuZ2V0Q29sdW1uKGluZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIGNvbHVtbiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQ29sdW1uIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSBhcnJheSAtIEFycmF5IG9yIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHNldENvbHVtbihpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgICAgICAgYXJyYXkgPSBjaGVja0NvbHVtblZlY3Rvcih0aGlzLCBhcnJheSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaW5kZXgsIGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN3YXBzIHR3byBjb2x1bW5zXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4xIC0gRmlyc3QgY29sdW1uIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4yIC0gU2Vjb25kIGNvbHVtbiBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN3YXBDb2x1bW5zKGNvbHVtbjEsIGNvbHVtbjIpIHtcbiAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uMSk7XG4gICAgICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbjIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5nZXQoaSwgY29sdW1uMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgY29sdW1uMSwgdGhpcy5nZXQoaSwgY29sdW1uMikpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGNvbHVtbjIsIHRlbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyB0aGUgdmFsdWVzIG9mIGEgdmVjdG9yIHRvIGVhY2ggcm93XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBhZGRSb3dWZWN0b3IodmVjdG9yKSB7XG4gICAgICAgICAgICB2ZWN0b3IgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgKyB2ZWN0b3Jbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnRyYWN0cyB0aGUgdmFsdWVzIG9mIGEgdmVjdG9yIGZyb20gZWFjaCByb3dcbiAgICAgICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN1YlJvd1ZlY3Rvcih2ZWN0b3IpIHtcbiAgICAgICAgICAgIHZlY3RvciA9IGNoZWNrUm93VmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAtIHZlY3RvcltqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTXVsdGlwbGllcyB0aGUgdmFsdWVzIG9mIGEgdmVjdG9yIHdpdGggZWFjaCByb3dcbiAgICAgICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG11bFJvd1ZlY3Rvcih2ZWN0b3IpIHtcbiAgICAgICAgICAgIHZlY3RvciA9IGNoZWNrUm93VmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAqIHZlY3RvcltqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGl2aWRlcyB0aGUgdmFsdWVzIG9mIGVhY2ggcm93IGJ5IHRob3NlIG9mIGEgdmVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBkaXZSb3dWZWN0b3IodmVjdG9yKSB7XG4gICAgICAgICAgICB2ZWN0b3IgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgLyB2ZWN0b3Jbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgdGhlIHZhbHVlcyBvZiBhIHZlY3RvciB0byBlYWNoIGNvbHVtblxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gdmVjdG9yIC0gQXJyYXkgb3IgdmVjdG9yXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ29sdW1uVmVjdG9yKHZlY3Rvcikge1xuICAgICAgICAgICAgdmVjdG9yID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICsgdmVjdG9yW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJ0cmFjdHMgdGhlIHZhbHVlcyBvZiBhIHZlY3RvciBmcm9tIGVhY2ggY29sdW1uXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBzdWJDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgICAgICAgICB2ZWN0b3IgPSBjaGVja0NvbHVtblZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgLSB2ZWN0b3JbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11bHRpcGxpZXMgdGhlIHZhbHVlcyBvZiBhIHZlY3RvciB3aXRoIGVhY2ggY29sdW1uXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBtdWxDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgICAgICAgICB2ZWN0b3IgPSBjaGVja0NvbHVtblZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgKiB2ZWN0b3JbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpdmlkZXMgdGhlIHZhbHVlcyBvZiBlYWNoIGNvbHVtbiBieSB0aG9zZSBvZiBhIHZlY3RvclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gdmVjdG9yIC0gQXJyYXkgb3IgdmVjdG9yXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgZGl2Q29sdW1uVmVjdG9yKHZlY3Rvcikge1xuICAgICAgICAgICAgdmVjdG9yID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC8gdmVjdG9yW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdWx0aXBsaWVzIHRoZSB2YWx1ZXMgb2YgYSByb3cgd2l0aCBhIHNjYWxhclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBSb3cgaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgbXVsUm93KGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoaW5kZXgsIGksIHRoaXMuZ2V0KGluZGV4LCBpKSAqIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11bHRpcGxpZXMgdGhlIHZhbHVlcyBvZiBhIGNvbHVtbiB3aXRoIGEgc2NhbGFyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIENvbHVtbiBpbmRleFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBtdWxDb2x1bW4oaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChpLCBpbmRleCwgdGhpcy5nZXQoaSwgaW5kZXgpICogdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG1heCgpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPiB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF4aW11bSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIG1heEluZGV4KCkge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldCgwLCAwKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBbMCwgMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPiB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHhbMF0gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4WzFdID0gajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG1pbigpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPCB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWluaW11bSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIG1pbkluZGV4KCkge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldCgwLCAwKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBbMCwgMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPCB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHhbMF0gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4WzFdID0gajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBvbmUgcm93XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBSb3cgaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4Um93KHJvdykge1xuICAgICAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldChyb3csIDApO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChyb3csIGkpID4gdikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQocm93LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF4aW11bSB2YWx1ZSBvZiBvbmUgcm93XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBSb3cgaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBtYXhSb3dJbmRleChyb3cpIHtcbiAgICAgICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93KTtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQocm93LCAwKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBbcm93LCAwXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQocm93LCBpKSA+IHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KHJvdywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlkeFsxXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIG9mIG9uZSByb3dcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIFJvdyBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBtaW5Sb3cocm93KSB7XG4gICAgICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIHJvdyk7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KHJvdywgMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KHJvdywgaSkgPCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLmdldChyb3csIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXhpbXVtIHZhbHVlIG9mIG9uZSByb3dcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIFJvdyBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIG1pblJvd0luZGV4KHJvdykge1xuICAgICAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldChyb3csIDApO1xuICAgICAgICAgICAgdmFyIGlkeCA9IFtyb3csIDBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChyb3csIGkpIDwgdikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQocm93LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWR4WzFdID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgb2Ygb25lIGNvbHVtblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gQ29sdW1uIGluZGV4XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG1heENvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQoMCwgY29sdW1uKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgY29sdW1uKSA+IHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1heGltdW0gdmFsdWUgb2Ygb25lIGNvbHVtblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gQ29sdW1uIGluZGV4XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4Q29sdW1uSW5kZXgoY29sdW1uKSB7XG4gICAgICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbik7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KDAsIGNvbHVtbik7XG4gICAgICAgICAgICB2YXIgaWR4ID0gWzAsIGNvbHVtbl07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGNvbHVtbikgPiB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLmdldChpLCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBpZHhbMF0gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBvZiBvbmUgY29sdW1uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gLSBDb2x1bW4gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbWluQ29sdW1uKGNvbHVtbikge1xuICAgICAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4pO1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldCgwLCBjb2x1bW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChpLCBjb2x1bW4pIDwgdikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWluaW11bSB2YWx1ZSBvZiBvbmUgY29sdW1uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gLSBDb2x1bW4gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBtaW5Db2x1bW5JbmRleChjb2x1bW4pIHtcbiAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQoMCwgY29sdW1uKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBbMCwgY29sdW1uXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgY29sdW1uKSA8IHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGlkeFswXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRpYWdvbmFsIHZhbHVlcyBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgZGlhZygpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG4gICAgICAgICAgICB2YXIgZGlhZyA9IG5ldyBBcnJheShtaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRpYWdbaV0gPSB0aGlzLmdldChpLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWFnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHN1bSBieSB0aGUgYXJndW1lbnQgZ2l2ZW4sIGlmIG5vIGFyZ3VtZW50IGdpdmVuLFxuICAgICAgICAgKiBpdCByZXR1cm5zIHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzIG9mIHRoZSBtYXRyaXguXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBieSAtIHN1bSBieSAncm93JyBvciAnY29sdW1uJy5cbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fG51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHN1bShieSkge1xuICAgICAgICAgICAgc3dpdGNoIChieSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Jvdyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW1CeVJvdyh0aGlzKTtcbiAgICAgICAgICAgICAgICBjYXNlICdjb2x1bW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtQnlDb2x1bW4odGhpcyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bUFsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZWFuIG9mIGFsbCBlbGVtZW50cyBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG1lYW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdW0oKSAvIHRoaXMuc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIGFsbCBlbGVtZW50cyBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHByb2QoKSB7XG4gICAgICAgICAgICB2YXIgcHJvZCA9IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9kICo9IHRoaXMuZ2V0KGksIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9kO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG5vcm0gb2YgYSBtYXRyaXguXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gXCJmcm9iZW5pdXNcIiAoZGVmYXVsdCkgb3IgXCJtYXhcIiByZXR1cm4gcmVzcC4gdGhlIEZyb2Jlbml1cyBub3JtIGFuZCB0aGUgbWF4IG5vcm0uXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG5vcm0odHlwZSA9ICdmcm9iZW5pdXMnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbWF4Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZnJvYmVuaXVzJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdGhpcy5nZXQoaSwgaikgKiB0aGlzLmdldChpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bmtub3duIG5vcm0gdHlwZTogJHt0eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXB1dGVzIHRoZSBjdW11bGF0aXZlIHN1bSBvZiB0aGUgbWF0cml4IGVsZW1lbnRzIChpbiBwbGFjZSwgcm93IGJ5IHJvdylcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBjdW11bGF0aXZlU3VtKCkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5nZXQoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHN1bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZXMgdGhlIGRvdCAoc2NhbGFyKSBwcm9kdWN0IGJldHdlZW4gdGhlIG1hdHJpeCBhbmQgYW5vdGhlclxuICAgICAgICAgKiBAcGFyYW0ge01hdHJpeH0gdmVjdG9yMiB2ZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZG90KHZlY3RvcjIpIHtcbiAgICAgICAgICAgIGlmIChNYXRyaXguaXNNYXRyaXgodmVjdG9yMikpIHZlY3RvcjIgPSB2ZWN0b3IyLnRvMURBcnJheSgpO1xuICAgICAgICAgICAgdmFyIHZlY3RvcjEgPSB0aGlzLnRvMURBcnJheSgpO1xuICAgICAgICAgICAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2ZWN0b3JzIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkb3QgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZWN0b3IxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZG90ICs9IHZlY3RvcjFbaV0gKiB2ZWN0b3IyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtYXRyaXggcHJvZHVjdCBiZXR3ZWVuIHRoaXMgYW5kIG90aGVyXG4gICAgICAgICAqIEBwYXJhbSB7TWF0cml4fSBvdGhlclxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICBtbXVsKG90aGVyKSB7XG4gICAgICAgICAgICBvdGhlciA9IHRoaXMuY29uc3RydWN0b3IuY2hlY2tNYXRyaXgob3RoZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1ucyAhPT0gb3RoZXIucm93cykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdOdW1iZXIgb2YgY29sdW1ucyBvZiBsZWZ0IG1hdHJpeCBhcmUgbm90IGVxdWFsIHRvIG51bWJlciBvZiByb3dzIG9mIHJpZ2h0IG1hdHJpeC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnJvd3M7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgIHZhciBwID0gb3RoZXIuY29sdW1ucztcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXShtLCBwKTtcblxuICAgICAgICAgICAgdmFyIEJjb2xqID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBCY29saltrXSA9IG90aGVyLmdldChrLCBqKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gdGhpcy5nZXQoaSwgaykgKiBCY29saltrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmFzc2VuMngyKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdKDIsIDIpO1xuICAgICAgICAgICAgY29uc3QgYTExID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgICAgICAgICBjb25zdCBiMTEgPSBvdGhlci5nZXQoMCwgMCk7XG4gICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmdldCgwLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGIxMiA9IG90aGVyLmdldCgwLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZ2V0KDEsIDApO1xuICAgICAgICAgICAgY29uc3QgYjIxID0gb3RoZXIuZ2V0KDEsIDApO1xuICAgICAgICAgICAgY29uc3QgYTIyID0gdGhpcy5nZXQoMSwgMSk7XG4gICAgICAgICAgICBjb25zdCBiMjIgPSBvdGhlci5nZXQoMSwgMSk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgaW50ZXJtZWRpYXRlIHZhbHVlcy5cbiAgICAgICAgICAgIGNvbnN0IG0xID0gKGExMSArIGEyMikgKiAoYjExICsgYjIyKTtcbiAgICAgICAgICAgIGNvbnN0IG0yID0gKGEyMSArIGEyMikgKiBiMTE7XG4gICAgICAgICAgICBjb25zdCBtMyA9IGExMSAqIChiMTIgLSBiMjIpO1xuICAgICAgICAgICAgY29uc3QgbTQgPSBhMjIgKiAoYjIxIC0gYjExKTtcbiAgICAgICAgICAgIGNvbnN0IG01ID0gKGExMSArIGExMikgKiBiMjI7XG4gICAgICAgICAgICBjb25zdCBtNiA9IChhMjEgLSBhMTEpICogKGIxMSArIGIxMik7XG4gICAgICAgICAgICBjb25zdCBtNyA9IChhMTIgLSBhMjIpICogKGIyMSArIGIyMik7XG5cbiAgICAgICAgICAgIC8vIENvbWJpbmUgaW50ZXJtZWRpYXRlIHZhbHVlcyBpbnRvIHRoZSBvdXRwdXQuXG4gICAgICAgICAgICBjb25zdCBjMDAgPSBtMSArIG00IC0gbTUgKyBtNztcbiAgICAgICAgICAgIGNvbnN0IGMwMSA9IG0zICsgbTU7XG4gICAgICAgICAgICBjb25zdCBjMTAgPSBtMiArIG00O1xuICAgICAgICAgICAgY29uc3QgYzExID0gbTEgLSBtMiArIG0zICsgbTY7XG5cbiAgICAgICAgICAgIHJlc3VsdC5zZXQoMCwgMCwgYzAwKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoMCwgMSwgYzAxKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoMSwgMCwgYzEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoMSwgMSwgYzExKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJhc3NlbjN4MyhvdGhlcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXSgzLCAzKTtcblxuICAgICAgICAgICAgY29uc3QgYTAwID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgICAgICAgICBjb25zdCBhMDEgPSB0aGlzLmdldCgwLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGEwMiA9IHRoaXMuZ2V0KDAsIDIpO1xuICAgICAgICAgICAgY29uc3QgYTEwID0gdGhpcy5nZXQoMSwgMCk7XG4gICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLmdldCgxLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGExMiA9IHRoaXMuZ2V0KDEsIDIpO1xuICAgICAgICAgICAgY29uc3QgYTIwID0gdGhpcy5nZXQoMiwgMCk7XG4gICAgICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmdldCgyLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuZ2V0KDIsIDIpO1xuXG4gICAgICAgICAgICBjb25zdCBiMDAgPSBvdGhlci5nZXQoMCwgMCk7XG4gICAgICAgICAgICBjb25zdCBiMDEgPSBvdGhlci5nZXQoMCwgMSk7XG4gICAgICAgICAgICBjb25zdCBiMDIgPSBvdGhlci5nZXQoMCwgMik7XG4gICAgICAgICAgICBjb25zdCBiMTAgPSBvdGhlci5nZXQoMSwgMCk7XG4gICAgICAgICAgICBjb25zdCBiMTEgPSBvdGhlci5nZXQoMSwgMSk7XG4gICAgICAgICAgICBjb25zdCBiMTIgPSBvdGhlci5nZXQoMSwgMik7XG4gICAgICAgICAgICBjb25zdCBiMjAgPSBvdGhlci5nZXQoMiwgMCk7XG4gICAgICAgICAgICBjb25zdCBiMjEgPSBvdGhlci5nZXQoMiwgMSk7XG4gICAgICAgICAgICBjb25zdCBiMjIgPSBvdGhlci5nZXQoMiwgMik7XG5cbiAgICAgICAgICAgIGNvbnN0IG0xID0gKGEwMCArIGEwMSArIGEwMiAtIGExMCAtIGExMSAtIGEyMSAtIGEyMikgKiBiMTE7XG4gICAgICAgICAgICBjb25zdCBtMiA9IChhMDAgLSBhMTApICogKC1iMDEgKyBiMTEpO1xuICAgICAgICAgICAgY29uc3QgbTMgPSBhMTEgKiAoLWIwMCArIGIwMSArIGIxMCAtIGIxMSAtIGIxMiAtIGIyMCArIGIyMik7XG4gICAgICAgICAgICBjb25zdCBtNCA9ICgtYTAwICsgYTEwICsgYTExKSAqIChiMDAgLSBiMDEgKyBiMTEpO1xuICAgICAgICAgICAgY29uc3QgbTUgPSAoYTEwICsgYTExKSAqICgtYjAwICsgYjAxKTtcbiAgICAgICAgICAgIGNvbnN0IG02ID0gYTAwICogYjAwO1xuICAgICAgICAgICAgY29uc3QgbTcgPSAoLWEwMCArIGEyMCArIGEyMSkgKiAoYjAwIC0gYjAyICsgYjEyKTtcbiAgICAgICAgICAgIGNvbnN0IG04ID0gKC1hMDAgKyBhMjApICogKGIwMiAtIGIxMik7XG4gICAgICAgICAgICBjb25zdCBtOSA9IChhMjAgKyBhMjEpICogKC1iMDAgKyBiMDIpO1xuICAgICAgICAgICAgY29uc3QgbTEwID0gKGEwMCArIGEwMSArIGEwMiAtIGExMSAtIGExMiAtIGEyMCAtIGEyMSkgKiBiMTI7XG4gICAgICAgICAgICBjb25zdCBtMTEgPSBhMjEgKiAoLWIwMCArIGIwMiArIGIxMCAtIGIxMSAtIGIxMiAtIGIyMCArIGIyMSk7XG4gICAgICAgICAgICBjb25zdCBtMTIgPSAoLWEwMiArIGEyMSArIGEyMikgKiAoYjExICsgYjIwIC0gYjIxKTtcbiAgICAgICAgICAgIGNvbnN0IG0xMyA9IChhMDIgLSBhMjIpICogKGIxMSAtIGIyMSk7XG4gICAgICAgICAgICBjb25zdCBtMTQgPSBhMDIgKiBiMjA7XG4gICAgICAgICAgICBjb25zdCBtMTUgPSAoYTIxICsgYTIyKSAqICgtYjIwICsgYjIxKTtcbiAgICAgICAgICAgIGNvbnN0IG0xNiA9ICgtYTAyICsgYTExICsgYTEyKSAqIChiMTIgKyBiMjAgLSBiMjIpO1xuICAgICAgICAgICAgY29uc3QgbTE3ID0gKGEwMiAtIGExMikgKiAoYjEyIC0gYjIyKTtcbiAgICAgICAgICAgIGNvbnN0IG0xOCA9IChhMTEgKyBhMTIpICogKC1iMjAgKyBiMjIpO1xuICAgICAgICAgICAgY29uc3QgbTE5ID0gYTAxICogYjEwO1xuICAgICAgICAgICAgY29uc3QgbTIwID0gYTEyICogYjIxO1xuICAgICAgICAgICAgY29uc3QgbTIxID0gYTEwICogYjAyO1xuICAgICAgICAgICAgY29uc3QgbTIyID0gYTIwICogYjAxO1xuICAgICAgICAgICAgY29uc3QgbTIzID0gYTIyICogYjIyO1xuXG4gICAgICAgICAgICBjb25zdCBjMDAgPSBtNiArIG0xNCArIG0xOTtcbiAgICAgICAgICAgIGNvbnN0IGMwMSA9IG0xICsgbTQgKyBtNSArIG02ICsgbTEyICsgbTE0ICsgbTE1O1xuICAgICAgICAgICAgY29uc3QgYzAyID0gbTYgKyBtNyArIG05ICsgbTEwICsgbTE0ICsgbTE2ICsgbTE4O1xuICAgICAgICAgICAgY29uc3QgYzEwID0gbTIgKyBtMyArIG00ICsgbTYgKyBtMTQgKyBtMTYgKyBtMTc7XG4gICAgICAgICAgICBjb25zdCBjMTEgPSBtMiArIG00ICsgbTUgKyBtNiArIG0yMDtcbiAgICAgICAgICAgIGNvbnN0IGMxMiA9IG0xNCArIG0xNiArIG0xNyArIG0xOCArIG0yMTtcbiAgICAgICAgICAgIGNvbnN0IGMyMCA9IG02ICsgbTcgKyBtOCArIG0xMSArIG0xMiArIG0xMyArIG0xNDtcbiAgICAgICAgICAgIGNvbnN0IGMyMSA9IG0xMiArIG0xMyArIG0xNCArIG0xNSArIG0yMjtcbiAgICAgICAgICAgIGNvbnN0IGMyMiA9IG02ICsgbTcgKyBtOCArIG05ICsgbTIzO1xuXG4gICAgICAgICAgICByZXN1bHQuc2V0KDAsIDAsIGMwMCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KDAsIDEsIGMwMSk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KDAsIDIsIGMwMik7XG4gICAgICAgICAgICByZXN1bHQuc2V0KDEsIDAsIGMxMCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KDEsIDEsIGMxMSk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KDEsIDIsIGMxMik7XG4gICAgICAgICAgICByZXN1bHQuc2V0KDIsIDAsIGMyMCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KDIsIDEsIGMyMSk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KDIsIDIsIGMyMik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1hdHJpeCBwcm9kdWN0IGJldHdlZW4geCBhbmQgeS4gTW9yZSBlZmZpY2llbnQgdGhhbiBtbXVsKG90aGVyKSBvbmx5IHdoZW4gd2UgbXVsdGlwbHkgc3F1YXJlZCBtYXRyaXggYW5kIHdoZW4gdGhlIHNpemUgb2YgdGhlIG1hdHJpeCBpcyA+IDEwMDAuXG4gICAgICAgICAqIEBwYXJhbSB7TWF0cml4fSB5XG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgICAgICovXG4gICAgICAgIG1tdWxTdHJhc3Nlbih5KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciByMSA9IHgucm93cztcbiAgICAgICAgICAgIHZhciBjMSA9IHguY29sdW1ucztcbiAgICAgICAgICAgIHZhciByMiA9IHkucm93cztcbiAgICAgICAgICAgIHZhciBjMiA9IHkuY29sdW1ucztcbiAgICAgICAgICAgIGlmIChjMSAhPT0gcjIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgTXVsdGlwbHlpbmcgJHtyMX0geCAke2MxfSBhbmQgJHtyMn0geCAke2MyfSBtYXRyaXg6IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoLmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQdXQgYSBtYXRyaXggaW50byB0aGUgdG9wIGxlZnQgb2YgYSBtYXRyaXggb2YgemVyb3MuXG4gICAgICAgICAgICAvLyBgcm93c2AgYW5kIGBjb2xzYCBhcmUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG91dHB1dCBtYXRyaXguXG4gICAgICAgICAgICBmdW5jdGlvbiBlbWJlZChtYXQsIHJvd3MsIGNvbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG1hdC5yb3dzO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbWF0LmNvbHVtbnM7XG4gICAgICAgICAgICAgICAgaWYgKChyID09PSByb3dzKSAmJiAoYyA9PT0gY29scykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0YXQgPSBNYXRyaXguemVyb3Mocm93cywgY29scyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGF0ID0gcmVzdWx0YXQuc2V0U3ViTWF0cml4KG1hdCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGJvdGggbWF0cmljZXMgYXJlIHRoZSBzYW1lIHNpemUuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGV4Y2x1c2l2ZWx5IGZvciBzaW1wbGljaXR5OlxuICAgICAgICAgICAgLy8gdGhpcyBhbGdvcml0aG0gY2FuIGJlIGltcGxlbWVudGVkIHdpdGggbWF0cmljZXMgb2YgZGlmZmVyZW50IHNpemVzLlxuXG4gICAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KHIxLCByMik7XG4gICAgICAgICAgICB2YXIgYyA9IE1hdGgubWF4KGMxLCBjMik7XG4gICAgICAgICAgICB4ID0gZW1iZWQoeCwgciwgYyk7XG4gICAgICAgICAgICB5ID0gZW1iZWQoeSwgciwgYyk7XG5cbiAgICAgICAgICAgIC8vIE91ciByZWN1cnNpdmUgbXVsdGlwbGljYXRpb24gZnVuY3Rpb24uXG4gICAgICAgICAgICBmdW5jdGlvbiBibG9ja011bHQoYSwgYiwgcm93cywgY29scykge1xuICAgICAgICAgICAgICAgIC8vIEZvciBzbWFsbCBtYXRyaWNlcywgcmVzb3J0IHRvIG5haXZlIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChyb3dzIDw9IDUxMiB8fCBjb2xzIDw9IDUxMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5tbXVsKGIpOyAvLyBhIGlzIGVxdWl2YWxlbnQgdG8gdGhpc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGR5bmFtaWMgcGFkZGluZy5cbiAgICAgICAgICAgICAgICBpZiAoKHJvd3MgJSAyID09PSAxKSAmJiAoY29scyAlIDIgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBlbWJlZChhLCByb3dzICsgMSwgY29scyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBiID0gZW1iZWQoYiwgcm93cyArIDEsIGNvbHMgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJvd3MgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBlbWJlZChhLCByb3dzICsgMSwgY29scyk7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBlbWJlZChiLCByb3dzICsgMSwgY29scyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xzICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhID0gZW1iZWQoYSwgcm93cywgY29scyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBiID0gZW1iZWQoYiwgcm93cywgY29scyArIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBoYWxmUm93cyA9IHBhcnNlSW50KGEucm93cyAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBoYWxmQ29scyA9IHBhcnNlSW50KGEuY29sdW1ucyAvIDIpO1xuICAgICAgICAgICAgICAgIC8vIFN1YmRpdmlkZSBpbnB1dCBtYXRyaWNlcy5cbiAgICAgICAgICAgICAgICB2YXIgYTExID0gYS5zdWJNYXRyaXgoMCwgaGFsZlJvd3MgLSAxLCAwLCBoYWxmQ29scyAtIDEpO1xuICAgICAgICAgICAgICAgIHZhciBiMTEgPSBiLnN1Yk1hdHJpeCgwLCBoYWxmUm93cyAtIDEsIDAsIGhhbGZDb2xzIC0gMSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYTEyID0gYS5zdWJNYXRyaXgoMCwgaGFsZlJvd3MgLSAxLCBoYWxmQ29scywgYS5jb2x1bW5zIC0gMSk7XG4gICAgICAgICAgICAgICAgdmFyIGIxMiA9IGIuc3ViTWF0cml4KDAsIGhhbGZSb3dzIC0gMSwgaGFsZkNvbHMsIGIuY29sdW1ucyAtIDEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGEyMSA9IGEuc3ViTWF0cml4KGhhbGZSb3dzLCBhLnJvd3MgLSAxLCAwLCBoYWxmQ29scyAtIDEpO1xuICAgICAgICAgICAgICAgIHZhciBiMjEgPSBiLnN1Yk1hdHJpeChoYWxmUm93cywgYi5yb3dzIC0gMSwgMCwgaGFsZkNvbHMgLSAxKTtcblxuICAgICAgICAgICAgICAgIHZhciBhMjIgPSBhLnN1Yk1hdHJpeChoYWxmUm93cywgYS5yb3dzIC0gMSwgaGFsZkNvbHMsIGEuY29sdW1ucyAtIDEpO1xuICAgICAgICAgICAgICAgIHZhciBiMjIgPSBiLnN1Yk1hdHJpeChoYWxmUm93cywgYi5yb3dzIC0gMSwgaGFsZkNvbHMsIGIuY29sdW1ucyAtIDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnRlcm1lZGlhdGUgdmFsdWVzLlxuICAgICAgICAgICAgICAgIHZhciBtMSA9IGJsb2NrTXVsdChNYXRyaXguYWRkKGExMSwgYTIyKSwgTWF0cml4LmFkZChiMTEsIGIyMiksIGhhbGZSb3dzLCBoYWxmQ29scyk7XG4gICAgICAgICAgICAgICAgdmFyIG0yID0gYmxvY2tNdWx0KE1hdHJpeC5hZGQoYTIxLCBhMjIpLCBiMTEsIGhhbGZSb3dzLCBoYWxmQ29scyk7XG4gICAgICAgICAgICAgICAgdmFyIG0zID0gYmxvY2tNdWx0KGExMSwgTWF0cml4LnN1YihiMTIsIGIyMiksIGhhbGZSb3dzLCBoYWxmQ29scyk7XG4gICAgICAgICAgICAgICAgdmFyIG00ID0gYmxvY2tNdWx0KGEyMiwgTWF0cml4LnN1YihiMjEsIGIxMSksIGhhbGZSb3dzLCBoYWxmQ29scyk7XG4gICAgICAgICAgICAgICAgdmFyIG01ID0gYmxvY2tNdWx0KE1hdHJpeC5hZGQoYTExLCBhMTIpLCBiMjIsIGhhbGZSb3dzLCBoYWxmQ29scyk7XG4gICAgICAgICAgICAgICAgdmFyIG02ID0gYmxvY2tNdWx0KE1hdHJpeC5zdWIoYTIxLCBhMTEpLCBNYXRyaXguYWRkKGIxMSwgYjEyKSwgaGFsZlJvd3MsIGhhbGZDb2xzKTtcbiAgICAgICAgICAgICAgICB2YXIgbTcgPSBibG9ja011bHQoTWF0cml4LnN1YihhMTIsIGEyMiksIE1hdHJpeC5hZGQoYjIxLCBiMjIpLCBoYWxmUm93cywgaGFsZkNvbHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tYmluZSBpbnRlcm1lZGlhdGUgdmFsdWVzIGludG8gdGhlIG91dHB1dC5cbiAgICAgICAgICAgICAgICB2YXIgYzExID0gTWF0cml4LmFkZChtMSwgbTQpO1xuICAgICAgICAgICAgICAgIGMxMS5zdWIobTUpO1xuICAgICAgICAgICAgICAgIGMxMS5hZGQobTcpO1xuICAgICAgICAgICAgICAgIHZhciBjMTIgPSBNYXRyaXguYWRkKG0zLCBtNSk7XG4gICAgICAgICAgICAgICAgdmFyIGMyMSA9IE1hdHJpeC5hZGQobTIsIG00KTtcbiAgICAgICAgICAgICAgICB2YXIgYzIyID0gTWF0cml4LnN1YihtMSwgbTIpO1xuICAgICAgICAgICAgICAgIGMyMi5hZGQobTMpO1xuICAgICAgICAgICAgICAgIGMyMi5hZGQobTYpO1xuXG4gICAgICAgICAgICAgICAgLy9Dcm9wIG91dHB1dCB0byB0aGUgZGVzaXJlZCBzaXplICh1bmRvIGR5bmFtaWMgcGFkZGluZykuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdGF0ID0gTWF0cml4Lnplcm9zKDIgKiBjMTEucm93cywgMiAqIGMxMS5jb2x1bW5zKTtcbiAgICAgICAgICAgICAgICByZXN1bHRhdCA9IHJlc3VsdGF0LnNldFN1Yk1hdHJpeChjMTEsIDAsIDApO1xuICAgICAgICAgICAgICAgIHJlc3VsdGF0ID0gcmVzdWx0YXQuc2V0U3ViTWF0cml4KGMxMiwgYzExLnJvd3MsIDApO1xuICAgICAgICAgICAgICAgIHJlc3VsdGF0ID0gcmVzdWx0YXQuc2V0U3ViTWF0cml4KGMyMSwgMCwgYzExLmNvbHVtbnMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdGF0ID0gcmVzdWx0YXQuc2V0U3ViTWF0cml4KGMyMiwgYzExLnJvd3MsIGMxMS5jb2x1bW5zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0YXQuc3ViTWF0cml4KDAsIHJvd3MgLSAxLCAwLCBjb2xzIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tNdWx0KHgsIHksIHIsIGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSByb3ctYnktcm93IHNjYWxlZCBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gLSBNaW5pbXVtIHNjYWxlZCB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSAtIE1heGltdW0gc2NhbGVkIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgc2NhbGVkIG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGVSb3dzKG1pbiwgbWF4KSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPT09IHVuZGVmaW5lZCA/IDAgOiBtaW47XG4gICAgICAgICAgICBtYXggPSBtYXggPT09IHVuZGVmaW5lZCA/IDEgOiBtYXg7XG4gICAgICAgICAgICBpZiAobWluID49IG1heCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaW4gc2hvdWxkIGJlIHN0cmljdGx5IHNtYWxsZXIgdGhhbiBtYXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdNYXRyaXggPSB0aGlzLmNvbnN0cnVjdG9yLmVtcHR5KHRoaXMucm93cywgdGhpcy5jb2x1bW5zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVkID0gcmVzY2FsZSh0aGlzLmdldFJvdyhpKSwge21pbiwgbWF4fSk7XG4gICAgICAgICAgICAgICAgbmV3TWF0cml4LnNldFJvdyhpLCBzY2FsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGNvbHVtbi1ieS1jb2x1bW4gc2NhbGVkIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSAtIE1pbmltdW0gc2NhbGVkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIC0gTWF4aW11bSBzY2FsZWQgdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBuZXcgc2NhbGVkIG1hdHJpeFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeChbWzEsMl0sWy0xLDBdXSk7XG4gICAgICAgICAqIHZhciBzY2FsZWRNYXRyaXggPSBtYXRyaXguc2NhbGVDb2x1bW5zKCk7IC8vIFtbMSwxXSxbMCwwXV1cbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlQ29sdW1ucyhtaW4sIG1heCkge1xuICAgICAgICAgICAgbWluID0gbWluID09PSB1bmRlZmluZWQgPyAwIDogbWluO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID09PSB1bmRlZmluZWQgPyAxIDogbWF4O1xuICAgICAgICAgICAgaWYgKG1pbiA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWluIHNob3VsZCBiZSBzdHJpY3RseSBzbWFsbGVyIHRoYW4gbWF4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3TWF0cml4ID0gdGhpcy5jb25zdHJ1Y3Rvci5lbXB0eSh0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlZCA9IHJlc2NhbGUodGhpcy5nZXRDb2x1bW4oaSksIHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICAgICAgICAgIG1heDogbWF4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmV3TWF0cml4LnNldENvbHVtbihpLCBzY2FsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIEtyb25lY2tlciBwcm9kdWN0IChhbHNvIGtub3duIGFzIHRlbnNvciBwcm9kdWN0KSBiZXR3ZWVuIHRoaXMgYW5kIG90aGVyXG4gICAgICAgICAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Lcm9uZWNrZXJfcHJvZHVjdFxuICAgICAgICAgKiBAcGFyYW0ge01hdHJpeH0gb3RoZXJcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fVxuICAgICAgICAgKi9cbiAgICAgICAga3JvbmVja2VyUHJvZHVjdChvdGhlcikge1xuICAgICAgICAgICAgb3RoZXIgPSB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrTWF0cml4KG90aGVyKTtcblxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnJvd3M7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgIHZhciBwID0gb3RoZXIucm93cztcbiAgICAgICAgICAgIHZhciBxID0gb3RoZXIuY29sdW1ucztcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXShtICogcCwgbiAqIHEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHA7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBxOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcCAqIGkgKyBrXVtxICogaiArIGxdID0gdGhpcy5nZXQoaSwgaikgKiBvdGhlci5nZXQoaywgbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zcG9zZXMgdGhlIG1hdHJpeCBhbmQgcmV0dXJucyBhIG5ldyBvbmUgY29udGFpbmluZyB0aGUgcmVzdWx0XG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zcG9zZSgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10odGhpcy5jb2x1bW5zLCB0aGlzLnJvd3MpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChqLCBpLCB0aGlzLmdldChpLCBqKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0cyB0aGUgcm93cyAoaW4gcGxhY2UpXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmVGdW5jdGlvbiAtIHVzdWFsIEFycmF5LnByb3RvdHlwZS5zb3J0IGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Um93cyhjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkgY29tcGFyZUZ1bmN0aW9uID0gY29tcGFyZU51bWJlcnM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb3coaSwgdGhpcy5nZXRSb3coaSkuc29ydChjb21wYXJlRnVuY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvcnRzIHRoZSBjb2x1bW5zIChpbiBwbGFjZSlcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZUZ1bmN0aW9uIC0gdXN1YWwgQXJyYXkucHJvdG90eXBlLnNvcnQgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRDb2x1bW5zKGNvbXBhcmVGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSBjb21wYXJlRnVuY3Rpb24gPSBjb21wYXJlTnVtYmVycztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbHVtbihpLCB0aGlzLmdldENvbHVtbihpKS5zb3J0KGNvbXBhcmVGdW5jdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFJvdyAtIEZpcnN0IHJvdyBpbmRleFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kUm93IC0gTGFzdCByb3cgaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Q29sdW1uIC0gRmlyc3QgY29sdW1uIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRDb2x1bW4gLSBMYXN0IGNvbHVtbiBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJNYXRyaXgoc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgICAgICAgICAgY2hlY2tSYW5nZSh0aGlzLCBzdGFydFJvdywgZW5kUm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKTtcbiAgICAgICAgICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10oZW5kUm93IC0gc3RhcnRSb3cgKyAxLCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0Um93OyBpIDw9IGVuZFJvdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0Q29sdW1uOyBqIDw9IGVuZENvbHVtbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdHJpeFtpIC0gc3RhcnRSb3ddW2ogLSBzdGFydENvbHVtbl0gPSB0aGlzLmdldChpLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3TWF0cml4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGhlIG1hdHJpeCBiYXNlZCBvbiBhbiBhcnJheSBvZiByb3cgaW5kaWNlc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIC0gQXJyYXkgY29udGFpbmluZyB0aGUgcm93IGluZGljZXNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydENvbHVtbiA9IDBdIC0gRmlyc3QgY29sdW1uIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kQ29sdW1uID0gdGhpcy5jb2x1bW5zLTFdIC0gTGFzdCBjb2x1bW4gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fVxuICAgICAgICAgKi9cbiAgICAgICAgc3ViTWF0cml4Um93KGluZGljZXMsIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChzdGFydENvbHVtbiA9PT0gdW5kZWZpbmVkKSBzdGFydENvbHVtbiA9IDA7XG4gICAgICAgICAgICBpZiAoZW5kQ29sdW1uID09PSB1bmRlZmluZWQpIGVuZENvbHVtbiA9IHRoaXMuY29sdW1ucyAtIDE7XG4gICAgICAgICAgICBpZiAoKHN0YXJ0Q29sdW1uID4gZW5kQ29sdW1uKSB8fCAoc3RhcnRDb2x1bW4gPCAwKSB8fCAoc3RhcnRDb2x1bW4gPj0gdGhpcy5jb2x1bW5zKSB8fCAoZW5kQ29sdW1uIDwgMCkgfHwgKGVuZENvbHVtbiA+PSB0aGlzLmNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0FyZ3VtZW50IG91dCBvZiByYW5nZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3TWF0cml4ID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdKGluZGljZXMubGVuZ3RoLCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0Q29sdW1uOyBqIDw9IGVuZENvbHVtbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzW2ldIDwgMCB8fCBpbmRpY2VzW2ldID49IHRoaXMucm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1JvdyBpbmRleCBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRpY2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdNYXRyaXguc2V0KGksIGogLSBzdGFydENvbHVtbiwgdGhpcy5nZXQoaW5kaWNlc1tpXSwgaikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdNYXRyaXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgbWF0cml4IGJhc2VkIG9uIGFuIGFycmF5IG9mIGNvbHVtbiBpbmRpY2VzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGljZXMgLSBBcnJheSBjb250YWluaW5nIHRoZSBjb2x1bW4gaW5kaWNlc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0Um93ID0gMF0gLSBGaXJzdCByb3cgaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRSb3cgPSB0aGlzLnJvd3MtMV0gLSBMYXN0IHJvdyBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJNYXRyaXhDb2x1bW4oaW5kaWNlcywgc3RhcnRSb3csIGVuZFJvdykge1xuICAgICAgICAgICAgaWYgKHN0YXJ0Um93ID09PSB1bmRlZmluZWQpIHN0YXJ0Um93ID0gMDtcbiAgICAgICAgICAgIGlmIChlbmRSb3cgPT09IHVuZGVmaW5lZCkgZW5kUm93ID0gdGhpcy5yb3dzIC0gMTtcbiAgICAgICAgICAgIGlmICgoc3RhcnRSb3cgPiBlbmRSb3cpIHx8IChzdGFydFJvdyA8IDApIHx8IChzdGFydFJvdyA+PSB0aGlzLnJvd3MpIHx8IChlbmRSb3cgPCAwKSB8fCAoZW5kUm93ID49IHRoaXMucm93cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXJndW1lbnQgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10oZW5kUm93IC0gc3RhcnRSb3cgKyAxLCBpbmRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRSb3c7IGogPD0gZW5kUm93OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGljZXNbaV0gPCAwIHx8IGluZGljZXNbaV0gPj0gdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ29sdW1uIGluZGV4IG91dCBvZiByYW5nZTogJyArIGluZGljZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdHJpeC5zZXQoaiAtIHN0YXJ0Um93LCBpLCB0aGlzLmdldChqLCBpbmRpY2VzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSBwYXJ0IG9mIHRoZSBtYXRyaXggdG8gdGhlIGdpdmVuIHN1Yi1tYXRyaXhcbiAgICAgICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXk8IEFycmF5ID59IG1hdHJpeCAtIFRoZSBzb3VyY2UgbWF0cml4IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB2YWx1ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFJvdyAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgcm93IHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRDb2x1bW4gLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGNvbHVtbiB0byBzZXRcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U3ViTWF0cml4KG1hdHJpeCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICBtYXRyaXggPSB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgICAgICAgICB2YXIgZW5kUm93ID0gc3RhcnRSb3cgKyBtYXRyaXgucm93cyAtIDE7XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gc3RhcnRDb2x1bW4gKyBtYXRyaXguY29sdW1ucyAtIDE7XG4gICAgICAgICAgICBjaGVja1JhbmdlKHRoaXMsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3RhcnRSb3cgKyBpXVtzdGFydENvbHVtbiArIGpdID0gbWF0cml4LmdldChpLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgbWF0cml4IGJhc2VkIG9uIGEgc2VsZWN0aW9uIG9mIHJvd3MgYW5kIGNvbHVtbnNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSByb3dJbmRpY2VzIC0gVGhlIHJvdyBpbmRpY2VzIHRvIHNlbGVjdC4gT3JkZXIgbWF0dGVycyBhbmQgYW4gaW5kZXggY2FuIGJlIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbHVtbkluZGljZXMgLSBUaGUgY29sdW1uIGluZGljZXMgdG8gc2VsZWN0LiBPcmRlciBtYXR0ZXJzIGFuZCBhbiBpbmRleCBjYW4gYmUgdXNlIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IFRoZSBuZXcgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb24ocm93SW5kaWNlcywgY29sdW1uSW5kaWNlcykge1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBjaGVja0luZGljZXModGhpcywgcm93SW5kaWNlcywgY29sdW1uSW5kaWNlcyk7XG4gICAgICAgICAgICB2YXIgbmV3TWF0cml4ID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdKHJvd0luZGljZXMubGVuZ3RoLCBjb2x1bW5JbmRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMucm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0luZGV4ID0gaW5kaWNlcy5yb3dbaV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbmRpY2VzLmNvbHVtbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBpbmRpY2VzLmNvbHVtbltqXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0cml4W2ldW2pdID0gdGhpcy5nZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3TWF0cml4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRyYWNlIG9mIHRoZSBtYXRyaXggKHN1bSBvZiB0aGUgZGlhZ29uYWwgZWxlbWVudHMpXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRyYWNlKCkge1xuICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHRoaXMucm93cywgdGhpcy5jb2x1bW5zKTtcbiAgICAgICAgICAgIHZhciB0cmFjZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UgKz0gdGhpcy5nZXQoaSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhY2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgTWF0cml4IHZpZXdzXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgdHJhbnNwb3NpdGlvbiBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeFRyYW5zcG9zZVZpZXd9XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc3Bvc2VWaWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXhUcmFuc3Bvc2VWaWV3KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSByb3cgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSByb3cgaW5kZXggb2YgdGhlIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXhSb3dWaWV3fVxuICAgICAgICAgKi9cbiAgICAgICAgcm93Vmlldyhyb3cpIHtcbiAgICAgICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4Um93Vmlldyh0aGlzLCByb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSBjb2x1bW4gdmVjdG9yIHdpdGggdGhlIGdpdmVuIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gLSBjb2x1bW4gaW5kZXggb2YgdGhlIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXhDb2x1bW5WaWV3fVxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uVmlldyhjb2x1bW4pIHtcbiAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4Q29sdW1uVmlldyh0aGlzLCBjb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSBtYXRyaXggZmxpcHBlZCBpbiB0aGUgcm93IGF4aXNcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4RmxpcFJvd1ZpZXd9XG4gICAgICAgICAqL1xuICAgICAgICBmbGlwUm93VmlldygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4RmxpcFJvd1ZpZXcodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHZpZXcgb2YgdGhlIG1hdHJpeCBmbGlwcGVkIGluIHRoZSBjb2x1bW4gYXhpc1xuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXhGbGlwQ29sdW1uVmlld31cbiAgICAgICAgICovXG4gICAgICAgIGZsaXBDb2x1bW5WaWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXhGbGlwQ29sdW1uVmlldyh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgdmlldyBvZiBhIHN1Ym1hdHJpeCBnaXZpbmcgdGhlIGluZGV4IGJvdW5kYXJpZXNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Um93IC0gZmlyc3Qgcm93IGluZGV4IG9mIHRoZSBzdWJtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFJvdyAtIGxhc3Qgcm93IGluZGV4IG9mIHRoZSBzdWJtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Q29sdW1uIC0gZmlyc3QgY29sdW1uIGluZGV4IG9mIHRoZSBzdWJtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZENvbHVtbiAtIGxhc3QgY29sdW1uIGluZGV4IG9mIHRoZSBzdWJtYXRyaXhcbiAgICAgICAgICogQHJldHVybiB7TWF0cml4U3ViVmlld31cbiAgICAgICAgICovXG4gICAgICAgIHN1Yk1hdHJpeFZpZXcoc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXhTdWJWaWV3KHRoaXMsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSBjcm9zcyBvZiB0aGUgcm93IGluZGljZXMgYW5kIHRoZSBjb2x1bW4gaW5kaWNlc1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyByZXN1bHRpbmcgdmVjdG9yIGlzIFtbMl0sIFsyXV1cbiAgICAgICAgICogdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoW1sxLDIsM10sIFs0LDUsNl1dKS5zZWxlY3Rpb25WaWV3KFswLCAwXSwgWzFdKVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHJvd0luZGljZXNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb2x1bW5JbmRpY2VzXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeFNlbGVjdGlvblZpZXd9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25WaWV3KHJvd0luZGljZXMsIGNvbHVtbkluZGljZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4U2VsZWN0aW9uVmlldyh0aGlzLCByb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgcm93IGluZGljZXNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gcmVzdWx0aW5nIHZlY3RvciBpcyBbWzEsMiwzXSwgWzEsMiwzXV1cbiAgICAgICAgICogdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoW1sxLDIsM10sIFs0LDUsNl1dKS5yb3dTZWxlY3Rpb25WaWV3KFswLCAwXSlcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSByb3dJbmRpY2VzXG4gICAgICAgICAqIEByZXR1cm4ge01hdHJpeFJvd1NlbGVjdGlvblZpZXd9XG4gICAgICAgICAqL1xuICAgICAgICByb3dTZWxlY3Rpb25WaWV3KHJvd0luZGljZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4Um93U2VsZWN0aW9uVmlldyh0aGlzLCByb3dJbmRpY2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgY29sdW1uIGluZGljZXNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gcmVzdWx0aW5nIHZlY3RvciBpcyBbWzIsIDJdLCBbNSwgNV1dXG4gICAgICAgICAqIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KFtbMSwyLDNdLCBbNCw1LDZdXSkuY29sdW1uU2VsZWN0aW9uVmlldyhbMSwgMV0pXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29sdW1uSW5kaWNlc1xuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXhDb2x1bW5TZWxlY3Rpb25WaWV3fVxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uU2VsZWN0aW9uVmlldyhjb2x1bW5JbmRpY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeENvbHVtblNlbGVjdGlvblZpZXcodGhpcywgY29sdW1uSW5kaWNlcyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4IGFzIGEgTnVtYmVyXG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKiAgIG5ldyBNYXRyaXgoW1sxLDIsM10sIFs0LDUsNl1dKS5kZXQoKVxuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZGV0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTcXVhcmUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBjLCBkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbnMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMiB4IDIgbWF0cml4XG4gICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLmdldCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuZ2V0KDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5nZXQoMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLmdldCgxLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAqIGQgLSAoYiAqIGMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb2x1bW5zID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDMgeCAzIG1hdHJpeFxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViTWF0cml4MCwgc3ViTWF0cml4MSwgc3ViTWF0cml4MjtcbiAgICAgICAgICAgICAgICAgICAgc3ViTWF0cml4MCA9IHRoaXMuc2VsZWN0aW9uVmlldyhbMSwgMl0sIFsxLCAyXSk7XG4gICAgICAgICAgICAgICAgICAgIHN1Yk1hdHJpeDEgPSB0aGlzLnNlbGVjdGlvblZpZXcoWzEsIDJdLCBbMCwgMl0pO1xuICAgICAgICAgICAgICAgICAgICBzdWJNYXRyaXgyID0gdGhpcy5zZWxlY3Rpb25WaWV3KFsxLCAyXSwgWzAsIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMuZ2V0KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5nZXQoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLmdldCgwLCAyKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAqIHN1Yk1hdHJpeDAuZGV0KCkgLSBiICogc3ViTWF0cml4MS5kZXQoKSArIGMgKiBzdWJNYXRyaXgyLmRldCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBkZXRlcm1pbmFudCB1c2luZyB0aGUgTFUgZGVjb21wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEx1RGVjb21wb3NpdGlvbiQkMSh0aGlzKS5kZXRlcm1pbmFudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0RldGVybWluYW50IGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgZm9yIGEgc3F1YXJlIG1hdHJpeC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGludmVyc2Ugb2YgYSBtYXRyaXggaWYgaXQgZXhpc3RzIG9yIHRoZSBwc2V1ZG9pbnZlcnNlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGQgLSB0aHJlc2hvbGQgZm9yIHRha2luZyBpbnZlcnNlIG9mIHNpbmd1bGFyIHZhbHVlcyAoZGVmYXVsdCA9IDFlLTE1KVxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoZSAocHNldWRvKWludmVydGVkIG1hdHJpeC5cbiAgICAgICAgICovXG4gICAgICAgIHBzZXVkb0ludmVyc2UodGhyZXNob2xkKSB7XG4gICAgICAgICAgICBpZiAodGhyZXNob2xkID09PSB1bmRlZmluZWQpIHRocmVzaG9sZCA9IE51bWJlci5FUFNJTE9OO1xuICAgICAgICAgICAgdmFyIHN2ZFNvbHV0aW9uID0gbmV3IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uJCQxKHRoaXMsIHthdXRvVHJhbnNwb3NlOiB0cnVlfSk7XG5cbiAgICAgICAgICAgIHZhciBVID0gc3ZkU29sdXRpb24ubGVmdFNpbmd1bGFyVmVjdG9ycztcbiAgICAgICAgICAgIHZhciBWID0gc3ZkU29sdXRpb24ucmlnaHRTaW5ndWxhclZlY3RvcnM7XG4gICAgICAgICAgICB2YXIgcyA9IHN2ZFNvbHV0aW9uLmRpYWdvbmFsO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc1tpXSkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc1tpXSA9IDEuMCAvIHNbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc1tpXSA9IDAuMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgbGlzdCB0byBkaWFnb25hbFxuICAgICAgICAgICAgcyA9IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdLmRpYWcocyk7XG4gICAgICAgICAgICByZXR1cm4gVi5tbXVsKHMubW11bChVLnRyYW5zcG9zZVZpZXcoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gZXhhY3QgYW5kIGluZGVwZW5kZW50IGNvcHkgb2YgdGhlIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZSgpIHtcbiAgICAgICAgICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10odGhpcy5yb3dzLCB0aGlzLmNvbHVtbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dzOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IHRoaXMuY29sdW1uczsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0cml4LnNldChyb3csIGNvbHVtbiwgdGhpcy5nZXQocm93LCBjb2x1bW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3TWF0cml4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5rbGFzcyA9ICdNYXRyaXgnO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgU3lub255bXNcbiAgICAgKi9cblxuICAgIE1hdHJpeC5yYW5kb20gPSBNYXRyaXgucmFuZDtcbiAgICBNYXRyaXguZGlhZ29uYWwgPSBNYXRyaXguZGlhZztcbiAgICBNYXRyaXgucHJvdG90eXBlLmRpYWdvbmFsID0gTWF0cml4LnByb3RvdHlwZS5kaWFnO1xuICAgIE1hdHJpeC5pZGVudGl0eSA9IE1hdHJpeC5leWU7XG4gICAgTWF0cml4LnByb3RvdHlwZS5uZWdhdGUgPSBNYXRyaXgucHJvdG90eXBlLm5lZztcbiAgICBNYXRyaXgucHJvdG90eXBlLnRlbnNvclByb2R1Y3QgPSBNYXRyaXgucHJvdG90eXBlLmtyb25lY2tlclByb2R1Y3Q7XG4gICAgTWF0cml4LnByb3RvdHlwZS5kZXRlcm1pbmFudCA9IE1hdHJpeC5wcm90b3R5cGUuZGV0O1xuXG4gICAgLypcbiAgICAgQWRkIGR5bmFtaWNhbGx5IGluc3RhbmNlIGFuZCBzdGF0aWMgbWV0aG9kcyBmb3IgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnNcbiAgICAgKi9cblxuICAgIHZhciBpbnBsYWNlT3BlcmF0b3IgPSBgXG4oZnVuY3Rpb24gJW5hbWUlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLiVuYW1lJVModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLiVuYW1lJU0odmFsdWUpO1xufSlcbmA7XG5cbiAgICB2YXIgaW5wbGFjZU9wZXJhdG9yU2NhbGFyID0gYFxuKGZ1bmN0aW9uICVuYW1lJVModmFsdWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICVvcCUgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSlcbmA7XG5cbiAgICB2YXIgaW5wbGFjZU9wZXJhdG9yTWF0cml4ID0gYFxuKGZ1bmN0aW9uICVuYW1lJU0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gdGhpcy5jb25zdHJ1Y3Rvci5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG4gICAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICVvcCUgbWF0cml4LmdldChpLCBqKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59KVxuYDtcblxuICAgIHZhciBzdGF0aWNPcGVyYXRvciA9IGBcbihmdW5jdGlvbiAlbmFtZSUobWF0cml4LCB2YWx1ZSkge1xuICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpc1tTeW1ib2wuc3BlY2llc10obWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LiVuYW1lJSh2YWx1ZSk7XG59KVxuYDtcblxuICAgIHZhciBpbnBsYWNlTWV0aG9kID0gYFxuKGZ1bmN0aW9uICVuYW1lJSgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGksIGosICVtZXRob2QlKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59KVxuYDtcblxuICAgIHZhciBzdGF0aWNNZXRob2QgPSBgXG4oZnVuY3Rpb24gJW5hbWUlKG1hdHJpeCkge1xuICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpc1tTeW1ib2wuc3BlY2llc10obWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LiVuYW1lJSgpO1xufSlcbmA7XG5cbiAgICB2YXIgaW5wbGFjZU1ldGhvZFdpdGhBcmdzID0gYFxuKGZ1bmN0aW9uICVuYW1lJSglYXJncyUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGksIGosICVtZXRob2QlKHRoaXMuZ2V0KGksIGopLCAlYXJncyUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn0pXG5gO1xuXG4gICAgdmFyIHN0YXRpY01ldGhvZFdpdGhBcmdzID0gYFxuKGZ1bmN0aW9uICVuYW1lJShtYXRyaXgsICVhcmdzJSkge1xuICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpc1tTeW1ib2wuc3BlY2llc10obWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LiVuYW1lJSglYXJncyUpO1xufSlcbmA7XG5cblxuICAgIHZhciBpbnBsYWNlTWV0aG9kV2l0aE9uZUFyZ1NjYWxhciA9IGBcbihmdW5jdGlvbiAlbmFtZSVTKHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLnNldChpLCBqLCAlbWV0aG9kJSh0aGlzLmdldChpLCBqKSwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn0pXG5gO1xuICAgIHZhciBpbnBsYWNlTWV0aG9kV2l0aE9uZUFyZ01hdHJpeCA9IGBcbihmdW5jdGlvbiAlbmFtZSVNKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IHRoaXMuY29uc3RydWN0b3IuY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgICB0aGlzLmNvbHVtbnMgIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLnNldChpLCBqLCAlbWV0aG9kJSh0aGlzLmdldChpLCBqKSwgbWF0cml4LmdldChpLCBqKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSlcbmA7XG5cbiAgICB2YXIgaW5wbGFjZU1ldGhvZFdpdGhPbmVBcmcgPSBgXG4oZnVuY3Rpb24gJW5hbWUlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLiVuYW1lJVModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLiVuYW1lJU0odmFsdWUpO1xufSlcbmA7XG5cbiAgICB2YXIgc3RhdGljTWV0aG9kV2l0aE9uZUFyZyA9IHN0YXRpY01ldGhvZFdpdGhBcmdzO1xuXG4gICAgdmFyIG9wZXJhdG9ycyA9IFtcbiAgICAgICAgLy8gQXJpdGhtZXRpYyBvcGVyYXRvcnNcbiAgICAgICAgWycrJywgJ2FkZCddLFxuICAgICAgICBbJy0nLCAnc3ViJywgJ3N1YnRyYWN0J10sXG4gICAgICAgIFsnKicsICdtdWwnLCAnbXVsdGlwbHknXSxcbiAgICAgICAgWycvJywgJ2RpdicsICdkaXZpZGUnXSxcbiAgICAgICAgWyclJywgJ21vZCcsICdtb2R1bHVzJ10sXG4gICAgICAgIC8vIEJpdHdpc2Ugb3BlcmF0b3JzXG4gICAgICAgIFsnJicsICdhbmQnXSxcbiAgICAgICAgWyd8JywgJ29yJ10sXG4gICAgICAgIFsnXicsICd4b3InXSxcbiAgICAgICAgWyc8PCcsICdsZWZ0U2hpZnQnXSxcbiAgICAgICAgWyc+PicsICdzaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0J10sXG4gICAgICAgIFsnPj4+JywgJ3JpZ2h0U2hpZnQnLCAnemVyb0ZpbGxSaWdodFNoaWZ0J11cbiAgICBdO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIGV2YWwyID0gZXZhbDtcbiAgICBmb3IgKHZhciBvcGVyYXRvciBvZiBvcGVyYXRvcnMpIHtcbiAgICAgICAgdmFyIGlucGxhY2VPcCA9IGV2YWwyKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VPcGVyYXRvciwge25hbWU6IG9wZXJhdG9yWzFdLCBvcDogb3BlcmF0b3JbMF19KSk7XG4gICAgICAgIHZhciBpbnBsYWNlT3BTID0gZXZhbDIoZmlsbFRlbXBsYXRlRnVuY3Rpb24oaW5wbGFjZU9wZXJhdG9yU2NhbGFyLCB7bmFtZTogb3BlcmF0b3JbMV0gKyAnUycsIG9wOiBvcGVyYXRvclswXX0pKTtcbiAgICAgICAgdmFyIGlucGxhY2VPcE0gPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihpbnBsYWNlT3BlcmF0b3JNYXRyaXgsIHtuYW1lOiBvcGVyYXRvclsxXSArICdNJywgb3A6IG9wZXJhdG9yWzBdfSkpO1xuICAgICAgICB2YXIgc3RhdGljT3AgPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihzdGF0aWNPcGVyYXRvciwge25hbWU6IG9wZXJhdG9yWzFdfSkpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgb3BlcmF0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIE1hdHJpeC5wcm90b3R5cGVbb3BlcmF0b3JbaV1dID0gaW5wbGFjZU9wO1xuICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVtvcGVyYXRvcltpXSArICdTJ10gPSBpbnBsYWNlT3BTO1xuICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVtvcGVyYXRvcltpXSArICdNJ10gPSBpbnBsYWNlT3BNO1xuICAgICAgICAgICAgTWF0cml4W29wZXJhdG9yW2ldXSA9IHN0YXRpY09wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1ldGhvZHMgPSBbXG4gICAgICAgIFsnficsICdub3QnXVxuICAgIF07XG5cbiAgICBbXG4gICAgICAgICdhYnMnLCAnYWNvcycsICdhY29zaCcsICdhc2luJywgJ2FzaW5oJywgJ2F0YW4nLCAnYXRhbmgnLCAnY2JydCcsICdjZWlsJyxcbiAgICAgICAgJ2NsejMyJywgJ2NvcycsICdjb3NoJywgJ2V4cCcsICdleHBtMScsICdmbG9vcicsICdmcm91bmQnLCAnbG9nJywgJ2xvZzFwJyxcbiAgICAgICAgJ2xvZzEwJywgJ2xvZzInLCAncm91bmQnLCAnc2lnbicsICdzaW4nLCAnc2luaCcsICdzcXJ0JywgJ3RhbicsICd0YW5oJywgJ3RydW5jJ1xuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAobWF0aE1ldGhvZCkge1xuICAgICAgICBtZXRob2RzLnB1c2goWydNYXRoLicgKyBtYXRoTWV0aG9kLCBtYXRoTWV0aG9kXSk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICB2YXIgaW5wbGFjZU1ldGggPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihpbnBsYWNlTWV0aG9kLCB7bmFtZTogbWV0aG9kWzFdLCBtZXRob2Q6IG1ldGhvZFswXX0pKTtcbiAgICAgICAgdmFyIHN0YXRpY01ldGggPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihzdGF0aWNNZXRob2QsIHtuYW1lOiBtZXRob2RbMV19KSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtZXRob2QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIE1hdHJpeC5wcm90b3R5cGVbbWV0aG9kW2ldXSA9IGlucGxhY2VNZXRoO1xuICAgICAgICAgICAgTWF0cml4W21ldGhvZFtpXV0gPSBzdGF0aWNNZXRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1ldGhvZHNXaXRoQXJncyA9IFtcbiAgICAgICAgWydNYXRoLnBvdycsIDEsICdwb3cnXVxuICAgIF07XG5cbiAgICBmb3IgKHZhciBtZXRob2RXaXRoQXJnIG9mIG1ldGhvZHNXaXRoQXJncykge1xuICAgICAgICB2YXIgYXJncyA9ICdhcmcwJztcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1ldGhvZFdpdGhBcmdbMV07IGkrKykge1xuICAgICAgICAgICAgYXJncyArPSBgLCBhcmcke2l9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kV2l0aEFyZ1sxXSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGlucGxhY2VNZXRoV2l0aEFyZ3MgPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihpbnBsYWNlTWV0aG9kV2l0aEFyZ3MsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtZXRob2RXaXRoQXJnWzJdLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kV2l0aEFyZ1swXSxcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgc3RhdGljTWV0aFdpdGhBcmdzID0gZXZhbDIoZmlsbFRlbXBsYXRlRnVuY3Rpb24oc3RhdGljTWV0aG9kV2l0aEFyZ3MsIHtuYW1lOiBtZXRob2RXaXRoQXJnWzJdLCBhcmdzOiBhcmdzfSkpO1xuICAgICAgICAgICAgZm9yIChpID0gMjsgaSA8IG1ldGhvZFdpdGhBcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBNYXRyaXgucHJvdG90eXBlW21ldGhvZFdpdGhBcmdbaV1dID0gaW5wbGFjZU1ldGhXaXRoQXJncztcbiAgICAgICAgICAgICAgICBNYXRyaXhbbWV0aG9kV2l0aEFyZ1tpXV0gPSBzdGF0aWNNZXRoV2l0aEFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG1wbFZhciA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtZXRob2RXaXRoQXJnWzJdLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RXaXRoQXJnWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGlucGxhY2VNZXRob2QyID0gZXZhbDIoZmlsbFRlbXBsYXRlRnVuY3Rpb24oaW5wbGFjZU1ldGhvZFdpdGhPbmVBcmcsIHRtcGxWYXIpKTtcbiAgICAgICAgICAgIHZhciBpbnBsYWNlTWV0aG9kUyA9IGV2YWwyKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VNZXRob2RXaXRoT25lQXJnU2NhbGFyLCB0bXBsVmFyKSk7XG4gICAgICAgICAgICB2YXIgaW5wbGFjZU1ldGhvZE0gPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihpbnBsYWNlTWV0aG9kV2l0aE9uZUFyZ01hdHJpeCwgdG1wbFZhcikpO1xuICAgICAgICAgICAgdmFyIHN0YXRpY01ldGhvZDIgPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihzdGF0aWNNZXRob2RXaXRoT25lQXJnLCB0bXBsVmFyKSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAyOyBpIDwgbWV0aG9kV2l0aEFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIE1hdHJpeC5wcm90b3R5cGVbbWV0aG9kV2l0aEFyZ1tpXV0gPSBpbnBsYWNlTWV0aG9kMjtcbiAgICAgICAgICAgICAgICBNYXRyaXgucHJvdG90eXBlW21ldGhvZFdpdGhBcmdbaV0gKyAnTSddID0gaW5wbGFjZU1ldGhvZE07XG4gICAgICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVttZXRob2RXaXRoQXJnW2ldICsgJ1MnXSA9IGlucGxhY2VNZXRob2RTO1xuICAgICAgICAgICAgICAgIE1hdHJpeFttZXRob2RXaXRoQXJnW2ldXSA9IHN0YXRpY01ldGhvZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsVGVtcGxhdGVGdW5jdGlvbih0ZW1wbGF0ZSwgdmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIHZhbHVlIGluIHZhbHVlcykge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKG5ldyBSZWdFeHAoJyUnICsgdmFsdWUgKyAnJScsICdnJyksIHZhbHVlc1t2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0cml4O1xufVxuXG5jbGFzcyBNYXRyaXggZXh0ZW5kcyBBYnN0cmFjdE1hdHJpeChBcnJheSkge1xuICAgIGNvbnN0cnVjdG9yKG5Sb3dzLCBuQ29sdW1ucykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG5Sb3dzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShuUm93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdHJpeC5pc01hdHJpeChuUm93cykpIHtcbiAgICAgICAgICAgIHJldHVybiBuUm93cy5jbG9uZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoblJvd3MpICYmIG5Sb3dzID4gMCkgeyAvLyBDcmVhdGUgYW4gZW1wdHkgbWF0cml4XG4gICAgICAgICAgICBzdXBlcihuUm93cyk7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihuQ29sdW1ucykgJiYgbkNvbHVtbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5Sb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IG5ldyBBcnJheShuQ29sdW1ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoblJvd3MpKSB7IC8vIENvcHkgdGhlIHZhbHVlcyBmcm9tIHRoZSAyRCBhcnJheVxuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gblJvd3M7XG4gICAgICAgICAgICBuUm93cyA9IG1hdHJpeC5sZW5ndGg7XG4gICAgICAgICAgICBuQ29sdW1ucyA9IG1hdHJpeFswXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5Db2x1bW5zICE9PSAnbnVtYmVyJyB8fCBuQ29sdW1ucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhIDJEIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyKG5Sb3dzKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuUm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdHJpeFtpXS5sZW5ndGggIT09IG5Db2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gW10uY29uY2F0KG1hdHJpeFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dzID0gblJvd3M7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IG5Db2x1bW5zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgICAgICB0aGlzW3Jvd0luZGV4XVtjb2x1bW5JbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpc1tyb3dJbmRleF1bY29sdW1uSW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSByb3cgZnJvbSB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBSb3cgaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICByZW1vdmVSb3coaW5kZXgpIHtcbiAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLnJvd3MgPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIG1hdHJpeCBjYW5ub3QgaGF2ZSBsZXNzIHRoYW4gb25lIHJvdycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5yb3dzIC09IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByb3cgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleCA9IHRoaXMucm93c10gLSBSb3cgaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gYXJyYXkgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBhZGRSb3coaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIGlmIChhcnJheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcnJheSA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCwgdHJ1ZSk7XG4gICAgICAgIGFycmF5ID0gY2hlY2tSb3dWZWN0b3IodGhpcywgYXJyYXksIHRydWUpO1xuICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMCwgYXJyYXkpO1xuICAgICAgICB0aGlzLnJvd3MgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbHVtbiBmcm9tIHRoZSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIENvbHVtbiBpbmRleFxuICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIHJlbW92ZUNvbHVtbihpbmRleCkge1xuICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1ucyA9PT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0EgbWF0cml4IGNhbm5vdCBoYXZlIGxlc3MgdGhhbiBvbmUgY29sdW1uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgdGhpc1tpXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1ucyAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29sdW1uIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXggPSB0aGlzLmNvbHVtbnNdIC0gQ29sdW1uIGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IGFycmF5IC0gQXJyYXkgb3IgdmVjdG9yXG4gICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG4gICAgICovXG4gICAgYWRkQ29sdW1uKGluZGV4LCBhcnJheSkge1xuICAgICAgICBpZiAodHlwZW9mIGFycmF5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYXJyYXkgPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5jb2x1bW5zO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgsIHRydWUpO1xuICAgICAgICBhcnJheSA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIGFycmF5KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgdGhpc1tpXS5zcGxpY2UoaW5kZXgsIDAsIGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbnMgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jbGFzcyBXcmFwcGVyTWF0cml4MUQgZXh0ZW5kcyBBYnN0cmFjdE1hdHJpeCgpIHtcbiAgICAvKipcbiAgICAgKiBAY2xhc3MgV3JhcHBlck1hdHJpeDFEXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5yb3dzID0gMV1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcm93cyA9IDFcbiAgICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICUgcm93cyAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgZGF0YSBsZW5ndGggaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgbnVtYmVyIG9mIHJvd3MnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBkYXRhLmxlbmd0aCAvIHJvd3M7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fY2FsY3VsYXRlSW5kZXgocm93SW5kZXgsIGNvbHVtbkluZGV4KTtcbiAgICAgICAgdGhpcy5kYXRhW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2NhbGN1bGF0ZUluZGV4KHJvd0luZGV4LCBjb2x1bW5JbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xuICAgIH1cblxuICAgIF9jYWxjdWxhdGVJbmRleChyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gKHJvdyAqIHRoaXMuY29sdW1ucykgKyBjb2x1bW47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgICAgICByZXR1cm4gTWF0cml4O1xuICAgIH1cbn1cblxuY2xhc3MgV3JhcHBlck1hdHJpeDJEIGV4dGVuZHMgQWJzdHJhY3RNYXRyaXgoKSB7XG4gICAgLyoqXG4gICAgICogQGNsYXNzIFdyYXBwZXJNYXRyaXgyRFxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGRhdGFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucm93cyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBkYXRhWzBdLmxlbmd0aDtcbiAgICB9XG5cbiAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFbcm93SW5kZXhdW2NvbHVtbkluZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbcm93SW5kZXhdW2NvbHVtbkluZGV4XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgICAgIHJldHVybiBNYXRyaXg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj58QXJyYXk8bnVtYmVyPn0gYXJyYXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5yb3dzID0gMV1cbiAqIEByZXR1cm4ge1dyYXBwZXJNYXRyaXgxRHxXcmFwcGVyTWF0cml4MkR9XG4gKi9cbmZ1bmN0aW9uIHdyYXAoYXJyYXksIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgaWYgKGFycmF5WzBdICYmIEFycmF5LmlzQXJyYXkoYXJyYXlbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyYXBwZXJNYXRyaXgyRChhcnJheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyYXBwZXJNYXRyaXgxRChhcnJheSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXknKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGNsYXNzIFFyRGVjb21wb3NpdGlvblxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2x1dHpyb2VkZXIvTWFwYWNrL2Jsb2IvbWFzdGVyL1NvdXJjZS9RckRlY29tcG9zaXRpb24uY3NcbiAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZVxuICovXG5jbGFzcyBRckRlY29tcG9zaXRpb24kJDEge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KHZhbHVlKTtcblxuICAgICAgICB2YXIgcXIgPSB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICB2YXIgbSA9IHZhbHVlLnJvd3M7XG4gICAgICAgIHZhciBuID0gdmFsdWUuY29sdW1ucztcbiAgICAgICAgdmFyIHJkaWFnID0gbmV3IEFycmF5KG4pO1xuICAgICAgICB2YXIgaSwgaiwgaywgcztcblxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAgICAgICB2YXIgbnJtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBucm0gPSBoeXBvdGVudXNlKG5ybSwgcXIuZ2V0KGksIGspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChucm0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocXIuZ2V0KGssIGspIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBucm0gPSAtbnJtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHFyLnNldChpLCBrLCBxci5nZXQoaSwgaykgLyBucm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxci5zZXQoaywgaywgcXIuZ2V0KGssIGspICsgMSk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gcXIuZ2V0KGksIGspICogcXIuZ2V0KGksIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHMgPSAtcyAvIHFyLmdldChrLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXIuc2V0KGksIGosIHFyLmdldChpLCBqKSArIHMgKiBxci5nZXQoaSwgaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmRpYWdba10gPSAtbnJtO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5RUiA9IHFyO1xuICAgICAgICB0aGlzLlJkaWFnID0gcmRpYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29sdmUgYSBwcm9ibGVtIG9mIGxlYXN0IHNxdWFyZSAoQXg9YikgYnkgdXNpbmcgdGhlIFFSIGRlY29tcG9zaXRpb24uIFVzZWZ1bCB3aGVuIEEgaXMgcmVjdGFuZ3VsYXIsIGJ1dCBub3Qgd29ya2luZyB3aGVuIEEgaXMgc2luZ3VsYXIuXG4gICAgICogRXhhbXBsZSA6IFdlIHNlYXJjaCB0byBhcHByb3hpbWF0ZSB4LCB3aXRoIEEgbWF0cml4IHNoYXBlIG0qbiwgeCB2ZWN0b3Igc2l6ZSBuLCBiIHZlY3RvciBzaXplIG0gKG0gPiBuKS4gV2Ugd2lsbCB1c2UgOlxuICAgICAqIHZhciBxciA9IFFyRGVjb21wb3NpdGlvbihBKTtcbiAgICAgKiB2YXIgeCA9IHFyLnNvbHZlKGIpO1xuICAgICAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZSAtIE1hdHJpeCAxRCB3aGljaCBpcyB0aGUgdmVjdG9yIGIgKGluIHRoZSBlcXVhdGlvbiBBeCA9IGIpXG4gICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSB2ZWN0b3IgeFxuICAgICAqL1xuICAgIHNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0cml4LmNoZWNrTWF0cml4KHZhbHVlKTtcblxuICAgICAgICB2YXIgcXIgPSB0aGlzLlFSO1xuICAgICAgICB2YXIgbSA9IHFyLnJvd3M7XG5cbiAgICAgICAgaWYgKHZhbHVlLnJvd3MgIT09IG0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IHJvdyBkaW1lbnNpb25zIG11c3QgYWdyZWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNGdWxsUmFuaygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBpcyByYW5rIGRlZmljaWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWUuY29sdW1ucztcbiAgICAgICAgdmFyIFggPSB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICB2YXIgbiA9IHFyLmNvbHVtbnM7XG4gICAgICAgIHZhciBpLCBqLCBrLCBzO1xuXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzICs9IHFyW2ldW2tdICogWFtpXVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyA9IC1zIC8gcXJba11ba107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdICs9IHMgKiBxcltpXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIFhba11bal0gLz0gdGhpcy5SZGlhZ1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdIC09IFhba11bal0gKiBxcltpXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWC5zdWJNYXRyaXgoMCwgbiAtIDEsIDAsIGNvdW50IC0gMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRnVsbFJhbmsoKSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5RUi5jb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuUmRpYWdbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG4gICAgICovXG4gICAgZ2V0IHVwcGVyVHJpYW5ndWxhck1hdHJpeCgpIHtcbiAgICAgICAgdmFyIHFyID0gdGhpcy5RUjtcbiAgICAgICAgdmFyIG4gPSBxci5jb2x1bW5zO1xuICAgICAgICB2YXIgWCA9IG5ldyBNYXRyaXgobiwgbik7XG4gICAgICAgIHZhciBpLCBqO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBqKSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSBxcltpXVtqXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSA9IHRoaXMuUmRpYWdbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBYO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybiB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldCBvcnRob2dvbmFsTWF0cml4KCkge1xuICAgICAgICB2YXIgcXIgPSB0aGlzLlFSO1xuICAgICAgICB2YXIgcm93cyA9IHFyLnJvd3M7XG4gICAgICAgIHZhciBjb2x1bW5zID0gcXIuY29sdW1ucztcbiAgICAgICAgdmFyIFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICB2YXIgaSwgaiwgaywgcztcblxuICAgICAgICBmb3IgKGsgPSBjb2x1bW5zIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBYW2ldW2tdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFhba11ba10gPSAxO1xuICAgICAgICAgICAgZm9yIChqID0gazsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChxcltrXVtrXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBxcltpXVtrXSAqIFhbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzID0gLXMgLyBxcltrXVtrXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBYW2ldW2pdICs9IHMgKiBxcltpXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWDtcbiAgICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGludmVyc2Ugb2YgYSBNYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZVNWRD1mYWxzZV1cbiAqIEByZXR1cm4ge01hdHJpeH1cbiAqL1xuZnVuY3Rpb24gaW52ZXJzZSQkMShtYXRyaXgsIHVzZVNWRCA9IGZhbHNlKSB7XG4gICAgbWF0cml4ID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHVzZVNWRCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uJCQxKG1hdHJpeCkuaW52ZXJzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzb2x2ZSQkMShtYXRyaXgsIE1hdHJpeC5leWUobWF0cml4LnJvd3MpKTtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7TWF0cml4fSBsZWZ0SGFuZFNpZGVcbiAqIEBwYXJhbSB7TWF0cml4fSByaWdodEhhbmRTaWRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VTVkQgPSBmYWxzZV1cbiAqIEByZXR1cm4ge01hdHJpeH1cbiAqL1xuZnVuY3Rpb24gc29sdmUkJDEobGVmdEhhbmRTaWRlLCByaWdodEhhbmRTaWRlLCB1c2VTVkQgPSBmYWxzZSkge1xuICAgIGxlZnRIYW5kU2lkZSA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeChsZWZ0SGFuZFNpZGUpO1xuICAgIHJpZ2h0SGFuZFNpZGUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgocmlnaHRIYW5kU2lkZSk7XG4gICAgaWYgKHVzZVNWRCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uJCQxKGxlZnRIYW5kU2lkZSkuc29sdmUocmlnaHRIYW5kU2lkZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxlZnRIYW5kU2lkZS5pc1NxdWFyZSgpID8gbmV3IEx1RGVjb21wb3NpdGlvbiQkMShsZWZ0SGFuZFNpZGUpLnNvbHZlKHJpZ2h0SGFuZFNpZGUpIDogbmV3IFFyRGVjb21wb3NpdGlvbiQkMShsZWZ0SGFuZFNpZGUpLnNvbHZlKHJpZ2h0SGFuZFNpZGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgRWlnZW52YWx1ZURlY29tcG9zaXRpb25cbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sdXR6cm9lZGVyL01hcGFjay9ibG9iL21hc3Rlci9Tb3VyY2UvRWlnZW52YWx1ZURlY29tcG9zaXRpb24uY3NcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXNzdW1lU3ltbWV0cmljPWZhbHNlXVxuICovXG5jbGFzcyBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbiQkMSB7XG4gICAgY29uc3RydWN0b3IobWF0cml4LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYXNzdW1lU3ltbWV0cmljID0gZmFsc2VcbiAgICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgbWF0cml4ID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIGlmICghbWF0cml4LmlzU3F1YXJlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGlzIG5vdCBhIHNxdWFyZSBtYXRyaXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gbWF0cml4LmNvbHVtbnM7XG4gICAgICAgIHZhciBWID0gZ2V0RmlsbGVkMkRBcnJheShuLCBuLCAwKTtcbiAgICAgICAgdmFyIGQgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIHZhciBlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICB2YXIgdmFsdWUgPSBtYXRyaXg7XG4gICAgICAgIHZhciBpLCBqO1xuXG4gICAgICAgIHZhciBpc1N5bW1ldHJpYyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXNzdW1lU3ltbWV0cmljKSB7XG4gICAgICAgICAgICBpc1N5bW1ldHJpYyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc1N5bW1ldHJpYyA9IG1hdHJpeC5pc1N5bW1ldHJpYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU3ltbWV0cmljKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBWW2ldW2pdID0gdmFsdWUuZ2V0KGksIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyZWQyKG4sIGUsIGQsIFYpO1xuICAgICAgICAgICAgdHFsMihuLCBlLCBkLCBWKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBIID0gZ2V0RmlsbGVkMkRBcnJheShuLCBuLCAwKTtcbiAgICAgICAgICAgIHZhciBvcnQgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBIW2ldW2pdID0gdmFsdWUuZ2V0KGksIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ydGhlcyhuLCBILCBvcnQsIFYpO1xuICAgICAgICAgICAgaHFyMihuLCBlLCBkLCBWLCBIKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubiA9IG47XG4gICAgICAgIHRoaXMuZSA9IGU7XG4gICAgICAgIHRoaXMuZCA9IGQ7XG4gICAgICAgIHRoaXMuViA9IFY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIGdldCByZWFsRWlnZW52YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIGdldCBpbWFnaW5hcnlFaWdlbnZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgKi9cbiAgICBnZXQgZWlnZW52ZWN0b3JNYXRyaXgoKSB7XG4gICAgICAgIGlmICghTWF0cml4LmlzTWF0cml4KHRoaXMuVikpIHtcbiAgICAgICAgICAgIHRoaXMuViA9IG5ldyBNYXRyaXgodGhpcy5WKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5WO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybiB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldCBkaWFnb25hbE1hdHJpeCgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLm47XG4gICAgICAgIHZhciBlID0gdGhpcy5lO1xuICAgICAgICB2YXIgZCA9IHRoaXMuZDtcbiAgICAgICAgdmFyIFggPSBuZXcgTWF0cml4KG4sIG4pO1xuICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgIFhbaV1bal0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgWFtpXVtpXSA9IGRbaV07XG4gICAgICAgICAgICBpZiAoZVtpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBYW2ldW2kgKyAxXSA9IGVbaV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVbaV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgWFtpXVtpIC0gMV0gPSBlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBYO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJlZDIobiwgZSwgZCwgVikge1xuICAgIHZhciBmLCBnLCBoLCBpLCBqLCBrLFxuICAgICAgICBoaCwgc2NhbGU7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGRbal0gPSBWW24gLSAxXVtqXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBuIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBzY2FsZSA9IDA7XG4gICAgICAgIGggPSAwO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlICsgTWF0aC5hYnMoZFtrXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NhbGUgPT09IDApIHtcbiAgICAgICAgICAgIGVbaV0gPSBkW2kgLSAxXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBkW2pdID0gVltpIC0gMV1bal07XG4gICAgICAgICAgICAgICAgVltpXVtqXSA9IDA7XG4gICAgICAgICAgICAgICAgVltqXVtpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG4gICAgICAgICAgICAgICAgZFtrXSAvPSBzY2FsZTtcbiAgICAgICAgICAgICAgICBoICs9IGRba10gKiBkW2tdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmID0gZFtpIC0gMV07XG4gICAgICAgICAgICBnID0gTWF0aC5zcXJ0KGgpO1xuICAgICAgICAgICAgaWYgKGYgPiAwKSB7XG4gICAgICAgICAgICAgICAgZyA9IC1nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlW2ldID0gc2NhbGUgKiBnO1xuICAgICAgICAgICAgaCA9IGggLSBmICogZztcbiAgICAgICAgICAgIGRbaSAtIDFdID0gZiAtIGc7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgZVtqXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmID0gZFtqXTtcbiAgICAgICAgICAgICAgICBWW2pdW2ldID0gZjtcbiAgICAgICAgICAgICAgICBnID0gZVtqXSArIFZbal1bal0gKiBmO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IGogKyAxOyBrIDw9IGkgLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZyArPSBWW2tdW2pdICogZFtrXTtcbiAgICAgICAgICAgICAgICAgICAgZVtrXSArPSBWW2tdW2pdICogZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZVtqXSA9IGc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGYgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgIGVbal0gLz0gaDtcbiAgICAgICAgICAgICAgICBmICs9IGVbal0gKiBkW2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoaCA9IGYgLyAoaCArIGgpO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgIGVbal0gLT0gaGggKiBkW2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgZiA9IGRbal07XG4gICAgICAgICAgICAgICAgZyA9IGVbal07XG4gICAgICAgICAgICAgICAgZm9yIChrID0gajsgayA8PSBpIC0gMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIFZba11bal0gLT0gKGYgKiBlW2tdICsgZyAqIGRba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkW2pdID0gVltpIC0gMV1bal07XG4gICAgICAgICAgICAgICAgVltpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZFtpXSA9IGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgVltuIC0gMV1baV0gPSBWW2ldW2ldO1xuICAgICAgICBWW2ldW2ldID0gMTtcbiAgICAgICAgaCA9IGRbaSArIDFdO1xuICAgICAgICBpZiAoaCAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8PSBpOyBrKyspIHtcbiAgICAgICAgICAgICAgICBkW2tdID0gVltrXVtpICsgMV0gLyBoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgICAgICAgICAgIGcgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGcgKz0gVltrXVtpICsgMV0gKiBWW2tdW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDw9IGk7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBWW2tdW2pdIC09IGcgKiBkW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoayA9IDA7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgICBWW2tdW2kgKyAxXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGRbal0gPSBWW24gLSAxXVtqXTtcbiAgICAgICAgVltuIC0gMV1bal0gPSAwO1xuICAgIH1cblxuICAgIFZbbiAtIDFdW24gLSAxXSA9IDE7XG4gICAgZVswXSA9IDA7XG59XG5cbmZ1bmN0aW9uIHRxbDIobiwgZSwgZCwgVikge1xuXG4gICAgdmFyIGcsIGgsIGksIGosIGssIGwsIG0sIHAsIHIsXG4gICAgICAgIGRsMSwgYywgYzIsIGMzLCBlbDEsIHMsIHMyLFxuICAgICAgICBpdGVyO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBlW2kgLSAxXSA9IGVbaV07XG4gICAgfVxuXG4gICAgZVtuIC0gMV0gPSAwO1xuXG4gICAgdmFyIGYgPSAwO1xuICAgIHZhciB0c3QxID0gMDtcbiAgICB2YXIgZXBzID0gTnVtYmVyLkVQU0lMT047XG5cbiAgICBmb3IgKGwgPSAwOyBsIDwgbjsgbCsrKSB7XG4gICAgICAgIHRzdDEgPSBNYXRoLm1heCh0c3QxLCBNYXRoLmFicyhkW2xdKSArIE1hdGguYWJzKGVbbF0pKTtcbiAgICAgICAgbSA9IGw7XG4gICAgICAgIHdoaWxlIChtIDwgbikge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVbbV0pIDw9IGVwcyAqIHRzdDEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID4gbCkge1xuICAgICAgICAgICAgaXRlciA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaXRlciA9IGl0ZXIgKyAxO1xuXG4gICAgICAgICAgICAgICAgZyA9IGRbbF07XG4gICAgICAgICAgICAgICAgcCA9IChkW2wgKyAxXSAtIGcpIC8gKDIgKiBlW2xdKTtcbiAgICAgICAgICAgICAgICByID0gaHlwb3RlbnVzZShwLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAocCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IC1yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRbbF0gPSBlW2xdIC8gKHAgKyByKTtcbiAgICAgICAgICAgICAgICBkW2wgKyAxXSA9IGVbbF0gKiAocCArIHIpO1xuICAgICAgICAgICAgICAgIGRsMSA9IGRbbCArIDFdO1xuICAgICAgICAgICAgICAgIGggPSBnIC0gZFtsXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsICsgMjsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkW2ldIC09IGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZiA9IGYgKyBoO1xuXG4gICAgICAgICAgICAgICAgcCA9IGRbbV07XG4gICAgICAgICAgICAgICAgYyA9IDE7XG4gICAgICAgICAgICAgICAgYzIgPSBjO1xuICAgICAgICAgICAgICAgIGMzID0gYztcbiAgICAgICAgICAgICAgICBlbDEgPSBlW2wgKyAxXTtcbiAgICAgICAgICAgICAgICBzID0gMDtcbiAgICAgICAgICAgICAgICBzMiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gbSAtIDE7IGkgPj0gbDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGMzID0gYzI7XG4gICAgICAgICAgICAgICAgICAgIGMyID0gYztcbiAgICAgICAgICAgICAgICAgICAgczIgPSBzO1xuICAgICAgICAgICAgICAgICAgICBnID0gYyAqIGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGggPSBjICogcDtcbiAgICAgICAgICAgICAgICAgICAgciA9IGh5cG90ZW51c2UocCwgZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGVbaSArIDFdID0gcyAqIHI7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBlW2ldIC8gcjtcbiAgICAgICAgICAgICAgICAgICAgYyA9IHAgLyByO1xuICAgICAgICAgICAgICAgICAgICBwID0gYyAqIGRbaV0gLSBzICogZztcbiAgICAgICAgICAgICAgICAgICAgZFtpICsgMV0gPSBoICsgcyAqIChjICogZyArIHMgKiBkW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gVltrXVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBWW2tdW2kgKyAxXSA9IHMgKiBWW2tdW2ldICsgYyAqIGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBWW2tdW2ldID0gYyAqIFZba11baV0gLSBzICogaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAgPSAtcyAqIHMyICogYzMgKiBlbDEgKiBlW2xdIC8gZGwxO1xuICAgICAgICAgICAgICAgIGVbbF0gPSBzICogcDtcbiAgICAgICAgICAgICAgICBkW2xdID0gYyAqIHA7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChNYXRoLmFicyhlW2xdKSA+IGVwcyAqIHRzdDEpO1xuICAgICAgICB9XG4gICAgICAgIGRbbF0gPSBkW2xdICsgZjtcbiAgICAgICAgZVtsXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgayA9IGk7XG4gICAgICAgIHAgPSBkW2ldO1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgaWYgKGRbal0gPCBwKSB7XG4gICAgICAgICAgICAgICAgayA9IGo7XG4gICAgICAgICAgICAgICAgcCA9IGRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoayAhPT0gaSkge1xuICAgICAgICAgICAgZFtrXSA9IGRbaV07XG4gICAgICAgICAgICBkW2ldID0gcDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwID0gVltqXVtpXTtcbiAgICAgICAgICAgICAgICBWW2pdW2ldID0gVltqXVtrXTtcbiAgICAgICAgICAgICAgICBWW2pdW2tdID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gb3J0aGVzKG4sIEgsIG9ydCwgVikge1xuXG4gICAgdmFyIGxvdyA9IDA7XG4gICAgdmFyIGhpZ2ggPSBuIC0gMTtcbiAgICB2YXIgZiwgZywgaCwgaSwgaiwgbTtcbiAgICB2YXIgc2NhbGU7XG5cbiAgICBmb3IgKG0gPSBsb3cgKyAxOyBtIDw9IGhpZ2ggLSAxOyBtKyspIHtcbiAgICAgICAgc2NhbGUgPSAwO1xuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSArIE1hdGguYWJzKEhbaV1bbSAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2FsZSAhPT0gMCkge1xuICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSBoaWdoOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgICAgIG9ydFtpXSA9IEhbaV1bbSAtIDFdIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgaCArPSBvcnRbaV0gKiBvcnRbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGcgPSBNYXRoLnNxcnQoaCk7XG4gICAgICAgICAgICBpZiAob3J0W21dID4gMCkge1xuICAgICAgICAgICAgICAgIGcgPSAtZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaCA9IGggLSBvcnRbbV0gKiBnO1xuICAgICAgICAgICAgb3J0W21dID0gb3J0W21dIC0gZztcblxuICAgICAgICAgICAgZm9yIChqID0gbTsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgIGYgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGhpZ2g7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgKz0gb3J0W2ldICogSFtpXVtqXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmID0gZiAvIGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gbTsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgSFtpXVtqXSAtPSBmICogb3J0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBoaWdoOyBqID49IG07IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBmICs9IG9ydFtqXSAqIEhbaV1bal07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZiA9IGYgLyBoO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IG07IGogPD0gaGlnaDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIEhbaV1bal0gLT0gZiAqIG9ydFtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9ydFttXSA9IHNjYWxlICogb3J0W21dO1xuICAgICAgICAgICAgSFttXVttIC0gMV0gPSBzY2FsZSAqIGc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgIFZbaV1bal0gPSAoaSA9PT0gaiA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobSA9IGhpZ2ggLSAxOyBtID49IGxvdyArIDE7IG0tLSkge1xuICAgICAgICBpZiAoSFttXVttIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IG0gKyAxOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgICAgIG9ydFtpXSA9IEhbaV1bbSAtIDFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSBtOyBqIDw9IGhpZ2g7IGorKykge1xuICAgICAgICAgICAgICAgIGcgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IG07IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGcgKz0gb3J0W2ldICogVltpXVtqXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnID0gKGcgLyBvcnRbbV0pIC8gSFttXVttIC0gMV07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gbTsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgVltpXVtqXSArPSBnICogb3J0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaHFyMihubiwgZSwgZCwgViwgSCkge1xuICAgIHZhciBuID0gbm4gLSAxO1xuICAgIHZhciBsb3cgPSAwO1xuICAgIHZhciBoaWdoID0gbm4gLSAxO1xuICAgIHZhciBlcHMgPSBOdW1iZXIuRVBTSUxPTjtcbiAgICB2YXIgZXhzaGlmdCA9IDA7XG4gICAgdmFyIG5vcm0gPSAwO1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgcSA9IDA7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBzID0gMDtcbiAgICB2YXIgeiA9IDA7XG4gICAgdmFyIGl0ZXIgPSAwO1xuICAgIHZhciBpLCBqLCBrLCBsLCBtLCB0LCB3LCB4LCB5O1xuICAgIHZhciByYSwgc2EsIHZyLCB2aTtcbiAgICB2YXIgbm90bGFzdCwgY2RpdnJlcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBubjsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgbG93IHx8IGkgPiBoaWdoKSB7XG4gICAgICAgICAgICBkW2ldID0gSFtpXVtpXTtcbiAgICAgICAgICAgIGVbaV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gTWF0aC5tYXgoaSAtIDEsIDApOyBqIDwgbm47IGorKykge1xuICAgICAgICAgICAgbm9ybSA9IG5vcm0gKyBNYXRoLmFicyhIW2ldW2pdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChuID49IGxvdykge1xuICAgICAgICBsID0gbjtcbiAgICAgICAgd2hpbGUgKGwgPiBsb3cpIHtcbiAgICAgICAgICAgIHMgPSBNYXRoLmFicyhIW2wgLSAxXVtsIC0gMV0pICsgTWF0aC5hYnMoSFtsXVtsXSk7XG4gICAgICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHMgPSBub3JtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKEhbbF1bbCAtIDFdKSA8IGVwcyAqIHMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGwtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsID09PSBuKSB7XG4gICAgICAgICAgICBIW25dW25dID0gSFtuXVtuXSArIGV4c2hpZnQ7XG4gICAgICAgICAgICBkW25dID0gSFtuXVtuXTtcbiAgICAgICAgICAgIGVbbl0gPSAwO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgaXRlciA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PT0gbiAtIDEpIHtcbiAgICAgICAgICAgIHcgPSBIW25dW24gLSAxXSAqIEhbbiAtIDFdW25dO1xuICAgICAgICAgICAgcCA9IChIW24gLSAxXVtuIC0gMV0gLSBIW25dW25dKSAvIDI7XG4gICAgICAgICAgICBxID0gcCAqIHAgKyB3O1xuICAgICAgICAgICAgeiA9IE1hdGguc3FydChNYXRoLmFicyhxKSk7XG4gICAgICAgICAgICBIW25dW25dID0gSFtuXVtuXSArIGV4c2hpZnQ7XG4gICAgICAgICAgICBIW24gLSAxXVtuIC0gMV0gPSBIW24gLSAxXVtuIC0gMV0gKyBleHNoaWZ0O1xuICAgICAgICAgICAgeCA9IEhbbl1bbl07XG5cbiAgICAgICAgICAgIGlmIChxID49IDApIHtcbiAgICAgICAgICAgICAgICB6ID0gKHAgPj0gMCkgPyAocCArIHopIDogKHAgLSB6KTtcbiAgICAgICAgICAgICAgICBkW24gLSAxXSA9IHggKyB6O1xuICAgICAgICAgICAgICAgIGRbbl0gPSBkW24gLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoeiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkW25dID0geCAtIHcgLyB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlW24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgZVtuXSA9IDA7XG4gICAgICAgICAgICAgICAgeCA9IEhbbl1bbiAtIDFdO1xuICAgICAgICAgICAgICAgIHMgPSBNYXRoLmFicyh4KSArIE1hdGguYWJzKHopO1xuICAgICAgICAgICAgICAgIHAgPSB4IC8gcztcbiAgICAgICAgICAgICAgICBxID0geiAvIHM7XG4gICAgICAgICAgICAgICAgciA9IE1hdGguc3FydChwICogcCArIHEgKiBxKTtcbiAgICAgICAgICAgICAgICBwID0gcCAvIHI7XG4gICAgICAgICAgICAgICAgcSA9IHEgLyByO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gbiAtIDE7IGogPCBubjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHogPSBIW24gLSAxXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgSFtuIC0gMV1bal0gPSBxICogeiArIHAgKiBIW25dW2pdO1xuICAgICAgICAgICAgICAgICAgICBIW25dW2pdID0gcSAqIEhbbl1bal0gLSBwICogejtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ID0gSFtpXVtuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIEhbaV1bbiAtIDFdID0gcSAqIHogKyBwICogSFtpXVtuXTtcbiAgICAgICAgICAgICAgICAgICAgSFtpXVtuXSA9IHEgKiBIW2ldW25dIC0gcCAqIHo7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ID0gVltpXVtuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIFZbaV1bbiAtIDFdID0gcSAqIHogKyBwICogVltpXVtuXTtcbiAgICAgICAgICAgICAgICAgICAgVltpXVtuXSA9IHEgKiBWW2ldW25dIC0gcCAqIHo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkW24gLSAxXSA9IHggKyBwO1xuICAgICAgICAgICAgICAgIGRbbl0gPSB4ICsgcDtcbiAgICAgICAgICAgICAgICBlW24gLSAxXSA9IHo7XG4gICAgICAgICAgICAgICAgZVtuXSA9IC16O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuID0gbiAtIDI7XG4gICAgICAgICAgICBpdGVyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSBIW25dW25dO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB3ID0gMDtcbiAgICAgICAgICAgIGlmIChsIDwgbikge1xuICAgICAgICAgICAgICAgIHkgPSBIW24gLSAxXVtuIC0gMV07XG4gICAgICAgICAgICAgICAgdyA9IEhbbl1bbiAtIDFdICogSFtuIC0gMV1bbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpdGVyID09PSAxMCkge1xuICAgICAgICAgICAgICAgIGV4c2hpZnQgKz0geDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIEhbaV1baV0gLT0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyA9IE1hdGguYWJzKEhbbl1bbiAtIDFdKSArIE1hdGguYWJzKEhbbiAtIDFdW24gLSAyXSk7XG4gICAgICAgICAgICAgICAgeCA9IHkgPSAwLjc1ICogcztcbiAgICAgICAgICAgICAgICB3ID0gLTAuNDM3NSAqIHMgKiBzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXRlciA9PT0gMzApIHtcbiAgICAgICAgICAgICAgICBzID0gKHkgLSB4KSAvIDI7XG4gICAgICAgICAgICAgICAgcyA9IHMgKiBzICsgdztcbiAgICAgICAgICAgICAgICBpZiAocyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IE1hdGguc3FydChzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gLXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcyA9IHggLSB3IC8gKCh5IC0geCkgLyAyICsgcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGxvdzsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1baV0gLT0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHNoaWZ0ICs9IHM7XG4gICAgICAgICAgICAgICAgICAgIHggPSB5ID0gdyA9IDAuOTY0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlciA9IGl0ZXIgKyAxO1xuXG4gICAgICAgICAgICBtID0gbiAtIDI7XG4gICAgICAgICAgICB3aGlsZSAobSA+PSBsKSB7XG4gICAgICAgICAgICAgICAgeiA9IEhbbV1bbV07XG4gICAgICAgICAgICAgICAgciA9IHggLSB6O1xuICAgICAgICAgICAgICAgIHMgPSB5IC0gejtcbiAgICAgICAgICAgICAgICBwID0gKHIgKiBzIC0gdykgLyBIW20gKyAxXVttXSArIEhbbV1bbSArIDFdO1xuICAgICAgICAgICAgICAgIHEgPSBIW20gKyAxXVttICsgMV0gLSB6IC0gciAtIHM7XG4gICAgICAgICAgICAgICAgciA9IEhbbSArIDJdW20gKyAxXTtcbiAgICAgICAgICAgICAgICBzID0gTWF0aC5hYnMocCkgKyBNYXRoLmFicyhxKSArIE1hdGguYWJzKHIpO1xuICAgICAgICAgICAgICAgIHAgPSBwIC8gcztcbiAgICAgICAgICAgICAgICBxID0gcSAvIHM7XG4gICAgICAgICAgICAgICAgciA9IHIgLyBzO1xuICAgICAgICAgICAgICAgIGlmIChtID09PSBsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoSFttXVttIC0gMV0pICogKE1hdGguYWJzKHEpICsgTWF0aC5hYnMocikpIDwgZXBzICogKE1hdGguYWJzKHApICogKE1hdGguYWJzKEhbbSAtIDFdW20gLSAxXSkgKyBNYXRoLmFicyh6KSArIE1hdGguYWJzKEhbbSArIDFdW20gKyAxXSkpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbS0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSBtICsgMjsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBIW2ldW2kgLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBtICsgMikge1xuICAgICAgICAgICAgICAgICAgICBIW2ldW2kgLSAzXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGsgPSBtOyBrIDw9IG4gLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICBub3RsYXN0ID0gKGsgIT09IG4gLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0gbSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gSFtrXVtrIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHEgPSBIW2sgKyAxXVtrIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHIgPSAobm90bGFzdCA/IEhbayArIDJdW2sgLSAxXSA6IDApO1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5hYnMocCkgKyBNYXRoLmFicyhxKSArIE1hdGguYWJzKHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAgLyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHEgLyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHIgLyB4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcyA9IE1hdGguc3FydChwICogcCArIHEgKiBxICsgciAqIHIpO1xuICAgICAgICAgICAgICAgIGlmIChwIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzID0gLXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhba11bayAtIDFdID0gLXMgKiB4O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGwgIT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhba11bayAtIDFdID0gLUhba11bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcCA9IHAgKyBzO1xuICAgICAgICAgICAgICAgICAgICB4ID0gcCAvIHM7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBxIC8gcztcbiAgICAgICAgICAgICAgICAgICAgeiA9IHIgLyBzO1xuICAgICAgICAgICAgICAgICAgICBxID0gcSAvIHA7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByIC8gcDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBrOyBqIDwgbm47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IEhba11bal0gKyBxICogSFtrICsgMV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90bGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwICsgciAqIEhbayArIDJdW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhbayArIDJdW2pdID0gSFtrICsgMl1bal0gLSBwICogejtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgSFtrXVtqXSA9IEhba11bal0gLSBwICogeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhbayArIDFdW2pdID0gSFtrICsgMV1bal0gLSBwICogeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gTWF0aC5taW4obiwgayArIDMpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB4ICogSFtpXVtrXSArIHkgKiBIW2ldW2sgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAgKyB6ICogSFtpXVtrICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtrICsgMl0gPSBIW2ldW2sgKyAyXSAtIHAgKiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBIW2ldW2tdID0gSFtpXVtrXSAtIHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBIW2ldW2sgKyAxXSA9IEhbaV1bayArIDFdIC0gcCAqIHE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0geCAqIFZbaV1ba10gKyB5ICogVltpXVtrICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90bGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwICsgeiAqIFZbaV1bayArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bayArIDJdID0gVltpXVtrICsgMl0gLSBwICogcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtrXSA9IFZbaV1ba10gLSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtrICsgMV0gPSBWW2ldW2sgKyAxXSAtIHAgKiBxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vcm0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobiA9IG5uIC0gMTsgbiA+PSAwOyBuLS0pIHtcbiAgICAgICAgcCA9IGRbbl07XG4gICAgICAgIHEgPSBlW25dO1xuXG4gICAgICAgIGlmIChxID09PSAwKSB7XG4gICAgICAgICAgICBsID0gbjtcbiAgICAgICAgICAgIEhbbl1bbl0gPSAxO1xuICAgICAgICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdyA9IEhbaV1baV0gLSBwO1xuICAgICAgICAgICAgICAgIHIgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGw7IGogPD0gbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByICsgSFtpXVtqXSAqIEhbal1bbl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVbaV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHogPSB3O1xuICAgICAgICAgICAgICAgICAgICBzID0gcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bbl0gPSAodyAhPT0gMCkgPyAoLXIgLyB3KSA6ICgtciAvIChlcHMgKiBub3JtKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gSFtpXVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gSFtpICsgMV1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gKGRbaV0gLSBwKSAqIChkW2ldIC0gcCkgKyBlW2ldICogZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoeCAqIHMgLSB6ICogcikgLyBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtuXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBIW2kgKyAxXVtuXSA9IChNYXRoLmFicyh4KSA+IE1hdGguYWJzKHopKSA/ICgoLXIgLSB3ICogdCkgLyB4KSA6ICgoLXMgLSB5ICogdCkgLyB6KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHQgPSBNYXRoLmFicyhIW2ldW25dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlcHMgKiB0KSAqIHQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IG47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhbal1bbl0gPSBIW2pdW25dIC8gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChxIDwgMCkge1xuICAgICAgICAgICAgbCA9IG4gLSAxO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoSFtuXVtuIC0gMV0pID4gTWF0aC5hYnMoSFtuIC0gMV1bbl0pKSB7XG4gICAgICAgICAgICAgICAgSFtuIC0gMV1bbiAtIDFdID0gcSAvIEhbbl1bbiAtIDFdO1xuICAgICAgICAgICAgICAgIEhbbiAtIDFdW25dID0gLShIW25dW25dIC0gcCkgLyBIW25dW24gLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2RpdnJlcyA9IGNkaXYoMCwgLUhbbiAtIDFdW25dLCBIW24gLSAxXVtuIC0gMV0gLSBwLCBxKTtcbiAgICAgICAgICAgICAgICBIW24gLSAxXVtuIC0gMV0gPSBjZGl2cmVzWzBdO1xuICAgICAgICAgICAgICAgIEhbbiAtIDFdW25dID0gY2RpdnJlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSFtuXVtuIC0gMV0gPSAwO1xuICAgICAgICAgICAgSFtuXVtuXSA9IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICByYSA9IDA7XG4gICAgICAgICAgICAgICAgc2EgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGw7IGogPD0gbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhID0gcmEgKyBIW2ldW2pdICogSFtqXVtuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHNhID0gc2EgKyBIW2ldW2pdICogSFtqXVtuXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3ID0gSFtpXVtpXSAtIHA7XG5cbiAgICAgICAgICAgICAgICBpZiAoZVtpXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHc7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByYTtcbiAgICAgICAgICAgICAgICAgICAgcyA9IHNhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZVtpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2RpdnJlcyA9IGNkaXYoLXJhLCAtc2EsIHcsIHEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtuIC0gMV0gPSBjZGl2cmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtuXSA9IGNkaXZyZXNbMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gSFtpXVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gSFtpICsgMV1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2ciA9IChkW2ldIC0gcCkgKiAoZFtpXSAtIHApICsgZVtpXSAqIGVbaV0gLSBxICogcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpID0gKGRbaV0gLSBwKSAqIDIgKiBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZyID09PSAwICYmIHZpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnIgPSBlcHMgKiBub3JtICogKE1hdGguYWJzKHcpICsgTWF0aC5hYnMocSkgKyBNYXRoLmFicyh4KSArIE1hdGguYWJzKHkpICsgTWF0aC5hYnMoeikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2RpdnJlcyA9IGNkaXYoeCAqIHIgLSB6ICogcmEgKyBxICogc2EsIHggKiBzIC0geiAqIHNhIC0gcSAqIHJhLCB2ciwgdmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtuIC0gMV0gPSBjZGl2cmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtuXSA9IGNkaXZyZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeCkgPiAoTWF0aC5hYnMoeikgKyBNYXRoLmFicyhxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2kgKyAxXVtuIC0gMV0gPSAoLXJhIC0gdyAqIEhbaV1bbiAtIDFdICsgcSAqIEhbaV1bbl0pIC8geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2kgKyAxXVtuXSA9ICgtc2EgLSB3ICogSFtpXVtuXSAtIHEgKiBIW2ldW24gLSAxXSkgLyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZGl2cmVzID0gY2RpdigtciAtIHkgKiBIW2ldW24gLSAxXSwgLXMgLSB5ICogSFtpXVtuXSwgeiwgcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFtpICsgMV1bbiAtIDFdID0gY2RpdnJlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2kgKyAxXVtuXSA9IGNkaXZyZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0ID0gTWF0aC5tYXgoTWF0aC5hYnMoSFtpXVtuIC0gMV0pLCBNYXRoLmFicyhIW2ldW25dKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZXBzICogdCkgKiB0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2pdW24gLSAxXSA9IEhbal1bbiAtIDFdIC8gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2pdW25dID0gSFtqXVtuXSAvIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbm47IGkrKykge1xuICAgICAgICBpZiAoaSA8IGxvdyB8fCBpID4gaGlnaCkge1xuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8IG5uOyBqKyspIHtcbiAgICAgICAgICAgICAgICBWW2ldW2pdID0gSFtpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaiA9IG5uIC0gMTsgaiA+PSBsb3c7IGotLSkge1xuICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgICB6ID0gMDtcbiAgICAgICAgICAgIGZvciAoayA9IGxvdzsgayA8PSBNYXRoLm1pbihqLCBoaWdoKTsgaysrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHogKyBWW2ldW2tdICogSFtrXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZbaV1bal0gPSB6O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjZGl2KHhyLCB4aSwgeXIsIHlpKSB7XG4gICAgdmFyIHIsIGQ7XG4gICAgaWYgKE1hdGguYWJzKHlyKSA+IE1hdGguYWJzKHlpKSkge1xuICAgICAgICByID0geWkgLyB5cjtcbiAgICAgICAgZCA9IHlyICsgciAqIHlpO1xuICAgICAgICByZXR1cm4gWyh4ciArIHIgKiB4aSkgLyBkLCAoeGkgLSByICogeHIpIC8gZF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHlyIC8geWk7XG4gICAgICAgIGQgPSB5aSArIHIgKiB5cjtcbiAgICAgICAgcmV0dXJuIFsociAqIHhyICsgeGkpIC8gZCwgKHIgKiB4aSAtIHhyKSAvIGRdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgQ2hvbGVza3lEZWNvbXBvc2l0aW9uXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vbHV0enJvZWRlci9NYXBhY2svYmxvYi9tYXN0ZXIvU291cmNlL0Nob2xlc2t5RGVjb21wb3NpdGlvbi5jc1xuICogQHBhcmFtIHtNYXRyaXh9IHZhbHVlXG4gKi9cbmNsYXNzIENob2xlc2t5RGVjb21wb3NpdGlvbiQkMSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgodmFsdWUpO1xuICAgICAgICBpZiAoIXZhbHVlLmlzU3ltbWV0cmljKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGlzIG5vdCBzeW1tZXRyaWMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhID0gdmFsdWU7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBhLnJvd3M7XG4gICAgICAgIHZhciBsID0gbmV3IE1hdHJpeChkaW1lbnNpb24sIGRpbWVuc2lvbik7XG4gICAgICAgIHZhciBwb3NpdGl2ZURlZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgdmFyIGksIGosIGs7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgTHJvd2ogPSBsW2pdO1xuICAgICAgICAgICAgdmFyIGQgPSAwO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGo7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBMcm93ayA9IGxba107XG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcyArPSBMcm93a1tpXSAqIExyb3dqW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBMcm93altrXSA9IHMgPSAoYS5nZXQoaiwgaykgLSBzKSAvIGxba11ba107XG4gICAgICAgICAgICAgICAgZCA9IGQgKyBzICogcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZCA9IGEuZ2V0KGosIGopIC0gZDtcblxuICAgICAgICAgICAgcG9zaXRpdmVEZWZpbml0ZSAmPSAoZCA+IDApO1xuICAgICAgICAgICAgbFtqXVtqXSA9IE1hdGguc3FydChNYXRoLm1heChkLCAwKSk7XG4gICAgICAgICAgICBmb3IgKGsgPSBqICsgMTsgayA8IGRpbWVuc2lvbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgbFtqXVtrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBvc2l0aXZlRGVmaW5pdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGlzIG5vdCBwb3NpdGl2ZSBkZWZpbml0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5MID0gbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgKi9cbiAgICBzb2x2ZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGwgPSB0aGlzLkw7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBsLnJvd3M7XG5cbiAgICAgICAgaWYgKHZhbHVlLnJvd3MgIT09IGRpbWVuc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggZGltZW5zaW9ucyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlLmNvbHVtbnM7XG4gICAgICAgIHZhciBCID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgdmFyIGksIGosIGs7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGRpbWVuc2lvbjsgaysrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgQltrXVtqXSAtPSBCW2ldW2pdICogbFtrXVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQltrXVtqXSAvPSBsW2tdW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrID0gZGltZW5zaW9uIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBkaW1lbnNpb247IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBCW2tdW2pdIC09IEJbaV1bal0gKiBsW2ldW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBCW2tdW2pdIC89IGxba11ba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01hdHJpeH1cbiAgICAgKi9cbiAgICBnZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5MO1xuICAgIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gTWF0cml4O1xuZXhwb3J0cy5NYXRyaXggPSBNYXRyaXg7XG5leHBvcnRzLmFic3RyYWN0TWF0cml4ID0gQWJzdHJhY3RNYXRyaXg7XG5leHBvcnRzLndyYXAgPSB3cmFwO1xuZXhwb3J0cy5XcmFwcGVyTWF0cml4MkQgPSBXcmFwcGVyTWF0cml4MkQ7XG5leHBvcnRzLldyYXBwZXJNYXRyaXgxRCA9IFdyYXBwZXJNYXRyaXgxRDtcbmV4cG9ydHMuc29sdmUgPSBzb2x2ZSQkMTtcbmV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2UkJDE7XG5leHBvcnRzLlNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uID0gU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24kJDE7XG5leHBvcnRzLlNWRCA9IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uJCQxO1xuZXhwb3J0cy5FaWdlbnZhbHVlRGVjb21wb3NpdGlvbiA9IEVpZ2VudmFsdWVEZWNvbXBvc2l0aW9uJCQxO1xuZXhwb3J0cy5FVkQgPSBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbiQkMTtcbmV4cG9ydHMuQ2hvbGVza3lEZWNvbXBvc2l0aW9uID0gQ2hvbGVza3lEZWNvbXBvc2l0aW9uJCQxO1xuZXhwb3J0cy5DSE8gPSBDaG9sZXNreURlY29tcG9zaXRpb24kJDE7XG5leHBvcnRzLkx1RGVjb21wb3NpdGlvbiA9IEx1RGVjb21wb3NpdGlvbiQkMTtcbmV4cG9ydHMuTFUgPSBMdURlY29tcG9zaXRpb24kJDE7XG5leHBvcnRzLlFyRGVjb21wb3NpdGlvbiA9IFFyRGVjb21wb3NpdGlvbiQkMTtcbmV4cG9ydHMuUVIgPSBRckRlY29tcG9zaXRpb24kJDE7XG5cbn0se1wibWwtYXJyYXktcmVzY2FsZVwiOjEyOX1dLDEzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQnKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHNpemU6IDEsXG4gICAgdmFsdWU6IDBcbn07XG5cbi8qKlxuICogQ2FzZSB3aGVuIHRoZSBlbnRyeSBpcyBhbiBhcnJheVxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q2FzZShkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJylcbiAgICAgICAgb3B0aW9ucy5zaXplID0gW29wdGlvbnMuc2l6ZSwgb3B0aW9ucy5zaXplXTtcblxuICAgIHZhciBjb25kID0gbGVuICsgb3B0aW9ucy5zaXplWzBdICsgb3B0aW9ucy5zaXplWzFdO1xuXG4gICAgdmFyIG91dHB1dDtcbiAgICBpZiAob3B0aW9ucy5vdXRwdXQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0Lmxlbmd0aCAhPT0gY29uZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdXcm9uZyBvdXRwdXQgc2l6ZScpO1xuICAgICAgICBvdXRwdXQgPSBvcHRpb25zLm91dHB1dDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkoY29uZCk7XG5cbiAgICB2YXIgaTtcblxuICAgIC8vIGNpcmN1bGFyIG9wdGlvblxuICAgIGlmIChvcHRpb25zLnZhbHVlID09PSAnY2lyY3VsYXInKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25kOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgb3B0aW9ucy5zaXplWzBdKVxuICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IGRhdGFbKChsZW4gLSAob3B0aW9ucy5zaXplWzBdICUgbGVuKSkgKyBpKSAlIGxlbl07XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgKG9wdGlvbnMuc2l6ZVswXSArIGxlbikpXG4gICAgICAgICAgICAgICAgb3V0cHV0W2ldID0gZGF0YVtpIC0gb3B0aW9ucy5zaXplWzBdXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBkYXRhWyhpIC0gb3B0aW9ucy5zaXplWzBdKSAlIGxlbl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXBsaWNhdGUgb3B0aW9uXG4gICAgZWxzZSBpZiAob3B0aW9ucy52YWx1ZSA9PT0gJ3JlcGxpY2F0ZScpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCBvcHRpb25zLnNpemVbMF0pXG4gICAgICAgICAgICAgICAgb3V0cHV0W2ldID0gZGF0YVswXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCAob3B0aW9ucy5zaXplWzBdICsgbGVuKSlcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBkYXRhW2kgLSBvcHRpb25zLnNpemVbMF1dO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IGRhdGFbbGVuIC0gMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzeW1tZXRyaWMgb3B0aW9uXG4gICAgZWxzZSBpZiAob3B0aW9ucy52YWx1ZSA9PT0gJ3N5bW1ldHJpYycpIHtcbiAgICAgICAgaWYgKChvcHRpb25zLnNpemVbMF0gPiBsZW4pIHx8IChvcHRpb25zLnNpemVbMV0gPiBsZW4pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2V4cGFuZGVkIHZhbHVlIHNob3VsZCBub3QgYmUgYmlnZ2VyIHRoYW4gdGhlIGRhdGEgbGVuZ3RoJyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25kOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgb3B0aW9ucy5zaXplWzBdKVxuICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IGRhdGFbb3B0aW9ucy5zaXplWzBdIC0gMSAtIGldO1xuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IChvcHRpb25zLnNpemVbMF0gKyBsZW4pKVxuICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IGRhdGFbaSAtIG9wdGlvbnMuc2l6ZVswXV07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3V0cHV0W2ldID0gZGF0YVsyKmxlbiArIG9wdGlvbnMuc2l6ZVswXSAtIGkgLSAxXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgb3B0aW9uXG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25kOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgb3B0aW9ucy5zaXplWzBdKVxuICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgKG9wdGlvbnMuc2l6ZVswXSArIGxlbikpXG4gICAgICAgICAgICAgICAgb3V0cHV0W2ldID0gZGF0YVtpIC0gb3B0aW9ucy5zaXplWzBdXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDYXNlIHdoZW4gdGhlIGVudHJ5IGlzIGEgbWF0cml4XG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWF0cml4Q2FzZShkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHJvdyA9IGRhdGEubGVuZ3RoO1xuICAgIHZhciBjb2wgPSBkYXRhWzBdLmxlbmd0aDtcbiAgICBpZiAob3B0aW9ucy5zaXplWzBdID09PSB1bmRlZmluZWQpXG4gICAgICAgIG9wdGlvbnMuc2l6ZSA9IFtvcHRpb25zLnNpemUsIG9wdGlvbnMuc2l6ZSwgb3B0aW9ucy5zaXplLCBvcHRpb25zLnNpemVdO1xuICAgIHRocm93IG5ldyBFcnJvcignbWF0cml4IG5vdCBzdXBwb3J0ZWQgeWV0LCBzb3JyeScpO1xufVxuXG4vKipcbiAqIFBhZHMgYW5kIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5IDxudW1iZXI+fSBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwYWRBcnJheSAoZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF0pKVxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeENhc2UoZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBhcnJheUNhc2UoZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBzaG91bGQgYmUgYW4gYXJyYXknKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYWRBcnJheTtcblxufSx7XCJleHRlbmRcIjoxMjZ9XSwxMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0cml4TGliID0gcmVxdWlyZSgnbWwtbWF0cml4Jyk7XG52YXIgTWF0cml4ID0gbWF0cml4TGliLk1hdHJpeDtcbnZhciBpbnZlcnNlID0gbWF0cml4TGliLmludmVyc2U7XG52YXIgcGFkQXJyYXkgPSByZXF1aXJlKCdtbC1wYWQtYXJyYXknKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQnKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHdpbmRvd1NpemU6IDUsXG4gICAgZGVyaXZhdGl2ZTogMSxcbiAgICBwb2x5bm9taWFsOiAyLFxuICAgIHBhZDogJ25vbmUnLFxuICAgIHBhZFZhbHVlOiAncmVwbGljYXRlJ1xufTtcblxuLyoqXG4gKiBTYXZpdHpreS1Hb2xheSBmaWx0ZXJcbiAqIEBwYXJhbSB7QXJyYXkgPG51bWJlcj59IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiBTYXZpdHpreUdvbGF5IChkYXRhLCBoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmICgob3B0aW9ucy53aW5kb3dTaXplICUgMiA9PT0gMCkgfHwgKG9wdGlvbnMud2luZG93U2l6ZSA8IDUpIHx8ICEoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLndpbmRvd1NpemUpKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgd2luZG93IHNpemUgKHNob3VsZCBiZSBvZGQgYW5kIGF0IGxlYXN0IDUgaW50ZWdlciBudW1iZXIpJyk7XG4gICAgaWYgKChvcHRpb25zLmRlcml2YXRpdmUgPCAwKSB8fCAhKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5kZXJpdmF0aXZlKSkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEZXJpdmF0aXZlIHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICBpZiAoKG9wdGlvbnMucG9seW5vbWlhbCA8IDEpIHx8ICEoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLnBvbHlub21pYWwpKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1BvbHlub21pYWwgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgdmFyIEMsIG5vcm07XG4gICAgdmFyIHN0ZXAgPSBNYXRoLmZsb29yKG9wdGlvbnMud2luZG93U2l6ZSAvIDIpO1xuXG4gICAgaWYgKG9wdGlvbnMucGFkID09PSAncHJlJykge1xuICAgICAgICBkYXRhID0gcGFkQXJyYXkoZGF0YSwge3NpemU6IHN0ZXAsIHZhbHVlOiBvcHRpb25zLnBhZFZhbHVlfSk7XG4gICAgfVxuXG4gICAgdmFyIGFucyA9ICBuZXcgQXJyYXkoZGF0YS5sZW5ndGggLSAyKnN0ZXApO1xuXG4gICAgaWYgKChvcHRpb25zLndpbmRvd1NpemUgPT09IDUpICYmIChvcHRpb25zLnBvbHlub21pYWwgPT09IDIpICYmICgob3B0aW9ucy5kZXJpdmF0aXZlID09PSAxKSB8fCAob3B0aW9ucy5kZXJpdmF0aXZlID09PSAyKSkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVyaXZhdGl2ZSA9PT0gMSkge1xuICAgICAgICAgICAgQyA9IFstMiwtMSwwLDEsMl07XG4gICAgICAgICAgICBub3JtID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBDID0gWzIsIC0xLCAtMiwgLTEsIDJdO1xuICAgICAgICAgICAgbm9ybSA9IDc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBKID0gTWF0cml4Lm9uZXMob3B0aW9ucy53aW5kb3dTaXplLCBvcHRpb25zLnBvbHlub21pYWwgKyAxKTtcbiAgICAgICAgdmFyIGluaWMgPSAtKG9wdGlvbnMud2luZG93U2l6ZSAtIDEpIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBKLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IEpbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGluaWMgKyAxICE9PSAwKSB8fCAoaiAhPT0gMCkpXG4gICAgICAgICAgICAgICAgICAgIEpbaV1bal0gPSBNYXRoLnBvdygoaW5pYyArIGkpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgSnRyYW5zcG9zZSA9IEoudHJhbnNwb3NlVmlldygpO1xuICAgICAgICB2YXIgSmludiA9IGludmVyc2UoSnRyYW5zcG9zZS5tbXVsKEopKTtcbiAgICAgICAgQyA9IEppbnYubW11bChKdHJhbnNwb3NlKTtcbiAgICAgICAgQyA9IENbb3B0aW9ucy5kZXJpdmF0aXZlXTtcbiAgICAgICAgbm9ybSA9IDE7XG4gICAgfVxuICAgIHZhciBkZXQgPSBub3JtICogTWF0aC5wb3coaCwgb3B0aW9ucy5kZXJpdmF0aXZlKTtcbiAgICBmb3IgKHZhciBrID0gc3RlcDsgayA8IChkYXRhLmxlbmd0aCAtIHN0ZXApOyBrKyspIHtcbiAgICAgICAgdmFyIGQgPSAwO1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IEMubGVuZ3RoOyBsKyspXG4gICAgICAgICAgICBkICs9IENbbF0gKiBkYXRhW2wgKyBrIC0gc3RlcF0gLyBkZXQ7XG4gICAgICAgIGFuc1trIC0gc3RlcF0gPSBkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBhZCA9PT0gJ3Bvc3QnKSB7XG4gICAgICAgIGFucyA9IHBhZEFycmF5KGFucywge3NpemU6IHN0ZXAsIHZhbHVlOiBvcHRpb25zLnBhZFZhbHVlfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFucztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTYXZpdHpreUdvbGF5O1xuXG59LHtcImV4dGVuZFwiOjEyNixcIm1sLW1hdHJpeFwiOjEzMCxcIm1sLXBhZC1hcnJheVwiOjEzMX1dLDEzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNpbmsgPSBleHBvcnRzLnNvdXJjZSA9IGV4cG9ydHMudXRpbHMgPSBleHBvcnRzLm9wZXJhdG9yID0gZXhwb3J0cy5jb3JlID0gZXhwb3J0cy52ZXJzaW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX25hbWVzcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9vcGVyYXRvci9fbmFtZXNwYWNlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnb3BlcmF0b3InLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9uYW1lc3BhY2UpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX25hbWVzcGFjZTIgPSByZXF1aXJlKCcuL3V0aWxzL19uYW1lc3BhY2UnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1dGlscycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25hbWVzcGFjZTIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX25hbWVzcGFjZTMgPSByZXF1aXJlKCcuL3NvdXJjZS9fbmFtZXNwYWNlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc291cmNlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbmFtZXNwYWNlMykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfbmFtZXNwYWNlNCA9IHJlcXVpcmUoJy4vc2luay9fbmFtZXNwYWNlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2luaycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25hbWVzcGFjZTQpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2NvcmUyID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgX2NvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdmVyc2lvbiA9IGV4cG9ydHMudmVyc2lvbiA9ICcxLjEuNic7XG5cbnZhciBjb3JlID0gZXhwb3J0cy5jb3JlID0gX2NvcmU7XG5cbn0se1wiLi4vY29tbW9uL29wZXJhdG9yL19uYW1lc3BhY2VcIjoxNzQsXCIuLi9jb3JlXCI6MTg0LFwiLi9zaW5rL19uYW1lc3BhY2VcIjoxNDQsXCIuL3NvdXJjZS9fbmFtZXNwYWNlXCI6MTQ4LFwiLi91dGlscy9fbmFtZXNwYWNlXCI6MTUwfV0sMTM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZURpc3BsYXkyID0gcmVxdWlyZSgnLi9CYXNlRGlzcGxheScpO1xuXG52YXIgX0Jhc2VEaXNwbGF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VEaXNwbGF5Mik7XG5cbnZhciBfRmZ0ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL29wZXJhdG9yL0ZmdCcpO1xuXG52YXIgX0ZmdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GZnQpO1xuXG52YXIgX2Rpc3BsYXlVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2Rpc3BsYXktdXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBzY2FsZToge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBjb2xvcnM6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiAoMCwgX2Rpc3BsYXlVdGlscy5nZXRDb2xvcnMpKCdiYXItY2hhcnQnKSxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBtaW46IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgbWF4OiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH1cbn07XG5cbi8qKlxuICogRGlzcGxheSBhIGJhciBjaGFydCBmcm9tIGFuIGluY29tbWluZyBgdmVjdG9yYCBpbnB1dC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNsaWVudC5zaW5rXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29sb3JzPW51bGxdIC0gQ29sb3JzIG9mIHRoZSBiYXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbj0tODBdIC0gTWluaW11bSBkaXNwbGF5ZWQgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4PTZdIC0gTWF4aW11bSBkaXNwbGF5ZWQgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MzAwXSAtIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD0xNTBdIC0gSGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtFbGVtZW50fENTU1NlbGVjdG9yfSBbb3B0aW9ucy5jb250YWluZXI9bnVsbF0gLSBDb250YWluZXIgZWxlbWVudFxuICogIGluIHdoaWNoIHRvIGluc2VydCB0aGUgY2FudmFzLiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtFbGVtZW50fENTU1NlbGVjdG9yfSBbb3B0aW9ucy5jYW52YXM9bnVsbF0gLSBDYW52YXMgZWxlbWVudFxuICogIGluIHdoaWNoIHRvIGRyYXcuIF9jb25zdGFudCBwYXJhbWV0ZXJfXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAqXG4gKiBjb25zdCBmcmFtZVNpemUgPSA1O1xuICogY29uc3QgZHQgPSAwLjAyO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHtcbiAqICAgZnJhbWVTaXplOiBmcmFtZVNpemUsXG4gKiAgIGZyYW1lUmF0ZTogMSAvIGR0LFxuICogICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICogfSk7XG4gKlxuICogY29uc3QgYmFyQ2hhcnQgPSBuZXcgbGZvLnNpbmsuQmFyQ2hhcnREaXNwbGF5KHtcbiAqICAgY2FudmFzOiAnI2Jhci1jaGFydCcsXG4gKiB9KTtcbiAqXG4gKiBldmVudEluLmNvbm5lY3QoYmFyQ2hhcnQpO1xuICogZXZlbnRJbi5zdGFydCgpO1xuICpcbiAqIGNvbnN0IGRhdGEgPSBbMCwgMC4yLCAwLjQsIDAuNiwgMC44XTtcbiAqXG4gKiAoZnVuY3Rpb24gZ2VuZXJhdGVEYXRhKCkge1xuICogICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKVxuICogICAgIGRhdGFbaV0gPSAoZGF0YVtpXSArIDAuMDAxKSAlIDE7XG4gKlxuICogICBldmVudEluLnByb2Nlc3MobnVsbCwgZGF0YSk7XG4gKlxuICogICBzZXRUaW1lb3V0KGdlbmVyYXRlRGF0YSwgZHQgKiAxMDAwKTtcbiAqIH0oKSk7XG4gKi9cblxudmFyIEJhckNoYXJ0RGlzcGxheSA9IGZ1bmN0aW9uIChfQmFzZURpc3BsYXkpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQmFyQ2hhcnREaXNwbGF5LCBfQmFzZURpc3BsYXkpO1xuXG4gIGZ1bmN0aW9uIEJhckNoYXJ0RGlzcGxheSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQmFyQ2hhcnREaXNwbGF5KTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoQmFyQ2hhcnREaXNwbGF5Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShCYXJDaGFydERpc3BsYXkpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zLCBmYWxzZSkpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShCYXJDaGFydERpc3BsYXksIFt7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1ZlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmNhbnZhc1dpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgICAgdmFyIGNvbG9ycyA9IHRoaXMucGFyYW1zLmdldCgnY29sb3JzJyk7XG4gICAgICB2YXIgZGF0YSA9IGZyYW1lLmRhdGE7XG5cbiAgICAgIHZhciBiYXJXaWR0aCA9IHdpZHRoIC8gZnJhbWVTaXplO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgICAvLyBlcnJvciBoYW5kbGluZyBuZWVkcyByZXZpZXcuLi5cbiAgICAgIHZhciBlcnJvciA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspIHtcbiAgICAgICAgdmFyIHgxRmxvYXQgPSBpICogYmFyV2lkdGggKyBlcnJvcjtcbiAgICAgICAgdmFyIHgxSW50ID0gTWF0aC5yb3VuZCh4MUZsb2F0KTtcbiAgICAgICAgdmFyIHgyRmxvYXQgPSB4MUZsb2F0ICsgKGJhcldpZHRoIC0gZXJyb3IpO1xuICAgICAgICB2YXIgeDJJbnQgPSBNYXRoLnJvdW5kKHgyRmxvYXQpO1xuXG4gICAgICAgIGVycm9yID0geDJJbnQgLSB4MkZsb2F0O1xuXG4gICAgICAgIGlmICh4MUludCAhPT0geDJJbnQpIHtcbiAgICAgICAgICB2YXIgX3dpZHRoID0geDJJbnQgLSB4MUludDtcbiAgICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0WVBvc2l0aW9uKGRhdGFbaV0pO1xuXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yc1tpICUgY29sb3JzLmxlbmd0aF07XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHgxSW50LCB5LCBfd2lkdGgsIGhlaWdodCAtIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yIC09IGJhcldpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCYXJDaGFydERpc3BsYXk7XG59KF9CYXNlRGlzcGxheTMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJhckNoYXJ0RGlzcGxheTtcblxufSx7XCIuLi8uLi9jb21tb24vb3BlcmF0b3IvRmZ0XCI6MTU2LFwiLi4vdXRpbHMvZGlzcGxheS11dGlsc1wiOjE1MSxcIi4vQmFzZURpc3BsYXlcIjoxMzUsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduJyk7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9nZXQyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldCcpO1xuXG52YXIgX2dldDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXQyKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VMZm8yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjb21tb25EZWZpbml0aW9ucyA9IHtcbiAgbWluOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAtMSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBtYXg6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgd2lkdGg6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogMzAwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIGhlaWdodDoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAxNTAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgY29udGFpbmVyOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBjb25zdGFudDogdHJ1ZVxuICB9LFxuICBjYW52YXM6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH1cbn07XG5cbnZhciBoYXNEdXJhdGlvbkRlZmluaXRpb25zID0ge1xuICBkdXJhdGlvbjoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgbWluOiAwLFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgcmVmZXJlbmNlVGltZToge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMCxcbiAgICBjb25zdGFudDogdHJ1ZVxuICB9XG59O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gZXh0ZW5kIGluIG9yZGVyIHRvIGNyZWF0ZSBncmFwaGljIHNpbmtzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9UaGlzIGNsYXNzIHNob3VsZCBiZSBjb25zaWRlcmVkIGFic3RyYWN0IGFuZCBvbmx5XG4gKiBiZSB1c2VkIHRvIGJlIGV4dGVuZGVkLl88L3NwYW4+XG4gKlxuICogQHRvZG8gLSBmaXggZmxvYXQgcm91bmRpbmcgZXJyb3JzIChwcm9kdWNlIGRlY2F5cyBpbiBzeW5jIGRyYXdzKVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y2xpZW50LnNpbmtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW49LTFdIC0gTWluaW11bSB2YWx1ZSByZXByZXNlbnRlZCBpbiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXg9MV0gLSBNYXhpbXVtIHZhbHVlIHJlcHJlc2VudGVkIGluIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTMwMF0gLSBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTUwXSAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY29udGFpbmVyPW51bGxdIC0gQ29udGFpbmVyIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy4gX2NvbnN0YW50IHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY2FudmFzPW51bGxdIC0gQ2FudmFzIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBkcmF3LiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTFdIC0gRHVyYXRpb24gKGluIHNlY29uZHMpIHJlcHJlc2VudGVkIGluXG4gKiAgdGhlIGNhbnZhcy4gVGhpcyBwYXJhbWV0ZXIgb25seSBleGlzdHMgZm9yIG9wZXJhdG9ycyB0aGF0IGRpc3BsYXkgc2V2ZXJhbFxuICogIGNvbnNlY3V0aXZlIGZyYW1lcyBvbiB0aGUgY2FudmFzLiBfZHluYW1pYyBwYXJhbWV0ZXJfXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVmZXJlbmNlVGltZT1udWxsXSAtIE9wdGlvbm5hbCByZWZlcmVuY2UgdGltZSB0aGVcbiAqICBkaXNwbGF5IHNob3VsZCBjb25zaWRlcmVyIGFzIHRoZSBvcmlnaW4uIElzIG9ubHkgdXNlZnVsbCB3aGVuIHN5bmNocm9uaXppbmdcbiAqICBzZXZlcmFsIGRpc3BsYXkgdXNpbmcgdGhlIGBEaXNwbGF5U3luY2AgY2xhc3MuIFRoaXMgcGFyYW1ldGVyIG9ubHkgZXhpc3RzXG4gKiAgZm9yIG9wZXJhdG9ycyB0aGF0IGRpc3BsYXkgc2V2ZXJhbCBjb25zZWN1dGl2ZSBmcmFtZXMgb24gdGhlIGNhbnZhcy5cbiAqL1xuXG52YXIgQmFzZURpc3BsYXkgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQmFzZURpc3BsYXksIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBCYXNlRGlzcGxheShkZWZzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBoYXNEdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBCYXNlRGlzcGxheSk7XG5cbiAgICB2YXIgY29tbW9uRGVmcyA9IHZvaWQgMDtcblxuICAgIGlmIChoYXNEdXJhdGlvbikgY29tbW9uRGVmcyA9ICgwLCBfYXNzaWduMi5kZWZhdWx0KSh7fSwgY29tbW9uRGVmaW5pdGlvbnMsIGhhc0R1cmF0aW9uRGVmaW5pdGlvbnMpO2Vsc2UgY29tbW9uRGVmcyA9IGNvbW1vbkRlZmluaXRpb25zO1xuXG4gICAgdmFyIGRlZmluaXRpb25zID0gKDAsIF9hc3NpZ24yLmRlZmF1bHQpKHt9LCBjb21tb25EZWZzLCBkZWZzKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKEJhc2VEaXNwbGF5Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShCYXNlRGlzcGxheSkpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcblxuICAgIGlmIChfdGhpcy5wYXJhbXMuZ2V0KCdjYW52YXMnKSA9PT0gbnVsbCAmJiBfdGhpcy5wYXJhbXMuZ2V0KCdjb250YWluZXInKSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogYGNhbnZhc2Agb3IgYGNvbnRhaW5lcmAgbm90IGRlZmluZWQnKTtcblxuICAgIHZhciBjYW52YXNQYXJhbSA9IF90aGlzLnBhcmFtcy5nZXQoJ2NhbnZhcycpO1xuICAgIHZhciBjb250YWluZXJQYXJhbSA9IF90aGlzLnBhcmFtcy5nZXQoJ2NvbnRhaW5lcicpO1xuXG4gICAgLy8gcHJlcGFyZSBjYW52YXNcbiAgICBpZiAoY2FudmFzUGFyYW0pIHtcbiAgICAgIGlmICh0eXBlb2YgY2FudmFzUGFyYW0gPT09ICdzdHJpbmcnKSBfdGhpcy5jYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNhbnZhc1BhcmFtKTtlbHNlIF90aGlzLmNhbnZhcyA9IGNhbnZhc1BhcmFtO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbmVyUGFyYW0pIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB2b2lkIDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyUGFyYW0gPT09ICdzdHJpbmcnKSBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lclBhcmFtKTtlbHNlIGNvbnRhaW5lciA9IGNvbnRhaW5lclBhcmFtO1xuXG4gICAgICBfdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChfdGhpcy5jYW52YXMpO1xuICAgIH1cblxuICAgIF90aGlzLmN0eCA9IF90aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF90aGlzLmNhY2hlZENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF90aGlzLmNhY2hlZEN0eCA9IF90aGlzLmNhY2hlZENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgX3RoaXMuaGFzRHVyYXRpb24gPSBoYXNEdXJhdGlvbjtcbiAgICBfdGhpcy5wcmV2aW91c0ZyYW1lID0gbnVsbDtcbiAgICBfdGhpcy5jdXJyZW50VGltZSA9IGhhc0R1cmF0aW9uID8gX3RoaXMucGFyYW1zLmdldCgncmVmZXJlbmNlVGltZScpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbmNlIG9mIHRoZSBgRGlzcGxheVN5bmNgIHVzZWQgdG8gc3luY2hyb25pemUgdGhlIGRpZmZlcmVudCBkaXNwbGF5c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuZGlzcGxheVN5bmMgPSBmYWxzZTtcblxuICAgIF90aGlzLl9zdGFjayA9IFtdO1xuICAgIF90aGlzLl9yYWZJZCA9IG51bGw7XG5cbiAgICBfdGhpcy5yZW5kZXJTdGFjayA9IF90aGlzLnJlbmRlclN0YWNrLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLnNoaWZ0RXJyb3IgPSAwO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjYW52YXMgc2l6ZSBhbmQgeSBzY2FsZSB0cmFuc2ZlcnQgZnVuY3Rpb25cbiAgICBfdGhpcy5fcmVzaXplKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShCYXNlRGlzcGxheSwgW3tcbiAgICBrZXk6ICdfcmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZSgpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMucGFyYW1zLmdldCgnd2lkdGgnKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnBhcmFtcy5nZXQoJ2hlaWdodCcpO1xuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgY2FjaGVkQ3R4ID0gdGhpcy5jYWNoZWRDdHg7XG5cbiAgICAgIHZhciBkUFIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgdmFyIGJQUiA9IGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IGRQUiAvIGJQUjtcblxuICAgICAgdmFyIGxhc3RXaWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgICB2YXIgbGFzdEhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgICAgdGhpcy5jYW52YXNXaWR0aCA9IHdpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgdGhpcy5jYW52YXNIZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAgIGNhY2hlZEN0eC5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhc1dpZHRoO1xuICAgICAgY2FjaGVkQ3R4LmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhc0hlaWdodDtcblxuICAgICAgLy8gY29weSBjdXJyZW50IGltYWdlIGZyb20gY3R4IChyZXNpemUpXG4gICAgICBpZiAobGFzdFdpZHRoICYmIGxhc3RIZWlnaHQpIHtcbiAgICAgICAgY2FjaGVkQ3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCAwLCAwLCBsYXN0V2lkdGgsIGxhc3RIZWlnaHQsIDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgICBjdHguY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgICAgY3R4LmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGN0eC5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgLy8gdXBkYXRlIHNjYWxlXG4gICAgICB0aGlzLl9zZXRZU2NhbGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHRyYW5zZmVydCBmdW5jdGlvbiB1c2VkIHRvIG1hcCB2YWx1ZXMgdG8gcGl4ZWwgaW4gdGhlIHkgYXhpc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zZXRZU2NhbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0WVNjYWxlKCkge1xuICAgICAgdmFyIG1pbiA9IHRoaXMucGFyYW1zLmdldCgnbWluJyk7XG4gICAgICB2YXIgbWF4ID0gdGhpcy5wYXJhbXMuZ2V0KCdtYXgnKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhbnZhc0hlaWdodDtcblxuICAgICAgdmFyIGEgPSAoMCAtIGhlaWdodCkgLyAobWF4IC0gbWluKTtcbiAgICAgIHZhciBiID0gaGVpZ2h0IC0gYSAqIG1pbjtcblxuICAgICAgdGhpcy5nZXRZUG9zaXRpb24gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gYSAqIHggKyBiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBpbiBwaXhlbCBhIGB2ZWN0b3JgIGZyYW1lIG5lZWRzIHRvIGJlIGRyYXduLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE1pbmltdW1GcmFtZVdpZHRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWluaW11bUZyYW1lV2lkdGgoKSB7XG4gICAgICByZXR1cm4gMTsgLy8gbmVlZCBvbmUgcGl4ZWwgdG8gZHJhdyB0aGUgbGluZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gYSBwYXJhbWV0ZXIgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gUGFyYW1ldGVyIG5hbWUuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBQYXJhbWV0ZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFzIC0gTWV0YWRhdGFzIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25QYXJhbVVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoQmFzZURpc3BsYXkucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShCYXNlRGlzcGxheS5wcm90b3R5cGUpLCAnb25QYXJhbVVwZGF0ZScsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgLy8gQHRvZG8gLSBtYWtlIHN1cmUgdGhhdCBtaW4gYW5kIG1heCBhcmUgZGlmZmVyZW50XG4gICAgICAgICAgdGhpcy5fc2V0WVNjYWxlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICB0aGlzLl9yZXNpemUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvcGFnYXRlU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcGFnYXRlU3RyZWFtUGFyYW1zKCkge1xuICAgICAgKDAsIF9nZXQzLmRlZmF1bHQpKEJhc2VEaXNwbGF5LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoQmFzZURpc3BsYXkucHJvdG90eXBlKSwgJ3Byb3BhZ2F0ZVN0cmVhbVBhcmFtcycsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0U3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTdHJlYW0oKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoQmFzZURpc3BsYXkucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShCYXNlRGlzcGxheS5wcm90b3R5cGUpLCAncmVzZXRTdHJlYW0nLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmNhbnZhc1dpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuXG4gICAgICB0aGlzLnByZXZpb3VzRnJhbWUgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHRoaXMuaGFzRHVyYXRpb24gPyB0aGlzLnBhcmFtcy5nZXQoJ3JlZmVyZW5jZVRpbWUnKSA6IG51bGw7XG5cbiAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FjaGVkQ3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluYWxpemVTdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZVN0cmVhbShlbmRUaW1lKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gbnVsbDtcbiAgICAgICgwLCBfZ2V0My5kZWZhdWx0KShCYXNlRGlzcGxheS5wcm90b3R5cGUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEJhc2VEaXNwbGF5LnByb3RvdHlwZSksICdmaW5hbGl6ZVN0cmVhbScsIHRoaXMpLmNhbGwodGhpcywgZW5kVGltZSk7XG5cbiAgICAgIHRoaXMuX3JhZklkID0gbnVsbDtcblxuICAgICAgLy8gY2xlYXIgdGhlIHN0YWNrIGlmIG5vdCBlbXB0eVxuICAgICAgaWYgKHRoaXMuX3N0YWNrLmxlbmd0aCA+IDApIHRoaXMucmVuZGVyU3RhY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGN1cnJlbnQgZnJhbWUgdG8gdGhlIGZyYW1lcyB0byBkcmF3LiBTaG91bGQgbm90IGJlIG92ZXJyaWRlbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzRnJhbWUoZnJhbWUpIHtcbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB2YXIgY29weSA9IG5ldyBGbG9hdDMyQXJyYXkoZnJhbWVTaXplKTtcbiAgICAgIHZhciBkYXRhID0gZnJhbWUuZGF0YTtcblxuICAgICAgLy8gY29weSB2YWx1ZXMgb2YgdGhlIGlucHV0IGZyYW1lIGFzIHRoZXkgbWlnaHQgYmUgdXBkYXRlZFxuICAgICAgLy8gaW4gcmVmZXJlbmNlIGJlZm9yZSBiZWluZyBjb25zdW1lZCBpbiB0aGUgZHJhdyBmdW5jdGlvblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgICBjb3B5W2ldID0gZGF0YVtpXTtcbiAgICAgIH10aGlzLl9zdGFjay5wdXNoKHtcbiAgICAgICAgdGltZTogZnJhbWUudGltZSxcbiAgICAgICAgZGF0YTogY29weSxcbiAgICAgICAgbWV0YWRhdGE6IGZyYW1lLm1ldGFkYXRhXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3JhZklkID09PSBudWxsKSB0aGlzLl9yYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJTdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBhY2N1bXVsYXRlZCBmcmFtZXMuIE1ldGhvZCBjYWxsZWQgaW4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyU3RhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTdGFjaygpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5oYXMoJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgLy8gcmVuZGVyIGFsbCBmcmFtZSBzaW5jZSBsYXN0IGByZW5kZXJTdGFja2AgY2FsbFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2Nyb2xsTW9kZURyYXcodGhpcy5fc3RhY2tbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbmx5IHJlbmRlciBsYXN0IHJlY2VpdmVkIGZyYW1lIGlmIGFueVxuICAgICAgICBpZiAodGhpcy5fc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodCk7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzRnVuY3Rpb24oZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0YWNrLmxlbmd0aCA9IDA7IC8vIHJlaW5pdCBzdGFjayBmb3IgbmV4dCBjYWxsXG4gICAgICB0aGlzLl9yYWZJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBkYXRhIGZyb20gcmlnaHQgdG8gbGVmdCB3aXRoIHNjcm9sbGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHRvZG8gLSBjaGVjayBwb3NzaWJpbGl0eSBvZiBtYWludGFpbmluZyBhbGwgdmFsdWVzIGZyb20gb25lIHBsYWNlIHRvXG4gICAgICogICAgICAgICBtaW5pbWl6ZSBmbG9hdCBlcnJvciB0cmFja2luZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2Nyb2xsTW9kZURyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxNb2RlRHJhdyhmcmFtZSkge1xuICAgICAgdmFyIGZyYW1lVHlwZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZTtcbiAgICAgIHZhciBmcmFtZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGU7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIHNvdXJjZVNhbXBsZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlO1xuXG4gICAgICB2YXIgY2FudmFzRHVyYXRpb24gPSB0aGlzLnBhcmFtcy5nZXQoJ2R1cmF0aW9uJyk7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLmNhbnZhc1dpZHRoO1xuICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuXG4gICAgICB2YXIgcHJldmlvdXNGcmFtZSA9IHRoaXMucHJldmlvdXNGcmFtZTtcblxuICAgICAgLy8gY3VycmVudCB0aW1lIGF0IHRoZSBsZWZ0IG9mIHRoZSBjYW52YXNcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMuY3VycmVudFRpbWUgIT09IG51bGwgPyB0aGlzLmN1cnJlbnRUaW1lIDogZnJhbWUudGltZTtcbiAgICAgIHZhciBmcmFtZVN0YXJ0VGltZSA9IGZyYW1lLnRpbWU7XG4gICAgICB2YXIgbGFzdEZyYW1lVGltZSA9IHByZXZpb3VzRnJhbWUgPyBwcmV2aW91c0ZyYW1lLnRpbWUgOiAwO1xuICAgICAgdmFyIGxhc3RGcmFtZUR1cmF0aW9uID0gdGhpcy5sYXN0RnJhbWVEdXJhdGlvbiA/IHRoaXMubGFzdEZyYW1lRHVyYXRpb24gOiAwO1xuXG4gICAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IHZvaWQgMDtcblxuICAgICAgaWYgKGZyYW1lVHlwZSA9PT0gJ3NjYWxhcicgfHwgZnJhbWVUeXBlID09PSAndmVjdG9yJykge1xuICAgICAgICB2YXIgcGl4ZWxEdXJhdGlvbiA9IGNhbnZhc0R1cmF0aW9uIC8gY2FudmFzV2lkdGg7XG4gICAgICAgIGZyYW1lRHVyYXRpb24gPSB0aGlzLmdldE1pbmltdW1GcmFtZVdpZHRoKCkgKiBwaXhlbER1cmF0aW9uO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVR5cGUgPT09ICdzaWduYWwnKSB7XG4gICAgICAgIGZyYW1lRHVyYXRpb24gPSBmcmFtZVNpemUgLyBzb3VyY2VTYW1wbGVSYXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJhbWVFbmRUaW1lID0gZnJhbWVTdGFydFRpbWUgKyBmcmFtZUR1cmF0aW9uO1xuICAgICAgLy8gZGVmaW5lIGlmIHdlIG5lZWQgdG8gc2hpZnQgdGhlIGNhbnZhc1xuICAgICAgdmFyIHNoaWZ0VGltZSA9IGZyYW1lRW5kVGltZSAtIGN1cnJlbnRUaW1lO1xuXG4gICAgICAvLyBpZiB0aGUgY2FudmFzIGlzIG5vdCBzeW5jZWQsIHNob3VsZCBuZXZlciBnbyB0byBgZWxzZWBcbiAgICAgIGlmIChzaGlmdFRpbWUgPiAwKSB7XG4gICAgICAgIC8vIHNoaWZ0IHRoZSBjYW52YXMgb2Ygc2hpZnRUaW1lIGluIHBpeGVsc1xuICAgICAgICB2YXIgZlNoaWZ0ID0gc2hpZnRUaW1lIC8gY2FudmFzRHVyYXRpb24gKiBjYW52YXNXaWR0aCAtIHRoaXMuc2hpZnRFcnJvcjtcbiAgICAgICAgdmFyIGlTaGlmdCA9IE1hdGguZmxvb3IoZlNoaWZ0ICsgMC41KTtcbiAgICAgICAgdGhpcy5zaGlmdEVycm9yID0gZlNoaWZ0IC0gaVNoaWZ0O1xuXG4gICAgICAgIHZhciBfY3VycmVudFRpbWUgPSBmcmFtZVN0YXJ0VGltZSArIGZyYW1lRHVyYXRpb247XG4gICAgICAgIHRoaXMuc2hpZnRDYW52YXMoaVNoaWZ0LCBfY3VycmVudFRpbWUpO1xuXG4gICAgICAgIC8vIGlmIHNpYmxpbmdzLCBzaGFyZSB0aGUgaW5mb3JtYXRpb25cbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheVN5bmMpIHRoaXMuZGlzcGxheVN5bmMuc2hpZnRTaWJsaW5ncyhpU2hpZnQsIF9jdXJyZW50VGltZSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdpZHRoIG9mIHRoZSBmcmFtZSBpbiBwaXhlbHNcbiAgICAgIHZhciBmbG9hdEZyYW1lV2lkdGggPSBmcmFtZUR1cmF0aW9uIC8gY2FudmFzRHVyYXRpb24gKiBjYW52YXNXaWR0aDtcbiAgICAgIHZhciBmcmFtZVdpZHRoID0gTWF0aC5mbG9vcihmbG9hdEZyYW1lV2lkdGggKyAwLjUpO1xuXG4gICAgICAvLyBkZWZpbmUgcG9zaXRpb24gb2YgdGhlIGhlYWQgaW4gdGhlIGNhbnZhc1xuICAgICAgdmFyIGNhbnZhc1N0YXJ0VGltZSA9IHRoaXMuY3VycmVudFRpbWUgLSBjYW52YXNEdXJhdGlvbjtcbiAgICAgIHZhciBzdGFydFRpbWVSYXRpbyA9IChmcmFtZVN0YXJ0VGltZSAtIGNhbnZhc1N0YXJ0VGltZSkgLyBjYW52YXNEdXJhdGlvbjtcbiAgICAgIHZhciBzdGFydFRpbWVQb3NpdGlvbiA9IHN0YXJ0VGltZVJhdGlvICogY2FudmFzV2lkdGg7XG5cbiAgICAgIC8vIG51bWJlciBvZiBwaXhlbHMgc2luY2UgbGFzdCBmcmFtZVxuICAgICAgdmFyIHBpeGVsc1NpbmNlTGFzdEZyYW1lID0gdGhpcy5sYXN0RnJhbWVXaWR0aDtcblxuICAgICAgaWYgKChmcmFtZVR5cGUgPT09ICdzY2FsYXInIHx8IGZyYW1lVHlwZSA9PT0gJ3ZlY3RvcicpICYmIHByZXZpb3VzRnJhbWUpIHtcbiAgICAgICAgdmFyIGZyYW1lSW50ZXJ2YWwgPSBmcmFtZS50aW1lIC0gcHJldmlvdXNGcmFtZS50aW1lO1xuICAgICAgICBwaXhlbHNTaW5jZUxhc3RGcmFtZSA9IGZyYW1lSW50ZXJ2YWwgLyBjYW52YXNEdXJhdGlvbiAqIGNhbnZhc1dpZHRoO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IGN1cnJlbnQgZnJhbWVcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHN0YXJ0VGltZVBvc2l0aW9uLCAwKTtcbiAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uKGZyYW1lLCBmcmFtZVdpZHRoLCBwaXhlbHNTaW5jZUxhc3RGcmFtZSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAvLyBzYXZlIGN1cnJlbnQgY2FudmFzIHN0YXRlIGludG8gY2FjaGVkIGNhbnZhc1xuICAgICAgdGhpcy5jYWNoZWRDdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgdGhpcy5jYWNoZWRDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzLCAwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcblxuICAgICAgLy8gdXBkYXRlIGxhc3RGcmFtZUR1cmF0aW9uLCBsYXN0RnJhbWVXaWR0aFxuICAgICAgdGhpcy5sYXN0RnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgICB0aGlzLmxhc3RGcmFtZVdpZHRoID0gZnJhbWVXaWR0aDtcbiAgICAgIHRoaXMucHJldmlvdXNGcmFtZSA9IGZyYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoaWZ0IGNhbnZhcywgYWxzbyBjYWxsZWQgZnJvbSBgRGlzcGxheVN5bmNgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2hpZnRDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdENhbnZhcyhpU2hpZnQsIHRpbWUpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGVkQ2FudmFzO1xuICAgICAgdmFyIGNhY2hlZEN0eCA9IHRoaXMuY2FjaGVkQ3R4O1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXNXaWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhbnZhc0hlaWdodDtcbiAgICAgIHZhciBjcm9wcGVkV2lkdGggPSB3aWR0aCAtIGlTaGlmdDtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aW1lO1xuXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShjYWNoZSwgaVNoaWZ0LCAwLCBjcm9wcGVkV2lkdGgsIGhlaWdodCwgMCwgMCwgY3JvcHBlZFdpZHRoLCBoZWlnaHQpO1xuICAgICAgLy8gc2F2ZSBjdXJyZW50IGNhbnZhcyBzdGF0ZSBpbnRvIGNhY2hlZCBjYW52YXNcbiAgICAgIGNhY2hlZEN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjYWNoZWRDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBAdG9kbyAtIEZpeCB0cmlnZ2VyIG1vZGVcbiAgICAvLyBhbGxvdyB0byB3aXRjaCBlYXNpbHkgYmV0d2VlbiB0aGUgMiBtb2Rlc1xuICAgIC8vIHNldFRyaWdnZXIoYm9vbCkge1xuICAgIC8vICAgdGhpcy5wYXJhbXMudHJpZ2dlciA9IGJvb2w7XG4gICAgLy8gICAvLyBjbGVhciBjYW52YXMgYW5kIGNhY2hlXG4gICAgLy8gICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5wYXJhbXMud2lkdGgsIHRoaXMucGFyYW1zLmhlaWdodCk7XG4gICAgLy8gICB0aGlzLmNhY2hlZEN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5wYXJhbXMud2lkdGgsIHRoaXMucGFyYW1zLmhlaWdodCk7XG4gICAgLy8gICAvLyByZXNldCBfY3VycmVudFhQb3NpdGlvblxuICAgIC8vICAgdGhpcy5fY3VycmVudFhQb3NpdGlvbiA9IDA7XG4gICAgLy8gICB0aGlzLmxhc3RTaGlmdEVycm9yID0gMDtcbiAgICAvLyB9XG5cbiAgICAvLyAvKipcbiAgICAvLyAgKiBBbHRlcm5hdGl2ZSBkcmF3aW5nIG1vZGUuXG4gICAgLy8gICogRHJhdyBmcm9tIGxlZnQgdG8gcmlnaHQsIGdvIGJhY2sgdG8gbGVmdCB3aGVuID4gd2lkdGhcbiAgICAvLyAgKi9cbiAgICAvLyB0cmlnZ2VyTW9kZURyYXcodGltZSwgZnJhbWUpIHtcbiAgICAvLyAgIGNvbnN0IHdpZHRoICA9IHRoaXMucGFyYW1zLndpZHRoO1xuICAgIC8vICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5wYXJhbXMuaGVpZ2h0O1xuICAgIC8vICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLnBhcmFtcy5kdXJhdGlvbjtcbiAgICAvLyAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgLy8gICBjb25zdCBkdCA9IHRpbWUgLSB0aGlzLnByZXZpb3VzVGltZTtcbiAgICAvLyAgIGNvbnN0IGZTaGlmdCA9IChkdCAvIGR1cmF0aW9uKSAqIHdpZHRoIC0gdGhpcy5sYXN0U2hpZnRFcnJvcjsgLy8gcHhcbiAgICAvLyAgIGNvbnN0IGlTaGlmdCA9IE1hdGgucm91bmQoZlNoaWZ0KTtcbiAgICAvLyAgIHRoaXMubGFzdFNoaWZ0RXJyb3IgPSBpU2hpZnQgLSBmU2hpZnQ7XG5cbiAgICAvLyAgIHRoaXMuY3VycmVudFhQb3NpdGlvbiArPSBpU2hpZnQ7XG5cbiAgICAvLyAgIC8vIGRyYXcgdGhlIHJpZ2h0IHBhcnRcbiAgICAvLyAgIGN0eC5zYXZlKCk7XG4gICAgLy8gICBjdHgudHJhbnNsYXRlKHRoaXMuY3VycmVudFhQb3NpdGlvbiwgMCk7XG4gICAgLy8gICBjdHguY2xlYXJSZWN0KC1pU2hpZnQsIDAsIGlTaGlmdCwgaGVpZ2h0KTtcbiAgICAvLyAgIHRoaXMuZHJhd0N1cnZlKGZyYW1lLCBpU2hpZnQpO1xuICAgIC8vICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIC8vICAgLy8gZ28gYmFjayB0byB0aGUgbGVmdCBvZiB0aGUgY2FudmFzIGFuZCByZWRyYXcgdGhlIHNhbWUgdGhpbmdcbiAgICAvLyAgIGlmICh0aGlzLmN1cnJlbnRYUG9zaXRpb24gPiB3aWR0aCkge1xuICAgIC8vICAgICAvLyBnbyBiYWNrIHRvIHN0YXJ0XG4gICAgLy8gICAgIHRoaXMuY3VycmVudFhQb3NpdGlvbiAtPSB3aWR0aDtcblxuICAgIC8vICAgICBjdHguc2F2ZSgpO1xuICAgIC8vICAgICBjdHgudHJhbnNsYXRlKHRoaXMuY3VycmVudFhQb3NpdGlvbiwgMCk7XG4gICAgLy8gICAgIGN0eC5jbGVhclJlY3QoLWlTaGlmdCwgMCwgaVNoaWZ0LCBoZWlnaHQpO1xuICAgIC8vICAgICB0aGlzLmRyYXdDdXJ2ZShmcmFtZSwgdGhpcy5wcmV2aW91c0ZyYW1lLCBpU2hpZnQpO1xuICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICB9XSk7XG4gIHJldHVybiBCYXNlRGlzcGxheTtcbn0oX0Jhc2VMZm8zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlRGlzcGxheTtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiOjYsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0XCI6MTgsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfZ2V0MiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXQnKTtcblxudmFyIF9nZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Mik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlRGlzcGxheTIgPSByZXF1aXJlKCcuL0Jhc2VEaXNwbGF5Jyk7XG5cbnZhciBfQmFzZURpc3BsYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZURpc3BsYXkyKTtcblxudmFyIF9kaXNwbGF5VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9kaXNwbGF5LXV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgcmFkaXVzOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBtaW46IDAsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBsaW5lOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEJyZWFrcG9pbnQgRnVuY3Rpb24sIGRpc3BsYXkgYSBzdHJlYW0gb2YgdHlwZSBgdmVjdG9yYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjbGllbnQuc2lua1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9ycz1udWxsXSAtIEFycmF5IG9mIGNvbG9ycyBmb3IgZWFjaCBpbmRleCBvZiB0aGVcbiAgICogIHZlY3Rvci4gX2R5bmFtaWMgcGFyYW1ldGVyX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmFkaXVzPTBdIC0gUmFkaXVzIG9mIHRoZSBkb3QgYXQgZWFjaCB2YWx1ZS5cbiAgICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmxpbmU9dHJ1ZV0gLSBEaXNwbGF5IGEgbGluZSBiZXR3ZWVuIGVhY2ggY29uc2VjdXRpdmVcbiAgICogIHZhbHVlcyBvZiB0aGUgdmVjdG9yLiBfZHluYW1pYyBwYXJhbWV0ZXJfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW49LTFdIC0gTWluaW11bSB2YWx1ZSByZXByZXNlbnRlZCBpbiB0aGUgY2FudmFzLlxuICAgKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4PTFdIC0gTWF4aW11bSB2YWx1ZSByZXByZXNlbnRlZCBpbiB0aGUgY2FudmFzLlxuICAgKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MzAwXSAtIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gICAqICBfZHluYW1pYyBwYXJhbWV0ZXJfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTUwXSAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICAgKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICAgKiBAcGFyYW0ge0VsZW1lbnR8Q1NTU2VsZWN0b3J9IFtvcHRpb25zLmNvbnRhaW5lcj1udWxsXSAtIENvbnRhaW5lciBlbGVtZW50XG4gICAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy4gX2NvbnN0YW50IHBhcmFtZXRlcl9cbiAgICogQHBhcmFtIHtFbGVtZW50fENTU1NlbGVjdG9yfSBbb3B0aW9ucy5jYW52YXM9bnVsbF0gLSBDYW52YXMgZWxlbWVudFxuICAgKiAgaW4gd2hpY2ggdG8gZHJhdy4gX2NvbnN0YW50IHBhcmFtZXRlcl9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTFdIC0gRHVyYXRpb24gKGluIHNlY29uZHMpIHJlcHJlc2VudGVkIGluXG4gICAqICB0aGUgY2FudmFzLiBfZHluYW1pYyBwYXJhbWV0ZXJfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWZlcmVuY2VUaW1lPW51bGxdIC0gT3B0aW9ubmFsIHJlZmVyZW5jZSB0aW1lIHRoZVxuICAgKiAgZGlzcGxheSBzaG91bGQgY29uc2lkZXJlciBhcyB0aGUgb3JpZ2luLiBJcyBvbmx5IHVzZWZ1bGwgd2hlbiBzeW5jaHJvbml6aW5nXG4gICAqICBzZXZlcmFsIGRpc3BsYXkgdXNpbmcgdGhlIGBEaXNwbGF5U3luY2AgY2xhc3MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICpcbiAgICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICAgKiAgIGZyYW1lU2l6ZTogMixcbiAgICogICBmcmFtZVJhdGU6IDAuMSxcbiAgICogICBmcmFtZVR5cGU6ICd2ZWN0b3InXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBicGYgPSBuZXcgbGZvLnNpbmsuQnBmRGlzcGxheSh7XG4gICAqICAgY2FudmFzOiAnI2JwZicsXG4gICAqICAgZHVyYXRpb246IDEwLFxuICAgKiB9KTtcbiAgICpcbiAgICogZXZlbnRJbi5jb25uZWN0KGJwZik7XG4gICAqIGV2ZW50SW4uc3RhcnQoKTtcbiAgICpcbiAgICogbGV0IHRpbWUgPSAwO1xuICAgKiBjb25zdCBkdCA9IDAuMTtcbiAgICpcbiAgICogKGZ1bmN0aW9uIGdlbmVyYXRlRGF0YSgpIHtcbiAgICogICBldmVudEluLnByb2Nlc3ModGltZSwgW01hdGgucmFuZG9tKCkgKiAyIC0gMSwgTWF0aC5yYW5kb20oKSAqIDIgLSAxXSk7XG4gICAqICAgdGltZSArPSBkdDtcbiAgICpcbiAgICogICBzZXRUaW1lb3V0KGdlbmVyYXRlRGF0YSwgZHQgKiAxMDAwKTtcbiAgICogfSgpKTtcbiAgICovXG59O1xudmFyIEJwZkRpc3BsYXkgPSBmdW5jdGlvbiAoX0Jhc2VEaXNwbGF5KSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEJwZkRpc3BsYXksIF9CYXNlRGlzcGxheSk7XG5cbiAgZnVuY3Rpb24gQnBmRGlzcGxheShvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQnBmRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChCcGZEaXNwbGF5Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShCcGZEaXNwbGF5KSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucHJldkZyYW1lID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKEJwZkRpc3BsYXksIFt7XG4gICAga2V5OiAnZ2V0TWluaW11bUZyYW1lV2lkdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNaW5pbXVtRnJhbWVXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5nZXQoJ3JhZGl1cycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0U3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTdHJlYW0oKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoQnBmRGlzcGxheS5wcm90b3R5cGUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEJwZkRpc3BsYXkucHJvdG90eXBlKSwgJ3Jlc2V0U3RyZWFtJywgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5wcmV2RnJhbWUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5nZXQoJ2NvbG9ycycpID09PSBudWxsKSB0aGlzLnBhcmFtcy5zZXQoJ2NvbG9ycycsICgwLCBfZGlzcGxheVV0aWxzLmdldENvbG9ycykoJ2JwZicsIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSkpO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSwgZnJhbWVXaWR0aCwgcGl4ZWxzU2luY2VMYXN0RnJhbWUpIHtcbiAgICAgIHZhciBjb2xvcnMgPSB0aGlzLnBhcmFtcy5nZXQoJ2NvbG9ycycpO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMucGFyYW1zLmdldCgncmFkaXVzJyk7XG4gICAgICB2YXIgZHJhd0xpbmUgPSB0aGlzLnBhcmFtcy5nZXQoJ2xpbmUnKTtcbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgZGF0YSA9IGZyYW1lLmRhdGE7XG4gICAgICB2YXIgcHJldkRhdGEgPSB0aGlzLnByZXZGcmFtZSA/IHRoaXMucHJldkZyYW1lLmRhdGEgOiBudWxsO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZyYW1lU2l6ZTsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcG9zWSA9IHRoaXMuZ2V0WVBvc2l0aW9uKGRhdGFbaV0pO1xuICAgICAgICB2YXIgY29sb3IgPSBjb2xvcnNbaV07XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblxuICAgICAgICBpZiAocHJldkRhdGEgJiYgZHJhd0xpbmUpIHtcbiAgICAgICAgICB2YXIgbGFzdFBvc1kgPSB0aGlzLmdldFlQb3NpdGlvbihwcmV2RGF0YVtpXSk7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oLXBpeGVsc1NpbmNlTGFzdEZyYW1lLCBsYXN0UG9zWSk7XG4gICAgICAgICAgY3R4LmxpbmVUbygwLCBwb3NZKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJhZGl1cyA+IDApIHtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LmFyYygwLCBwb3NZLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgdGhpcy5wcmV2RnJhbWUgPSBmcmFtZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJwZkRpc3BsYXk7XG59KF9CYXNlRGlzcGxheTMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJwZkRpc3BsYXk7XG5cbn0se1wiLi4vdXRpbHMvZGlzcGxheS11dGlsc1wiOjE1MSxcIi4vQmFzZURpc3BsYXlcIjoxMzUsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0XCI6MTgsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlRGlzcGxheTIgPSByZXF1aXJlKCcuL0Jhc2VEaXNwbGF5Jyk7XG5cbnZhciBfQmFzZURpc3BsYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZURpc3BsYXkyKTtcblxudmFyIF9kaXNwbGF5VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9kaXNwbGF5LXV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgdGhyZXNob2xkOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIHRocmVzaG9sZEluZGV4OiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgY29sb3I6IHtcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiAoMCwgX2Rpc3BsYXlVdGlscy5nZXRDb2xvcnMpKCdtYXJrZXInKSxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9XG59O1xuXG4vKipcbiAqIERpc3BsYXkgYSBtYXJrZXIgYWNjb3JkaW5nIHRvIGEgYHZlY3RvcmAgaW5wdXQgZnJhbWUuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjbGllbnQuc2lua1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY29sb3IgLSBDb2xvciBvZiB0aGUgbWFya2VyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZEluZGV4PTBdIC0gSW5kZXggb2YgdGhlIGluY29tbWluZyBmcmFtZVxuICogIGRhdGEgdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSB0aHJlc2hvbGQuIF9TaG91bGQgYmUgdXNlZCBpbiBjb25qb25jdGlvbiB3aXRoXG4gKiAgYHRocmVzaG9sZGBfLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD1udWxsXSAtIE1pbmltdW0gdmFsdWUgdGhlIGluY29tbWluZyB2YWx1ZVxuICogIG11c3QgaGF2ZSB0byB0cmlnZ2VyIHRoZSBkaXNwbGF5IG9mIGEgbWFya2VyLiBJZiBudWxsIGVhY2ggaW5jb21taW5nIGV2ZW50XG4gKiAgdHJpZ2dlcnMgYSBtYXJrZXIuIF9TaG91bGQgYmUgdXNlZCBpbiBjb25qb25jdGlvbiB3aXRoIGB0aHJlc2hvbGRJbmRleGBfLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTMwMF0gLSBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTUwXSAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY29udGFpbmVyPW51bGxdIC0gQ29udGFpbmVyIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy4gX2NvbnN0YW50IHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY2FudmFzPW51bGxdIC0gQ2FudmFzIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBkcmF3LiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTFdIC0gRHVyYXRpb24gKGluIHNlY29uZHMpIHJlcHJlc2VudGVkIGluXG4gKiAgdGhlIGNhbnZhcy4gVGhpcyBwYXJhbWV0ZXIgb25seSBleGlzdHMgZm9yIG9wZXJhdG9ycyB0aGF0IGRpc3BsYXkgc2V2ZXJhbFxuICogIGNvbnNlY3V0aXZlIGZyYW1lcyBvbiB0aGUgY2FudmFzLiBfZHluYW1pYyBwYXJhbWV0ZXJfXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVmZXJlbmNlVGltZT1udWxsXSAtIE9wdGlvbm5hbCByZWZlcmVuY2UgdGltZSB0aGVcbiAqICBkaXNwbGF5IHNob3VsZCBjb25zaWRlcmVyIGFzIHRoZSBvcmlnaW4uIElzIG9ubHkgdXNlZnVsbCB3aGVuIHN5bmNocm9uaXppbmdcbiAqICBzZXZlcmFsIGRpc3BsYXkgdXNpbmcgdGhlIGBEaXNwbGF5U3luY2AgY2xhc3MuIFRoaXMgcGFyYW1ldGVyIG9ubHkgZXhpc3RzXG4gKiAgZm9yIG9wZXJhdG9ycyB0aGF0IGRpc3BsYXkgc2V2ZXJhbCBjb25zZWN1dGl2ZSBmcmFtZXMgb24gdGhlIGNhbnZhcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHtcbiAqICAgZnJhbWVUeXBlOiAnc2NhbGFyJyxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IG1hcmtlciA9IG5ldyBsZm8uc2luay5NYXJrZXJEaXNwbGF5KHtcbiAqICAgY2FudmFzOiAnI21hcmtlcicsXG4gKiAgIHRocmVzaG9sZDogMC41LFxuICogfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KG1hcmtlcik7XG4gKiBldmVudEluLnN0YXJ0KCk7XG4gKlxuICogbGV0IHRpbWUgPSAwO1xuICogY29uc3QgcGVyaW9kID0gMTtcbiAqXG4gKiAoZnVuY3Rpb24gZ2VuZXJhdGVEYXRhKCkge1xuICogICBldmVudEluLnByb2Nlc3ModGltZSwgTWF0aC5yYW5kb20oKSk7XG4gKlxuICogICB0aW1lICs9IHBlcmlvZDtcbiAqICAgc2V0VGltZW91dChnZW5lcmF0ZURhdGEsIHBlcmlvZCAqIDEwMDApO1xuICogfSgpKTtcbiAqL1xuXG52YXIgTWFya2VyRGlzcGxheSA9IGZ1bmN0aW9uIChfQmFzZURpc3BsYXkpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoTWFya2VyRGlzcGxheSwgX0Jhc2VEaXNwbGF5KTtcblxuICBmdW5jdGlvbiBNYXJrZXJEaXNwbGF5KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBNYXJrZXJEaXNwbGF5KTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoTWFya2VyRGlzcGxheS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoTWFya2VyRGlzcGxheSkpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoTWFya2VyRGlzcGxheSwgW3tcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSwgZnJhbWVXaWR0aCwgcGl4ZWxzU2luY2VMYXN0RnJhbWUpIHtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMucGFyYW1zLmdldCgnY29sb3InKTtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnBhcmFtcy5nZXQoJ3RocmVzaG9sZCcpO1xuICAgICAgdmFyIHRocmVzaG9sZEluZGV4ID0gdGhpcy5wYXJhbXMuZ2V0KCd0aHJlc2hvbGRJbmRleCcpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdmFyIGhlaWdodCA9IGN0eC5oZWlnaHQ7XG4gICAgICB2YXIgdmFsdWUgPSBmcmFtZS5kYXRhW3RocmVzaG9sZEluZGV4XTtcblxuICAgICAgaWYgKHRocmVzaG9sZCA9PT0gbnVsbCB8fCB2YWx1ZSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIHlNaW4gPSB0aGlzLmdldFlQb3NpdGlvbih0aGlzLnBhcmFtcy5nZXQoJ21pbicpKTtcbiAgICAgICAgdmFyIHlNYXggPSB0aGlzLmdldFlQb3NpdGlvbih0aGlzLnBhcmFtcy5nZXQoJ21heCcpKTtcblxuICAgICAgICBpZiAoeU1pbiA+IHlNYXgpIHtcbiAgICAgICAgICB2YXIgdiA9IHlNYXg7XG4gICAgICAgICAgeU1heCA9IHlNaW47XG4gICAgICAgICAgeU1pbiA9IHY7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCB5TWluLCAxLCB5TWF4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1hcmtlckRpc3BsYXk7XG59KF9CYXNlRGlzcGxheTMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1hcmtlckRpc3BsYXk7XG5cbn0se1wiLi4vdXRpbHMvZGlzcGxheS11dGlsc1wiOjE1MSxcIi4vQmFzZURpc3BsYXlcIjoxMzUsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlRGlzcGxheTIgPSByZXF1aXJlKCcuL0Jhc2VEaXNwbGF5Jyk7XG5cbnZhciBfQmFzZURpc3BsYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZURpc3BsYXkyKTtcblxudmFyIF9kaXNwbGF5VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9kaXNwbGF5LXV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcblxuZnVuY3Rpb24gZG93blNhbXBsZShkYXRhLCB0YXJnZXRMZW5ndGgpIHtcbiAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgaG9wID0gbGVuZ3RoIC8gdGFyZ2V0TGVuZ3RoO1xuICB2YXIgdGFyZ2V0ID0gbmV3IEZsb2F0MzJBcnJheSh0YXJnZXRMZW5ndGgpO1xuICB2YXIgY291bnRlciA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRMZW5ndGg7IGkrKykge1xuICAgIHZhciBpbmRleCA9IGZsb29yKGNvdW50ZXIpO1xuICAgIHZhciBwaGFzZSA9IGNvdW50ZXIgLSBpbmRleDtcbiAgICB2YXIgcHJldiA9IGRhdGFbaW5kZXhdO1xuICAgIHZhciBuZXh0ID0gZGF0YVtpbmRleCArIDFdO1xuXG4gICAgdGFyZ2V0W2ldID0gKG5leHQgLSBwcmV2KSAqIHBoYXNlICsgcHJldjtcbiAgICBjb3VudGVyICs9IGhvcDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgY29sb3I6IHtcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiAoMCwgX2Rpc3BsYXlVdGlscy5nZXRDb2xvcnMpKCdzaWduYWwnKSxcbiAgICBudWxsYWJsZTogdHJ1ZVxuICB9XG59O1xuXG4vKipcbiAqIERpc3BsYXkgYSBzdHJlYW0gb2YgdHlwZSBgc2lnbmFsYCBvbiBhIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb2xvcj0nIzAwZTYwMCddIC0gQ29sb3Igb2YgdGhlIHNpZ25hbC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW49LTFdIC0gTWluaW11bSB2YWx1ZSByZXByZXNlbnRlZCBpbiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXg9MV0gLSBNYXhpbXVtIHZhbHVlIHJlcHJlc2VudGVkIGluIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTMwMF0gLSBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTUwXSAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY29udGFpbmVyPW51bGxdIC0gQ29udGFpbmVyIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy4gX2NvbnN0YW50IHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY2FudmFzPW51bGxdIC0gQ2FudmFzIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBkcmF3LiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTFdIC0gRHVyYXRpb24gKGluIHNlY29uZHMpIHJlcHJlc2VudGVkIGluXG4gKiAgdGhlIGNhbnZhcy4gVGhpcyBwYXJhbWV0ZXIgb25seSBleGlzdHMgZm9yIG9wZXJhdG9ycyB0aGF0IGRpc3BsYXkgc2V2ZXJhbFxuICogIGNvbnNlY3V0aXZlIGZyYW1lcyBvbiB0aGUgY2FudmFzLiBfZHluYW1pYyBwYXJhbWV0ZXJfXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVmZXJlbmNlVGltZT1udWxsXSAtIE9wdGlvbm5hbCByZWZlcmVuY2UgdGltZSB0aGVcbiAqICBkaXNwbGF5IHNob3VsZCBjb25zaWRlcmVyIGFzIHRoZSBvcmlnaW4uIElzIG9ubHkgdXNlZnVsbCB3aGVuIHN5bmNocm9uaXppbmdcbiAqICBzZXZlcmFsIGRpc3BsYXkgdXNpbmcgdGhlIGBEaXNwbGF5U3luY2AgY2xhc3MuIFRoaXMgcGFyYW1ldGVyIG9ubHkgZXhpc3RzXG4gKiAgZm9yIG9wZXJhdG9ycyB0aGF0IGRpc3BsYXkgc2V2ZXJhbCBjb25zZWN1dGl2ZSBmcmFtZXMgb24gdGhlIGNhbnZhcy5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNsaWVudC5zaW5rXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHtcbiAqICAgZnJhbWVUeXBlOiAnc2lnbmFsJyxcbiAqICAgc2FtcGxlUmF0ZTogOCxcbiAqICAgZnJhbWVTaXplOiA0LFxuICogfSk7XG4gKlxuICogY29uc3Qgc2lnbmFsRGlzcGxheSA9IG5ldyBsZm8uc2luay5TaWduYWxEaXNwbGF5KHtcbiAqICAgY2FudmFzOiAnI3NpZ25hbC1jYW52YXMnLFxuICogfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KHNpZ25hbERpc3BsYXkpO1xuICogZXZlbnRJbi5zdGFydCgpO1xuICpcbiAqIC8vIHB1c2ggdHJpYW5nbGUgc2lnbmFsIGluIHRoZSBncmFwaFxuICogZXZlbnRJbi5wcm9jZXNzKDAsIFswLCAwLjUsIDEsIDAuNV0pO1xuICogZXZlbnRJbi5wcm9jZXNzKDAuNSwgWzAsIC0wLjUsIC0xLCAtMC41XSk7XG4gKiAvLyAuLi5cbiAqL1xuXG52YXIgU2lnbmFsRGlzcGxheSA9IGZ1bmN0aW9uIChfQmFzZURpc3BsYXkpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoU2lnbmFsRGlzcGxheSwgX0Jhc2VEaXNwbGF5KTtcblxuICBmdW5jdGlvbiBTaWduYWxEaXNwbGF5KG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTaWduYWxEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKFNpZ25hbERpc3BsYXkuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNpZ25hbERpc3BsYXkpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zLCB0cnVlKSk7XG5cbiAgICBfdGhpcy5sYXN0UG9zWSA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShTaWduYWxEaXNwbGF5LCBbe1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKGZyYW1lLCBmcmFtZVdpZHRoLCBwaXhlbHNTaW5jZUxhc3RGcmFtZSkge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5wYXJhbXMuZ2V0KCdjb2xvcicpO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBkYXRhID0gZnJhbWUuZGF0YTtcblxuICAgICAgaWYgKGZyYW1lV2lkdGggPCBmcmFtZVNpemUpIGRhdGEgPSBkb3duU2FtcGxlKGRhdGEsIGZyYW1lV2lkdGgpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB2YXIgaG9wWCA9IGZyYW1lV2lkdGggLyBsZW5ndGg7XG4gICAgICB2YXIgcG9zWCA9IDA7XG4gICAgICB2YXIgbGFzdFkgPSB0aGlzLmxhc3RQb3NZO1xuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3NZID0gdGhpcy5nZXRZUG9zaXRpb24oZGF0YVtpXSk7XG5cbiAgICAgICAgaWYgKGxhc3RZID09PSBudWxsKSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhwb3NYLCBwb3NZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgY3R4Lm1vdmVUbygtaG9wWCwgbGFzdFkpO1xuXG4gICAgICAgICAgY3R4LmxpbmVUbyhwb3NYLCBwb3NZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc1ggKz0gaG9wWDtcbiAgICAgICAgbGFzdFkgPSBwb3NZO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIHRoaXMubGFzdFBvc1kgPSBsYXN0WTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNpZ25hbERpc3BsYXk7XG59KF9CYXNlRGlzcGxheTMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNpZ25hbERpc3BsYXk7XG5cbn0se1wiLi4vdXRpbHMvZGlzcGxheS11dGlsc1wiOjE1MSxcIi4vQmFzZURpc3BsYXlcIjoxMzUsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZScpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9nZXQyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldCcpO1xuXG52YXIgX2dldDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXQyKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VMZm8yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvMik7XG5cbnZhciBfd3NVdGlscyA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi91dGlscy93c1V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBwYXJhbWV0ZXJzID0ge1xuICBwb3J0OiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDgwMDAsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgY29uc3RhbnQ6IHRydWVcbiAgfSxcbiAgdXJsOiB7XG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBjb25zdGFudDogdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYW4gbGZvIGZyYW1lIGFzIGEgc29ja2V0IG1lc3NhZ2UgdG8gYSBgbm9kZS5zb3VyY2UuU29ja2V0UmVjZWl2ZWBcbiAgICogaW5zdGFuY2UuXG4gICAqXG4gICAqIDxwIGNsYXNzPVwid2FybmluZ1wiPkV4cGVyaW1lbnRhbDwvcD5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjbGllbnQuc2lua1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBldmVudEluID0gbmV3IGxmby5zb3VyY2UuRXZlbnRJbih7XG4gICAqICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAgICogICBmcmFtZVNpemU6IDIsXG4gICAqICAgZnJhbWVSYXRlOiAxLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3Qgc29ja2V0U2VuZCA9IG5ldyBsZm8uc2luay5Tb2NrZXRTZW5kKHtcbiAgICogICBwb3J0OiAzMDAwXG4gICAqIH0pO1xuICAgKlxuICAgKiBldmVudEluLmNvbm5lY3Qoc29ja2V0U2VuZCk7XG4gICAqXG4gICAqIGV2ZW50SW4uaW5pdCgpLnRoZW4oKCkgPT4ge1xuICAgKiAgIGV2ZW50SW4uc3RhcnQoKTtcbiAgICpcbiAgICogICBsZXQgdGltZSA9IDA7XG4gICAqXG4gICAqICAgKGZ1bmN0aW9uIGNyZWF0ZUZyYW1lKCkge1xuICAgKiAgICAgZXZlbnRJbi5wcm9jZXNzKHRpbWUsIFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXSwgeyB0ZXN0OiB0cnVlIH0pO1xuICAgKiAgICAgdGltZSArPSAxO1xuICAgKlxuICAgKiAgICAgc2V0VGltZW91dChjcmVhdGVGcmFtZSwgMTAwMCk7XG4gICAqICAgfSgpKTtcbiAgICogfSk7XG4gICAqL1xufTtcbnZhciBTb2NrZXRTZW5kID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFNvY2tldFNlbmQsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBTb2NrZXRTZW5kKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTb2NrZXRTZW5kKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKFNvY2tldFNlbmQuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNvY2tldFNlbmQpKS5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIG9wdGlvbnMpKTtcblxuICAgIHZhciBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKC9eaHR0cC8sICd3cycpO1xuICAgIHZhciBhZGRyZXNzID0gX3RoaXMucGFyYW1zLmdldCgndXJsJykgfHwgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIHZhciBwb3J0ID0gX3RoaXMucGFyYW1zLmdldCgncG9ydCcpIHx8ICcnOyAvLyBldmVyeXRoaW5nIGZhbHN5IGJlY29tZXMgJydcbiAgICB2YXIgc29ja2V0QWRkcmVzcyA9IHByb3RvY29sICsgJy8vJyArIGFkZHJlc3MgKyAnOicgKyBwb3J0O1xuXG4gICAgX3RoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldChzb2NrZXRBZGRyZXNzKTtcbiAgICBfdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICBfdGhpcy5vcGVuZWRQcm9taXNlID0gbmV3IF9wcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIF90aGlzLnNvY2tldC5vbm9wZW4gPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuc29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoU29ja2V0U2VuZCwgW3tcbiAgICBrZXk6ICdpbml0TW9kdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdE1vZHVsZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBzZW5kIGEgSU5JVF9NT0RVTEVfUkVRIGFuZCB3YWl0IGZvciBJTklUX01PRFVMRV9BQ0tcbiAgICAgIC8vIG5vIG5lZWQgdG8gZ2V0IGNoaWxkcmVuIHByb21pc2VzIGFzIHdlIGFyZSBpbiBhIGxlZWZcbiAgICAgIHJldHVybiB0aGlzLm9wZW5lZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIF90aGlzMi5zb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBvcGNvZGUgPSBfd3NVdGlscy5kZWNvZGVycy5vcGNvZGUoZS5kYXRhKTtcblxuICAgICAgICAgICAgaWYgKG9wY29kZSA9PT0gX3dzVXRpbHMub3Bjb2Rlcy5JTklUX01PRFVMRV9BQ0spIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IF93c1V0aWxzLmVuY29kZXJzLmluaXRNb2R1bGVSZXEoKTtcbiAgICAgICAgICBfdGhpczIuc29ja2V0LnNlbmQoYnVmZmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoU29ja2V0U2VuZC5wcm90b3R5cGUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNvY2tldFNlbmQucHJvdG90eXBlKSwgJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLCB0aGlzKS5jYWxsKHRoaXMsIHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgICB2YXIgYnVmZmVyID0gX3dzVXRpbHMuZW5jb2RlcnMuc3RyZWFtUGFyYW1zKHRoaXMuc3RyZWFtUGFyYW1zKTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoYnVmZmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldFN0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0U3RyZWFtKCkge1xuICAgICAgKDAsIF9nZXQzLmRlZmF1bHQpKFNvY2tldFNlbmQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShTb2NrZXRTZW5kLnByb3RvdHlwZSksICdyZXNldFN0cmVhbScsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHZhciBidWZmZXIgPSBfd3NVdGlscy5lbmNvZGVycy5yZXNldFN0cmVhbSgpO1xuICAgICAgdGhpcy5zb2NrZXQuc2VuZChidWZmZXIpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmaW5hbGl6ZVN0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplU3RyZWFtKGVuZFRpbWUpIHtcbiAgICAgICgwLCBfZ2V0My5kZWZhdWx0KShTb2NrZXRTZW5kLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoU29ja2V0U2VuZC5wcm90b3R5cGUpLCAnZmluYWxpemVTdHJlYW0nLCB0aGlzKS5jYWxsKHRoaXMsIGVuZFRpbWUpO1xuXG4gICAgICB2YXIgYnVmZmVyID0gX3dzVXRpbHMuZW5jb2RlcnMuZmluYWxpemVTdHJlYW0oZW5kVGltZSk7XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgLy8gcHJvY2VzcyBhbnkgdHlwZVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU2NhbGFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NjYWxhcigpIHt9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmVjdG9yKCkge31cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoKSB7fVxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc0ZyYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdGhpcy5mcmFtZS50aW1lID0gZnJhbWUudGltZTtcbiAgICAgIHRoaXMuZnJhbWUuZGF0YS5zZXQoZnJhbWUuZGF0YSwgMCk7XG4gICAgICB0aGlzLmZyYW1lLm1ldGFkYXRhID0gZnJhbWUubWV0YWRhdGE7XG5cbiAgICAgIHZhciBidWZmZXIgPSBfd3NVdGlscy5lbmNvZGVycy5wcm9jZXNzRnJhbWUodGhpcy5mcmFtZSwgZnJhbWVTaXplKTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoYnVmZmVyKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNvY2tldFNlbmQ7XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU29ja2V0U2VuZDtcblxufSx7XCIuLi8uLi9jb21tb24vdXRpbHMvd3NVdGlsc1wiOjE4MSxcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIjoxMixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0XCI6MTgsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2xvZyA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXRoL2xvZzEwJyk7XG5cbnZhciBfbG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VEaXNwbGF5MiA9IHJlcXVpcmUoJy4vQmFzZURpc3BsYXknKTtcblxudmFyIF9CYXNlRGlzcGxheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlRGlzcGxheTIpO1xuXG52YXIgX0ZmdCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9vcGVyYXRvci9GZnQnKTtcblxudmFyIF9GZnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRmZ0KTtcblxudmFyIF9kaXNwbGF5VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9kaXNwbGF5LXV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgc2NhbGU6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgY29sb3I6IHtcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiAoMCwgX2Rpc3BsYXlVdGlscy5nZXRDb2xvcnMpKCdzcGVjdHJ1bScpLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIG1pbjoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogLTgwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIG1heDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogNixcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9XG59O1xuXG4vKipcbiAqIERpc3BsYXkgdGhlIHNwZWN0cnVtIG9mIHRoZSBpbmNvbW1pbmcgYHNpZ25hbGAgaW5wdXQuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjbGllbnQuc2lua1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlPTFdIC0gU2NhbGUgZGlzcGxheSBvZiB0aGUgc3BlY3Ryb2dyYW0uXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29sb3I9bnVsbF0gLSBDb2xvciBvZiB0aGUgc3BlY3Ryb2dyYW0uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluPS04MF0gLSBNaW5pbXVtIGRpc3BsYXllZCB2YWx1ZSAoaW4gZEIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heD02XSAtIE1heGltdW0gZGlzcGxheWVkIHZhbHVlIChpbiBkQikuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MzAwXSAtIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD0xNTBdIC0gSGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtFbGVtZW50fENTU1NlbGVjdG9yfSBbb3B0aW9ucy5jb250YWluZXI9bnVsbF0gLSBDb250YWluZXIgZWxlbWVudFxuICogIGluIHdoaWNoIHRvIGluc2VydCB0aGUgY2FudmFzLiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtFbGVtZW50fENTU1NlbGVjdG9yfSBbb3B0aW9ucy5jYW52YXM9bnVsbF0gLSBDYW52YXMgZWxlbWVudFxuICogIGluIHdoaWNoIHRvIGRyYXcuIF9jb25zdGFudCBwYXJhbWV0ZXJfXG4gKlxuICogQHRvZG8gLSBleHBvc2UgbW9yZSBgZmZ0YCBjb25maWcgb3B0aW9uc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICpcbiAqIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAqICAgLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pXG4gKiAgIC50aGVuKGluaXQpXG4gKiAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKGVyci5zdGFjaykpO1xuICpcbiAqIGZ1bmN0aW9uIGluaXQoc3RyZWFtKSB7XG4gKiAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuICpcbiAqICAgY29uc3QgYXVkaW9Jbk5vZGUgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luTm9kZSh7XG4gKiAgICAgYXVkaW9Db250ZXh0OiBhdWRpb0NvbnRleHQsXG4gKiAgICAgc291cmNlTm9kZTogc291cmNlLFxuICogICB9KTtcbiAqXG4gKiAgIGNvbnN0IHNwZWN0cnVtID0gbmV3IGxmby5zaW5rLlNwZWN0cnVtRGlzcGxheSh7XG4gKiAgICAgY2FudmFzOiAnI3NwZWN0cnVtJyxcbiAqICAgfSk7XG4gKlxuICogICBhdWRpb0luTm9kZS5jb25uZWN0KHNwZWN0cnVtKTtcbiAqICAgYXVkaW9Jbk5vZGUuc3RhcnQoKTtcbiAqIH1cbiAqL1xuXG52YXIgU3BlY3RydW1EaXNwbGF5ID0gZnVuY3Rpb24gKF9CYXNlRGlzcGxheSkge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShTcGVjdHJ1bURpc3BsYXksIF9CYXNlRGlzcGxheSk7XG5cbiAgZnVuY3Rpb24gU3BlY3RydW1EaXNwbGF5KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTcGVjdHJ1bURpc3BsYXkpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChTcGVjdHJ1bURpc3BsYXkuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNwZWN0cnVtRGlzcGxheSkpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMsIGZhbHNlKSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFNwZWN0cnVtRGlzcGxheSwgW3tcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIHRoaXMuZmZ0ID0gbmV3IF9GZnQyLmRlZmF1bHQoe1xuICAgICAgICBzaXplOiB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUsXG4gICAgICAgIHdpbmRvdzogJ2hhbm4nLFxuICAgICAgICBub3JtOiAnbGluZWFyJ1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZmZ0LmluaXRTdHJlYW0odGhpcy5zdHJlYW1QYXJhbXMpO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU2lnbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NpZ25hbChmcmFtZSkge1xuICAgICAgdmFyIGJpbnMgPSB0aGlzLmZmdC5pbnB1dFNpZ25hbChmcmFtZS5kYXRhKTtcbiAgICAgIHZhciBuYnJCaW5zID0gYmlucy5sZW5ndGg7XG5cbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jYW52YXNIZWlnaHQ7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnBhcmFtcy5nZXQoJ3NjYWxlJyk7XG5cbiAgICAgIHZhciBiaW5XaWR0aCA9IHdpZHRoIC8gbmJyQmlucztcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMucGFyYW1zLmdldCgnY29sb3InKTtcblxuICAgICAgLy8gZXJyb3IgaGFuZGxpbmcgbmVlZHMgcmV2aWV3Li4uXG4gICAgICB2YXIgZXJyb3IgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ickJpbnM7IGkrKykge1xuICAgICAgICB2YXIgeDFGbG9hdCA9IGkgKiBiaW5XaWR0aCArIGVycm9yO1xuICAgICAgICB2YXIgeDFJbnQgPSBNYXRoLnJvdW5kKHgxRmxvYXQpO1xuICAgICAgICB2YXIgeDJGbG9hdCA9IHgxRmxvYXQgKyAoYmluV2lkdGggLSBlcnJvcik7XG4gICAgICAgIHZhciB4MkludCA9IE1hdGgucm91bmQoeDJGbG9hdCk7XG5cbiAgICAgICAgZXJyb3IgPSB4MkludCAtIHgyRmxvYXQ7XG5cbiAgICAgICAgaWYgKHgxSW50ICE9PSB4MkludCkge1xuICAgICAgICAgIHZhciBfd2lkdGggPSB4MkludCAtIHgxSW50O1xuICAgICAgICAgIHZhciBkYiA9IDIwICogKDAsIF9sb2cyLmRlZmF1bHQpKGJpbnNbaV0pO1xuICAgICAgICAgIHZhciB5ID0gdGhpcy5nZXRZUG9zaXRpb24oZGIgKiBzY2FsZSk7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHgxSW50LCB5LCBfd2lkdGgsIGhlaWdodCAtIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yIC09IGJpbldpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTcGVjdHJ1bURpc3BsYXk7XG59KF9CYXNlRGlzcGxheTMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNwZWN0cnVtRGlzcGxheTtcblxufSx7XCIuLi8uLi9jb21tb24vb3BlcmF0b3IvRmZ0XCI6MTU2LFwiLi4vdXRpbHMvZGlzcGxheS11dGlsc1wiOjE1MSxcIi4vQmFzZURpc3BsYXlcIjoxMzUsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvbWF0aC9sb2cxMFwiOjQsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlRGlzcGxheTIgPSByZXF1aXJlKCcuL0Jhc2VEaXNwbGF5Jyk7XG5cbnZhciBfQmFzZURpc3BsYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZURpc3BsYXkyKTtcblxudmFyIF9kaXNwbGF5VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9kaXNwbGF5LXV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgY29sb3I6IHtcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiAoMCwgX2Rpc3BsYXlVdGlscy5nZXRDb2xvcnMpKCd0cmFjZScpLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIGNvbG9yU2NoZW1lOiB7XG4gICAgdHlwZTogJ2VudW0nLFxuICAgIGRlZmF1bHQ6ICdub25lJyxcbiAgICBsaXN0OiBbJ25vbmUnLCAnaHVlJywgJ29wYWNpdHknXVxuICB9XG59O1xuXG4vKipcbiAqIERpc3BsYXkgYSByYW5nZSB2YWx1ZSBhcm91bmQgYSBtZWFuIHZhbHVlIChmb3IgZXhhbXBsZSBtZWFuXG4gKiBhbmQgc3RhbmRhcnQgZGV2aWF0aW9uKS5cbiAqXG4gKiBUaGlzIHNpbmsgY2FuIGhhbmRsZSBpbnB1dCBvZiB0eXBlIGB2ZWN0b3JgIG9mIGZyYW1lU2l6ZSA+PSAyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yPSdvcmFuZ2UnXSAtIENvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yU2NoZW1lPSdub25lJ10gLSBJZiBhIHRoaXJkIHZhbHVlIGlzIGF2YWlsYWJsZVxuICogIGluIHRoZSBpbnB1dCwgY2FuIGJlIHVzZWQgdG8gY29udHJvbCB0aGUgb3BhY2l0eSBvciB0aGUgaHVlLiBJZiBpbnB1dCBmcmFtZVxuICogIHNpemUgaXMgMiwgdGhpcyBwYXJhbSBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byBgbm9uZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW49LTFdIC0gTWluaW11bSB2YWx1ZSByZXByZXNlbnRlZCBpbiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXg9MV0gLSBNYXhpbXVtIHZhbHVlIHJlcHJlc2VudGVkIGluIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTMwMF0gLSBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTUwXSAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY29udGFpbmVyPW51bGxdIC0gQ29udGFpbmVyIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy4gX2NvbnN0YW50IHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7RWxlbWVudHxDU1NTZWxlY3Rvcn0gW29wdGlvbnMuY2FudmFzPW51bGxdIC0gQ2FudmFzIGVsZW1lbnRcbiAqICBpbiB3aGljaCB0byBkcmF3LiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTFdIC0gRHVyYXRpb24gKGluIHNlY29uZHMpIHJlcHJlc2VudGVkIGluXG4gKiAgdGhlIGNhbnZhcy4gX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlZmVyZW5jZVRpbWU9bnVsbF0gLSBPcHRpb25uYWwgcmVmZXJlbmNlIHRpbWUgdGhlXG4gKiAgZGlzcGxheSBzaG91bGQgY29uc2lkZXJlciBhcyB0aGUgb3JpZ2luLiBJcyBvbmx5IHVzZWZ1bGwgd2hlbiBzeW5jaHJvbml6aW5nXG4gKiAgc2V2ZXJhbCBkaXNwbGF5IHVzaW5nIHRoZSBgRGlzcGxheVN5bmNgIGNsYXNzLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y2xpZW50LnNpbmtcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICpcbiAqIGNvbnN0IEF1ZGlvQ29udGV4dCA9ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8wqB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KTtcbiAqIGNvbnN0IGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAqXG4gKiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gKiAgIC5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSB9KVxuICogICAudGhlbihpbml0KVxuICogICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIuc3RhY2spKTtcbiAqXG4gKiBmdW5jdGlvbiBpbml0KHN0cmVhbSkge1xuICogICBjb25zdCBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAqXG4gKiAgIGNvbnN0IGF1ZGlvSW5Ob2RlID0gbmV3IGxmby5zb3VyY2UuQXVkaW9Jbk5vZGUoe1xuICogICAgIHNvdXJjZU5vZGU6IHNvdXJjZSxcbiAqICAgICBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCxcbiAqICAgfSk7XG4gKlxuICogICAvLyBub3Qgc3VyZSBpdCBtYWtlIHNlbnMgYnV0Li4uXG4gKiAgIGNvbnN0IG1lYW5TdGRkZXYgPSBuZXcgbGZvLm9wZXJhdG9yLk1lYW5TdGRkZXYoKTtcbiAqXG4gKiAgIGNvbnN0IHRyYWNlRGlzcGxheSA9IG5ldyBsZm8uc2luay5UcmFjZURpc3BsYXkoe1xuICogICAgIGNhbnZhczogJyN0cmFjZScsXG4gKiAgIH0pO1xuICpcbiAqICAgY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogICBhdWRpb0luTm9kZS5jb25uZWN0KG1lYW5TdGRkZXYpO1xuICogICBtZWFuU3RkZGV2LmNvbm5lY3QodHJhY2VEaXNwbGF5KTtcbiAqXG4gKiAgIGF1ZGlvSW5Ob2RlLnN0YXJ0KCk7XG4gKiB9XG4gKi9cblxudmFyIFRyYWNlRGlzcGxheSA9IGZ1bmN0aW9uIChfQmFzZURpc3BsYXkpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoVHJhY2VEaXNwbGF5LCBfQmFzZURpc3BsYXkpO1xuXG4gIGZ1bmN0aW9uIFRyYWNlRGlzcGxheSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVHJhY2VEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKFRyYWNlRGlzcGxheS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoVHJhY2VEaXNwbGF5KSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucHJldkZyYW1lID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFRyYWNlRGlzcGxheSwgW3tcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIGlmICh0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPT09IDIpIHRoaXMucGFyYW1zLnNldCgnY29sb3JTY2hlbWUnLCAnbm9uZScpO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSwgZnJhbWVXaWR0aCwgcGl4ZWxzU2luY2VMYXN0RnJhbWUpIHtcbiAgICAgIHZhciBjb2xvclNjaGVtZSA9IHRoaXMucGFyYW1zLmdldCgnY29sb3JTY2hlbWUnKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBwcmV2RGF0YSA9IHRoaXMucHJldkZyYW1lID8gdGhpcy5wcmV2RnJhbWUuZGF0YSA6IG51bGw7XG4gICAgICB2YXIgZGF0YSA9IGZyYW1lLmRhdGE7XG5cbiAgICAgIHZhciBoYWxmUmFuZ2UgPSBkYXRhWzFdIC8gMjtcbiAgICAgIHZhciBtZWFuID0gdGhpcy5nZXRZUG9zaXRpb24oZGF0YVswXSk7XG4gICAgICB2YXIgbWluID0gdGhpcy5nZXRZUG9zaXRpb24oZGF0YVswXSAtIGhhbGZSYW5nZSk7XG4gICAgICB2YXIgbWF4ID0gdGhpcy5nZXRZUG9zaXRpb24oZGF0YVswXSArIGhhbGZSYW5nZSk7XG5cbiAgICAgIHZhciBwcmV2SGFsZlJhbmdlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZNZWFuID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZNaW4gPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldk1heCA9IHZvaWQgMDtcblxuICAgICAgaWYgKHByZXZEYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHByZXZIYWxmUmFuZ2UgPSBwcmV2RGF0YVsxXSAvIDI7XG4gICAgICAgIHByZXZNZWFuID0gdGhpcy5nZXRZUG9zaXRpb24ocHJldkRhdGFbMF0pO1xuICAgICAgICBwcmV2TWluID0gdGhpcy5nZXRZUG9zaXRpb24ocHJldkRhdGFbMF0gLSBwcmV2SGFsZlJhbmdlKTtcbiAgICAgICAgcHJldk1heCA9IHRoaXMuZ2V0WVBvc2l0aW9uKHByZXZEYXRhWzBdICsgcHJldkhhbGZSYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvciA9IHRoaXMucGFyYW1zLmdldCgnY29sb3InKTtcbiAgICAgIHZhciBncmFkaWVudCA9IHZvaWQgMDtcbiAgICAgIHZhciByZ2IgPSB2b2lkIDA7XG5cbiAgICAgIHN3aXRjaCAoY29sb3JTY2hlbWUpIHtcbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgcmdiID0gKDAsIF9kaXNwbGF5VXRpbHMuaGV4VG9SR0IpKGNvbG9yKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoJyArIHJnYi5qb2luKCcsJykgKyAnLCAwLjcpJztcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHVlJzpcbiAgICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgtcGl4ZWxzU2luY2VMYXN0RnJhbWUsIDAsIDAsIDApO1xuXG4gICAgICAgICAgaWYgKHByZXZEYXRhKSBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJ2hzbCgnICsgKDAsIF9kaXNwbGF5VXRpbHMuZ2V0SHVlKShwcmV2RGF0YVsyXSkgKyAnLCAxMDAlLCA1MCUpJyk7ZWxzZSBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJ2hzbCgnICsgKDAsIF9kaXNwbGF5VXRpbHMuZ2V0SHVlKShkYXRhWzJdKSArICcsIDEwMCUsIDUwJSknKTtcblxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnaHNsKCcgKyAoMCwgX2Rpc3BsYXlVdGlscy5nZXRIdWUpKGRhdGFbMl0pICsgJywgMTAwJSwgNTAlKScpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgICAgcmdiID0gKDAsIF9kaXNwbGF5VXRpbHMuaGV4VG9SR0IpKHRoaXMucGFyYW1zLmdldCgnY29sb3InKSk7XG4gICAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoLXBpeGVsc1NpbmNlTGFzdEZyYW1lLCAwLCAwLCAwKTtcblxuICAgICAgICAgIGlmIChwcmV2RGF0YSkgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKCcgKyByZ2Iuam9pbignLCcpICsgJywgJyArIHByZXZEYXRhWzJdICsgJyknKTtlbHNlIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAncmdiYSgnICsgcmdiLmpvaW4oJywnKSArICcsICcgKyBkYXRhWzJdICsgJyknKTtcblxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAncmdiYSgnICsgcmdiLmpvaW4oJywnKSArICcsICcgKyBkYXRhWzJdICsgJyknKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBkcmF3IHJhbmdlXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKDAsIG1lYW4pO1xuICAgICAgY3R4LmxpbmVUbygwLCBtYXgpO1xuXG4gICAgICBpZiAocHJldkRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgY3R4LmxpbmVUbygtcGl4ZWxzU2luY2VMYXN0RnJhbWUsIHByZXZNYXgpO1xuICAgICAgICBjdHgubGluZVRvKC1waXhlbHNTaW5jZUxhc3RGcmFtZSwgcHJldk1pbik7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lVG8oMCwgbWluKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgLy8gZHJhdyBtZWFuXG4gICAgICBpZiAoY29sb3JTY2hlbWUgPT09ICdub25lJyAmJiBwcmV2TWVhbikge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oLXBpeGVsc1NpbmNlTGFzdEZyYW1lLCBwcmV2TWVhbik7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgbWVhbik7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB0aGlzLnByZXZGcmFtZSA9IGZyYW1lO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJhY2VEaXNwbGF5O1xufShfQmFzZURpc3BsYXkzLmRlZmF1bHQpO1xuXG47XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRyYWNlRGlzcGxheTtcblxufSx7XCIuLi91dGlscy9kaXNwbGF5LXV0aWxzXCI6MTUxLFwiLi9CYXNlRGlzcGxheVwiOjEzNSxcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX2xvZyA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXRoL2xvZzEwJyk7XG5cbnZhciBfbG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZyk7XG5cbnZhciBfQmFzZURpc3BsYXkyID0gcmVxdWlyZSgnLi9CYXNlRGlzcGxheScpO1xuXG52YXIgX0Jhc2VEaXNwbGF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VEaXNwbGF5Mik7XG5cbnZhciBfUm1zID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL29wZXJhdG9yL1JtcycpO1xuXG52YXIgX1JtczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SbXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbG9nMTAgPSBfbG9nMi5kZWZhdWx0O1xuXG52YXIgZGVmaW5pdGlvbnMgPSB7XG4gIG9mZnNldDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogLTE0LFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9XG4gIH0sXG4gIG1pbjoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogLTgwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIG1heDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogNixcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICB3aWR0aDoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiA2LFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH1cblxuICAvKipcbiAgICogU2ltcGxlIFZVLU1ldGVyIHRvIHVzZWQgb24gYSBgc2lnbmFsYCBzdHJlYW0uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2xpZW50LnNpbmtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0cyBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PS0xNF0gLSBkQiBvZmZzZXQgYXBwbGllZCB0byB0aGUgc2lnbmFsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluPS04MF0gLSBNaW5pbXVtIGRpc3BsYXllZCB2YWx1ZSAoaW4gZEIpLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4PTZdIC0gTWF4aW11bSBkaXNwbGF5ZWQgdmFsdWUgKGluIGRCKS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTZdIC0gV2lkdGggb2YgdGhlIGRpc3BsYXkgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTUwXSAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8Q1NTU2VsZWN0b3J9IFtvcHRpb25zLmNvbnRhaW5lcj1udWxsXSAtIENvbnRhaW5lciBlbGVtZW50XG4gICAqICBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGNhbnZhcy5cbiAgICogQHBhcmFtIHtFbGVtZW50fENTU1NlbGVjdG9yfSBbb3B0aW9ucy5jYW52YXM9bnVsbF0gLSBDYW52YXMgZWxlbWVudFxuICAgKiAgaW4gd2hpY2ggdG8gZHJhdy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICAgKlxuICAgKiBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpO1xuICAgKlxuICAgKiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gICAqICAgLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pXG4gICAqICAgLnRoZW4oaW5pdClcbiAgICogICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIuc3RhY2spKTtcbiAgICpcbiAgICogZnVuY3Rpb24gaW5pdChzdHJlYW0pIHtcbiAgICogICBjb25zdCBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAgICpcbiAgICogICBjb25zdCBhdWRpb0luTm9kZSA9IG5ldyBsZm8uc291cmNlLkF1ZGlvSW5Ob2RlKHtcbiAgICogICAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICAgKiAgICAgc291cmNlTm9kZTogc291cmNlLFxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0IHZ1TWV0ZXIgPSBuZXcgbGZvLnNpbmsuVnVNZXRlckRpc3BsYXkoe1xuICAgKiAgICAgY2FudmFzOiAnI3Z1LW1ldGVyJyxcbiAgICogICB9KTtcbiAgICpcbiAgICogICBhdWRpb0luTm9kZS5jb25uZWN0KHZ1TWV0ZXIpO1xuICAgKiAgIGF1ZGlvSW5Ob2RlLnN0YXJ0KCk7XG4gICAqIH1cbiAgICovXG59O1xudmFyIFZ1TWV0ZXJEaXNwbGF5ID0gZnVuY3Rpb24gKF9CYXNlRGlzcGxheSkge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShWdU1ldGVyRGlzcGxheSwgX0Jhc2VEaXNwbGF5KTtcblxuICBmdW5jdGlvbiBWdU1ldGVyRGlzcGxheSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVnVNZXRlckRpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoVnVNZXRlckRpc3BsYXkuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFZ1TWV0ZXJEaXNwbGF5KSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucywgZmFsc2UpKTtcblxuICAgIF90aGlzLnJtc09wZXJhdG9yID0gbmV3IF9SbXMyLmRlZmF1bHQoKTtcblxuICAgIF90aGlzLmxhc3REQiA9IDA7XG4gICAgX3RoaXMucGVhayA9IHtcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgdGltZTogMFxuICAgIH07XG5cbiAgICBfdGhpcy5wZWFrTGlmZXRpbWUgPSAxOyAvLyBzZWNcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFZ1TWV0ZXJEaXNwbGF5LCBbe1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgICAgdGhpcy5ybXNPcGVyYXRvci5pbml0U3RyZWFtKHRoaXMuc3RyZWFtUGFyYW1zKTtcblxuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDA7IC8vIHNlY1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMucGFyYW1zLmdldCgnb2Zmc2V0Jyk7IC8vIG9mZnNldCB6ZXJvIG9mIHRoZSB2dSBtZXRlclxuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXNXaWR0aDtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgdmFyIGxhc3REQiA9IHRoaXMubGFzdERCO1xuICAgICAgdmFyIHBlYWsgPSB0aGlzLnBlYWs7XG5cbiAgICAgIHZhciByZWQgPSAnI2ZmMjEyMSc7XG4gICAgICB2YXIgeWVsbG93ID0gJyNmZmZmMWYnO1xuICAgICAgdmFyIGdyZWVuID0gJyMwMGZmMDAnO1xuXG4gICAgICAvLyBoYW5kbGUgY3VycmVudCBkYiB2YWx1ZVxuICAgICAgdmFyIHJtcyA9IHRoaXMucm1zT3BlcmF0b3IuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gICAgICB2YXIgZEIgPSAyMCAqIGxvZzEwKHJtcykgLSBvZmZzZXQ7XG5cbiAgICAgIC8vIHNsb3cgcmVsZWFzZSAoY291bGQgcHJvYmFibHkgYmUgaW1wcm92ZWQpXG4gICAgICBpZiAobGFzdERCID4gZEIpIGRCID0gbGFzdERCIC0gNjtcblxuICAgICAgLy8gaGFuZGxlIHBlYWtcbiAgICAgIGlmIChkQiA+IHBlYWsudmFsdWUgfHwgbm93IC0gcGVhay50aW1lID4gdGhpcy5wZWFrTGlmZXRpbWUpIHtcbiAgICAgICAgcGVhay52YWx1ZSA9IGRCO1xuICAgICAgICBwZWFrLnRpbWUgPSBub3c7XG4gICAgICB9XG5cbiAgICAgIHZhciB5MCA9IHRoaXMuZ2V0WVBvc2l0aW9uKDApO1xuICAgICAgdmFyIHkgPSB0aGlzLmdldFlQb3NpdGlvbihkQik7XG4gICAgICB2YXIgeVBlYWsgPSB0aGlzLmdldFlQb3NpdGlvbihwZWFrLnZhbHVlKTtcblxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwMDAwJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgdmFyIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIGhlaWdodCwgMCwgMCk7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgZ3JlZW4pO1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKChoZWlnaHQgLSB5MCkgLyBoZWlnaHQsIHllbGxvdyk7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgcmVkKTtcblxuICAgICAgLy8gZEJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCB5LCB3aWR0aCwgaGVpZ2h0IC0geSk7XG5cbiAgICAgIC8vIDAgZEIgbWFya2VyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJyNkY2RjZGMnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIHkwLCB3aWR0aCwgMik7XG5cbiAgICAgIC8vIHBlYWtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCB5UGVhaywgd2lkdGgsIDIpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB0aGlzLmxhc3REQiA9IGRCO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVnVNZXRlckRpc3BsYXk7XG59KF9CYXNlRGlzcGxheTMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFZ1TWV0ZXJEaXNwbGF5O1xuXG59LHtcIi4uLy4uL2NvbW1vbi9vcGVyYXRvci9SbXNcIjoxNjgsXCIuL0Jhc2VEaXNwbGF5XCI6MTM1LFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL21hdGgvbG9nMTBcIjo0LFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZURpc3BsYXkyID0gcmVxdWlyZSgnLi9CYXNlRGlzcGxheScpO1xuXG52YXIgX0Jhc2VEaXNwbGF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VEaXNwbGF5Mik7XG5cbnZhciBfTWluTWF4ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL29wZXJhdG9yL01pbk1heCcpO1xuXG52YXIgX01pbk1heDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NaW5NYXgpO1xuXG52YXIgX1JtcyA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9vcGVyYXRvci9SbXMnKTtcblxudmFyIF9SbXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm1zKTtcblxudmFyIF9kaXNwbGF5VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9kaXNwbGF5LXV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogKDAsIF9kaXNwbGF5VXRpbHMuZ2V0Q29sb3JzKSgnd2F2ZWZvcm0nKSxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfVxuICB9LFxuICBybXM6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH1cbiAgfVxufTtcblxuLyoqXG4gKiBEaXNwbGF5IGEgd2F2ZWZvcm0gKGFsb25nIHdpdGggb3B0aW9ubmFsIFJtcykgb2YgYSBnaXZlbiBgc2lnbmFsYCBpbnB1dCBpblxuICogYSBjYW52YXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IFtvcHRpb25zLmNvbG9ycz1bJ3dhdmVmb3JtJywgJ3JtcyddXSAtIEFycmF5XG4gKiAgY29udGFpbmluZyB0aGUgY29sb3IgY29kZXMgZm9yIHRoZSB3YXZlZm9ybSAoaW5kZXggMCkgYW5kIHJtcyAoaW5kZXggMSkuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ybXM9ZmFsc2VdIC0gU2V0IHRvIGB0cnVlYCB0byBkaXNwbGF5IHRoZSBybXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTFdIC0gRHVyYXRpb24gKGluIHNlY29uZHMpIHJlcHJlc2VudGVkIGluXG4gKiAgdGhlIGNhbnZhcy4gX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbj0tMV0gLSBNaW5pbXVtIHZhbHVlIHJlcHJlc2VudGVkIGluIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heD0xXSAtIE1heGltdW0gdmFsdWUgcmVwcmVzZW50ZWQgaW4gdGhlIGNhbnZhcy5cbiAqICBfZHluYW1pYyBwYXJhbWV0ZXJfXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MzAwXSAtIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD0xNTBdIC0gSGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gKiAgX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtFbGVtZW50fENTU1NlbGVjdG9yfSBbb3B0aW9ucy5jb250YWluZXI9bnVsbF0gLSBDb250YWluZXIgZWxlbWVudFxuICogIGluIHdoaWNoIHRvIGluc2VydCB0aGUgY2FudmFzLiBfY29uc3RhbnQgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtFbGVtZW50fENTU1NlbGVjdG9yfSBbb3B0aW9ucy5jYW52YXM9bnVsbF0gLSBDYW52YXMgZWxlbWVudFxuICogIGluIHdoaWNoIHRvIGRyYXcuIF9jb25zdGFudCBwYXJhbWV0ZXJfXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVmZXJlbmNlVGltZT1udWxsXSAtIE9wdGlvbm5hbCByZWZlcmVuY2UgdGltZSB0aGVcbiAqICBkaXNwbGF5IHNob3VsZCBjb25zaWRlcmVyIGFzIHRoZSBvcmlnaW4uIElzIG9ubHkgdXNlZnVsbCB3aGVuIHN5bmNocm9uaXppbmdcbiAqICBzZXZlcmFsIGRpc3BsYXkgdXNpbmcgdGhlIGBEaXNwbGF5U3luY2AgY2xhc3MuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjbGllbnQuc2lua1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcbiAqXG4gKiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gKiAgIC5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSB9KVxuICogICAudGhlbihpbml0KVxuICogICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIuc3RhY2spKTtcbiAqXG4gKiBmdW5jdGlvbiBpbml0KHN0cmVhbSkge1xuICogICBjb25zdCBhdWRpb0luID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG4gKlxuICogICBjb25zdCBhdWRpb0luTm9kZSA9IG5ldyBsZm8uc291cmNlLkF1ZGlvSW5Ob2RlKHtcbiAqICAgICBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCxcbiAqICAgICBzb3VyY2VOb2RlOiBhdWRpb0luLFxuICogICAgIGZyYW1lU2l6ZTogNTEyLFxuICogICB9KTtcbiAqXG4gKiAgIGNvbnN0IHdhdmVmb3JtRGlzcGxheSA9IG5ldyBsZm8uc2luay5XYXZlZm9ybURpc3BsYXkoe1xuICogICAgIGNhbnZhczogJyN3YXZlZm9ybScsXG4gKiAgICAgZHVyYXRpb246IDMuNSxcbiAqICAgICBybXM6IHRydWUsXG4gKiAgIH0pO1xuICpcbiAqICAgYXVkaW9Jbk5vZGUuY29ubmVjdCh3YXZlZm9ybURpc3BsYXkpO1xuICogICBhdWRpb0luTm9kZS5zdGFydCgpO1xuICogfSk7XG4gKi9cblxudmFyIFdhdmVmb3JtRGlzcGxheSA9IGZ1bmN0aW9uIChfQmFzZURpc3BsYXkpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoV2F2ZWZvcm1EaXNwbGF5LCBfQmFzZURpc3BsYXkpO1xuXG4gIGZ1bmN0aW9uIFdhdmVmb3JtRGlzcGxheShvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgV2F2ZWZvcm1EaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKFdhdmVmb3JtRGlzcGxheS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoV2F2ZWZvcm1EaXNwbGF5KSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucywgdHJ1ZSkpO1xuXG4gICAgX3RoaXMubWluTWF4T3BlcmF0b3IgPSBuZXcgX01pbk1heDIuZGVmYXVsdCgpO1xuICAgIF90aGlzLnJtc09wZXJhdG9yID0gbmV3IF9SbXMyLmRlZmF1bHQoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFdhdmVmb3JtRGlzcGxheSwgW3tcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIHRoaXMubWluTWF4T3BlcmF0b3IuaW5pdFN0cmVhbSh0aGlzLnN0cmVhbVBhcmFtcyk7XG4gICAgICB0aGlzLnJtc09wZXJhdG9yLmluaXRTdHJlYW0odGhpcy5zdHJlYW1QYXJhbXMpO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU2lnbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NpZ25hbChmcmFtZSwgZnJhbWVXaWR0aCwgcGl4ZWxzU2luY2VMYXN0RnJhbWUpIHtcbiAgICAgIC8vIGRyb3AgZnJhbWVzIHRoYXQgY2Fubm90IGJlIGRpc3BsYXllZFxuICAgICAgaWYgKGZyYW1lV2lkdGggPCAxKSByZXR1cm47XG5cbiAgICAgIHZhciBjb2xvcnMgPSB0aGlzLnBhcmFtcy5nZXQoJ2NvbG9ycycpO1xuICAgICAgdmFyIHNob3dSbXMgPSB0aGlzLnBhcmFtcy5nZXQoJ3JtcycpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdmFyIGRhdGEgPSBmcmFtZS5kYXRhO1xuICAgICAgdmFyIGlTYW1wbGVzUGVyUGl4ZWxzID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIGZyYW1lV2lkdGgpO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZnJhbWVXaWR0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc3RhcnQgPSBpbmRleCAqIGlTYW1wbGVzUGVyUGl4ZWxzO1xuICAgICAgICB2YXIgZW5kID0gaW5kZXggPT09IGZyYW1lV2lkdGggLSAxID8gdW5kZWZpbmVkIDogc3RhcnQgKyBpU2FtcGxlc1BlclBpeGVscztcbiAgICAgICAgdmFyIHNsaWNlID0gZGF0YS5zdWJhcnJheShzdGFydCwgZW5kKTtcblxuICAgICAgICB2YXIgbWluTWF4ID0gdGhpcy5taW5NYXhPcGVyYXRvci5pbnB1dFNpZ25hbChzbGljZSk7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5nZXRZUG9zaXRpb24obWluTWF4WzBdKTtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLmdldFlQb3NpdGlvbihtaW5NYXhbMV0pO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yc1swXTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGluZGV4LCBtaW5ZKTtcbiAgICAgICAgY3R4LmxpbmVUbyhpbmRleCwgbWF4WSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGlmIChzaG93Um1zKSB7XG4gICAgICAgICAgdmFyIHJtcyA9IHRoaXMucm1zT3BlcmF0b3IuaW5wdXRTaWduYWwoc2xpY2UpO1xuICAgICAgICAgIHZhciBybXNNYXhZID0gdGhpcy5nZXRZUG9zaXRpb24ocm1zKTtcbiAgICAgICAgICB2YXIgcm1zTWluWSA9IHRoaXMuZ2V0WVBvc2l0aW9uKC1ybXMpO1xuXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3JzWzFdO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKGluZGV4LCBybXNNaW5ZKTtcbiAgICAgICAgICBjdHgubGluZVRvKGluZGV4LCBybXNNYXhZKTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBXYXZlZm9ybURpc3BsYXk7XG59KF9CYXNlRGlzcGxheTMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdhdmVmb3JtRGlzcGxheTtcblxufSx7XCIuLi8uLi9jb21tb24vb3BlcmF0b3IvTWluTWF4XCI6MTYyLFwiLi4vLi4vY29tbW9uL29wZXJhdG9yL1Jtc1wiOjE2OCxcIi4uL3V0aWxzL2Rpc3BsYXktdXRpbHNcIjoxNTEsXCIuL0Jhc2VEaXNwbGF5XCI6MTM1LFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9CcmlkZ2UgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vc2luay9CcmlkZ2UnKTtcblxudmFyIF9CcmlkZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQnJpZGdlKTtcblxudmFyIF9Mb2dnZXIgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vc2luay9Mb2dnZXInKTtcblxudmFyIF9Mb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTG9nZ2VyKTtcblxudmFyIF9EYXRhUmVjb3JkZXIgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vc2luay9EYXRhUmVjb3JkZXInKTtcblxudmFyIF9EYXRhUmVjb3JkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0YVJlY29yZGVyKTtcblxudmFyIF9TaWduYWxSZWNvcmRlciA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9zaW5rL1NpZ25hbFJlY29yZGVyJyk7XG5cbnZhciBfU2lnbmFsUmVjb3JkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2lnbmFsUmVjb3JkZXIpO1xuXG52YXIgX0Jhc2VEaXNwbGF5ID0gcmVxdWlyZSgnLi9CYXNlRGlzcGxheScpO1xuXG52YXIgX0Jhc2VEaXNwbGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VEaXNwbGF5KTtcblxudmFyIF9CYXJDaGFydERpc3BsYXkgPSByZXF1aXJlKCcuL0JhckNoYXJ0RGlzcGxheScpO1xuXG52YXIgX0JhckNoYXJ0RGlzcGxheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXJDaGFydERpc3BsYXkpO1xuXG52YXIgX0JwZkRpc3BsYXkgPSByZXF1aXJlKCcuL0JwZkRpc3BsYXknKTtcblxudmFyIF9CcGZEaXNwbGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JwZkRpc3BsYXkpO1xuXG52YXIgX01hcmtlckRpc3BsYXkgPSByZXF1aXJlKCcuL01hcmtlckRpc3BsYXknKTtcblxudmFyIF9NYXJrZXJEaXNwbGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcmtlckRpc3BsYXkpO1xuXG52YXIgX1NpZ25hbERpc3BsYXkgPSByZXF1aXJlKCcuL1NpZ25hbERpc3BsYXknKTtcblxudmFyIF9TaWduYWxEaXNwbGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NpZ25hbERpc3BsYXkpO1xuXG52YXIgX1NvY2tldFNlbmQgPSByZXF1aXJlKCcuL1NvY2tldFNlbmQnKTtcblxudmFyIF9Tb2NrZXRTZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NvY2tldFNlbmQpO1xuXG52YXIgX1NwZWN0cnVtRGlzcGxheSA9IHJlcXVpcmUoJy4vU3BlY3RydW1EaXNwbGF5Jyk7XG5cbnZhciBfU3BlY3RydW1EaXNwbGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NwZWN0cnVtRGlzcGxheSk7XG5cbnZhciBfVHJhY2VEaXNwbGF5ID0gcmVxdWlyZSgnLi9UcmFjZURpc3BsYXknKTtcblxudmFyIF9UcmFjZURpc3BsYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJhY2VEaXNwbGF5KTtcblxudmFyIF9WdU1ldGVyRGlzcGxheSA9IHJlcXVpcmUoJy4vVnVNZXRlckRpc3BsYXknKTtcblxudmFyIF9WdU1ldGVyRGlzcGxheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WdU1ldGVyRGlzcGxheSk7XG5cbnZhciBfV2F2ZWZvcm1EaXNwbGF5ID0gcmVxdWlyZSgnLi9XYXZlZm9ybURpc3BsYXknKTtcblxudmFyIF9XYXZlZm9ybURpc3BsYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2F2ZWZvcm1EaXNwbGF5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gY2xpZW50IG9ubHlcbi8vIGNvbW1vblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBCcmlkZ2U6IF9CcmlkZ2UyLmRlZmF1bHQsXG4gIExvZ2dlcjogX0xvZ2dlcjIuZGVmYXVsdCxcbiAgRGF0YVJlY29yZGVyOiBfRGF0YVJlY29yZGVyMi5kZWZhdWx0LFxuICBTaWduYWxSZWNvcmRlcjogX1NpZ25hbFJlY29yZGVyMi5kZWZhdWx0LFxuXG4gIEJhc2VEaXNwbGF5OiBfQmFzZURpc3BsYXkyLmRlZmF1bHQsXG4gIEJhckNoYXJ0RGlzcGxheTogX0JhckNoYXJ0RGlzcGxheTIuZGVmYXVsdCxcbiAgQnBmRGlzcGxheTogX0JwZkRpc3BsYXkyLmRlZmF1bHQsXG4gIE1hcmtlckRpc3BsYXk6IF9NYXJrZXJEaXNwbGF5Mi5kZWZhdWx0LFxuICBTaWduYWxEaXNwbGF5OiBfU2lnbmFsRGlzcGxheTIuZGVmYXVsdCxcbiAgU29ja2V0U2VuZDogX1NvY2tldFNlbmQyLmRlZmF1bHQsXG4gIFNwZWN0cnVtRGlzcGxheTogX1NwZWN0cnVtRGlzcGxheTIuZGVmYXVsdCxcbiAgVHJhY2VEaXNwbGF5OiBfVHJhY2VEaXNwbGF5Mi5kZWZhdWx0LFxuICBWdU1ldGVyRGlzcGxheTogX1Z1TWV0ZXJEaXNwbGF5Mi5kZWZhdWx0LFxuICBXYXZlZm9ybURpc3BsYXk6IF9XYXZlZm9ybURpc3BsYXkyLmRlZmF1bHRcbn07XG5cbn0se1wiLi4vLi4vY29tbW9uL3NpbmsvQnJpZGdlXCI6MTc1LFwiLi4vLi4vY29tbW9uL3NpbmsvRGF0YVJlY29yZGVyXCI6MTc2LFwiLi4vLi4vY29tbW9uL3NpbmsvTG9nZ2VyXCI6MTc3LFwiLi4vLi4vY29tbW9uL3NpbmsvU2lnbmFsUmVjb3JkZXJcIjoxNzgsXCIuL0JhckNoYXJ0RGlzcGxheVwiOjEzNCxcIi4vQmFzZURpc3BsYXlcIjoxMzUsXCIuL0JwZkRpc3BsYXlcIjoxMzYsXCIuL01hcmtlckRpc3BsYXlcIjoxMzcsXCIuL1NpZ25hbERpc3BsYXlcIjoxMzgsXCIuL1NvY2tldFNlbmRcIjoxMzksXCIuL1NwZWN0cnVtRGlzcGxheVwiOjE0MCxcIi4vVHJhY2VEaXNwbGF5XCI6MTQxLFwiLi9WdU1ldGVyRGlzcGxheVwiOjE0MixcIi4vV2F2ZWZvcm1EaXNwbGF5XCI6MTQzfV0sMTQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5Jyk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkyKTtcblxudmFyIF9kZWZpbml0aW9ucztcblxudmFyIF9CYXNlTGZvID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvKTtcblxudmFyIF9Tb3VyY2VNaXhpbjIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL1NvdXJjZU1peGluJyk7XG5cbnZhciBfU291cmNlTWl4aW4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU291cmNlTWl4aW4yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmluaXRpb25zID0gKF9kZWZpbml0aW9ucyA9IHtcbiAgYXVkaW9CdWZmZXI6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH0sXG4gIGZyYW1lU2l6ZToge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiA1MTIsXG4gICAgY29uc3RhbnQ6IHRydWVcbiAgfSxcbiAgY2hhbm5lbDoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAwLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH0sXG4gIHByb2dyZXNzQ2FsbGJhY2s6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH1cbn0sICgwLCBfZGVmaW5lUHJvcGVydHkzLmRlZmF1bHQpKF9kZWZpbml0aW9ucywgJ3Byb2dyZXNzQ2FsbGJhY2snLCB7XG4gIHR5cGU6ICdhbnknLFxuICBkZWZhdWx0OiBudWxsLFxuICBudWxsYWJsZTogdHJ1ZSxcbiAgY29uc3RhbnQ6IHRydWVcbn0pLCAoMCwgX2RlZmluZVByb3BlcnR5My5kZWZhdWx0KShfZGVmaW5pdGlvbnMsICdhc3luYycsIHtcbiAgdHlwZTogJ2Jvb2xlYW4nLFxuICBkZWZhdWx0OiBmYWxzZVxufSksIF9kZWZpbml0aW9ucyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4vKipcbiAqIFNsaWNlIGFuIGBBdWRpb0J1ZmZlcmAgaW50byBzaWduYWwgYmxvY2tzIGFuZCBwcm9wYWdhdGUgdGhlIHJlc3VsdGluZyBmcmFtZXNcbiAqIHRocm91Z2ggdGhlIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgcGFyYW1ldGVyJyBkZWZhdWx0IHZhbHVlcy5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmF1ZGlvQnVmZmVyXSAtIEF1ZGlvIGJ1ZmZlciB0byBwcm9jZXNzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyYW1lU2l6ZT01MTJdIC0gU2l6ZSBvZiB0aGUgb3V0cHV0IGJsb2Nrcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jaGFubmVsPTBdIC0gTnVtYmVyIG9mIHRoZSBjaGFubmVsIHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvZ3Jlc3NDYWxsYmFjaz1udWxsXSAtIENhbGxiYWNrIHRvIGJlIGV4Y3V0ZWQgb24gZWFjaFxuICogIGZyYW1lIG91dHB1dCwgcmVjZWl2ZSBhcyBhcmd1bWVudCB0aGUgY3VycmVudCBwcm9ncmVzcyByYXRpby5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNsaWVudC5zb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICpcbiAqIGNvbnN0IGF1ZGlvSW5CdWZmZXIgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luQnVmZmVyKHtcbiAqICAgYXVkaW9CdWZmZXI6IGF1ZGlvQnVmZmVyLFxuICogICBmcmFtZVNpemU6IDUxMixcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHdhdmVmb3JtID0gbmV3IGxmby5zaW5rLldhdmVmb3JtKHtcbiAqICAgY2FudmFzOiAnI3dhdmVmb3JtJyxcbiAqICAgZHVyYXRpb246IDEsXG4gKiAgIGNvbG9yOiAnc3RlZWxibHVlJyxcbiAqICAgcm1zOiB0cnVlLFxuICogfSk7XG4gKlxuICogYXVkaW9JbkJ1ZmZlci5jb25uZWN0KHdhdmVmb3JtKTtcbiAqIGF1ZGlvSW5CdWZmZXIuc3RhcnQoKTtcbiAqL1xuXG52YXIgQXVkaW9JbkJ1ZmZlciA9IGZ1bmN0aW9uIChfU291cmNlTWl4aW4pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQXVkaW9JbkJ1ZmZlciwgX1NvdXJjZU1peGluKTtcblxuICBmdW5jdGlvbiBBdWRpb0luQnVmZmVyKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBBdWRpb0luQnVmZmVyKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKEF1ZGlvSW5CdWZmZXIuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEF1ZGlvSW5CdWZmZXIpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG5cbiAgICB2YXIgYXVkaW9CdWZmZXIgPSBfdGhpcy5wYXJhbXMuZ2V0KCdhdWRpb0J1ZmZlcicpO1xuXG4gICAgaWYgKCFhdWRpb0J1ZmZlcikgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwiYXVkaW9CdWZmZXJcIiBwYXJhbWV0ZXInKTtcblxuICAgIF90aGlzLmVuZFRpbWUgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGUgdGhlIGBzdHJlYW1QYXJhbXNgIGluIHRoZSBncmFwaCBhbmQgc3RhcnQgcHJvcGFnYXRpbmcgZnJhbWVzLlxuICAgKiBXaGVuIGNhbGxlZCwgdGhlIHNsaWNpbmcgb2YgdGhlIGdpdmVuIGBhdWRpb0J1ZmZlcmAgc3RhcnRzIGltbWVkaWF0ZWx5IGFuZFxuICAgKiBlYWNoIHJlc3VsdGluZyBmcmFtZSBpcyBwcm9wYWdhdGVkIGluIGdyYXBoLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NTdHJlYW1QYXJhbXN9XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcmVzZXRTdHJlYW19XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjbGllbnQuc291cmNlLkF1ZGlvSW5CdWZmZXIjc3RvcH1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShBdWRpb0luQnVmZmVyLCBbe1xuICAgIGtleTogJ3N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdFByb21pc2UgPT09IG51bGwpIC8vIGluaXQgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWRcbiAgICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0KCk7XG5cbiAgICAgICAgdGhpcy5pbml0UHJvbWlzZS50aGVuKHRoaXMuc3RhcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFubmVsID0gdGhpcy5wYXJhbXMuZ2V0KCdjaGFubmVsJyk7XG4gICAgICB2YXIgYXVkaW9CdWZmZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ2F1ZGlvQnVmZmVyJyk7XG4gICAgICB2YXIgYnVmZmVyID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG4gICAgICB0aGlzLmVuZFRpbWUgPSAwO1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5wcm9jZXNzRnJhbWUoYnVmZmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZSB0aGUgc3RyZWFtIGFuZCBzdG9wIHRoZSB3aG9sZSBncmFwaC4gV2hlbiBjYWxsZWQsIHRoZSBzbGljaW5nIG9mXG4gICAgICogdGhlIGBhdWRpb0J1ZmZlcmAgc3RvcHMgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI2ZpbmFsaXplU3RyZWFtfVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjbGllbnQuc291cmNlLkF1ZGlvSW5CdWZmZXIjc3RhcnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5maW5hbGl6ZVN0cmVhbSh0aGlzLmVuZFRpbWUpO1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKCkge1xuICAgICAgdmFyIGF1ZGlvQnVmZmVyID0gdGhpcy5wYXJhbXMuZ2V0KCdhdWRpb0J1ZmZlcicpO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnZnJhbWVTaXplJyk7XG4gICAgICB2YXIgc291cmNlU2FtcGxlUmF0ZSA9IGF1ZGlvQnVmZmVyLnNhbXBsZVJhdGU7XG4gICAgICB2YXIgZnJhbWVSYXRlID0gc291cmNlU2FtcGxlUmF0ZSAvIGZyYW1lU2l6ZTtcblxuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gZnJhbWVTaXplO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlID0gZnJhbWVSYXRlO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3NpZ25hbCc7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlID0gc291cmNlU2FtcGxlUmF0ZTtcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZUNvdW50ID0gZnJhbWVTaXplO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzRnJhbWUoYnVmZmVyKSB7XG4gICAgICB2YXIgYXN5bmMgPSB0aGlzLnBhcmFtcy5nZXQoJ2FzeW5jJyk7XG4gICAgICB2YXIgc2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIHByb2dyZXNzQ2FsbGJhY2sgPSB0aGlzLnBhcmFtcy5nZXQoJ3Byb2dyZXNzQ2FsbGJhY2snKSB8fCBub29wO1xuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICB2YXIgbmJyRnJhbWVzID0gTWF0aC5jZWlsKGJ1ZmZlci5sZW5ndGggLyBmcmFtZVNpemUpO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIHNsaWNlKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIGZyYW1lU2l6ZTtcbiAgICAgICAgdmFyIG5ickNvcHkgPSBNYXRoLm1pbihsZW5ndGggLSBvZmZzZXQsIGZyYW1lU2l6ZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmcmFtZVNpemU7IGorKykge1xuICAgICAgICAgIGRhdGFbal0gPSBqIDwgbmJyQ29weSA/IGJ1ZmZlcltvZmZzZXQgKyBqXSA6IDA7XG4gICAgICAgIH10aGF0LmZyYW1lLnRpbWUgPSBvZmZzZXQgLyBzYW1wbGVSYXRlO1xuICAgICAgICB0aGF0LmVuZFRpbWUgPSB0aGF0LmZyYW1lLnRpbWUgKyBuYnJDb3B5IC8gc2FtcGxlUmF0ZTtcbiAgICAgICAgdGhhdC5wcm9wYWdhdGVGcmFtZSgpO1xuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhpIC8gbmJyRnJhbWVzKTtcblxuICAgICAgICBpZiAoaSA8IG5ickZyYW1lcykge1xuICAgICAgICAgIGlmIChhc3luYykgc2V0VGltZW91dChzbGljZSwgMCk7ZWxzZSBzbGljZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQuZmluYWxpemVTdHJlYW0odGhhdC5lbmRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYWxsb3cgdGhlIGZvbGxvd2luZyB0byBkbyB0aGUgZXhwZWN0ZWQgdGhpbmc6XG4gICAgICAvLyBhdWRpb0luLmNvbm5lY3QocmVjb3JkZXIpO1xuICAgICAgLy8gYXVkaW9Jbi5zdGFydCgpO1xuICAgICAgLy8gcmVjb3JkZXIuc3RhcnQoKTtcbiAgICAgIHNldFRpbWVvdXQoc2xpY2UsIDApO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXVkaW9JbkJ1ZmZlcjtcbn0oKDAsIF9Tb3VyY2VNaXhpbjMuZGVmYXVsdCkoX0Jhc2VMZm8yLmRlZmF1bHQpKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQXVkaW9JbkJ1ZmZlcjtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCIuLi8uLi9jb3JlL1NvdXJjZU1peGluXCI6MTgzLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCI6MTcsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvKTtcblxudmFyIF9Tb3VyY2VNaXhpbjIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL1NvdXJjZU1peGluJyk7XG5cbnZhciBfU291cmNlTWl4aW4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU291cmNlTWl4aW4yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcblxudmFyIGRlZmluaXRpb25zID0ge1xuICBmcmFtZVNpemU6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogNTEyLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH0sXG4gIGNoYW5uZWw6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogMCxcbiAgICBjb25zdGFudDogdHJ1ZVxuICB9LFxuICBzb3VyY2VOb2RlOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBjb25zdGFudDogdHJ1ZVxuICB9LFxuICBhdWRpb0NvbnRleHQ6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH1cbn07XG5cbi8qKlxuICogVXNlIGEgYFdlYkF1ZGlvYCBub2RlIGFzIGEgc291cmNlIGZvciB0aGUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBwYXJhbWV0ZXInIGRlZmF1bHQgdmFsdWVzLlxuICogQHBhcmFtIHtBdWRpb05vZGV9IFtvcHRpb25zLnNvdXJjZU5vZGU9bnVsbF0gLSBBdWRpbyBub2RlIHRvIHByb2Nlc3NcbiAqICAobWFuZGF0b3J5KS5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBbb3B0aW9ucy5hdWRpb0NvbnRleHQ9bnVsbF0gLSBBdWRpbyBjb250ZXh0IHVzZWQgdG9cbiAqICBjcmVhdGUgdGhlIGF1ZGlvIG5vZGUgKG1hbmRhdG9yeSkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJhbWVTaXplPTUxMl0gLSBTaXplIG9mIHRoZSBvdXRwdXQgYmxvY2tzLCBkZWZpbmVcbiAqICB0aGUgYGZyYW1lU2l6ZWAgaW4gdGhlIGBzdHJlYW1QYXJhbXNgLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNoYW5uZWw9MF0gLSBOdW1iZXIgb2YgdGhlIGNoYW5uZWwgdG8gcHJvY2Vzcy5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNsaWVudC5zb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICpcbiAqIGNvbnN0IGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAqIGNvbnN0IHNpbmUgPSBhdWRpb0NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICogc2luZS5mcmVxdWVuY3kudmFsdWUgPSAyO1xuICpcbiAqIGNvbnN0IGF1ZGlvSW5Ob2RlID0gbmV3IGxmby5zb3VyY2UuQXVkaW9Jbk5vZGUoe1xuICogICBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCxcbiAqICAgc291cmNlTm9kZTogc2luZSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHNpZ25hbERpc3BsYXkgPSBuZXcgbGZvLnNpbmsuU2lnbmFsRGlzcGxheSh7XG4gKiAgIGNhbnZhczogJyNzaWduYWwnLFxuICogICBkdXJhdGlvbjogMSxcbiAqIH0pO1xuICpcbiAqIGF1ZGlvSW5Ob2RlLmNvbm5lY3Qoc2lnbmFsRGlzcGxheSk7XG4gKlxuICogLy8gc3RhcnQgdGhlIHNpbmUgb3NjaWxsYXRvciBub2RlIGFuZCB0aGUgbGZvIGdyYXBoXG4gKiBzaW5lLnN0YXJ0KCk7XG4gKiBhdWRpb0luTm9kZS5zdGFydCgpO1xuICovXG5cbnZhciBBdWRpb0luTm9kZSA9IGZ1bmN0aW9uIChfU291cmNlTWl4aW4pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQXVkaW9Jbk5vZGUsIF9Tb3VyY2VNaXhpbik7XG5cbiAgZnVuY3Rpb24gQXVkaW9Jbk5vZGUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEF1ZGlvSW5Ob2RlKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKEF1ZGlvSW5Ob2RlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShBdWRpb0luTm9kZSkpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcblxuICAgIHZhciBhdWRpb0NvbnRleHQgPSBfdGhpcy5wYXJhbXMuZ2V0KCdhdWRpb0NvbnRleHQnKTtcbiAgICB2YXIgc291cmNlTm9kZSA9IF90aGlzLnBhcmFtcy5nZXQoJ3NvdXJjZU5vZGUnKTtcblxuICAgIGlmICghYXVkaW9Db250ZXh0IHx8ICEoYXVkaW9Db250ZXh0IGluc3RhbmNlb2YgQXVkaW9Db250ZXh0KSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGBhdWRpb0NvbnRleHRgIHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKCFzb3VyY2VOb2RlIHx8ICEoc291cmNlTm9kZSBpbnN0YW5jZW9mIEF1ZGlvTm9kZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBgc291cmNlTm9kZWAgcGFyYW1ldGVyJyk7XG5cbiAgICBfdGhpcy5zb3VyY2VOb2RlID0gc291cmNlTm9kZTtcbiAgICBfdGhpcy5fY2hhbm5lbCA9IF90aGlzLnBhcmFtcy5nZXQoJ2NoYW5uZWwnKTtcbiAgICBfdGhpcy5fYmxvY2tEdXJhdGlvbiA9IG51bGw7XG5cbiAgICBfdGhpcy5wcm9jZXNzRnJhbWUgPSBfdGhpcy5wcm9jZXNzRnJhbWUuYmluZChfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZSB0aGUgYHN0cmVhbVBhcmFtc2AgaW4gdGhlIGdyYXBoIGFuZCBzdGFydCB0byBwcm9wYWdhdGUgc2lnbmFsXG4gICAqIGJsb2NrcyBwcm9kdWNlZCBieSB0aGUgYXVkaW8gbm9kZSBpbnRvIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzU3RyZWFtUGFyYW1zfVxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Jlc2V0U3RyZWFtfVxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y2xpZW50LnNvdXJjZS5BdWRpb0luTm9kZSNzdG9wfVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKEF1ZGlvSW5Ob2RlLCBbe1xuICAgIGtleTogJ3N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdFByb21pc2UgPT09IG51bGwpIC8vIGluaXQgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWRcbiAgICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0KCk7XG5cbiAgICAgICAgdGhpcy5pbml0UHJvbWlzZS50aGVuKHRoaXMuc3RhcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLnBhcmFtcy5nZXQoJ2F1ZGlvQ29udGV4dCcpO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnZnJhbWVTaXplJyk7XG5cbiAgICAgIHRoaXMuZnJhbWUudGltZSA9IDA7XG4gICAgICAvLyBAbm90ZTogcmVjcmVhdGUgZWFjaCB0aW1lIGJlY2F1c2Ugb2YgYSBmaXJlZm94IHdlaXJkIGJlaGF2aW9yXG4gICAgICB0aGlzLnNjcmlwdFByb2Nlc3NvciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoZnJhbWVTaXplLCAxLCAxKTtcbiAgICAgIHRoaXMuc2NyaXB0UHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gdGhpcy5wcm9jZXNzRnJhbWU7XG5cbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLnNvdXJjZU5vZGUuY29ubmVjdCh0aGlzLnNjcmlwdFByb2Nlc3Nvcik7XG4gICAgICB0aGlzLnNjcmlwdFByb2Nlc3Nvci5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluYWxpemUgdGhlIHN0cmVhbSBhbmQgc3RvcCB0aGUgd2hvbGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI2ZpbmFsaXplU3RyZWFtfVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjbGllbnQuc291cmNlLkF1ZGlvSW5Ob2RlI3N0YXJ0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdG9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZmluYWxpemVTdHJlYW0odGhpcy5mcmFtZS50aW1lKTtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zb3VyY2VOb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuc2NyaXB0UHJvY2Vzc29yLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMoKSB7XG4gICAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5wYXJhbXMuZ2V0KCdhdWRpb0NvbnRleHQnKTtcbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZyYW1lU2l6ZScpO1xuICAgICAgdmFyIHNhbXBsZVJhdGUgPSBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZTtcblxuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gZnJhbWVTaXplO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlID0gc2FtcGxlUmF0ZSAvIGZyYW1lU2l6ZTtcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICdzaWduYWwnO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVDb3VudCA9IGZyYW1lU2l6ZTtcblxuICAgICAgdGhpcy5fYmxvY2tEdXJhdGlvbiA9IGZyYW1lU2l6ZSAvIHNhbXBsZVJhdGU7XG5cbiAgICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFzaWNhbGx5IHRoZSBgc2NyaXB0UHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzYCBjYWxsYmFja1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NGcmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGcmFtZShlKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLmZyYW1lLmRhdGEgPSBlLmlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKHRoaXMuX2NoYW5uZWwpO1xuICAgICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuXG4gICAgICB0aGlzLmZyYW1lLnRpbWUgKz0gdGhpcy5fYmxvY2tEdXJhdGlvbjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEF1ZGlvSW5Ob2RlO1xufSgoMCwgX1NvdXJjZU1peGluMy5kZWZhdWx0KShfQmFzZUxmbzIuZGVmYXVsdCkpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBdWRpb0luTm9kZTtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCIuLi8uLi9jb3JlL1NvdXJjZU1peGluXCI6MTgzLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UnKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG52YXIgX3dzVXRpbHMgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vdXRpbHMvd3NVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcGFyYW1ldGVycyA9IHtcbiAgcG9ydDoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiA4MDAwLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH0sXG4gIHVybDoge1xuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgY29uc3RhbnQ6IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlIGFuIGxmbyBmcmFtZSBhcyBhIHNvY2tldCBtZXNzYWdlIGZyb20gYSBgbm9kZS5zaW5rLlNvY2tldFNlbmRgXG4gICAqIGluc3RhbmNlLlxuICAgKlxuICAgKiA8cCBjbGFzcz1cIndhcm5pbmdcIj5FeHBlcmltZW50YWw8L3A+XG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2xpZW50LnNvdXJjZVxuICAgKlxuICAgKiBAdG9kbyAtIGhhbmRsZSBpbml0IC8gc3RhcnQgcHJvcGVybHkuXG4gICAqL1xufTtcbnZhciBTb2NrZXRSZWNlaXZlID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFNvY2tldFJlY2VpdmUsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBTb2NrZXRSZWNlaXZlKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTb2NrZXRSZWNlaXZlKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKFNvY2tldFJlY2VpdmUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNvY2tldFJlY2VpdmUpKS5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIG9wdGlvbnMpKTtcblxuICAgIHZhciBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKC9eaHR0cC8sICd3cycpO1xuICAgIHZhciBhZGRyZXNzID0gX3RoaXMucGFyYW1zLmdldCgndXJsJykgfHwgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIHZhciBwb3J0ID0gX3RoaXMucGFyYW1zLmdldCgncG9ydCcpIHx8ICcnOyAvLyBldmVyeXRoaW5nIGZhbHN5IGJlY29tZXMgJydcbiAgICB2YXIgc29ja2V0QWRkcmVzcyA9IHByb3RvY29sICsgJy8vJyArIGFkZHJlc3MgKyAnOicgKyBwb3J0O1xuXG4gICAgX3RoaXMuX2Rpc3BhdGNoID0gX3RoaXMuX2Rpc3BhdGNoLmJpbmQoX3RoaXMpO1xuXG4gICAgX3RoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldChzb2NrZXRBZGRyZXNzKTtcbiAgICBfdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICBfdGhpcy5vcGVuZWRQcm9taXNlID0gbmV3IF9wcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIF90aGlzLnNvY2tldC5vbm9wZW4gPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IF90aGlzLl9kaXNwYXRjaDtcbiAgICBfdGhpcy5zb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFNvY2tldFJlY2VpdmUsIFt7XG4gICAga2V5OiAnaW5pdE1vZHVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRNb2R1bGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHByb21pc2VzID0gdGhpcy5uZXh0TW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICByZXR1cm4gbW9kLmluaXRNb2R1bGUoKTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLm9wZW5lZFByb21pc2UpO1xuICAgICAgLy8gd2FpdCBmb3IgY2hpbGRyZW4gcHJvbWlzZXMgYW5kIHNlbmQgSU5JVF9NT0RVTEVfQUNLXG4gICAgICBfcHJvbWlzZTIuZGVmYXVsdC5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gX3dzVXRpbHMuZW5jb2RlcnMuaW5pdE1vZHVsZUFjaygpO1xuICAgICAgICBfdGhpczIuc29ja2V0LnNlbmQoYnVmZmVyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgYW55IHR5cGVcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NjYWxhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTY2FsYXIoKSB7fVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcigpIHt9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKCkge31cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzRnJhbWUoZnJhbWUpIHtcbiAgICAgIHRoaXMucHJlcGFyZUZyYW1lKCk7XG4gICAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gICAgICB0aGlzLnByb3BhZ2F0ZUZyYW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuZCBkaXNwYXRjaCBpbmNvbW1pbmcgZnJhbWUgYWNjb3JkaW5nIHRvIG9wY29kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kaXNwYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXNwYXRjaChlKSB7XG4gICAgICB2YXIgYXJyYXlCdWZmZXIgPSBlLmRhdGE7XG4gICAgICB2YXIgb3Bjb2RlID0gX3dzVXRpbHMuZGVjb2RlcnMub3Bjb2RlKGFycmF5QnVmZmVyKTtcblxuICAgICAgc3dpdGNoIChvcGNvZGUpIHtcbiAgICAgICAgY2FzZSBfd3NVdGlscy5vcGNvZGVzLklOSVRfTU9EVUxFX1JFUTpcbiAgICAgICAgICB0aGlzLmluaXRNb2R1bGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfd3NVdGlscy5vcGNvZGVzLlBST0NFU1NfU1RSRUFNX1BBUkFNUzpcbiAgICAgICAgICB2YXIgcHJldlN0cmVhbVBhcmFtcyA9IF93c1V0aWxzLmRlY29kZXJzLnN0cmVhbVBhcmFtcyhhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF93c1V0aWxzLm9wY29kZXMuUkVTRVRfU1RSRUFNOlxuICAgICAgICAgIHRoaXMucmVzZXRTdHJlYW0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfd3NVdGlscy5vcGNvZGVzLkZJTkFMSVpFX1NUUkVBTTpcbiAgICAgICAgICB2YXIgZW5kVGltZSA9IF93c1V0aWxzLmRlY29kZXJzLmZpbmFsaXplU3RyZWFtKGFycmF5QnVmZmVyKTtcbiAgICAgICAgICB0aGlzLmZpbmFsaXplU3RyZWFtKGVuZFRpbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF93c1V0aWxzLm9wY29kZXMuUFJPQ0VTU19GUkFNRTpcbiAgICAgICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgICAgIHZhciBmcmFtZSA9IF93c1V0aWxzLmRlY29kZXJzLnByb2Nlc3NGcmFtZShhcnJheUJ1ZmZlciwgZnJhbWVTaXplKTtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NGcmFtZShmcmFtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTb2NrZXRSZWNlaXZlO1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNvY2tldFJlY2VpdmU7XG5cbn0se1wiLi4vLi4vY29tbW9uL3V0aWxzL3dzVXRpbHNcIjoxODEsXCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCI6MTIsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9FdmVudEluID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3NvdXJjZS9FdmVudEluJyk7XG5cbnZhciBfRXZlbnRJbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEluKTtcblxudmFyIF9BdWRpb0luQnVmZmVyID0gcmVxdWlyZSgnLi9BdWRpb0luQnVmZmVyJyk7XG5cbnZhciBfQXVkaW9JbkJ1ZmZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BdWRpb0luQnVmZmVyKTtcblxudmFyIF9BdWRpb0luTm9kZSA9IHJlcXVpcmUoJy4vQXVkaW9Jbk5vZGUnKTtcblxudmFyIF9BdWRpb0luTm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BdWRpb0luTm9kZSk7XG5cbnZhciBfU29ja2V0UmVjZWl2ZSA9IHJlcXVpcmUoJy4vU29ja2V0UmVjZWl2ZScpO1xuXG52YXIgX1NvY2tldFJlY2VpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU29ja2V0UmVjZWl2ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGNvbW1vblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBFdmVudEluOiBfRXZlbnRJbjIuZGVmYXVsdCxcblxuICBBdWRpb0luQnVmZmVyOiBfQXVkaW9JbkJ1ZmZlcjIuZGVmYXVsdCxcbiAgQXVkaW9Jbk5vZGU6IF9BdWRpb0luTm9kZTIuZGVmYXVsdCxcbiAgU29ja2V0UmVjZWl2ZTogX1NvY2tldFJlY2VpdmUyLmRlZmF1bHRcbn07XG4vLyBjbGllbnQgb25seVxuXG59LHtcIi4uLy4uL2NvbW1vbi9zb3VyY2UvRXZlbnRJblwiOjE3OSxcIi4vQXVkaW9JbkJ1ZmZlclwiOjE0NSxcIi4vQXVkaW9Jbk5vZGVcIjoxNDYsXCIuL1NvY2tldFJlY2VpdmVcIjoxNDd9XSwxNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIik7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBTeW5jaHJvbml6ZSBzZXZlcmFsIGRpc3BsYXkgc2lua3MgdG8gYSBjb21tb24gdGltZS5cbiAqXG4gKiBAcGFyYW0gey4uLkJhc2VEaXNwbGF5fSB2aWV3cyAtIExpc3Qgb2YgdGhlIGRpc3BsYXkgdG8gc3luY2hyb25pemUuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjbGllbnQudXRpbHNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4xID0gbmV3IGxmby5zb3VyY2UuRXZlbnRJbih7XG4gKiAgIGZyYW1lVHlwZTogJ3NjYWxhcicsXG4gKiAgIGZyYW1lU2l6ZTogMSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGJwZjEgPSBuZXcgbGZvLnNpbmsuQnBmRGlzcGxheSh7XG4gKiAgIGNhbnZhczogJyNicGYtMScsXG4gKiAgIGR1cmF0aW9uOiAyLFxuICogICBzdGFydFRpbWU6IDAsXG4gKiAgIG1pbjogMCxcbiAqICAgY29sb3JzOiBbJ3N0ZWVsYmx1ZSddLFxuICogfSk7XG4gKlxuICogZXZlbnRJbjEuY29ubmVjdChicGYxKTtcbiAqXG4gKiBjb25zdCBldmVudEluMiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICogICBmcmFtZVR5cGU6ICdzY2FsYXInLFxuICogICBmcmFtZVNpemU6IDEsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBicGYyID0gbmV3IGxmby5zaW5rLkJwZkRpc3BsYXkoe1xuICogICBjYW52YXM6ICcjYnBmLTInLFxuICogICBkdXJhdGlvbjogMixcbiAqICAgc3RhcnRUaW1lOiA3LFxuICogICBtaW46IDAsXG4gKiAgIGNvbG9yczogWydvcmFuZ2UnXSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGRpc3BsYXlTeW5jID0gbmV3IGxmby51dGlscy5EaXNwbGF5U3luYyhicGYxLCBicGYyKTtcbiAqXG4gKiBldmVudEluMi5jb25uZWN0KGJwZjIpO1xuICpcbiAqIGV2ZW50SW4xLnN0YXJ0KCk7XG4gKiBldmVudEluMi5zdGFydCgpO1xuICpcbiAqIGxldCB0aW1lID0gMDtcbiAqIGNvbnN0IHBlcmlvZCA9IDAuNDtcbiAqIGNvbnN0IG9mZnNldCA9IDcuMjtcbiAqXG4gKiAoZnVuY3Rpb24gZ2VuZXJhdGVEYXRhKCkge1xuICogICBjb25zdCB2ID0gTWF0aC5yYW5kb20oKTtcbiAqXG4gKiAgIGV2ZW50SW4xLnByb2Nlc3ModGltZSwgdik7XG4gKiAgIGV2ZW50SW4yLnByb2Nlc3ModGltZSArIG9mZnNldCwgdik7XG4gKlxuICogICB0aW1lICs9IHBlcmlvZDtcbiAqXG4gKiAgIHNldFRpbWVvdXQoZ2VuZXJhdGVEYXRhLCBwZXJpb2QgKiAxMDAwKTtcbiAqIH0oKSk7XG4gKi9cbnZhciBEaXNwbGF5U3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGlzcGxheVN5bmMoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgRGlzcGxheVN5bmMpO1xuXG4gICAgdGhpcy52aWV3cyA9IFtdO1xuXG4gICAgdGhpcy5hZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoRGlzcGxheVN5bmMsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmlld3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgdmlld3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmluc3RhbGwodmlldyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluc3RhbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zdGFsbCh2aWV3KSB7XG4gICAgICB0aGlzLnZpZXdzLnB1c2godmlldyk7XG5cbiAgICAgIHZpZXcuZGlzcGxheVN5bmMgPSB0aGlzO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRTaWJsaW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdFNpYmxpbmdzKGlTaGlmdCwgdGltZSwgdmlldykge1xuICAgICAgdGhpcy52aWV3cy5mb3JFYWNoKGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgIGlmIChkaXNwbGF5ICE9PSB2aWV3KSBkaXNwbGF5LnNoaWZ0Q2FudmFzKGlTaGlmdCwgdGltZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERpc3BsYXlTeW5jO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEaXNwbGF5U3luYztcblxufSx7XCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2fV0sMTUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9EaXNwbGF5U3luYyA9IHJlcXVpcmUoJy4vRGlzcGxheVN5bmMnKTtcblxudmFyIF9EaXNwbGF5U3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwbGF5U3luYyk7XG5cbnZhciBfd2luZG93cyA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi91dGlscy93aW5kb3dzJyk7XG5cbnZhciBfd2luZG93czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93aW5kb3dzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBEaXNwbGF5U3luYzogX0Rpc3BsYXlTeW5jMi5kZWZhdWx0LFxuICBpbml0V2luZG93czogX3dpbmRvd3MyLmRlZmF1bHRcbn07XG5cbn0se1wiLi4vLi4vY29tbW9uL3V0aWxzL3dpbmRvd3NcIjoxODAsXCIuL0Rpc3BsYXlTeW5jXCI6MTQ5fV0sMTUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBjb2xvcnMgPSBbJyM0NjgyQjQnLCAnI2ZmYTUwMCcsICcjMDBlNjAwJywgJyNmZjAwMDAnLCAnIzgwMDA4MCcsICcjMjI0MTUzJ107XG5cbnZhciBnZXRDb2xvcnMgPSBleHBvcnRzLmdldENvbG9ycyA9IGZ1bmN0aW9uIGdldENvbG9ycyh0eXBlLCBuYnIpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc2lnbmFsJzpcbiAgICAgIHJldHVybiBjb2xvcnNbMF07IC8vIHN0ZWVsYmx1ZVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYnBmJzpcbiAgICAgIGlmIChuYnIgPD0gY29sb3JzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY29sb3JzLnNsaWNlKDAsIG5icik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbG9ycyA9IGNvbG9ycy5zbGljZSgwKTtcbiAgICAgICAgd2hpbGUgKF9jb2xvcnMubGVuZ3RoIDwgbmJyKSB7XG4gICAgICAgICAgX2NvbG9ycy5wdXNoKGdldFJhbmRvbUNvbG9yKCkpO1xuICAgICAgICB9cmV0dXJuIF9jb2xvcnM7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXZlZm9ybSc6XG4gICAgICByZXR1cm4gW2NvbG9yc1swXSwgY29sb3JzWzVdXTsgLy8gc3RlZWxibHVlIC8gZGFya2JsdWVcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21hcmtlcic6XG4gICAgICByZXR1cm4gY29sb3JzWzNdOyAvLyByZWRcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NwZWN0cnVtJzpcbiAgICAgIHJldHVybiBjb2xvcnNbMl07IC8vIGdyZWVuXG4gICAgICBicmVhaztcbiAgICBjYXNlICd0cmFjZSc6XG4gICAgICByZXR1cm4gY29sb3JzWzFdOyAvLyBvcmFuZ2VcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhci1jaGFydCc6XG4gICAgICByZXR1cm4gY29sb3JzO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ4NDUwNi9yYW5kb20tY29sb3ItZ2VuZXJhdG9yLWluLWphdmFzY3JpcHRcbnZhciBnZXRSYW5kb21Db2xvciA9IGV4cG9ydHMuZ2V0UmFuZG9tQ29sb3IgPSBmdW5jdGlvbiBnZXRSYW5kb21Db2xvcigpIHtcbiAgdmFyIGxldHRlcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRicuc3BsaXQoJycpO1xuICB2YXIgY29sb3IgPSAnIyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgY29sb3IgKz0gbGV0dGVyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNildO1xuICB9XG4gIHJldHVybiBjb2xvcjtcbn07XG5cbi8vIHNjYWxlIGZyb20gZG9tYWluIFswLCAxXSB0byByYW5nZSBbMjcwLCAwXSB0byBjb25zdW1lIGluXG4vLyBoc2woeCwgMTAwJSwgNTAlKSBjb2xvciBzY2hlbWVcbnZhciBnZXRIdWUgPSBleHBvcnRzLmdldEh1ZSA9IGZ1bmN0aW9uIGdldEh1ZSh4KSB7XG4gIHZhciBkb21haW5NaW4gPSAwO1xuICB2YXIgZG9tYWluTWF4ID0gMTtcbiAgdmFyIHJhbmdlTWluID0gMjcwO1xuICB2YXIgcmFuZ2VNYXggPSAwO1xuXG4gIHJldHVybiAocmFuZ2VNYXggLSByYW5nZU1pbikgKiAoeCAtIGRvbWFpbk1pbikgLyAoZG9tYWluTWF4IC0gZG9tYWluTWluKSArIHJhbmdlTWluO1xufTtcblxudmFyIGhleFRvUkdCID0gZXhwb3J0cy5oZXhUb1JHQiA9IGZ1bmN0aW9uIGhleFRvUkdCKGhleCkge1xuICBoZXggPSBoZXguc3Vic3RyaW5nKDEsIDcpO1xuICB2YXIgciA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMCwgMiksIDE2KTtcbiAgdmFyIGcgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDIsIDQpLCAxNik7XG4gIHZhciBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpO1xuICByZXR1cm4gW3IsIGcsIGJdO1xufTtcblxufSx7fV0sMTUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgXzJQSSA9IE1hdGguUEkgKiAyO1xuXG4vLyBwbG90IChmcm9tIGh0dHA6Ly93d3cuZWFybGV2ZWwuY29tL3NjcmlwdHMvd2lkZ2V0cy8yMDEzMTAxMy9iaXF1YWRzMi5qcylcbi8vIHZhciBsZW4gPSA1MTI7XG4vLyB2YXIgbWFnUGxvdCA9IFtdO1xuLy8gZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuLy8gICB2YXIgdztcbi8vICAgaWYgKHBsb3RUeXBlID09IFwibGluZWFyXCIpXG4vLyAgICAgdyA9IGlkeCAvIChsZW4gLSAxKSAqIE1hdGguUEk7ICAvLyAwIHRvIHBpLCBsaW5lYXIgc2NhbGVcbi8vICAgZWxzZVxuLy8gICAgIHcgPSBNYXRoLmV4cChNYXRoLmxvZygxIC8gMC4wMDEpICogaWR4IC8gKGxlbiAtIDEpKSAqIDAuMDAxICogTWF0aC5QSTsgIC8vIDAuMDAxIHRvIDEsIHRpbWVzIHBpLCBsb2cgc2NhbGVcblxuLy8gICB2YXIgcGhpID0gTWF0aC5wb3coTWF0aC5zaW4ody8yKSwgMik7XG4vLyAgIHZhciB5ID0gTWF0aC5sb2coTWF0aC5wb3coYTArYTErYTIsIDIpIC0gNCooYTAqYTEgKyA0KmEwKmEyICsgYTEqYTIpKnBoaSArIDE2KmEwKmEyKnBoaSpwaGkpIC0gTWF0aC5sb2coTWF0aC5wb3coMStiMStiMiwgMikgLSA0KihiMSArIDQqYjIgKyBiMSpiMikqcGhpICsgMTYqYjIqcGhpKnBoaSk7XG4vLyAgIHkgPSB5ICogMTAgLyBNYXRoLkxOMTBcbi8vICAgaWYgKHkgPT0gLUluZmluaXR5KVxuLy8gICAgIHkgPSAtMjAwO1xuXG4vLyAgIGlmIChwbG90VHlwZSA9PSBcImxpbmVhclwiKVxuLy8gICAgIG1hZ1Bsb3QucHVzaChbaWR4IC8gKGxlbiAtIDEpICogRnMgLyAyLCB5XSk7XG4vLyAgIGVsc2Vcbi8vICAgICBtYWdQbG90LnB1c2goW2lkeCAvIChsZW4gLSAxKSAvIDIsIHldKTtcblxuLy8gICBpZiAoaWR4ID09IDApXG4vLyAgICAgbWluVmFsID0gbWF4VmFsID0geTtcbi8vICAgZWxzZSBpZiAoeSA8IG1pblZhbClcbi8vICAgICBtaW5WYWwgPSB5O1xuLy8gICBlbHNlIGlmICh5ID4gbWF4VmFsKVxuLy8gICAgIG1heFZhbCA9IHk7XG4vLyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgdHlwZToge1xuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBkZWZhdWx0OiAnbG93cGFzcycsXG4gICAgbGlzdDogWydsb3dwYXNzJywgJ2hpZ2hwYXNzJywgJ2JhbmRwYXNzX2NvbnN0YW50X3NraXJ0JywgJ2JhbmRwYXNzJywgJ2JhbmRwYXNzX2NvbnN0YW50X3BlYWsnLCAnbm90Y2gnLCAnYWxscGFzcycsICdwZWFraW5nJywgJ2xvd3NoZWxmJywgJ2hpZ2hzaGVsZiddLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9XG4gIH0sXG4gIGYwOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9XG4gIH0sXG4gIGdhaW46IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluOiAwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9XG4gIH0sXG4gIHE6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluOiAwLjAwMSwgLy8gUElQT19CSVFVQURfTUlOX1FcbiAgICAvLyBtYXg6IDEsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH1cbiAgfVxuICAvLyBiYW5kd2lkdGg6IHtcbiAgLy8gICB0eXBlOiAnZmxvYXQnLFxuICAvLyAgIGRlZmF1bHQ6IG51bGwsXG4gIC8vICAgbnVsbGFibGU6IHRydWUsXG4gIC8vICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH0sXG4gIC8vIH0sXG5cblxuICAvKipcbiAgICogQmlxdWFkIGZpbHRlciAoRGlyZWN0IGZvcm0gSSkuIElmIGlucHV0IGlzIG9mIHR5cGUgYHZlY3RvcmAgdGhlIGZpbHRlciBpc1xuICAgKiBhcHBsaWVkIG9uIGVhY2ggZGltZW5zaW9uIGkgcGFyYWxsZWwuXG4gICAqXG4gICAqIEJhc2VkIG9uIHRoZSBbXCJDb29rYm9vayBmb3JtdWxhZSBmb3IgYXVkaW8gRVEgYmlxdWFkIGZpbHRlciBjb2VmZmljaWVudHNcIl0oaHR0cDovL3d3dy5tdXNpY2RzcC5vcmcvZmlsZXMvQXVkaW8tRVEtQ29va2Jvb2sudHh0KVxuICAgKiBieSBSb2JlcnQgQnJpc3Rvdy1Kb2huc29uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHlwZT0nbG93cGFzcyddIC0gVHlwZSBvZiB0aGUgZmlsdGVyLiBBdmFpbGFibGVcbiAgICogIGZpbHRlcnM6ICdsb3dwYXNzJywgJ2hpZ2hwYXNzJywgJ2JhbmRwYXNzX2NvbnN0YW50X3NraXJ0JywgJ2JhbmRwYXNzX2NvbnN0YW50X3BlYWsnXG4gICAqICAoYWxpYXMgJ2JhbmRwYXNzJyksICdub3RjaCcsICdhbGxwYXNzJywgJ3BlYWtpbmcnLCAnbG93c2hlbGYnLCAnaGlnaHNoZWxmJy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmYwPTFdIC0gQ3V0b2ZmIG9yIGNlbnRlciBmcmVxdWVuY3kgb2YgdGhlIGZpbHRlclxuICAgKiAgYWNjb3JkaW5nIHRvIGl0cyB0eXBlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIEdhaW4gb2YgdGhlIGZpbHRlciAoaW4gZEIpLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucT0xXSAtIFF1YWxpdHkgZmFjdG9yIG9mIHRoZSBmaWx0ZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICpcbiAgICogY29uc3QgYXVkaW9JbkJ1ZmZlciA9IG5ldyBsZm8uc291cmNlLkF1ZGlvSW5CdWZmZXIoe1xuICAgKiAgIGF1ZGlvQnVmZmVyOiBidWZmZXIsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBiaXF1YWQgPSBuZXcgbGZvLm9wZXJhdG9yLkJpcXVhZCh7XG4gICAqICAgdHlwZTogJ2xvd3Bhc3MnLFxuICAgKiAgIGYwOiAyMDAwLFxuICAgKiAgIGdhaW46IDMsXG4gICAqICAgcTogMTIsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBzcGVjdHJ1bURpc3BsYXkgPSBuZXcgbGZvLnNpbmsuU3BlY3RydW1EaXNwbGF5KHtcbiAgICogICBjYW52YXM6ICcjc3BlY3RydW0nLFxuICAgKiB9KTtcbiAgICpcbiAgICogYXVkaW9JbkJ1ZmZlci5jb25uZWN0KGJpcXVhZCk7XG4gICAqIGJpcXVhZC5jb25uZWN0KHNwZWN0cnVtRGlzcGxheSk7XG4gICAqXG4gICAqIGF1ZGlvSW5CdWZmZXIuc3RhcnQoKTtcbiAgICovXG59O1xudmFyIEJpcXVhZCA9IGZ1bmN0aW9uIChfQmFzZUxmbykge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShCaXF1YWQsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBCaXF1YWQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEJpcXVhZCk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKEJpcXVhZC5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoQmlxdWFkKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoQmlxdWFkLCBbe1xuICAgIGtleTogJ29uUGFyYW1VcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhcmFtVXBkYXRlKG5hbWUsIHZhbHVlLCBtZXRhcykge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlQ29lZnMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2FsY3VsYXRlQ29lZnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlQ29lZnMoKSB7XG4gICAgICB2YXIgc2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG4gICAgICB2YXIgZnJhbWVUeXBlID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcblxuICAgICAgdmFyIHR5cGUgPSB0aGlzLnBhcmFtcy5nZXQoJ3R5cGUnKTtcbiAgICAgIHZhciBmMCA9IHRoaXMucGFyYW1zLmdldCgnZjAnKTtcbiAgICAgIHZhciBnYWluID0gdGhpcy5wYXJhbXMuZ2V0KCdnYWluJyk7XG4gICAgICB2YXIgcSA9IHRoaXMucGFyYW1zLmdldCgncScpO1xuICAgICAgLy8gY29uc3QgYmFuZHdpZHRoID0gdGhpcy5wYXJhbXMuZ2V0KCdiYW5kd2lkdGgnKTtcbiAgICAgIHZhciBiYW5kd2lkdGggPSBudWxsO1xuXG4gICAgICB2YXIgYjAgPSAwLFxuICAgICAgICAgIGIxID0gMCxcbiAgICAgICAgICBiMiA9IDAsXG4gICAgICAgICAgYTAgPSAwLFxuICAgICAgICAgIGExID0gMCxcbiAgICAgICAgICBhMiA9IDA7XG5cbiAgICAgIHZhciBBID0gcG93KDEwLCBnYWluIC8gNDApO1xuICAgICAgdmFyIHcwID0gXzJQSSAqIGYwIC8gc2FtcGxlUmF0ZTtcbiAgICAgIHZhciBjb3NXMCA9IGNvcyh3MCk7XG4gICAgICB2YXIgc2luVzAgPSBzaW4odzApO1xuICAgICAgdmFyIGFscGhhID0gdm9pZCAwOyAvLyBkZXBlbmQgb2YgdGhlIGZpbHRlciB0eXBlXG4gICAgICB2YXIgXzJSb290QUFscGhhID0gdm9pZCAwOyAvLyBpbnRlcm1lZGlhdGUgdmFsdWUgZm9yIGxvd3NoZWxmIGFuZCBoaWdoc2hlbGZcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8vIEgocykgPSAxIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICAgIGNhc2UgJ2xvd3Bhc3MnOlxuICAgICAgICAgIGFscGhhID0gc2luVzAgLyAoMiAqIHEpO1xuICAgICAgICAgIGIwID0gKDEgLSBjb3NXMCkgLyAyO1xuICAgICAgICAgIGIxID0gMSAtIGNvc1cwO1xuICAgICAgICAgIGIyID0gYjA7XG4gICAgICAgICAgYTAgPSAxICsgYWxwaGE7XG4gICAgICAgICAgYTEgPSAtMiAqIGNvc1cwO1xuICAgICAgICAgIGEyID0gMSAtIGFscGhhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBIKHMpID0gc14yIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICAgIGNhc2UgJ2hpZ2hwYXNzJzpcbiAgICAgICAgICBhbHBoYSA9IHNpblcwIC8gKDIgKiBxKTtcbiAgICAgICAgICBiMCA9ICgxICsgY29zVzApIC8gMjtcbiAgICAgICAgICBiMSA9IC0oMSArIGNvc1cwKTtcbiAgICAgICAgICBiMiA9IGIwO1xuICAgICAgICAgIGEwID0gMSArIGFscGhhO1xuICAgICAgICAgIGExID0gLTIgKiBjb3NXMDtcbiAgICAgICAgICBhMiA9IDEgLSBhbHBoYTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSChzKSA9IHMgLyAoc14yICsgcy9RICsgMSkgIChjb25zdGFudCBza2lydCBnYWluLCBwZWFrIGdhaW4gPSBRKVxuICAgICAgICBjYXNlICdiYW5kcGFzc19jb25zdGFudF9za2lydCc6XG4gICAgICAgICAgaWYgKGJhbmR3aWR0aCkge1xuICAgICAgICAgICAgLy8gc2luKHcwKSpzaW5oKCBsbigyKS8yICogQlcgKiB3MC9zaW4odzApICkgICAgICAgICAgIChjYXNlOiBCVylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxwaGEgPSBzaW5XMCAvICgyICogcSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYjAgPSBzaW5XMCAvIDI7XG4gICAgICAgICAgYjEgPSAwO1xuICAgICAgICAgIGIyID0gLWIwO1xuICAgICAgICAgIGEwID0gMSArIGFscGhhO1xuICAgICAgICAgIGExID0gLTIgKiBjb3NXMDtcbiAgICAgICAgICBhMiA9IDEgLSBhbHBoYTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSChzKSA9IChzL1EpIC8gKHNeMiArIHMvUSArIDEpICAgICAgKGNvbnN0YW50IDAgZEIgcGVhayBnYWluKVxuICAgICAgICBjYXNlICdiYW5kcGFzcyc6IC8vIGxvb2tzIGxpa2Ugd2hhdCBpcyBnbmVyYWxseSBjb25zaWRlcmVkIGFzIGEgYmFuZHBhc3NcbiAgICAgICAgY2FzZSAnYmFuZHBhc3NfY29uc3RhbnRfcGVhayc6XG4gICAgICAgICAgaWYgKGJhbmR3aWR0aCkge1xuICAgICAgICAgICAgLy8gc2luKHcwKSpzaW5oKCBsbigyKS8yICogQlcgKiB3MC9zaW4odzApICkgICAgICAgICAgIChjYXNlOiBCVylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxwaGEgPSBzaW5XMCAvICgyICogcSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYjAgPSBhbHBoYTtcbiAgICAgICAgICBiMSA9IDA7XG4gICAgICAgICAgYjIgPSAtYWxwaGE7XG4gICAgICAgICAgYTAgPSAxICsgYWxwaGE7XG4gICAgICAgICAgYTEgPSAtMiAqIGNvc1cwO1xuICAgICAgICAgIGEyID0gMSAtIGFscGhhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBIKHMpID0gKHNeMiArIDEpIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICAgIGNhc2UgJ25vdGNoJzpcbiAgICAgICAgICBhbHBoYSA9IHNpblcwIC8gKDIgKiBxKTtcbiAgICAgICAgICBiMCA9IDE7XG4gICAgICAgICAgYjEgPSAtMiAqIGNvc1cwO1xuICAgICAgICAgIGIyID0gMTtcbiAgICAgICAgICBhMCA9IDEgKyBhbHBoYTtcbiAgICAgICAgICBhMSA9IGIxO1xuICAgICAgICAgIGEyID0gMSAtIGFscGhhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBIKHMpID0gKHNeMiAtIHMvUSArIDEpIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICAgIGNhc2UgJ2FsbHBhc3MnOlxuICAgICAgICAgIGFscGhhID0gc2luVzAgLyAoMiAqIHEpO1xuICAgICAgICAgIGIwID0gMSAtIGFscGhhO1xuICAgICAgICAgIGIxID0gLTIgKiBjb3NXMDtcbiAgICAgICAgICBiMiA9IDEgKyBhbHBoYTtcbiAgICAgICAgICBhMCA9IGIyO1xuICAgICAgICAgIGExID0gYjE7XG4gICAgICAgICAgYTIgPSBiMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSChzKSA9IChzXjIgKyBzKihBL1EpICsgMSkgLyAoc14yICsgcy8oQSpRKSArIDEpXG4gICAgICAgIGNhc2UgJ3BlYWtpbmcnOlxuICAgICAgICAgIGlmIChiYW5kd2lkdGgpIHtcbiAgICAgICAgICAgIC8vIHNpbih3MCkqc2luaCggbG4oMikvMiAqIEJXICogdzAvc2luKHcwKSApICAgICAgICAgICAoY2FzZTogQlcpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhID0gc2luVzAgLyAoMiAqIHEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGIwID0gMSArIGFscGhhICogQTtcbiAgICAgICAgICBiMSA9IC0yICogY29zVzA7XG4gICAgICAgICAgYjIgPSAxIC0gYWxwaGEgKiBBO1xuICAgICAgICAgIGEwID0gMSArIGFscGhhIC8gQTtcbiAgICAgICAgICBhMSA9IGIxO1xuICAgICAgICAgIGEyID0gMSAtIGFscGhhIC8gQTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSChzKSA9IEEgKiAoc14yICsgKHNxcnQoQSkvUSkqcyArIEEpLyhBKnNeMiArIChzcXJ0KEEpL1EpKnMgKyAxKVxuICAgICAgICBjYXNlICdsb3dzaGVsZic6XG4gICAgICAgICAgYWxwaGEgPSBzaW5XMCAvICgyICogcSk7XG4gICAgICAgICAgXzJSb290QUFscGhhID0gMiAqIHNxcnQoQSkgKiBhbHBoYTtcblxuICAgICAgICAgIGIwID0gQSAqIChBICsgMSAtIChBIC0gMSkgKiBjb3NXMCArIF8yUm9vdEFBbHBoYSk7XG4gICAgICAgICAgYjEgPSAyICogQSAqIChBIC0gMSAtIChBICsgMSkgKiBjb3NXMCk7XG4gICAgICAgICAgYjIgPSBBICogKEEgKyAxIC0gKEEgLSAxKSAqIGNvc1cwIC0gXzJSb290QUFscGhhKTtcbiAgICAgICAgICBhMCA9IEEgKyAxICsgKEEgLSAxKSAqIGNvc1cwICsgXzJSb290QUFscGhhO1xuICAgICAgICAgIGExID0gLTIgKiAoQSAtIDEgKyAoQSArIDEpICogY29zVzApO1xuICAgICAgICAgIGEyID0gQSArIDEgKyAoQSAtIDEpICogY29zVzAgLSBfMlJvb3RBQWxwaGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEgocykgPSBBICogKEEqc14yICsgKHNxcnQoQSkvUSkqcyArIDEpLyhzXjIgKyAoc3FydChBKS9RKSpzICsgQSlcbiAgICAgICAgY2FzZSAnaGlnaHNoZWxmJzpcbiAgICAgICAgICBhbHBoYSA9IHNpblcwIC8gKDIgKiBxKTtcbiAgICAgICAgICBfMlJvb3RBQWxwaGEgPSAyICogc3FydChBKSAqIGFscGhhO1xuXG4gICAgICAgICAgYjAgPSBBICogKEEgKyAxICsgKEEgLSAxKSAqIGNvc1cwICsgXzJSb290QUFscGhhKTtcbiAgICAgICAgICBiMSA9IC0yICogQSAqIChBIC0gMSArIChBICsgMSkgKiBjb3NXMCk7XG4gICAgICAgICAgYjIgPSBBICogKEEgKyAxICsgKEEgLSAxKSAqIGNvc1cwIC0gXzJSb290QUFscGhhKTtcbiAgICAgICAgICBhMCA9IEEgKyAxIC0gKEEgLSAxKSAqIGNvc1cwICsgXzJSb290QUFscGhhO1xuICAgICAgICAgIGExID0gMiAqIChBIC0gMSAtIChBICsgMSkgKiBjb3NXMCk7XG4gICAgICAgICAgYTIgPSBBICsgMSAtIChBIC0gMSkgKiBjb3NXMCAtIF8yUm9vdEFBbHBoYTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvZWZzID0ge1xuICAgICAgICBiMDogYjAgLyBhMCxcbiAgICAgICAgYjE6IGIxIC8gYTAsXG4gICAgICAgIGIyOiBiMiAvIGEwLFxuICAgICAgICBhMTogYTEgLyBhMCxcbiAgICAgICAgYTI6IGEyIC8gYTBcbiAgICAgIH07XG5cbiAgICAgIC8vIHJlc2V0IHN0YXRlXG4gICAgICBpZiAoZnJhbWVUeXBlID09PSAnc2lnbmFsJykge1xuICAgICAgICB0aGlzLnN0YXRlID0geyB4MTogMCwgeDI6IDAsIHkxOiAwLCB5MjogMCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICB4MTogbmV3IEZsb2F0MzJBcnJheShmcmFtZVNpemUpLFxuICAgICAgICAgIHgyOiBuZXcgRmxvYXQzMkFycmF5KGZyYW1lU2l6ZSksXG4gICAgICAgICAgeTE6IG5ldyBGbG9hdDMyQXJyYXkoZnJhbWVTaXplKSxcbiAgICAgICAgICB5MjogbmV3IEZsb2F0MzJBcnJheShmcmFtZVNpemUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgICAgLy8gaWYgbm8gYHNhbXBsZVJhdGVgIG9yIGBzYW1wbGVSYXRlYCBpcyAwIHdlIHNoYWxsIGhhbHQhXG4gICAgICB2YXIgc2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG5cbiAgICAgIGlmICghc2FtcGxlUmF0ZSB8fCBzYW1wbGVSYXRlIDw9IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzYW1wbGVSYXRlIHZhbHVlICgwKSBmb3IgYmlxdWFkJyk7XG5cbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUNvZWZzKCk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgdmFyIGluRGF0YSA9IGZyYW1lLmRhdGE7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdmFyIGNvZWZzID0gdGhpcy5jb2VmcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgICB2YXIgeCA9IGluRGF0YVtpXTtcbiAgICAgICAgdmFyIHkgPSBjb2Vmcy5iMCAqIHggKyBjb2Vmcy5iMSAqIHN0YXRlLngxW2ldICsgY29lZnMuYjIgKiBzdGF0ZS54MltpXSAtIGNvZWZzLmExICogc3RhdGUueTFbaV0gLSBjb2Vmcy5hMiAqIHN0YXRlLnkyW2ldO1xuXG4gICAgICAgIG91dERhdGFbaV0gPSB5O1xuXG4gICAgICAgIC8vIHVwZGF0ZSBzdGF0ZXNcbiAgICAgICAgc3RhdGUueDJbaV0gPSBzdGF0ZS54MVtpXTtcbiAgICAgICAgc3RhdGUueDFbaV0gPSB4O1xuICAgICAgICBzdGF0ZS55MltpXSA9IHN0YXRlLnkxW2ldO1xuICAgICAgICBzdGF0ZS55MVtpXSA9IHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgICB2YXIgaW5EYXRhID0gZnJhbWUuZGF0YTtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB2YXIgY29lZnMgPSB0aGlzLmNvZWZzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gaW5EYXRhW2ldO1xuICAgICAgICB2YXIgeSA9IGNvZWZzLmIwICogeCArIGNvZWZzLmIxICogc3RhdGUueDEgKyBjb2Vmcy5iMiAqIHN0YXRlLngyIC0gY29lZnMuYTEgKiBzdGF0ZS55MSAtIGNvZWZzLmEyICogc3RhdGUueTI7XG5cbiAgICAgICAgb3V0RGF0YVtpXSA9IHk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlc1xuICAgICAgICBzdGF0ZS54MiA9IHN0YXRlLngxO1xuICAgICAgICBzdGF0ZS54MSA9IHg7XG4gICAgICAgIHN0YXRlLnkyID0gc3RhdGUueTE7XG4gICAgICAgIHN0YXRlLnkxID0geTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJpcXVhZDtcbn0oX0Jhc2VMZm8zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCaXF1YWQ7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBtaW46IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWluOiAtSW5maW5pdHksXG4gICAgbWF4OiArSW5maW5pdHlcbiAgfSxcbiAgbWF4OiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbjogLUluZmluaXR5LFxuICAgIG1heDogK0luZmluaXR5XG4gIH1cbn07XG5cbi8qKlxuICogQ2xpcCBpbmNvbW1pbmcgYWNjb3JkaW5nIHRvIGdpdmVuIGBtaW5gIGFuZCBgbWF4YCBwYXJhbWV0ZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtdGVyc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbj0wXSAtIE1pbmltdW0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXg9MV0gLSBNYXhpbXVtIHZhbHVlXG4gKi9cblxudmFyIENsaXAgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQ2xpcCwgX0Jhc2VMZm8pO1xuXG4gIGZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIENsaXApO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChDbGlwLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShDbGlwKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoQ2xpcCwgW3tcbiAgICBrZXk6ICdpbnB1dFZlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0VmVjdG9yKGRhdGEpIHtcbiAgICAgIHZhciBtaW4gPSB0aGlzLnBhcmFtcy5nZXQoJ21pbicpO1xuICAgICAgdmFyIG1heCA9IHRoaXMucGFyYW1zLmdldCgnbWF4Jyk7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG5cbiAgICAgIC8vIEB0b2RvIC0gY291bGQgaGFuZGxlIHZlY3RvciBhcyBtaW4gYW5kIG1heFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgICBvdXREYXRhW2ldID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIGRhdGFbaV0pKTtcbiAgICAgIH1yZXR1cm4gb3V0RGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5kYXRhID0gdGhpcy5pbnB1dFZlY3RvcihmcmFtZS5kYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFNpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0U2lnbmFsKGRhdGEpIHtcbiAgICAgIHZhciBtaW4gPSB0aGlzLnBhcmFtcy5nZXQoJ21pbicpO1xuICAgICAgdmFyIG1heCA9IHRoaXMucGFyYW1zLmdldCgnbWF4Jyk7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspIHtcbiAgICAgICAgb3V0RGF0YVtpXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCBkYXRhW2ldKSk7XG4gICAgICB9cmV0dXJuIG91dERhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICAgIHRoaXMuZnJhbWUuZGF0YSA9IHRoaXMuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDbGlwO1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENsaXA7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgUEkgPSBNYXRoLlBJO1xuXG4vLyBEY3QgVHlwZSAyIC0gb3J0aG9nb25hbCBtYXRyaXggc2NhbGluZ1xuZnVuY3Rpb24gZ2V0RGN0V2VpZ2h0cyhvcmRlciwgTikge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2h0ayc7XG5cbiAgdmFyIHdlaWdodHMgPSBuZXcgRmxvYXQzMkFycmF5KE4gKiBvcmRlcik7XG4gIHZhciBwaU92ZXJOID0gUEkgLyBOO1xuICB2YXIgc2NhbGUwID0gMSAvIHNxcnQoMik7XG4gIHZhciBzY2FsZSA9IHNxcnQoMiAvIE4pO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgb3JkZXI7IGsrKykge1xuICAgIHZhciBzID0gayA9PT0gMCA/IHNjYWxlMCAqIHNjYWxlIDogc2NhbGU7XG4gICAgLy8gY29uc3QgcyA9IHNjYWxlOyAvLyBydGEgZG9lc24ndCBhcHBseSBrPTAgc2NhbGluZ1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBOOyBuKyspIHtcbiAgICAgIHdlaWdodHNbayAqIE4gKyBuXSA9IHMgKiBjb3MoayAqIChuICsgMC41KSAqIHBpT3Zlck4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3ZWlnaHRzO1xufVxuXG52YXIgZGVmaW5pdGlvbnMgPSB7XG4gIG9yZGVyOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDEyLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBEaXNjcmV0ZSBDb3NpbmUgVHJhbnNmb3JtIG9mIGFuIGlucHV0IGBzaWduYWxgIG9yIGB2ZWN0b3JgLlxuICogKEhUSyBzdHlsZSB3ZWlnaHRpbmcpLlxuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9yZGVyPTEyXSAtIE51bWJlciBvZiBjb21wdXRlZCBiaW5zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogLy8gYXNzdW1pbmcgc29tZSBhdWRpbyBidWZmZXJcbiAqIGNvbnN0IHNvdXJjZSA9IG5ldyBBdWRpb0luQnVmZmVyKHtcbiAqICAgYXVkaW9CdWZmZXI6IGF1ZGlvQnVmZmVyLFxuICogICB1c2VXb3JrZXI6IGZhbHNlLFxuICogfSk7XG4gKlxuICogY29uc3Qgc2xpY2VyID0gbmV3IFNsaWNlcih7XG4gKiAgIGZyYW1lU2l6ZTogNTEyLFxuICogICBob3BTaXplOiA1MTIsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBkY3QgPSBuZXcgRGN0KHtcbiAqICAgb3JkZXI6IDEyLFxuICogfSk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogc291cmNlLmNvbm5lY3Qoc2xpY2VyKTtcbiAqIHNsaWNlci5jb25uZWN0KGRjdCk7XG4gKiBkY3QuY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIHNvdXJjZS5zdGFydCgpO1xuICovXG5cbnZhciBEY3QgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoRGN0LCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gRGN0KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBEY3QpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChEY3QuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERjdCkpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoRGN0LCBbe1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgICAgdmFyIG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuICAgICAgdmFyIGluRnJhbWVTaXplID0gcHJldlN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG5cbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IG9yZGVyO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3ZlY3Rvcic7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5kZXNjcmlwdGlvbiA9IFtdO1xuXG4gICAgICB0aGlzLndlaWdodE1hdHJpeCA9IGdldERjdFdlaWdodHMob3JkZXIsIGluRnJhbWVTaXplKTtcblxuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGBEY3RgIG9wZXJhdG9yIGluIGBzdGFuZGFsb25lYCBtb2RlIChpLmUuIG91dHNpZGUgb2YgYSBncmFwaCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgLSBJbnB1dCB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IC0gRGN0IG9mIHRoZSBpbnB1dCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZGN0ID0gbmV3IGxmby5vcGVyYXRvci5EY3QoeyBvcmRlcjogMTIgfSk7XG4gICAgICogLy8gbWFuZGF0b3J5IGZvciB1c2UgaW4gc3RhbmRhbG9uZSBtb2RlXG4gICAgICogZGN0LmluaXRTdHJlYW0oeyBmcmFtZVNpemU6IDUxMiwgZnJhbWVUeXBlOiAnc2lnbmFsJyB9KTtcbiAgICAgKiBkY3QuaW5wdXRTaWduYWwoZGF0YSk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lucHV0U2lnbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5wdXRTaWduYWwodmFsdWVzKSB7XG4gICAgICB2YXIgb3JkZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ29yZGVyJyk7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgIHZhciBvdXRGcmFtZSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICAgIHZhciB3ZWlnaHRzID0gdGhpcy53ZWlnaHRNYXRyaXg7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3JkZXI7IGsrKykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gayAqIGZyYW1lU2l6ZTtcbiAgICAgICAgb3V0RnJhbWVba10gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZnJhbWVTaXplOyBuKyspIHtcbiAgICAgICAgICBvdXRGcmFtZVtrXSArPSB2YWx1ZXNbbl0gKiB3ZWlnaHRzW29mZnNldCArIG5dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRGcmFtZTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICAgIHRoaXMuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmVjdG9yKGZyYW1lKSB7XG4gICAgICB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGN0O1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERjdDtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfZ2V0MiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXQnKTtcblxudmFyIF9nZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Mik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzaW1wbGVMaW5lYXJSZWdyZXNzaW9uKHZhbHVlcywgZHQpIHtcbiAgLy8gbWVhbnNcbiAgdmFyIHhTdW0gPSAwO1xuICB2YXIgeVN1bSA9IDA7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB4U3VtICs9IGkgKiBkdDtcbiAgICB5U3VtICs9IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHZhciB4TWVhbiA9IHhTdW0gLyBsZW5ndGg7XG4gIHZhciB5TWVhbiA9IHlTdW0gLyBsZW5ndGg7XG5cbiAgdmFyIHN1bURpZmZYTWVhblNxdWFyZWQgPSAwOyAvLyBzdW1bIHBvdygoeCAtIHhNZWFuKSwgMikgXVxuICB2YXIgc3VtRGlmZllNZWFuU3F1YXJlZCA9IDA7IC8vIHN1bVsgcG93KCh5IC0geU1lYW4pLCAyKSBdXG4gIHZhciBzdW1EaWZmWFlNZWFuID0gMDsgLy8gc3VtWyAoeCAtIHhNZWFuKSh5IC0geU1lYW4pIF1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGRpZmZYTWVhbiA9IGR0ICogX2kgLSB4TWVhbjtcbiAgICB2YXIgZGlmZllNZWFuID0gdmFsdWVzW19pXSAtIHlNZWFuO1xuXG4gICAgdmFyIGRpZmZYTWVhblNxdWFyZWQgPSBkaWZmWE1lYW4gKiBkaWZmWE1lYW47XG4gICAgdmFyIGRpZmZZTWVhblNxdWFyZWQgPSBkaWZmWU1lYW4gKiBkaWZmWU1lYW47XG4gICAgdmFyIGRpZmZYWU1lYW4gPSBkaWZmWE1lYW4gKiBkaWZmWU1lYW47XG5cbiAgICBzdW1EaWZmWE1lYW5TcXVhcmVkICs9IGRpZmZYTWVhblNxdWFyZWQ7XG4gICAgc3VtRGlmZllNZWFuU3F1YXJlZCArPSBkaWZmWU1lYW5TcXVhcmVkO1xuICAgIHN1bURpZmZYWU1lYW4gKz0gZGlmZlhZTWVhbjtcbiAgfVxuXG4gIC8vIGhvcml6b250YWwgbGluZSwgYWxsIHkgb24gc2FtZSBsaW5lXG4gIGlmIChzdW1EaWZmWU1lYW5TcXVhcmVkID09PSAwKSByZXR1cm4gMDtcblxuICAvLyBQZWFyc29uIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50OlxuICAvLyBjZi4gaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0yU0NnOEt1aDB0RVxuICAvL1xuICAvLyAgICAgICAgICAgICAgICAg4oiRIFsgKHggLSB4TWVhbikoeSAtIHlNZWFuKSBdXG4gIC8vIHIgPSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gICAgIHNxcnQoIOKIkcKgWyBwb3coKHggLSB4TWVhbiksIDIpLCBwb3coKHkgLSB5TWVhbiksIDIpIF0gKVxuICAvL1xuICAvL1xuICB2YXIgciA9IHN1bURpZmZYWU1lYW4gLyBNYXRoLnNxcnQoc3VtRGlmZlhNZWFuU3F1YXJlZCAqIHN1bURpZmZZTWVhblNxdWFyZWQpO1xuXG4gIC8vIHRoZW4gd2UgaGF2ZTpcbiAgLy8gY2YuIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9R2hyeGdiUW5FRVVcbiAgLy9cbiAgLy8geSA9IGEgKyBieFxuICAvLyB3aGVyZTpcbiAgLy8gICAgICAgICBTeVxuICAvLyBiID0gciAqIC0tXG4gIC8vICAgICAgICAgU3hcbiAgLy9cbiAgLy8gYSA9IHlNZWFuIC0gYiAqIHhNZWFuXG4gIC8vXG4gIC8vIFMgZm9yIHN0YW5kYXJkIGRldmlhdGlvblxuICAvLyAgICAgICAgICAgIOKIkSBbIHBvdygoeCAtIHhNZWFuKSwgMikgXVxuICAvLyBTeCA9IHNxcnQoIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIClcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgTiAtIDFcbiAgdmFyIFN4ID0gTWF0aC5zcXJ0KHN1bURpZmZYTWVhblNxdWFyZWQgLyAobGVuZ3RoIC0gMSkpO1xuICB2YXIgU3kgPSBNYXRoLnNxcnQoc3VtRGlmZllNZWFuU3F1YXJlZCAvIChsZW5ndGggLSAxKSk7XG4gIHZhciBiID0gciAqIChTeSAvIFN4KTtcblxuICByZXR1cm4gYjtcbn1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBzaXplOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIG1pbjogMixcbiAgICBtYXg6ICtJbmZpbml0eSxcbiAgICBkZWZhdWx0OiAzXG4gIH0sXG4gIHVzZUZyYW1lUmF0ZToge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBtaW46IDAsXG4gICAgbWF4OiArSW5maW5pdHksXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNpbXBsZSBkZXJpdmF0aXZlIG9mIHN1Y2Nlc3NpdmUgdmFsdWUgdXNpbmdcbiAqIHNpbXBsZSBsaW5lYXIgcmVncmVzc2lvbi5cbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGFzc3VtZXMgYSBmaXhlZCBgZnJhbWVSYXRlYCAoYGZyYW1lLnRpbWVgIGlzIGlnbm9yZWQpXG4gKlxuICogQmVmb3JlIHRoZSBtb2R1bGUgaXMgZmlsbGVkLCBpdCBvdXRwdXRzIGEgdmFsdWUgb2YgMC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNpemU9M10gLSBTaXplIG9mIHRoZSB3aW5kb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy51c2VGcmFtZVJhdGU9bnVsbF0gLSBPdmVycmlkZSBzdHJlYW0gZnJhbWUgcmF0ZSBmb3JcbiAqICB0aGUgcmVncmVzc2lvblxuICovXG5cbnZhciBEZWx0YSA9IGZ1bmN0aW9uIChfQmFzZUxmbykge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShEZWx0YSwgX0Jhc2VMZm8pO1xuXG4gIGZ1bmN0aW9uIERlbHRhKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBEZWx0YSk7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChEZWx0YS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVsdGEpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5idWZmZXJzID0gbnVsbDtcbiAgICBfdGhpcy5yaW5nSW5kZXggPSAwO1xuICAgIF90aGlzLmZyYW1lUmF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShEZWx0YSwgW3tcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnc2l6ZScpO1xuICAgICAgdmFyIGJ1ZmZlclNpemUgPSBmcmFtZVNpemUgKiBzaXplO1xuXG4gICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgIC8vIGNvdW50ZXIgYmVmb3JlIHRoZSBvcGVyYXRvciBzdGFydHMgb3V0cHV0aW5nIGZyYW1lc1xuICAgICAgdGhpcy5yaW5nSW5kZXggPSAwO1xuICAgICAgdGhpcy5mcmFtZVJhdGUgPSB0aGlzLnBhcmFtcy5nZXQoJ3VzZUZyYW1lUmF0ZScpID09PSBudWxsID8gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlIDogdGhpcy5wYXJhbXMuZ2V0KCd1c2VGcmFtZVJhdGUnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgICB0aGlzLmJ1ZmZlcnNbaV0gPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgICAgfXRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0U3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTdHJlYW0oKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoRGVsdGEucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZWx0YS5wcm90b3R5cGUpLCAncmVzZXRTdHJlYW0nLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnBhcmFtcy5nZXQoJ3NpemUnKTtcbiAgICAgIHZhciBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZTsgaisrKSB7XG4gICAgICAgICAgYnVmZmVyc1tpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yaW5nSW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc3VtZSBhIHN0cmVhbSBvZiB2ZWN0b3IgYXQgYSBmaXhlZCBgZnJhbWVSYXRlYC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5wdXRWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFZlY3RvcihkYXRhKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnc2l6ZScpO1xuICAgICAgdmFyIG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgLy8gY29uc3QgZnJhbWVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlO1xuICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgICB2YXIgZHQgPSAxIC8gdGhpcy5mcmFtZVJhdGU7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKGR0KTtcblxuICAgICAgaWYgKHRoaXMucmluZ0luZGV4IDwgc2l6ZSkgdGhpcy5yaW5nSW5kZXggKz0gMTtcblxuICAgICAgLy8gY29weSBpbmNvbW1pbmcgZGF0YSBpbnRvIGJ1ZmZlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpXTtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgdGhlIG9yZGVyIG9mIHRoZSBpbmNvbW1pbmcgZnJhbWVzXG4gICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gc2hpZnQgYWxsIHRoZSB2YWx1ZXMgaW4gdGhlIGJ1ZmZlcnNcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBzaXplOyBqKyspIHtcbiAgICAgICAgICBidWZmZXJbaiAtIDFdID0gYnVmZmVyW2pdO1xuICAgICAgICB9YnVmZmVyW3NpemUgLSAxXSA9IGRhdGFbaV07XG5cbiAgICAgICAgaWYgKHRoaXMucmluZ0luZGV4ID49IHNpemUpIG91dERhdGFbaV0gPSBzaW1wbGVMaW5lYXJSZWdyZXNzaW9uKGJ1ZmZlciwgZHQpO2Vsc2Ugb3V0RGF0YVtpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXREYXRhO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5kYXRhID0gdGhpcy5pbnB1dFZlY3RvcihmcmFtZS5kYXRhKTtcbiAgICAgIC8vIGNlbnRlciB0aW1lIGFjY29yZGluZyB0byBkZWx0YSBzaXplXG4gICAgICB2YXIgc2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnc2l6ZScpO1xuICAgICAgdmFyIGZyYW1lUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZTtcbiAgICAgIHRoaXMuZnJhbWUudGltZSAtPSAwLjUgKiAoc2l6ZSAtIDEpIC8gZnJhbWVSYXRlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGVsdGE7XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGVsdGE7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldFwiOjE4LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxudmFyIF93aW5kb3dzID0gcmVxdWlyZSgnLi4vdXRpbHMvd2luZG93cycpO1xuXG52YXIgX3dpbmRvd3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2luZG93cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGh0dHBzOi8vY29kZS5zb3VuZHNvZnR3YXJlLmFjLnVrL3Byb2plY3RzL2pzLWRzcC10ZXN0L3JlcG9zaXRvcnkvZW50cnkvZmZ0L25heXVraS1vYmovZmZ0LmpzXG4vKlxuICogRnJlZSBGZnQgYW5kIGNvbnZvbHV0aW9uIChKYXZhU2NyaXB0KVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBQcm9qZWN0IE5heXVraVxuICogaHR0cDovL3d3dy5uYXl1a2kuaW8vcGFnZS9mcmVlLXNtYWxsLWZmdC1pbi1tdWx0aXBsZS1sYW5ndWFnZXNcbiAqXG4gKiAoTUlUIExpY2Vuc2UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuICogdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiAtIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiAgIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogLSBUaGUgU29mdHdhcmUgaXMgcHJvdmlkZWQgXCJhcyBpc1wiLCB3aXRob3V0IHdhcnJhbnR5IG9mIGFueSBraW5kLCBleHByZXNzIG9yXG4gKiAgIGltcGxpZWQsIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gdGhlIHdhcnJhbnRpZXMgb2YgbWVyY2hhbnRhYmlsaXR5LFxuICogICBmaXRuZXNzIGZvciBhIHBhcnRpY3VsYXIgcHVycG9zZSBhbmQgbm9uaW5mcmluZ2VtZW50LiBJbiBubyBldmVudCBzaGFsbCB0aGVcbiAqICAgYXV0aG9ycyBvciBjb3B5cmlnaHQgaG9sZGVycyBiZSBsaWFibGUgZm9yIGFueSBjbGFpbSwgZGFtYWdlcyBvciBvdGhlclxuICogICBsaWFiaWxpdHksIHdoZXRoZXIgaW4gYW4gYWN0aW9uIG9mIGNvbnRyYWN0LCB0b3J0IG9yIG90aGVyd2lzZSwgYXJpc2luZyBmcm9tLFxuICogICBvdXQgb2Ygb3IgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSBTb2Z0d2FyZSBvciB0aGUgdXNlIG9yIG90aGVyIGRlYWxpbmdzIGluIHRoZVxuICogICBTb2Z0d2FyZS5cbiAqXG4gKiBTbGlnaHRseSByZXN0cnVjdHVyZWQgYnkgQ2hyaXMgQ2FubmFtLCBjYW5uYW1AYWxsLWRheS1icmVha2Zhc3QuY29tXG4gKlxuICogQHByaXZhdGVcbiAqL1xuLypcbiAqIENvbnN0cnVjdCBhbiBvYmplY3QgZm9yIGNhbGN1bGF0aW5nIHRoZSBkaXNjcmV0ZSBGb3VyaWVyIHRyYW5zZm9ybSAoREZUKSBvZlxuICogc2l6ZSBuLCB3aGVyZSBuIGlzIGEgcG93ZXIgb2YgMi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBGZnROYXl1a2kobikge1xuXG4gIHRoaXMubiA9IG47XG4gIHRoaXMubGV2ZWxzID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKDEgPDwgaSA9PSBuKSB7XG4gICAgICB0aGlzLmxldmVscyA9IGk7IC8vIEVxdWFsIHRvIGxvZzIobilcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5sZXZlbHMgPT0gLTEpIHtcbiAgICB0aHJvdyBcIkxlbmd0aCBpcyBub3QgYSBwb3dlciBvZiAyXCI7XG4gIH1cblxuICB0aGlzLmNvc1RhYmxlID0gbmV3IEFycmF5KG4gLyAyKTtcbiAgdGhpcy5zaW5UYWJsZSA9IG5ldyBBcnJheShuIC8gMik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuIC8gMjsgaSsrKSB7XG4gICAgdGhpcy5jb3NUYWJsZVtpXSA9IE1hdGguY29zKDIgKiBNYXRoLlBJICogaSAvIG4pO1xuICAgIHRoaXMuc2luVGFibGVbaV0gPSBNYXRoLnNpbigyICogTWF0aC5QSSAqIGkgLyBuKTtcbiAgfVxuXG4gIC8qXG4gICAqIENvbXB1dGVzIHRoZSBkaXNjcmV0ZSBGb3VyaWVyIHRyYW5zZm9ybSAoREZUKSBvZiB0aGUgZ2l2ZW4gY29tcGxleCB2ZWN0b3IsXG4gICAqIHN0b3JpbmcgdGhlIHJlc3VsdCBiYWNrIGludG8gdGhlIHZlY3Rvci5cbiAgICogVGhlIHZlY3RvcidzIGxlbmd0aCBtdXN0IGJlIGVxdWFsIHRvIHRoZSBzaXplIG4gdGhhdCB3YXMgcGFzc2VkIHRvIHRoZVxuICAgKiBvYmplY3QgY29uc3RydWN0b3IsIGFuZCB0aGlzIG11c3QgYmUgYSBwb3dlciBvZiAyLiBVc2VzIHRoZSBDb29sZXktVHVrZXlcbiAgICogZGVjaW1hdGlvbi1pbi10aW1lIHJhZGl4LTIgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5mb3J3YXJkID0gZnVuY3Rpb24gKHJlYWwsIGltYWcpIHtcbiAgICB2YXIgbiA9IHRoaXMubjtcblxuICAgIC8vIEJpdC1yZXZlcnNlZCBhZGRyZXNzaW5nIHBlcm11dGF0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBqID0gcmV2ZXJzZUJpdHMoaSwgdGhpcy5sZXZlbHMpO1xuXG4gICAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSByZWFsW2ldO1xuICAgICAgICByZWFsW2ldID0gcmVhbFtqXTtcbiAgICAgICAgcmVhbFtqXSA9IHRlbXA7XG4gICAgICAgIHRlbXAgPSBpbWFnW2ldO1xuICAgICAgICBpbWFnW2ldID0gaW1hZ1tqXTtcbiAgICAgICAgaW1hZ1tqXSA9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29vbGV5LVR1a2V5IGRlY2ltYXRpb24taW4tdGltZSByYWRpeC0yIEZmdFxuICAgIGZvciAodmFyIHNpemUgPSAyOyBzaXplIDw9IG47IHNpemUgKj0gMikge1xuICAgICAgdmFyIGhhbGZzaXplID0gc2l6ZSAvIDI7XG4gICAgICB2YXIgdGFibGVzdGVwID0gbiAvIHNpemU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArPSBzaXplKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpLCBrID0gMDsgaiA8IGkgKyBoYWxmc2l6ZTsgaisrLCBrICs9IHRhYmxlc3RlcCkge1xuICAgICAgICAgIHZhciB0cHJlID0gcmVhbFtqICsgaGFsZnNpemVdICogdGhpcy5jb3NUYWJsZVtrXSArIGltYWdbaiArIGhhbGZzaXplXSAqIHRoaXMuc2luVGFibGVba107XG4gICAgICAgICAgdmFyIHRwaW0gPSAtcmVhbFtqICsgaGFsZnNpemVdICogdGhpcy5zaW5UYWJsZVtrXSArIGltYWdbaiArIGhhbGZzaXplXSAqIHRoaXMuY29zVGFibGVba107XG4gICAgICAgICAgcmVhbFtqICsgaGFsZnNpemVdID0gcmVhbFtqXSAtIHRwcmU7XG4gICAgICAgICAgaW1hZ1tqICsgaGFsZnNpemVdID0gaW1hZ1tqXSAtIHRwaW07XG4gICAgICAgICAgcmVhbFtqXSArPSB0cHJlO1xuICAgICAgICAgIGltYWdbal0gKz0gdHBpbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIGludGVnZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGxvd2VzdCAnYml0cydcbiAgICAvLyBiaXRzIG9mIHRoZSBpbnRlZ2VyICd4Jy5cbiAgICBmdW5jdGlvbiByZXZlcnNlQml0cyh4LCBiaXRzKSB7XG4gICAgICB2YXIgeSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0czsgaSsrKSB7XG4gICAgICAgIHkgPSB5IDw8IDEgfCB4ICYgMTtcbiAgICAgICAgeCA+Pj49IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBDb21wdXRlcyB0aGUgaW52ZXJzZSBkaXNjcmV0ZSBGb3VyaWVyIHRyYW5zZm9ybSAoSURGVCkgb2YgdGhlIGdpdmVuIGNvbXBsZXhcbiAgICogdmVjdG9yLCBzdG9yaW5nIHRoZSByZXN1bHQgYmFjayBpbnRvIHRoZSB2ZWN0b3IuXG4gICAqIFRoZSB2ZWN0b3IncyBsZW5ndGggbXVzdCBiZSBlcXVhbCB0byB0aGUgc2l6ZSBuIHRoYXQgd2FzIHBhc3NlZCB0byB0aGVcbiAgICogb2JqZWN0IGNvbnN0cnVjdG9yLCBhbmQgdGhpcyBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gVGhpcyBpcyBhIHdyYXBwZXJcbiAgICogZnVuY3Rpb24uIFRoaXMgdHJhbnNmb3JtIGRvZXMgbm90IHBlcmZvcm0gc2NhbGluZywgc28gdGhlIGludmVyc2UgaXMgbm90XG4gICAqIGEgdHJ1ZSBpbnZlcnNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pbnZlcnNlID0gZnVuY3Rpb24gKHJlYWwsIGltYWcpIHtcbiAgICBmb3J3YXJkKGltYWcsIHJlYWwpO1xuICB9O1xufVxuXG52YXIgc3FydCA9IE1hdGguc3FydDtcblxudmFyIGlzUG93ZXJPZlR3byA9IGZ1bmN0aW9uIGlzUG93ZXJPZlR3byhudW1iZXIpIHtcbiAgd2hpbGUgKG51bWJlciAlIDIgPT09IDAgJiYgbnVtYmVyID4gMSkge1xuICAgIG51bWJlciA9IG51bWJlciAvIDI7XG4gIH1yZXR1cm4gbnVtYmVyID09PSAxO1xufTtcblxudmFyIGRlZmluaXRpb25zID0ge1xuICBzaXplOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDEwMjQsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfVxuICB9LFxuICB3aW5kb3c6IHtcbiAgICB0eXBlOiAnZW51bScsXG4gICAgbGlzdDogWydub25lJywgJ2hhbm4nLCAnaGFubmluZycsICdoYW1taW5nJywgJ2JsYWNrbWFuJywgJ2JsYWNrbWFuaGFycmlzJywgJ3NpbmUnLCAncmVjdGFuZ2xlJ10sXG4gICAgZGVmYXVsdDogJ25vbmUnLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgbW9kZToge1xuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBsaXN0OiBbJ21hZ25pdHVkZScsICdwb3dlciddLCAvLyBhZGQgY29tcGxleCBvdXRwdXRcbiAgICBkZWZhdWx0OiAnbWFnbml0dWRlJ1xuICB9LFxuICBub3JtOiB7XG4gICAgdHlwZTogJ2VudW0nLFxuICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICBsaXN0OiBbJ2F1dG8nLCAnbm9uZScsICdsaW5lYXInLCAncG93ZXInXVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gb2YgYW4gaW5jb21taW5nIGBzaWduYWxgLlxuICAgKlxuICAgKiBGZnQgaW1wbGVtZW50YXRpb24gYnkgW05heXVraV0oaHR0cHM6Ly9jb2RlLnNvdW5kc29mdHdhcmUuYWMudWsvcHJvamVjdHMvanMtZHNwLXRlc3QvcmVwb3NpdG9yeS9lbnRyeS9mZnQvbmF5dWtpLW9iai9mZnQuanMpLlxuICAgKlxuICAgKiBfc3VwcG9ydCBgc3RhbmRhbG9uZWAgdXNhZ2VfXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2l6ZT0xMDI0XSAtIFNpemUgb2YgdGhlIGZmdCwgc2hvdWxkIGJlIGEgcG93ZXIgb2YgMi5cbiAgICogIElmIHRoZSBmcmFtZSBzaXplIG9mIHRoZSBpbmNvbW1pbmcgc2lnbmFsIGlzIGxvd2VyIHRoYW4gdGhpcyB2YWx1ZSxcbiAgICogIGl0IGlzIHplcm8gcGFkZGVkIHRvIG1hdGNoIHRoZSBmZnQgc2l6ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpbmRvdz0nbm9uZSddIC0gTmFtZSBvZiB0aGUgd2luZG93IGFwcGxpZWQgb24gdGhlXG4gICAqICBpbmNvbW1pbmcgc2lnbmFsLiBBdmFpbGFibGUgd2luZG93cyBhcmU6ICdub25lJywgJ2hhbm4nLCAnaGFubmluZycsXG4gICAqICAnaGFtbWluZycsICdibGFja21hbicsICdibGFja21hbmhhcnJpcycsICdzaW5lJywgJ3JlY3RhbmdsZScuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RlPSdtYWduaXR1ZGUnXSAtIFR5cGUgb2YgdGhlIG91dHB1dCAoYG1hZ25pdHVkZWBcbiAgICogIG9yIGBwb3dlcmApXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ub3JtPSdhdXRvJ10gLSBUeXBlIG9mIG5vcm1hbGl6YXRpb24gYXBwbGllZCBvbiB0aGVcbiAgICogIG91dHB1dC4gUG9zc2libGUgdmFsdWVzIGFyZSAnYXV0bycsICdub25lJywgJ2xpbmVhcicsICdwb3dlcicuIFdoZW4gc2V0IHRvXG4gICAqICBgYXV0b2AsIGEgYGxpbmVhcmAgbm9ybWFsaXphdGlvbiBpcyBhcHBsaWVkIG9uIHRoZSBtYWduaXR1ZGUgc3BlY3RydW0sIHdoaWxlXG4gICAqICBhIGBwb3dlcmAgbm9ybWFsaXphdGlvbiBpcyBhcHBsaWVkIG9uIHRoZSBwb3dlciBzcGVjdHJ1bS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICAgKlxuICAgKiAvLyBhc3N1bWluZyBhbiBgYXVkaW9CdWZmZXJgIGV4aXN0c1xuICAgKiBjb25zdCBzb3VyY2UgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luQnVmZmVyKHsgYXVkaW9CdWZmZXIgfSk7XG4gICAqXG4gICAqIGNvbnN0IHNsaWNlciA9IG5ldyBsZm8ub3BlcmF0b3IuU2xpY2VyKHtcbiAgICogICBmcmFtZVNpemU6IDI1NixcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IGZmdCA9IG5ldyBsZm8ub3BlcmF0b3IuRmZ0KHtcbiAgICogICBtb2RlOiAncG93ZXInLFxuICAgKiAgIHdpbmRvdzogJ2hhbm4nLFxuICAgKiAgIG5vcm06ICdwb3dlcicsXG4gICAqICAgc2l6ZTogMjU2LFxuICAgKiB9KTtcbiAgICpcbiAgICogc291cmNlLmNvbm5lY3Qoc2xpY2VyKTtcbiAgICogc2xpY2VyLmNvbm5lY3QoZmZ0KTtcbiAgICogc291cmNlLnN0YXJ0KCk7XG4gICAqXG4gICAqIC8vID4gb3V0cHV0cyAxMjkgYmlucyBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHBvd2VyIHNwZWN0cnVtIChpbmNsdWRpbmdcbiAgICogLy8gPiBEQyBhbmQgTnl1aXN0IGZyZXF1ZW5jaWVzKS5cbiAgICpcbiAgICogQHRvZG8gLSBjaGVjayBpZiAncmVjdGFuZ2xlJyBhbmQgJ25vbmUnIHdpbmRvd3MgYXJlIG5vdCByZWRvbmRhbnQuXG4gICAqIEB0b2RvIC0gY2hlY2sgZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBwYXJhbXMuXG4gICAqL1xufTtcbnZhciBGZnQgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoRmZ0LCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gRmZ0KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBGZnQpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoRmZ0Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShGZnQpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy53aW5kb3dTaXplID0gbnVsbDtcbiAgICBfdGhpcy5ub3JtYWxpemVDb2VmcyA9IG51bGw7XG4gICAgX3RoaXMud2luZG93ID0gbnVsbDtcbiAgICBfdGhpcy5yZWFsID0gbnVsbDtcbiAgICBfdGhpcy5pbWFnID0gbnVsbDtcbiAgICBfdGhpcy5mZnQgPSBudWxsO1xuXG4gICAgaWYgKCFpc1Bvd2VyT2ZUd28oX3RoaXMucGFyYW1zLmdldCgnc2l6ZScpKSkgdGhyb3cgbmV3IEVycm9yKCdmZnRTaXplIG11c3QgYmUgYSBwb3dlciBvZiB0d28nKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKEZmdCwgW3tcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG4gICAgICAvLyBzZXQgdGhlIG91dHB1dCBmcmFtZSBzaXplXG4gICAgICB2YXIgaW5GcmFtZVNpemUgPSBwcmV2U3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBmZnRTaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdzaXplJyk7XG4gICAgICB2YXIgbW9kZSA9IHRoaXMucGFyYW1zLmdldCgnbW9kZScpO1xuICAgICAgdmFyIG5vcm0gPSB0aGlzLnBhcmFtcy5nZXQoJ25vcm0nKTtcbiAgICAgIHZhciB3aW5kb3dOYW1lID0gdGhpcy5wYXJhbXMuZ2V0KCd3aW5kb3cnKTtcbiAgICAgIC8vIHdpbmRvdyBgbm9uZWAgYW5kIGByZWN0YW5nbGVgIGFyZSBhbGlhc2VzXG4gICAgICBpZiAod2luZG93TmFtZSA9PT0gJ25vbmUnKSB3aW5kb3dOYW1lID0gJ3JlY3RhbmdsZSc7XG5cbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IGZmdFNpemUgLyAyICsgMTtcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICd2ZWN0b3InO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBbXTtcbiAgICAgIC8vIHNpemUgb2YgdGhlIHdpbmRvdyB0byBhcHBseSBvbiB0aGUgaW5wdXQgZnJhbWVcbiAgICAgIHRoaXMud2luZG93U2l6ZSA9IGluRnJhbWVTaXplIDwgZmZ0U2l6ZSA/IGluRnJhbWVTaXplIDogZmZ0U2l6ZTtcblxuICAgICAgLy8gcmVmZXJlbmNlcyB0byBwb3B1bGF0ZSBpbiB0aGUgd2luZG93IGZ1bmN0aW9ucyAoY2YuIGBpbml0V2luZG93YClcbiAgICAgIHRoaXMubm9ybWFsaXplQ29lZnMgPSB7IGxpbmVhcjogMCwgcG93ZXI6IDAgfTtcbiAgICAgIHRoaXMud2luZG93ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLndpbmRvd1NpemUpO1xuXG4gICAgICAoMCwgX3dpbmRvd3MyLmRlZmF1bHQpKHdpbmRvd05hbWUsIC8vIG5hbWUgb2YgdGhlIHdpbmRvd1xuICAgICAgdGhpcy53aW5kb3csIC8vIGJ1ZmZlciBwb3B1bGF0ZWQgd2l0aCB0aGUgd2luZG93IHNpZ25hbFxuICAgICAgdGhpcy53aW5kb3dTaXplLCAvLyBzaXplIG9mIHRoZSB3aW5kb3dcbiAgICAgIHRoaXMubm9ybWFsaXplQ29lZnMgLy8gb2JqZWN0IHBvcHVsYXRlZCB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGNvZWZzXG4gICAgICApO1xuXG4gICAgICB2YXIgX25vcm1hbGl6ZUNvZWZzID0gdGhpcy5ub3JtYWxpemVDb2VmcyxcbiAgICAgICAgICBsaW5lYXIgPSBfbm9ybWFsaXplQ29lZnMubGluZWFyLFxuICAgICAgICAgIHBvd2VyID0gX25vcm1hbGl6ZUNvZWZzLnBvd2VyO1xuXG5cbiAgICAgIHN3aXRjaCAobm9ybSkge1xuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB0aGlzLndpbmRvd05vcm0gPSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICAgICAgdGhpcy53aW5kb3dOb3JtID0gbGluZWFyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Bvd2VyJzpcbiAgICAgICAgICB0aGlzLndpbmRvd05vcm0gPSBwb3dlcjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICBpZiAobW9kZSA9PT0gJ21hZ25pdHVkZScpIHRoaXMud2luZG93Tm9ybSA9IGxpbmVhcjtlbHNlIGlmIChtb2RlID09PSAncG93ZXInKSB0aGlzLndpbmRvd05vcm0gPSBwb3dlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWFsID0gbmV3IEZsb2F0MzJBcnJheShmZnRTaXplKTtcbiAgICAgIHRoaXMuaW1hZyA9IG5ldyBGbG9hdDMyQXJyYXkoZmZ0U2l6ZSk7XG4gICAgICB0aGlzLmZmdCA9IG5ldyBGZnROYXl1a2koZmZ0U2l6ZSk7XG5cbiAgICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBgRmZ0YCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGEgZ3JhcGgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gc2lnbmFsIC0gSW5wdXQgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAtIEZmdCBvZiB0aGUgaW5wdXQgc2lnbmFsLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBmZnQgPSBuZXcgbGZvLm9wZXJhdG9yLkZmdCh7IHNpemU6IDUxMiwgd2luZG93OiAnaGFubicgfSk7XG4gICAgICogLy8gbWFuZGF0b3J5IGZvciB1c2UgaW4gc3RhbmRhbG9uZSBtb2RlXG4gICAgICogZmZ0LmluaXRTdHJlYW0oeyBmcmFtZVNpemU6IDI1NiwgZnJhbWVUeXBlOiAnc2lnbmFsJyB9KTtcbiAgICAgKiBmZnQuaW5wdXRTaWduYWwoc2lnbmFsKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5wdXRTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFNpZ25hbChzaWduYWwpIHtcbiAgICAgIHZhciBtb2RlID0gdGhpcy5wYXJhbXMuZ2V0KCdtb2RlJyk7XG4gICAgICB2YXIgd2luZG93U2l6ZSA9IHRoaXMud2luZG93U2l6ZTtcbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB2YXIgZmZ0U2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnc2l6ZScpO1xuICAgICAgdmFyIG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG5cbiAgICAgIC8vIGFwcGx5IHdpbmRvdyBvbiB0aGUgaW5wdXQgc2lnbmFsIGFuZCByZXNldCBpbWFnIGJ1ZmZlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgdGhpcy5yZWFsW2ldID0gc2lnbmFsW2ldICogdGhpcy53aW5kb3dbaV0gKiB0aGlzLndpbmRvd05vcm07XG4gICAgICAgIHRoaXMuaW1hZ1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHJlYWwgaXMgYmlnZ2VyIHRoYW4gaW5wdXQgc2lnbmFsLCBmaWxsIHdpdGggemVyb3NcbiAgICAgIGZvciAodmFyIF9pID0gd2luZG93U2l6ZTsgX2kgPCBmZnRTaXplOyBfaSsrKSB7XG4gICAgICAgIHRoaXMucmVhbFtfaV0gPSAwO1xuICAgICAgICB0aGlzLmltYWdbX2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mZnQuZm9yd2FyZCh0aGlzLnJlYWwsIHRoaXMuaW1hZyk7XG5cbiAgICAgIGlmIChtb2RlID09PSAnbWFnbml0dWRlJykge1xuICAgICAgICB2YXIgbm9ybSA9IDEgLyBmZnRTaXplO1xuXG4gICAgICAgIC8vIERDIGluZGV4XG4gICAgICAgIHZhciByZWFsRGMgPSB0aGlzLnJlYWxbMF07XG4gICAgICAgIHZhciBpbWFnRGMgPSB0aGlzLmltYWdbMF07XG4gICAgICAgIG91dERhdGFbMF0gPSBzcXJ0KHJlYWxEYyAqIHJlYWxEYyArIGltYWdEYyAqIGltYWdEYykgKiBub3JtO1xuXG4gICAgICAgIC8vIE5xdXlzdCBpbmRleFxuICAgICAgICB2YXIgcmVhbE55ID0gdGhpcy5yZWFsW2ZmdFNpemUgLyAyXTtcbiAgICAgICAgdmFyIGltYWdOeSA9IHRoaXMuaW1hZ1tmZnRTaXplIC8gMl07XG4gICAgICAgIG91dERhdGFbZmZ0U2l6ZSAvIDJdID0gc3FydChyZWFsTnkgKiByZWFsTnkgKyBpbWFnTnkgKiBpbWFnTnkpICogbm9ybTtcblxuICAgICAgICAvLyBwb3dlciBzcGVjdHJ1bVxuICAgICAgICBmb3IgKHZhciBfaTIgPSAxLCBqID0gZmZ0U2l6ZSAtIDE7IF9pMiA8IGZmdFNpemUgLyAyOyBfaTIrKywgai0tKSB7XG4gICAgICAgICAgdmFyIHJlYWwgPSAwLjUgKiAodGhpcy5yZWFsW19pMl0gKyB0aGlzLnJlYWxbal0pO1xuICAgICAgICAgIHZhciBpbWFnID0gMC41ICogKHRoaXMuaW1hZ1tfaTJdIC0gdGhpcy5pbWFnW2pdKTtcblxuICAgICAgICAgIG91dERhdGFbX2kyXSA9IDIgKiBzcXJ0KHJlYWwgKiByZWFsICsgaW1hZyAqIGltYWcpICogbm9ybTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAncG93ZXInKSB7XG4gICAgICAgIHZhciBfbm9ybSA9IDEgLyAoZmZ0U2l6ZSAqIGZmdFNpemUpO1xuXG4gICAgICAgIC8vIERDIGluZGV4XG4gICAgICAgIHZhciBfcmVhbERjID0gdGhpcy5yZWFsWzBdO1xuICAgICAgICB2YXIgX2ltYWdEYyA9IHRoaXMuaW1hZ1swXTtcbiAgICAgICAgb3V0RGF0YVswXSA9IChfcmVhbERjICogX3JlYWxEYyArIF9pbWFnRGMgKiBfaW1hZ0RjKSAqIF9ub3JtO1xuXG4gICAgICAgIC8vIE5xdXlzdCBpbmRleFxuICAgICAgICB2YXIgX3JlYWxOeSA9IHRoaXMucmVhbFtmZnRTaXplIC8gMl07XG4gICAgICAgIHZhciBfaW1hZ055ID0gdGhpcy5pbWFnW2ZmdFNpemUgLyAyXTtcbiAgICAgICAgb3V0RGF0YVtmZnRTaXplIC8gMl0gPSAoX3JlYWxOeSAqIF9yZWFsTnkgKyBfaW1hZ055ICogX2ltYWdOeSkgKiBfbm9ybTtcblxuICAgICAgICAvLyBwb3dlciBzcGVjdHJ1bVxuICAgICAgICBmb3IgKHZhciBfaTMgPSAxLCBfaiA9IGZmdFNpemUgLSAxOyBfaTMgPCBmZnRTaXplIC8gMjsgX2kzKyssIF9qLS0pIHtcbiAgICAgICAgICB2YXIgX3JlYWwgPSAwLjUgKiAodGhpcy5yZWFsW19pM10gKyB0aGlzLnJlYWxbX2pdKTtcbiAgICAgICAgICB2YXIgX2ltYWcgPSAwLjUgKiAodGhpcy5pbWFnW19pM10gLSB0aGlzLmltYWdbX2pdKTtcblxuICAgICAgICAgIG91dERhdGFbX2kzXSA9IDQgKiAoX3JlYWwgKiBfcmVhbCArIF9pbWFnICogX2ltYWcpICogX25vcm07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dERhdGE7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgICB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRmZ0O1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEZmdDtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCIuLi91dGlscy93aW5kb3dzXCI6MTgwLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2dldDIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0Jyk7XG5cbnZhciBfZ2V0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldDIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgbm9ybWFsaXplOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgcG93ZXI6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBtYWduaXR1ZGUgb2YgYSBgdmVjdG9yYCBpbnB1dC5cbiAgICpcbiAgICogX3N1cHBvcnQgYHN0YW5kYWxvbmVgIHVzYWdlX1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub3JtYWxpemU9dHJ1ZV0gLSBOb3JtYWxpemUgb3V0cHV0IGFjY29yZGluZyB0b1xuICAgKiAgdGhlIHZlY3RvciBzaXplLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBvd2VyPWZhbHNlXSAtIElmIHRydWUsIHJldHVybnMgdGhlIHNxdWFyZWRcbiAgICogIG1hZ25pdHVkZSAocG93ZXIpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gICAqXG4gICAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHsgZnJhbWVTaXplOiAyLCBmcmFtZVR5cGU6ICd2ZWN0b3InIH0pO1xuICAgKiBjb25zdCBtYWduaXR1ZGUgPSBuZXcgbGZvLm9wZXJhdG9yLk1hZ25pdHVkZSgpO1xuICAgKiBjb25zdCBsb2dnZXIgPSBuZXcgbGZvLnNpbmsuTG9nZ2VyKHsgb3V0RnJhbWU6IHRydWUgfSk7XG4gICAqXG4gICAqIGV2ZW50SW4uY29ubmVjdChtYWduaXR1ZGUpO1xuICAgKiBtYWduaXR1ZGUuY29ubmVjdChsb2dnZXIpO1xuICAgKiBldmVudEluLnN0YXJ0KCk7XG4gICAqXG4gICAqIGV2ZW50SW4ucHJvY2VzcyhudWxsLCBbMSwgMV0pO1xuICAgKiA+IFsxXVxuICAgKiBldmVudEluLnByb2Nlc3MobnVsbCwgWzIsIDJdKTtcbiAgICogPiBbMi44Mjg0MjcxMjQ3NV1cbiAgICogZXZlbnRJbi5wcm9jZXNzKG51bGwsIFszLCAzXSk7XG4gICAqID4gWzQuMjQyNjQwNjg3MTJdXG4gICAqL1xufTtcbnZhciBNYWduaXR1ZGUgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoTWFnbml0dWRlLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gTWFnbml0dWRlKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBNYWduaXR1ZGUpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoTWFnbml0dWRlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShNYWduaXR1ZGUpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5fbm9ybWFsaXplID0gX3RoaXMucGFyYW1zLmdldCgnbm9ybWFsaXplJyk7XG4gICAgX3RoaXMuX3Bvd2VyID0gX3RoaXMucGFyYW1zLmdldCgncG93ZXInKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE1hZ25pdHVkZSwgW3tcbiAgICBrZXk6ICdvblBhcmFtVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSwgbWV0YXMpIHtcbiAgICAgICgwLCBfZ2V0My5kZWZhdWx0KShNYWduaXR1ZGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShNYWduaXR1ZGUucHJvdG90eXBlKSwgJ29uUGFyYW1VcGRhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlLCBtZXRhcyk7XG5cbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdub3JtYWxpemUnOlxuICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwb3dlcic6XG4gICAgICAgICAgdGhpcy5fcG93ZXIgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gMTtcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICdzY2FsYXInO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBbJ21hZ25pdHVkZSddO1xuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGBNYWduaXR1ZGVgIG9wZXJhdG9yIGluIGBzdGFuZGFsb25lYCBtb2RlIChpLmUuIG91dHNpZGUgb2YgYSBncmFwaCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fEZsb2F0MzJBcnJheX0gdmFsdWVzIC0gVmFsdWVzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIE1hZ25pdHVkZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICAgICAqXG4gICAgICogY29uc3QgbWFnbml0dWRlID0gbmV3IGxmby5vcGVyYXRvci5NYWduaXR1ZGUoeyBwb3dlcjogdHJ1ZSB9KTtcbiAgICAgKiBtYWduaXR1ZGUuaW5pdFN0cmVhbSh7IGZyYW1lVHlwZTogJ3ZlY3RvcicsIGZyYW1lU2l6ZTogMyB9KTtcbiAgICAgKiBtYWduaXR1ZGUuaW5wdXRWZWN0b3IoWzMsIDNdKTtcbiAgICAgKiA+IDQuMjQyNjQwNjg3MTJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5wdXRWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFZlY3Rvcih2YWx1ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IHZhbHVlc1tpXSAqIHZhbHVlc1tpXTtcbiAgICAgIH12YXIgbWFnID0gc3VtO1xuXG4gICAgICBpZiAodGhpcy5fbm9ybWFsaXplKSBtYWcgLz0gbGVuZ3RoO1xuXG4gICAgICBpZiAoIXRoaXMuX3Bvd2VyKSBtYWcgPSBzcXJ0KG1hZyk7XG5cbiAgICAgIHJldHVybiBtYWc7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmVjdG9yKGZyYW1lKSB7XG4gICAgICB0aGlzLmZyYW1lLmRhdGFbMF0gPSB0aGlzLmlucHV0VmVjdG9yKGZyYW1lLmRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWFnbml0dWRlO1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1hZ25pdHVkZTtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0XCI6MTgsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3FydCA9IE1hdGguc3FydDtcblxuLyoqXG4gKiBDb21wdXRlIG1lYW4gYW5kIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhIGdpdmVuIGBzaWduYWxgLlxuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICpcbiAqIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAqICAgLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pXG4gKiAgIC50aGVuKGluaXQpXG4gKiAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKGVyci5zdGFjaykpO1xuICpcbiAqIGZ1bmN0aW9uIGluaXQoc3RyZWFtKSB7XG4gKiAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuICpcbiAqICAgY29uc3QgYXVkaW9Jbk5vZGUgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luTm9kZSh7XG4gKiAgICAgc291cmNlTm9kZTogc291cmNlLFxuICogICAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICogICB9KTtcbiAqXG4gKiAgIGNvbnN0IG1lYW5TdGRkZXYgPSBuZXcgbGZvLm9wZXJhdG9yLk1lYW5TdGRkZXYoKTtcbiAqXG4gKiAgIGNvbnN0IHRyYWNlRGlzcGxheSA9IG5ldyBsZm8uc2luay5UcmFjZURpc3BsYXkoe1xuICogICAgIGNhbnZhczogJyN0cmFjZScsXG4gKiAgIH0pO1xuICpcbiAqICAgYXVkaW9Jbk5vZGUuY29ubmVjdChtZWFuU3RkZGV2KTtcbiAqICAgbWVhblN0ZGRldi5jb25uZWN0KHRyYWNlRGlzcGxheSk7XG4gKiAgIGF1ZGlvSW5Ob2RlLnN0YXJ0KCk7XG4gKiB9XG4gKi9cblxudmFyIE1lYW5TdGRkZXYgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoTWVhblN0ZGRldiwgX0Jhc2VMZm8pO1xuXG4gIGZ1bmN0aW9uIE1lYW5TdGRkZXYoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE1lYW5TdGRkZXYpO1xuXG4gICAgLy8gbm8gb3B0aW9ucyBhdmFpbGFibGUsIGp1c3QgdGhyb3cgYW4gZXJyb3IgaWYgc29tZSBwYXJhbSB0cnkgdG8gYmUgc2V0LlxuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChNZWFuU3RkZGV2Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShNZWFuU3RkZGV2KSkuY2FsbCh0aGlzLCB7fSwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShNZWFuU3RkZGV2LCBbe1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3ZlY3Rvcic7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSAyO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBbJ21lYW4nLCAnc3RkZGV2J107XG5cbiAgICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBgTWVhblN0ZGRldmAgb3BlcmF0b3IgaW4gYHN0YW5kYWxvbmVgIG1vZGUgKGkuZS4gb3V0c2lkZSBvZiBhIGdyYXBoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RmxvYXQzMkFycmF5fSB2YWx1ZXMgLSBWYWx1ZXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gLSBNZWFuIGFuZCBzdGFuZGFydCBkZXZpYXRpb24gb2YgdGhlIGlucHV0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICAgICAqXG4gICAgICogY29uc3QgbWVhblN0ZGRldiA9IG5ldyBsZm8ub3BlcmF0b3IuTWVhblN0ZGRldigpO1xuICAgICAqIG1lYW5TdGRkZXYuaW5pdFN0cmVhbSh7IGZyYW1lVHlwZTogJ3ZlY3RvcicsIGZyYW1lU2l6ZTogMTAyNCB9KTtcbiAgICAgKiBtZWFuU3RkZGV2LmlucHV0VmVjdG9yKHNvbWVTaW5lU2lnbmFsKTtcbiAgICAgKiA+IFswLCAwLjcwNzFdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lucHV0U2lnbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5wdXRTaWduYWwodmFsdWVzKSB7XG4gICAgICB2YXIgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB2YXIgbWVhbiA9IDA7XG4gICAgICB2YXIgbTIgPSAwO1xuXG4gICAgICAvLyBjb21wdXRlIG1lYW4gYW5kIHZhcmlhbmNlIHdpdGggV2VsZm9yZCBhbGdvcml0aG1cbiAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FsZ29yaXRobXNfZm9yX2NhbGN1bGF0aW5nX3ZhcmlhbmNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gdmFsdWVzW2ldO1xuICAgICAgICB2YXIgZGVsdGEgPSB4IC0gbWVhbjtcbiAgICAgICAgbWVhbiArPSBkZWx0YSAvIChpICsgMSk7XG4gICAgICAgIG0yICs9IGRlbHRhICogKHggLSBtZWFuKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhcmlhbmNlID0gbTIgLyAobGVuZ3RoIC0gMSk7XG4gICAgICB2YXIgc3RkZGV2ID0gc3FydCh2YXJpYW5jZSk7XG5cbiAgICAgIG91dERhdGFbMF0gPSBtZWFuO1xuICAgICAgb3V0RGF0YVsxXSA9IHN0ZGRldjtcblxuICAgICAgcmV0dXJuIG91dERhdGE7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgICB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWVhblN0ZGRldjtcbn0oX0Jhc2VMZm8zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNZWFuU3RkZGV2O1xuXG59LHtcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX2xvZyA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXRoL2xvZzEwJyk7XG5cbnZhciBfbG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZyk7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGxvZzEwID0gX2xvZzIuZGVmYXVsdDtcblxuZnVuY3Rpb24gaGVydHpUb01lbEh0ayhmcmVxSHopIHtcbiAgcmV0dXJuIDI1OTUgKiAoMCwgX2xvZzIuZGVmYXVsdCkoMSArIGZyZXFIeiAvIDcwMCk7XG59XG5cbmZ1bmN0aW9uIG1lbFRvSGVydHpIdGsoZnJlcU1lbCkge1xuICByZXR1cm4gNzAwICogKE1hdGgucG93KDEwLCBmcmVxTWVsIC8gMjU5NSkgLSAxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVzY3JpcHRpb24gb2YgdGhlIHdlaWdodHMgdG8gYXBwbHkgb24gdGhlIGZmdCBiaW5zIGZvciBlYWNoXG4gKiBNZWwgYmFuZCBmaWx0ZXIuXG4gKiBAbm90ZSAtIGFkYXB0ZWQgZnJvbSBpbXRyLXRvb2xzL3J0YVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuYnJCaW5zIC0gTnVtYmVyIG9mIGZmdCBiaW5zLlxuICogQHBhcmFtIHtOdW1iZXJ9IG5ickZpbHRlciAtIE51bWJlciBvZiBtZWwgZmlsdGVycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVSYXRlIC0gU2FtcGxlIFJhdGUgb2YgdGhlIHNpZ25hbC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5GcmVxIC0gTWluaW11bSBGcmVxdWVuY3kgdG8gYmUgY29uc2lkZXJlcmVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZyZXEgLSBNYXhpbXVtIGZyZXF1ZW5jeSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IC0gRGVzY3JpcHRpb24gb2YgdGhlIHdlaWdodHMgdG8gYXBwbHkgb24gdGhlIGJpbnMgZm9yXG4gKiAgZWFjaCBtZWwgZmlsdGVyLiBFYWNoIGRlc2NyaXB0aW9uIGhhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqICB7IHN0YXJ0SW5kZXg6IGJpbkluZGV4LCBjZW50ZXJGcmVxOiBiaW5DZW50ZXJGcmVxdWVuY3ksIHdlaWdodHM6IFtdIH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRNZWxCYW5kV2VpZ2h0cyhuYnJCaW5zLCBuYnJCYW5kcywgc2FtcGxlUmF0ZSwgbWluRnJlcSwgbWF4RnJlcSkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogJ2h0ayc7XG5cblxuICB2YXIgaGVydHpUb01lbCA9IG51bGw7XG4gIHZhciBtZWxUb0hlcnR6ID0gbnVsbDtcbiAgdmFyIG1pbk1lbCA9IHZvaWQgMDtcbiAgdmFyIG1heE1lbCA9IHZvaWQgMDtcblxuICBpZiAodHlwZSA9PT0gJ2h0aycpIHtcbiAgICBoZXJ0elRvTWVsID0gaGVydHpUb01lbEh0aztcbiAgICBtZWxUb0hlcnR6ID0gbWVsVG9IZXJ0ekh0aztcbiAgICBtaW5NZWwgPSBoZXJ0elRvTWVsKG1pbkZyZXEpO1xuICAgIG1heE1lbCA9IGhlcnR6VG9NZWwobWF4RnJlcSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lbCBiYW5kIHR5cGU6IFwiJyArIHR5cGUgKyAnXCInKTtcbiAgfVxuXG4gIHZhciBtZWxCYW5kRGVzY3JpcHRpb25zID0gbmV3IEFycmF5KG5ickJhbmRzKTtcbiAgLy8gY2VudGVyIGZyZXF1ZW5jaWVzIG9mIEZmdCBiaW5zXG4gIHZhciBmZnRGcmVxcyA9IG5ldyBGbG9hdDMyQXJyYXkobmJyQmlucyk7XG4gIC8vIGNlbnRlciBmcmVxdWVuY2llcyBvZiBtZWwgYmFuZHMgLSB1bmlmb3JtbHkgc3BhY2VkIGluIG1lbCBkb21haW4gYmV0d2VlblxuICAvLyBsaW1pdHMsIHRoZXJlIGFyZSAyIG1vcmUgZnJlcXVlbmNpZXMgdGhhbiB0aGUgYWN0dWFsIG51bWJlciBvZiBmaWx0ZXJzIGluXG4gIC8vIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgc2xvcGVzXG4gIHZhciBmaWx0ZXJGcmVxcyA9IG5ldyBGbG9hdDMyQXJyYXkobmJyQmFuZHMgKyAyKTtcblxuICB2YXIgZmZ0U2l6ZSA9IChuYnJCaW5zIC0gMSkgKiAyO1xuICAvLyBjb21wdXRlIGJpbnMgY2VudGVyIGZyZXF1ZW5jaWVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmJyQmluczsgaSsrKSB7XG4gICAgZmZ0RnJlcXNbaV0gPSBzYW1wbGVSYXRlICogaSAvIGZmdFNpemU7XG4gIH1mb3IgKHZhciBfaSA9IDA7IF9pIDwgbmJyQmFuZHMgKyAyOyBfaSsrKSB7XG4gICAgZmlsdGVyRnJlcXNbX2ldID0gbWVsVG9IZXJ0eihtaW5NZWwgKyBfaSAvIChuYnJCYW5kcyArIDEpICogKG1heE1lbCAtIG1pbk1lbCkpO1xuICB9IC8vIGxvb3AgdGhyb3VnaHQgZmlsdGVyc1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuYnJCYW5kczsgX2kyKyspIHtcbiAgICB2YXIgbWluV2VpZ2h0SW5kZXhEZWZpbmVkID0gMDtcblxuICAgIHZhciBkZXNjcmlwdGlvbiA9IHtcbiAgICAgIHN0YXJ0SW5kZXg6IG51bGwsXG4gICAgICBjZW50ZXJGcmVxOiBudWxsLFxuICAgICAgd2VpZ2h0czogW11cblxuICAgICAgLy8gZGVmaW5lIGNvbnRyaWJ1dGlvbiBvZiBlYWNoIGJpbiBmb3IgdGhlIGZpbHRlciBhdCBpbmRleCAoaSArIDEpXG4gICAgICAvLyBkbyBub3QgcHJvY2VzcyB0aGUgbGFzdCBzcGVjdHJ1bSBjb21wb25lbnQgKE55cXVpc3QpXG4gICAgfTtmb3IgKHZhciBqID0gMDsgaiA8IG5ickJpbnMgLSAxOyBqKyspIHtcbiAgICAgIHZhciBwb3NTbG9wZUNvbnRyaWIgPSAoZmZ0RnJlcXNbal0gLSBmaWx0ZXJGcmVxc1tfaTJdKSAvIChmaWx0ZXJGcmVxc1tfaTIgKyAxXSAtIGZpbHRlckZyZXFzW19pMl0pO1xuXG4gICAgICB2YXIgbmVnU2xvcGVDb250cmliID0gKGZpbHRlckZyZXFzW19pMiArIDJdIC0gZmZ0RnJlcXNbal0pIC8gKGZpbHRlckZyZXFzW19pMiArIDJdIC0gZmlsdGVyRnJlcXNbX2kyICsgMV0pO1xuICAgICAgLy8gbG93ZXJTbG9wZSBhbmQgdXBwZXIgc2xvcGUgaW50ZXJzZWN0IGF0IHplcm8gYW5kIHdpdGggZWFjaCBvdGhlclxuICAgICAgdmFyIGNvbnRyaWJ1dGlvbiA9IG1heCgwLCBtaW4ocG9zU2xvcGVDb250cmliLCBuZWdTbG9wZUNvbnRyaWIpKTtcblxuICAgICAgaWYgKGNvbnRyaWJ1dGlvbiA+IDApIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnN0YXJ0SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbi5zdGFydEluZGV4ID0gajtcbiAgICAgICAgICBkZXNjcmlwdGlvbi5jZW50ZXJGcmVxID0gZmlsdGVyRnJlcXNbX2kyICsgMV07XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjcmlwdGlvbi53ZWlnaHRzLnB1c2goY29udHJpYnV0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlbXB0eSBmaWx0ZXJcbiAgICBpZiAoZGVzY3JpcHRpb24uc3RhcnRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgZGVzY3JpcHRpb24uc3RhcnRJbmRleCA9IDA7XG4gICAgICBkZXNjcmlwdGlvbi5jZW50ZXJGcmVxID0gMDtcbiAgICB9XG5cbiAgICAvLyBAdG9kbyAtIGRvIHNvbWUgc2NhbGluZyBmb3IgU2xhbmV5LXN0eWxlIG1lbFxuICAgIG1lbEJhbmREZXNjcmlwdGlvbnNbX2kyXSA9IGRlc2NyaXB0aW9uO1xuICB9XG5cbiAgcmV0dXJuIG1lbEJhbmREZXNjcmlwdGlvbnM7XG59XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgbG9nOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgbmJyQmFuZHM6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogMjQsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfVxuICB9LFxuICBtaW5GcmVxOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgbWF4RnJlcToge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9XG4gIH0sXG4gIHBvd2VyOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtZWwgYmFuZHMgc3BlY3RydW0gZnJvbSBhIGdpdmVuIHNwZWN0cnVtIChgdmVjdG9yYCB0eXBlKS5cbiAqIF9JbXBsZW1lbnQgdGhlIGBodGtgIG1lbCBiYW5kIHN0eWxlLl9cbiAqXG4gKiBfc3VwcG9ydCBgc3RhbmRhbG9uZWAgdXNhZ2VfXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24ub3BlcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubG9nPWZhbHNlXSAtIEFwcGx5IGEgbG9nYXJpdGhtaWMgc2NhbGUgb24gdGhlIG91dHB1dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5uYnJCYW5kcz0yNF0gLSBOdW1iZXIgb2YgZmlsdGVycyBkZWZpbmluZyB0aGUgbWVsXG4gKiAgYmFuZHMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluRnJlcT0wXSAtIE1pbmltdW0gZnJlcXVlbmN5IHRvIGNvbnNpZGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZyZXE9bnVsbF0gLSBNYXhpbXVtIGZyZXF1ZW5jeSB0byBjb25zaWRlci5cbiAqICBJZiBgbnVsbGAsIGlzIHNldCB0byBOeXF1aXN0IGZyZXF1ZW5jeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3dlcj0xXSAtIEFwcGx5IGEgcG93ZXIgc2NhbGluZyBvbiBlYWNoIG1lbCBiYW5kLlxuICpcbiAqIEB0b2RvIC0gaW1wbGVtZW50IFNsYW5leSBzdHlsZSBtZWwgYmFuZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IGxmbyBmcm9tICd3YXZlcy1sZm8vbm9kZSdcbiAqXG4gKiAvLyByZWFkIGEgZmlsZSBmcm9tIHBhdGggKG5vZGUgb25seSBzb3VyY2UpXG4gKiBjb25zdCBhdWRpb0luRmlsZSA9IG5ldyBsZm8uc291cmNlLkF1ZGlvSW5GaWxlKHtcbiAqICAgZmlsZW5hbWU6ICdwYXRoL3RvL2ZpbGUnLFxuICogICBmcmFtZVNpemU6IDUxMixcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHNsaWNlciA9IG5ldyBsZm8ub3BlcmF0b3IuU2xpY2VyKHtcbiAqICAgZnJhbWVTaXplOiAyNTYsXG4gKiAgIGhvcFNpemU6IDI1NixcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGZmdCA9IG5ldyBsZm8ub3BlcmF0b3IuRmZ0KHtcbiAqICAgc2l6ZTogMTAyNCxcbiAqICAgd2luZG93OiAnaGFubicsXG4gKiAgIG1vZGU6ICdwb3dlcicsXG4gKiAgIG5vcm06ICdwb3dlcicsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBtZWwgPSBuZXcgbGZvLm9wZXJhdG9yLk1lbCh7XG4gKiAgIGxvZzogdHJ1ZSxcbiAqICAgbmJyQmFuZHM6IDI0LFxuICogfSk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogYXVkaW9JbkZpbGUuY29ubmVjdChzbGljZXIpO1xuICogc2xpY2VyLmNvbm5lY3QoZmZ0KTtcbiAqIGZmdC5jb25uZWN0KG1lbCk7XG4gKiBtZWwuY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIGF1ZGlvSW5GaWxlLnN0YXJ0KCk7XG4gKi9cblxudmFyIE1lbCA9IGZ1bmN0aW9uIChfQmFzZUxmbykge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShNZWwsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBNZWwoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE1lbCk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKE1lbC5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoTWVsKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShNZWwsIFt7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgICB2YXIgbmJyQmlucyA9IHByZXZTdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIG5ickJhbmRzID0gdGhpcy5wYXJhbXMuZ2V0KCduYnJCYW5kcycpO1xuICAgICAgdmFyIHNhbXBsZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlO1xuICAgICAgdmFyIG1pbkZyZXEgPSB0aGlzLnBhcmFtcy5nZXQoJ21pbkZyZXEnKTtcbiAgICAgIHZhciBtYXhGcmVxID0gdGhpcy5wYXJhbXMuZ2V0KCdtYXhGcmVxJyk7XG5cbiAgICAgIC8vXG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSBuYnJCYW5kcztcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICd2ZWN0b3InO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBbXTtcblxuICAgICAgaWYgKG1heEZyZXEgPT09IG51bGwpIG1heEZyZXEgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlIC8gMjtcblxuICAgICAgdGhpcy5tZWxCYW5kRGVzY3JpcHRpb25zID0gZ2V0TWVsQmFuZFdlaWdodHMobmJyQmlucywgbmJyQmFuZHMsIHNhbXBsZVJhdGUsIG1pbkZyZXEsIG1heEZyZXEpO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGUgYE1lbGAgb3BlcmF0b3IgaW4gYHN0YW5kYWxvbmVgIG1vZGUgKGkuZS4gb3V0c2lkZSBvZiBhIGdyYXBoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNwZWN0cnVtIC0gRmZ0IGJpbnMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IC0gTWVsIGJhbmRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBtZWwgPSBuZXcgbGZvLm9wZXJhdG9yLk1lbCh7IG5ickJhbmRzOiAyNCB9KTtcbiAgICAgKiAvLyBtYW5kYXRvcnkgZm9yIHVzZSBpbiBzdGFuZGFsb25lIG1vZGVcbiAgICAgKiBtZWwuaW5pdFN0cmVhbSh7IGZyYW1lU2l6ZTogMjU2LCBmcmFtZVR5cGU6ICd2ZWN0b3InLCBzb3VyY2VTYW1wbGVSYXRlOiA0NDEwMCB9KTtcbiAgICAgKiBtZWwuaW5wdXRWZWN0b3IoZmZ0Qmlucyk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lucHV0VmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5wdXRWZWN0b3IoYmlucykge1xuXG4gICAgICB2YXIgcG93ZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ3Bvd2VyJyk7XG4gICAgICB2YXIgbG9nID0gdGhpcy5wYXJhbXMuZ2V0KCdsb2cnKTtcbiAgICAgIHZhciBtZWxCYW5kcyA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICAgIHZhciBuYnJCYW5kcyA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBzY2FsZSA9IDE7XG5cbiAgICAgIHZhciBtaW5Mb2dWYWx1ZSA9IDFlLTQ4O1xuICAgICAgdmFyIG1pbkxvZyA9IC00ODA7XG5cbiAgICAgIGlmIChsb2cpIHNjYWxlICo9IG5ickJhbmRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ickJhbmRzOyBpKyspIHtcbiAgICAgICAgdmFyIF9tZWxCYW5kRGVzY3JpcHRpb25zJCA9IHRoaXMubWVsQmFuZERlc2NyaXB0aW9uc1tpXSxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBfbWVsQmFuZERlc2NyaXB0aW9ucyQuc3RhcnRJbmRleCxcbiAgICAgICAgICAgIHdlaWdodHMgPSBfbWVsQmFuZERlc2NyaXB0aW9ucyQud2VpZ2h0cztcblxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2VpZ2h0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhbHVlICs9IHdlaWdodHNbal0gKiBiaW5zW3N0YXJ0SW5kZXggKyBqXTtcbiAgICAgICAgfSAvLyBhcHBseSBzYW1lIGxvZ2ljIGFzIGluIFBpUG9CYW5kc1xuICAgICAgICBpZiAoc2NhbGUgIT09IDEpIHZhbHVlICo9IHNjYWxlO1xuXG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPiBtaW5Mb2dWYWx1ZSkgdmFsdWUgPSAxMCAqIGxvZzEwKHZhbHVlKTtlbHNlIHZhbHVlID0gbWluTG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvd2VyICE9PSAxKSB2YWx1ZSA9IHBvdyh2YWx1ZSwgcG93ZXIpO1xuXG4gICAgICAgIG1lbEJhbmRzW2ldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZWxCYW5kcztcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1ZlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICAgIHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNZWw7XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTWVsO1xuXG59LHtcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXRoL2xvZzEwXCI6NCxcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VMZm8yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgLy8gYXJyYXkgZGVmaW5pbmcgdGhlIGZyYW1lU2l6ZXMgb2YgdGhlIGlucHV0IHN0cmVhbXNzXG4gIC8vIGUuZy4gaWYgWzMsIDIsIDFdLCB3ZSB3YWl0IGZvciAzIGRpZmZlcmVudCBzb3VyY2VzIG9mIHJlc3BlY3RpdmUgMywgMiwgMSBmcmFtZVNpemVzXG4gIGZyYW1lU2l6ZXM6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgbXVsdGlwbGUgdmVjdG9yIGZyYW1lcy4gVGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiBkZXBlbmRzIG9uIHRoZVxuICAgKiBvcmRlciB0aGUgYnJhbmNoaW5nIHdhcyBpbml0aWFsbHkgbWFkZS4gVGhlIGZpcnN0IGJyYW5jaGUgaXMgbWFzdGVyXG4gICAqIG9uIHRoZSB0aW1lIGFuZCB0cmlnZ2VyIHRoZSBvdXRwdXQgb2YgdGhlIGZyYW1lLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5mcmFtZVNpemVzPW51bGxdIC0gQXJyYXkgdGhhdCBkZWZpbmVzIHRoZSBudW1iZXJcbiAgICogIG9mIHZhbHVlcyB0byBwaWNrIGZyb20gZWFjaCBpbmNvbW1pbmcgdmVjdG9ycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jb21vbidcbiAgICpcbiAgICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8ub3BlcmF0b3IuRXZlbnRJbih7XG4gICAqICAgdHlwZTogJ3ZlY3RvcicsXG4gICAqICAgZnJhbWVTaXplOiA0LFxuICAgKiAgIGZyYW1lUmF0ZTogMCxcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IG1pbk1heCA9IG5ldyBsZm8ub3BlcmF0b3IuTWluTWF4KCk7XG4gICAqIGNvbnN0IG1hZ25pdHVkZSA9IG5ldyBsZm8ub3BlcmF0b3IuTWFnbml0dWRlKCk7XG4gICAqXG4gICAqIC8vIHRha2UgdGhlIGZpcnN0IDIgdmFsdWVzIG9mIHRoZSBmaXJzdCBicmFuY2ggYW5kIDEgdmFsdWUgZnJvbSB0aGUgc2Vjb25kIGJyYW5jaFxuICAgKiBjb25zdCBtZXJnZSA9IG5ldyBsZm8ub3BlcmF0b3IuTWVyZ2VyKHsgZnJhbWVTaXplczogWzIsIDFdIH0pO1xuICAgKlxuICAgKiAvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyIGluIHdoaWNoIE1lcmdlciB3aWxsIGJlIGNhbGxlZFxuICAgKiBldmVudEluLmNvbm5lY3QobWluTWF4KTtcbiAgICogZXZlbnRJbi5jb25uZWN0KG1hZ25pdHVkZSk7XG4gICAqXG4gICAqIG1pbk1heC5jb25uZWN0KG1lcmdlcik7XG4gICAqIG1hZ25pdHVkZS5jb25uZWN0KG1lcmdlcik7XG4gICAqL1xufTtcbnZhciBNZXJnZXIgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoTWVyZ2VyLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gTWVyZ2VyKG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBNZXJnZXIpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChNZXJnZXIuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKE1lcmdlcikpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE1lcmdlciwgW3tcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIC8vIC4uLlxuICAgICAgdmFyIGZyYW1lU2l6ZXMgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZyYW1lU2l6ZXMnKTtcbiAgICAgIHZhciBudW1Tb3VyY2VzID0gZnJhbWVTaXplcy5sZW5ndGg7XG5cbiAgICAgIHZhciBmcmFtZVNpemUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Tb3VyY2VzOyBpKyspIHtcbiAgICAgICAgZnJhbWVTaXplICs9IGZyYW1lU2l6ZXNbaV07XG4gICAgICB9dGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gZnJhbWVTaXplO1xuICAgICAgdGhpcy5udW1Tb3VyY2VzID0gbnVtU291cmNlcztcbiAgICAgIHRoaXMuc291cmNlSW5kZXggPSAwO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmVjdG9yKCkge31cbiAgICAvLyBwcm9jZXNzU2lnbmFsKCkge30gLy8gbWFrZXMgbm8gc2VucyB0byBtZXJnZSBzaWduYWxzIChtYXliZSBNVVggLyBERU1VWClcblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc0ZyYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5zb3VyY2VJbmRleDtcbiAgICAgIHZhciBmcmFtZVNpemVzID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVNpemVzJyk7XG4gICAgICB2YXIgbnVtU291cmNlcyA9IGZyYW1lU2l6ZXMubGVuZ3RoO1xuICAgICAgdmFyIGlucHV0ID0gZnJhbWUuZGF0YTtcbiAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmZyYW1lLmRhdGE7XG5cbiAgICAgIC8vIGZpcnN0IHNvdXJjZSBkZWZpbmUgdGltZVxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCkgdGhpcy5mcmFtZS50aW1lID0gZnJhbWUudGltZTtcblxuICAgICAgdmFyIGN1cnJlbnRGcmFtZVNpemUgPSBmcmFtZVNpemVzW2N1cnJlbnRJbmRleF07XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50SW5kZXg7IGkrKykge1xuICAgICAgICBvZmZzZXQgKz0gZnJhbWVTaXplc1tpXTtcbiAgICAgIH0gLy8gY29weSBkYXRhXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY3VycmVudEZyYW1lU2l6ZTsgX2krKykge1xuICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgX2ldID0gaW5wdXRbX2ldO1xuICAgICAgfXRoaXMuc291cmNlSW5kZXggPSAodGhpcy5zb3VyY2VJbmRleCArIDEpICUgbnVtU291cmNlcztcblxuICAgICAgLy8gd2UganVzdCByZWNlaXZlZCB0aGUgbGFzdCBpbnB1dCwgb3V0cHV0IHRoZSBmcmFtZVxuICAgICAgaWYgKHRoaXMuc291cmNlSW5kZXggPT09IDApIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1lcmdlcjtcbn0oX0Jhc2VMZm8zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNZXJnZXI7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxudmFyIF9GZnQgPSByZXF1aXJlKCcuL0ZmdCcpO1xuXG52YXIgX0ZmdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GZnQpO1xuXG52YXIgX01lbCA9IHJlcXVpcmUoJy4vTWVsJyk7XG5cbnZhciBfTWVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lbCk7XG5cbnZhciBfRGN0ID0gcmVxdWlyZSgnLi9EY3QnKTtcblxudmFyIF9EY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBuYnJCYW5kczoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAyNCxcbiAgICBtZXRhOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgbmJyQ29lZnM6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogMTIsXG4gICAgbWV0YTogeyBraW5kOiAnc3RhdGljJyB9XG4gIH0sXG4gIG1pbkZyZXE6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWV0YTogeyBraW5kOiAnc3RhdGljJyB9XG4gIH0sXG4gIG1heEZyZXE6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YTogeyBraW5kOiAnc3RhdGljJyB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgTWZjYyBvZiB0aGUgaW5jb21taW5nIGBzaWduYWxgLiBJcyBiYXNpY2FsbHkgYSB3cmFwcGVyIGFyb3VuZFxuICogW2BGZnRgXXtAbGluayBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yLkZmdH0sIFtgTWVsYF17QGxpbmsgbW9kdWxlOmNvbW1vbi5vcGVyYXRvci5NZWx9XG4gKiBhbmQgW2BEY3RgXXtAbGluayBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yLkRjdH0uXG4gKlxuICogX3N1cHBvcnQgYHN0YW5kYWxvbmVgIHVzYWdlX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge25ickJhbmRzfSBbb3B0aW9ucy5uYnJCYW5kcz0yNF0gLSBOdW1iZXIgb2YgTWVsIGJhbmRzLlxuICogQHBhcmFtIHtuYnJDb2Vmc30gW29wdGlvbnMubmJyQ29lZnM9MTJdIC0gTnVtYmVyIG9mIG91dHB1dCBjb2Vmcy5cbiAqXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yLkZmdH1cbiAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb21tb24ub3BlcmF0b3IuTWVsfVxuICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvbW1vbi5vcGVyYXRvci5EY3R9XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBsZm8gZnJvbSAnd2F2ZXMtbGZvL25vZGUnXG4gKlxuICogY29uc3QgYXVkaW9JbkZpbGUgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luRmlsZSh7XG4gKiAgIGZpbGVuYW1lOiAncGF0aC90by9maWxlJyxcbiAqICAgZnJhbWVTaXplOiA1MTIsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBzbGljZXIgPSBuZXcgbGZvLm9wZXJhdG9yLlNsaWNlcih7XG4gKiAgIGZyYW1lU2l6ZTogMjU2LFxuICogfSk7XG4gKlxuICogY29uc3QgbWZjYyA9IG5ldyBsZm8ub3BlcmF0b3IuTWZjYyh7XG4gKiAgIG5ickJhbmRzOiAyNCxcbiAqICAgbmJyQ29lZnM6IDEyLFxuICogfSk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogYXVkaW9JbkZpbGUuY29ubmVjdChzbGljZXIpO1xuICogc2xpY2VyLmNvbm5lY3QobWZjYyk7XG4gKiBtZmNjLmNvbm5lY3QobG9nZ2VyKTtcbiAqXG4gKiBhdWRpb0luRmlsZS5zdGFydCgpO1xuICovXG5cbnZhciBNZmNjID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKE1mY2MsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBNZmNjKG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBNZmNjKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoTWZjYy5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoTWZjYykpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoTWZjYywgW3tcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIHZhciBuYnJCYW5kcyA9IHRoaXMucGFyYW1zLmdldCgnbmJyQmFuZHMnKTtcbiAgICAgIHZhciBuYnJDb2VmcyA9IHRoaXMucGFyYW1zLmdldCgnbmJyQ29lZnMnKTtcbiAgICAgIHZhciBtaW5GcmVxID0gdGhpcy5wYXJhbXMuZ2V0KCdtaW5GcmVxJyk7XG4gICAgICB2YXIgbWF4RnJlcSA9IHRoaXMucGFyYW1zLmdldCgnbWF4RnJlcScpO1xuICAgICAgdmFyIGlucHV0RnJhbWVTaXplID0gcHJldlN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB2YXIgaW5wdXRGcmFtZVJhdGUgPSBwcmV2U3RyZWFtUGFyYW1zLmZyYW1lUmF0ZTtcbiAgICAgIHZhciBpbnB1dFNhbXBsZVJhdGUgPSBwcmV2U3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG4gICAgICB2YXIgbmJyQmlucyA9IGlucHV0RnJhbWVTaXplIC8gMiArIDE7XG5cbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IG5ickNvZWZzO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3ZlY3Rvcic7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5kZXNjcmlwdGlvbiA9IFtdO1xuXG4gICAgICB0aGlzLmZmdCA9IG5ldyBfRmZ0Mi5kZWZhdWx0KHtcbiAgICAgICAgd2luZG93OiAnaGFubicsXG4gICAgICAgIG1vZGU6ICdwb3dlcicsXG4gICAgICAgIG5vcm06ICdwb3dlcicsXG4gICAgICAgIHNpemU6IGlucHV0RnJhbWVTaXplXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tZWwgPSBuZXcgX01lbDIuZGVmYXVsdCh7XG4gICAgICAgIG5ickJhbmRzOiBuYnJCYW5kcyxcbiAgICAgICAgbG9nOiB0cnVlLFxuICAgICAgICBwb3dlcjogMSxcbiAgICAgICAgbWluRnJlcTogbWluRnJlcSxcbiAgICAgICAgbWF4RnJlcTogbWF4RnJlcVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGN0ID0gbmV3IF9EY3QyLmRlZmF1bHQoe1xuICAgICAgICBvcmRlcjogbmJyQ29lZnNcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpbml0IHN0cmVhbXNcbiAgICAgIHRoaXMuZmZ0LmluaXRTdHJlYW0oe1xuICAgICAgICBmcmFtZVR5cGU6ICdzaWduYWwnLFxuICAgICAgICBmcmFtZVNpemU6IGlucHV0RnJhbWVTaXplLFxuICAgICAgICBmcmFtZVJhdGU6IGlucHV0RnJhbWVSYXRlLFxuICAgICAgICBzb3VyY2VTYW1wbGVSYXRlOiBpbnB1dFNhbXBsZVJhdGVcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1lbC5pbml0U3RyZWFtKHtcbiAgICAgICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAgICAgICAgZnJhbWVTaXplOiBuYnJCaW5zLFxuICAgICAgICBmcmFtZVJhdGU6IGlucHV0RnJhbWVSYXRlLFxuICAgICAgICBzb3VyY2VTYW1wbGVSYXRlOiBpbnB1dFNhbXBsZVJhdGVcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmRjdC5pbml0U3RyZWFtKHtcbiAgICAgICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAgICAgICAgZnJhbWVTaXplOiBuYnJCYW5kcyxcbiAgICAgICAgZnJhbWVSYXRlOiBpbnB1dEZyYW1lUmF0ZSxcbiAgICAgICAgc291cmNlU2FtcGxlUmF0ZTogaW5wdXRTYW1wbGVSYXRlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGBNZmNjYCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGEgZ3JhcGgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIFNpZ25hbCBjaHVuayB0byBhbmFseXNlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAtIE1mY2MgY29lZmZpY2llbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBtZmNjID0gbmV3IGxmby5vcGVyYXRvci5NZmNjKCk7XG4gICAgICogLy8gbWFuZGF0b3J5IGZvciB1c2UgaW4gc3RhbmRhbG9uZSBtb2RlXG4gICAgICogbWZjYy5pbml0U3RyZWFtKHsgZnJhbWVTaXplOiAyNTYsIGZyYW1lVHlwZTogJ3ZlY3RvcicgfSk7XG4gICAgICogbWZjYy5pbnB1dFNpZ25hbChzaWduYWwpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFNpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0U2lnbmFsKGRhdGEpIHtcbiAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgICB2YXIgbmJyQ29lZnMgPSB0aGlzLnBhcmFtcy5nZXQoJ25ickNvZWZzJyk7XG5cbiAgICAgIHZhciBiaW5zID0gdGhpcy5mZnQuaW5wdXRTaWduYWwoZGF0YSk7XG4gICAgICB2YXIgbWVsQmFuZHMgPSB0aGlzLm1lbC5pbnB1dFZlY3RvcihiaW5zKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKG1lbEJhbmRzKTtcbiAgICAgIHZhciBjb2VmcyA9IHRoaXMuZGN0LmlucHV0U2lnbmFsKG1lbEJhbmRzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYnJDb2VmczsgaSsrKSB7XG4gICAgICAgIG91dHB1dFtpXSA9IGNvZWZzW2ldO1xuICAgICAgfXJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgICB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWZjYztcbn0oX0Jhc2VMZm8zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNZmNjO1xuXG59LHtcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcIi4vRGN0XCI6MTU0LFwiLi9GZnRcIjoxNTYsXCIuL01lbFwiOjE1OSxcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VMZm8yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogRmluZCBtaW5pbXVuIGFuZCBtYXhpbXVtIHZhbHVlcyBvZiBhIGdpdmVuIGBzaWduYWxgLlxuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICogICBmcmFtZVNpemU6IDUxMixcbiAqICAgZnJhbWVUeXBlOiAnc2lnbmFsJyxcbiAqICAgc2FtcGxlUmF0ZTogMCxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IG1pbk1heCA9IG5ldyBsZm8ub3BlcmF0b3IuTWluTWF4KCk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KG1pbk1heCk7XG4gKiBtaW5NYXguY29ubmVjdChsb2dnZXIpO1xuICogZXZlbnRJbi5zdGFydCgpXG4gKlxuICogLy8gY3JlYXRlIGEgZnJhbWVcbiAqIGNvbnN0IHNpZ25hbCA9IG5ldyBGbG9hdDMyQXJyYXkoNTEyKTtcbiAqIGZvciAobGV0IGkgPSAwOyBpIDwgNTEyOyBpKyspXG4gKiAgIHNpZ25hbFtpXSA9IGkgKyAxO1xuICpcbiAqIGV2ZW50SW4ucHJvY2VzcyhudWxsLCBzaWduYWwpO1xuICogPiBbMSwgNTEyXTtcbiAqL1xudmFyIE1pbk1heCA9IGZ1bmN0aW9uIChfQmFzZUxmbykge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShNaW5NYXgsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBNaW5NYXgoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE1pbk1heCk7XG5cbiAgICAvLyB0aHJvdyBlcnJvcnMgaWYgb3B0aW9ucyBhcmUgZ2l2ZW5cbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoTWluTWF4Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShNaW5NYXgpKS5jYWxsKHRoaXMsIHt9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE1pbk1heCwgW3tcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcygpIHtcbiAgICAgIHZhciBwcmV2U3RyZWFtUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVR5cGUgPSAndmVjdG9yJztcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IDI7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5kZXNjcmlwdGlvbiA9IFsnbWluJywgJ21heCddO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGUgYE1pbk1heGAgb3BlcmF0b3IgaW4gYHN0YW5kYWxvbmVgIG1vZGUgKGkuZS4gb3V0c2lkZSBvZiBhIGdyYXBoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5fSBkYXRhIC0gSW5wdXQgc2lnbmFsLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAtIE1pbiBhbmQgbWF4IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbWluTWF4ID0gbmV3IE1pbk1heCgpO1xuICAgICAqIG1pbk1heC5pbml0U3RyZWFtKHsgZnJhbWVUeXBlOiAnc2lnbmFsJywgZnJhbWVTaXplOiAxMCB9KTtcbiAgICAgKlxuICAgICAqIG1pbk1heC5pbnB1dFNpZ25hbChbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0pO1xuICAgICAqID4gWzAsIDVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lucHV0U2lnbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5wdXRTaWduYWwoZGF0YSkge1xuICAgICAgdmFyIG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgICB2YXIgbWluID0gK0luZmluaXR5O1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCBtaW4pIG1pbiA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXgpIG1heCA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBvdXREYXRhWzBdID0gbWluO1xuICAgICAgb3V0RGF0YVsxXSA9IG1heDtcblxuICAgICAgcmV0dXJuIG91dERhdGE7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgICB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWluTWF4O1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1pbk1heDtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfZ2V0MiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXQnKTtcblxudmFyIF9nZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Mik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmaW5pdGlvbnMgPSB7XG4gIG9yZGVyOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIG1pbjogMSxcbiAgICBtYXg6IDFlOSxcbiAgICBkZWZhdWx0OiAxMCxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBmaWxsOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBtaW46IC1JbmZpbml0eSxcbiAgICBtYXg6ICtJbmZpbml0eSxcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhIG1vdmluZyBhdmVyYWdlIG9wZXJhdGlvbiBvbiB0aGUgaW5jb21taW5nIGZyYW1lcyAoYHNjYWxhcmAgb3JcbiAqIGB2ZWN0b3JgIHR5cGUpLiBJZiB0aGUgaW5wdXQgaXMgb2YgdHlwZSB2ZWN0b3IsIHRoZSBtb3ZpbmcgYXZlcmFnZSBpc1xuICogY29tcHV0ZWQgZm9yIGVhY2ggZGltZW5zaW9uIGluIHBhcmFsbGVsLiBJZiB0aGUgc291cmNlIHNhbXBsZSByYXRlIGlzIGRlZmluZWRcbiAqIGZyYW1lIHRpbWUgaXMgc2hpZnRlZCB0byB0aGUgbWlkZGxlIG9mIHRoZSB3aW5kb3cgZGVmaW5lZCBieSB0aGUgb3JkZXIuXG4gKlxuICogX3N1cHBvcnQgYHN0YW5kYWxvbmVgIHVzYWdlX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub3JkZXI9MTBdIC0gTnVtYmVyIG9mIHN1Y2Nlc3NpdmUgdmFsdWVzIG9uIHdoaWNoXG4gKiAgdGhlIGF2ZXJhZ2UgaXMgY29tcHV0ZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmlsbD0wXSAtIFZhbHVlIHRvIGZpbGwgdGhlIHJpbmcgYnVmZmVyIHdpdGggYmVmb3JlXG4gKiAgdGhlIGZpcnN0IGlucHV0IGZyYW1lLlxuICpcbiAqIEB0b2RvIC0gSW1wbGVtZW50IGBwcm9jZXNzU2lnbmFsYCA/XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tbW9uJztcbiAqXG4gKiBjb25zdCBldmVudEluID0gbmV3IGxmby5zb3VyY2UuRXZlbnRJbih7XG4gKiAgIGZyYW1lU2l6ZTogMixcbiAqICAgZnJhbWVUeXBlOiAndmVjdG9yJ1xuICogfSk7XG4gKlxuICogY29uc3QgbW92aW5nQXZlcmFnZSA9IG5ldyBsZm8ub3BlcmF0b3IuTW92aW5nQXZlcmFnZSh7XG4gKiAgIG9yZGVyOiA1LFxuICogICBmaWxsOiAwXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBsb2dnZXIgPSBuZXcgbGZvLnNpbmsuTG9nZ2VyKHsgZGF0YTogdHJ1ZSB9KTtcbiAqXG4gKiBldmVudEluLmNvbm5lY3QobW92aW5nQXZlcmFnZSk7XG4gKiBtb3ZpbmdBdmVyYWdlLmNvbm5lY3QobG9nZ2VyKTtcbiAqXG4gKiBldmVudEluLnN0YXJ0KCk7XG4gKlxuICogZXZlbnRJbi5wcm9jZXNzKG51bGwsIFsxLCAxXSk7XG4gKiA+IFswLjIsIDAuMl1cbiAqIGV2ZW50SW4ucHJvY2VzcyhudWxsLCBbMSwgMV0pO1xuICogPiBbMC40LCAwLjRdXG4gKiBldmVudEluLnByb2Nlc3MobnVsbCwgWzEsIDFdKTtcbiAqID4gWzAuNiwgMC42XVxuICogZXZlbnRJbi5wcm9jZXNzKG51bGwsIFsxLCAxXSk7XG4gKiA+IFswLjgsIDAuOF1cbiAqIGV2ZW50SW4ucHJvY2VzcyhudWxsLCBbMSwgMV0pO1xuICogPiBbMSwgMV1cbiAqL1xuXG52YXIgTW92aW5nQXZlcmFnZSA9IGZ1bmN0aW9uIChfQmFzZUxmbykge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShNb3ZpbmdBdmVyYWdlLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gTW92aW5nQXZlcmFnZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgTW92aW5nQXZlcmFnZSk7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChNb3ZpbmdBdmVyYWdlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShNb3ZpbmdBdmVyYWdlKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuc3VtID0gbnVsbDtcbiAgICBfdGhpcy5yaW5nQnVmZmVyID0gbnVsbDtcbiAgICBfdGhpcy5yaW5nSW5kZXggPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoTW92aW5nQXZlcmFnZSwgW3tcbiAgICBrZXk6ICdvblBhcmFtVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSwgbWV0YXMpIHtcbiAgICAgICgwLCBfZ2V0My5kZWZhdWx0KShNb3ZpbmdBdmVyYWdlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoTW92aW5nQXZlcmFnZS5wcm90b3R5cGUpLCAnb25QYXJhbVVwZGF0ZScsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgICAgLy8gQHRvZG8gLSBzaG91bGQgYmUgZG9uZSBsYXppbHkgaW4gcHJvY2Vzc1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ29yZGVyJzpcbiAgICAgICAgICB0aGlzLnByb2Nlc3NTdHJlYW1QYXJhbXMoKTtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RyZWFtKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICAgIHRoaXMucmVzZXRTdHJlYW0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuXG4gICAgICB0aGlzLnJpbmdCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KG9yZGVyICogZnJhbWVTaXplKTtcblxuICAgICAgaWYgKGZyYW1lU2l6ZSA+IDEpIHRoaXMuc3VtID0gbmV3IEZsb2F0MzJBcnJheShmcmFtZVNpemUpO2Vsc2UgdGhpcy5zdW0gPSAwO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldFN0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0U3RyZWFtKCkge1xuICAgICAgKDAsIF9nZXQzLmRlZmF1bHQpKE1vdmluZ0F2ZXJhZ2UucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShNb3ZpbmdBdmVyYWdlLnByb3RvdHlwZSksICdyZXNldFN0cmVhbScsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHZhciBvcmRlciA9IHRoaXMucGFyYW1zLmdldCgnb3JkZXInKTtcbiAgICAgIHZhciBmaWxsID0gdGhpcy5wYXJhbXMuZ2V0KCdmaWxsJyk7XG4gICAgICB2YXIgcmluZ0J1ZmZlciA9IHRoaXMucmluZ0J1ZmZlcjtcbiAgICAgIHZhciByaW5nTGVuZ3RoID0gcmluZ0J1ZmZlci5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJpbmdCdWZmZXJbaV0gPSBmaWxsO1xuICAgICAgfXZhciBmaWxsU3VtID0gb3JkZXIgKiBmaWxsO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcblxuICAgICAgaWYgKGZyYW1lU2l6ZSA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZyYW1lU2l6ZTsgX2krKykge1xuICAgICAgICAgIHRoaXMuc3VtW19pXSA9IGZpbGxTdW07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3VtID0gZmlsbFN1bTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yaW5nSW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU2NhbGFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NjYWxhcihmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5kYXRhWzBdID0gdGhpcy5pbnB1dFNjYWxhcihmcmFtZS5kYXRhWzBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGBNb3ZpbmdBdmVyYWdlYCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGFcbiAgICAgKiBncmFwaCkgd2l0aCBhIGBzY2FsYXJgIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVmFsdWUgdG8gZmVlZCB0aGUgbW92aW5nIGF2ZXJhZ2Ugd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gQXZlcmFnZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICAgICAqXG4gICAgICogY29uc3QgbW92aW5nQXZlcmFnZSA9IG5ldyBsZm8ub3BlcmF0b3IuTW92aW5nQXZlcmFnZSh7IG9yZGVyOiA1IH0pO1xuICAgICAqIG1vdmluZ0F2ZXJhZ2UuaW5pdFN0cmVhbSh7IGZyYW1lU2l6ZTogMSwgZnJhbWVUeXBlOiAnc2NhbGFyJyB9KTtcbiAgICAgKlxuICAgICAqIG1vdmluZ0F2ZXJhZ2UuaW5wdXRTY2FsYXIoMSk7XG4gICAgICogPiAwLjJcbiAgICAgKiBtb3ZpbmdBdmVyYWdlLmlucHV0U2NhbGFyKDEpO1xuICAgICAqID4gMC40XG4gICAgICogbW92aW5nQXZlcmFnZS5pbnB1dFNjYWxhcigxKTtcbiAgICAgKiA+IDAuNlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFNjYWxhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0U2NhbGFyKHZhbHVlKSB7XG4gICAgICB2YXIgb3JkZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ29yZGVyJyk7XG4gICAgICB2YXIgcmluZ0luZGV4ID0gdGhpcy5yaW5nSW5kZXg7XG4gICAgICB2YXIgcmluZ0J1ZmZlciA9IHRoaXMucmluZ0J1ZmZlcjtcbiAgICAgIHZhciBzdW0gPSB0aGlzLnN1bTtcblxuICAgICAgc3VtIC09IHJpbmdCdWZmZXJbcmluZ0luZGV4XTtcbiAgICAgIHN1bSArPSB2YWx1ZTtcblxuICAgICAgdGhpcy5zdW0gPSBzdW07XG4gICAgICB0aGlzLnJpbmdCdWZmZXJbcmluZ0luZGV4XSA9IHZhbHVlO1xuICAgICAgdGhpcy5yaW5nSW5kZXggPSAocmluZ0luZGV4ICsgMSkgJSBvcmRlcjtcblxuICAgICAgcmV0dXJuIHN1bSAvIG9yZGVyO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgICAgdGhpcy5pbnB1dFZlY3RvcihmcmFtZS5kYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGBNb3ZpbmdBdmVyYWdlYCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGFcbiAgICAgKiBncmFwaCkgd2l0aCBhIGB2ZWN0b3JgIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gVmFsdWVzIHRvIGZlZWQgdGhlIG1vdmluZyBhdmVyYWdlIHdpdGguXG4gICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAtIEF2ZXJhZ2UgdmFsdWUgZm9yIGVhY2ggZGltZW5zaW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gICAgICpcbiAgICAgKiBjb25zdCBtb3ZpbmdBdmVyYWdlID0gbmV3IGxmby5vcGVyYXRvci5Nb3ZpbmdBdmVyYWdlKHsgb3JkZXI6IDUgfSk7XG4gICAgICogbW92aW5nQXZlcmFnZS5pbml0U3RyZWFtKHsgZnJhbWVTaXplOiAyLCBmcmFtZVR5cGU6ICdzY2FsYXInIH0pO1xuICAgICAqXG4gICAgICogbW92aW5nQXZlcmFnZS5pbnB1dEFycmF5KFsxLCAxXSk7XG4gICAgICogPiBbMC4yLCAwLjJdXG4gICAgICogbW92aW5nQXZlcmFnZS5pbnB1dEFycmF5KFsxLCAxXSk7XG4gICAgICogPiBbMC40LCAwLjRdXG4gICAgICogbW92aW5nQXZlcmFnZS5pbnB1dEFycmF5KFsxLCAxXSk7XG4gICAgICogPiBbMC42LCAwLjZdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lucHV0VmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5wdXRWZWN0b3IodmFsdWVzKSB7XG4gICAgICB2YXIgb3JkZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ29yZGVyJyk7XG4gICAgICB2YXIgb3V0RnJhbWUgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIHJpbmdJbmRleCA9IHRoaXMucmluZ0luZGV4O1xuICAgICAgdmFyIHJpbmdPZmZzZXQgPSByaW5nSW5kZXggKiBmcmFtZVNpemU7XG4gICAgICB2YXIgcmluZ0J1ZmZlciA9IHRoaXMucmluZ0J1ZmZlcjtcbiAgICAgIHZhciBzdW0gPSB0aGlzLnN1bTtcbiAgICAgIHZhciBzY2FsZSA9IDEgLyBvcmRlcjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgICB2YXIgcmluZ0J1ZmZlckluZGV4ID0gcmluZ09mZnNldCArIGk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgdmFyIGxvY2FsU3VtID0gc3VtW2ldO1xuXG4gICAgICAgIGxvY2FsU3VtIC09IHJpbmdCdWZmZXJbcmluZ0J1ZmZlckluZGV4XTtcbiAgICAgICAgbG9jYWxTdW0gKz0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5zdW1baV0gPSBsb2NhbFN1bTtcbiAgICAgICAgb3V0RnJhbWVbaV0gPSBsb2NhbFN1bSAqIHNjYWxlO1xuICAgICAgICByaW5nQnVmZmVyW3JpbmdCdWZmZXJJbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yaW5nSW5kZXggPSAocmluZ0luZGV4ICsgMSkgJSBvcmRlcjtcblxuICAgICAgcmV0dXJuIG91dEZyYW1lO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzRnJhbWUoZnJhbWUpIHtcbiAgICAgIHRoaXMucHJlcGFyZUZyYW1lKCk7XG4gICAgICB0aGlzLnByb2Nlc3NGdW5jdGlvbihmcmFtZSk7XG5cbiAgICAgIHZhciBvcmRlciA9IHRoaXMucGFyYW1zLmdldCgnb3JkZXInKTtcbiAgICAgIHZhciB0aW1lID0gZnJhbWUudGltZTtcbiAgICAgIC8vIHNoaWZ0IHRpbWUgdG8gdGFrZSBhY2NvdW50IG9mIHRoZSBhZGRlZCBsYXRlbmN5XG4gICAgICBpZiAodGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlUmF0ZSkgdGltZSAtPSAwLjUgKiAob3JkZXIgLSAxKSAvIHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG5cbiAgICAgIHRoaXMuZnJhbWUudGltZSA9IHRpbWU7XG4gICAgICB0aGlzLmZyYW1lLm1ldGFkYXRhID0gZnJhbWUubWV0YWRhdGE7XG5cbiAgICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1vdmluZ0F2ZXJhZ2U7XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTW92aW5nQXZlcmFnZTtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0XCI6MTgsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfZ2V0MiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXQnKTtcblxudmFyIF9nZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Mik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmaW5pdGlvbnMgPSB7XG4gIG9yZGVyOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIG1pbjogMSxcbiAgICBtYXg6IDFlOSxcbiAgICBkZWZhdWx0OiA5LFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgZmlsbDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgbWluOiAtSW5maW5pdHksXG4gICAgbWF4OiArSW5maW5pdHksXG4gICAgZGVmYXVsdDogMCxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhIG1vdmluZyBtZWRpYW4gb3BlcmF0aW9uIG9uIHRoZSBpbmNvbW1pbmcgZnJhbWVzIChgc2NhbGFyYCBvclxuICogYHZlY3RvcmAgdHlwZSkuIElmIHRoZSBpbnB1dCBpcyBvZiB0eXBlIHZlY3RvciwgdGhlIG1vdmluZyBtZWRpYW4gaXNcbiAqIGNvbXB1dGVkIGZvciBlYWNoIGRpbWVuc2lvbiBpbiBwYXJhbGxlbC4gSWYgdGhlIHNvdXJjZSBzYW1wbGUgcmF0ZSBpcyBkZWZpbmVkXG4gKiBmcmFtZSB0aW1lIGlzIHNoaWZ0ZWQgdG8gdGhlIG1pZGRsZSBvZiB0aGUgd2luZG93IGRlZmluZWQgYnkgdGhlIG9yZGVyLlxuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9yZGVyPTldIC0gTnVtYmVyIG9mIHN1Y2Nlc3NpdmUgdmFsdWVzIGluIHdoaWNoXG4gKiAgdGhlIG1lZGlhbiBpcyBzZWFyY2hlZC4gVGhpcyB2YWx1ZSBtdXN0IGJlIG9kZC4gX2R5bmFtaWMgcGFyYW1ldGVyX1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZpbGw9MF0gLSBWYWx1ZSB0byBmaWxsIHRoZSByaW5nIGJ1ZmZlciB3aXRoIGJlZm9yZVxuICogIHRoZSBmaXJzdCBpbnB1dCBmcmFtZS4gX2R5bmFtaWMgcGFyYW1ldGVyX1xuICpcbiAqIEB0b2RvIC0gSW1wbGVtZW50IGBwcm9jZXNzU2lnbmFsYFxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICogICBmcmFtZVNpemU6IDIsXG4gKiAgIGZyYW1lVHlwZTogJ3ZlY3RvcicsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBtb3ZpbmdNZWRpYW4gPSBuZXcgbGZvLm9wZXJhdG9yLk1vdmluZ01lZGlhbih7XG4gKiAgIG9yZGVyOiA1LFxuICogICBmaWxsOiAwLFxuICogfSk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KG1vdmluZ01lZGlhbik7XG4gKiBtb3ZpbmdNZWRpYW4uY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIGV2ZW50SW4uc3RhcnQoKTtcbiAqXG4gKiBldmVudEluLnByb2Nlc3NGcmFtZShudWxsLCBbMSwgMV0pO1xuICogPiBbMCwgMF1cbiAqIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKG51bGwsIFsyLCAyXSk7XG4gKiA+IFswLCAwXVxuICogZXZlbnRJbi5wcm9jZXNzRnJhbWUobnVsbCwgWzMsIDNdKTtcbiAqID4gWzEsIDFdXG4gKiBldmVudEluLnByb2Nlc3NGcmFtZShudWxsLCBbNCwgNF0pO1xuICogPiBbMiwgMl1cbiAqIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKG51bGwsIFs1LCA1XSk7XG4gKiA+IFszLCAzXVxuICovXG5cbnZhciBNb3ZpbmdNZWRpYW4gPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoTW92aW5nTWVkaWFuLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gTW92aW5nTWVkaWFuKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBNb3ZpbmdNZWRpYW4pO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoTW92aW5nTWVkaWFuLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShNb3ZpbmdNZWRpYW4pKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5yaW5nQnVmZmVyID0gbnVsbDtcbiAgICBfdGhpcy5zb3J0QnVmZmVyID0gbnVsbDtcbiAgICBfdGhpcy5yaW5nSW5kZXggPSAwO1xuXG4gICAgX3RoaXMuX2Vuc3VyZU9kZE9yZGVyKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShNb3ZpbmdNZWRpYW4sIFt7XG4gICAga2V5OiAnX2Vuc3VyZU9kZE9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Vuc3VyZU9kZE9yZGVyKCkge1xuICAgICAgaWYgKHRoaXMucGFyYW1zLmdldCgnb3JkZXInKSAlIDIgPT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSAnICsgb3JkZXIgKyAnIGZvciBwYXJhbSBcIm9yZGVyXCIgLSBtdXN0IGJlIG9kZCcpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvblBhcmFtVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSwgbWV0YXMpIHtcbiAgICAgICgwLCBfZ2V0My5kZWZhdWx0KShNb3ZpbmdNZWRpYW4ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShNb3ZpbmdNZWRpYW4ucHJvdG90eXBlKSwgJ29uUGFyYW1VcGRhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlLCBtZXRhcyk7XG5cbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdvcmRlcic6XG4gICAgICAgICAgdGhpcy5fZW5zdXJlT2RkT3JkZXIoKTtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NTdHJlYW1QYXJhbXMoKTtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RyZWFtKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICAgIHRoaXMucmVzZXRTdHJlYW0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuICAgICAgLy8gb3V0VHlwZSBpcyBzaW1pbGFyIHRvIGlucHV0IHR5cGVcblxuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBvcmRlciA9IHRoaXMucGFyYW1zLmdldCgnb3JkZXInKTtcblxuICAgICAgdGhpcy5yaW5nQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShmcmFtZVNpemUgKiBvcmRlcik7XG4gICAgICB0aGlzLnNvcnRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGZyYW1lU2l6ZSAqIG9yZGVyKTtcblxuICAgICAgdGhpcy5taW5JbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KGZyYW1lU2l6ZSk7XG5cbiAgICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0U3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTdHJlYW0oKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoTW92aW5nTWVkaWFuLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoTW92aW5nTWVkaWFuLnByb3RvdHlwZSksICdyZXNldFN0cmVhbScsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHZhciBmaWxsID0gdGhpcy5wYXJhbXMuZ2V0KCdmaWxsJyk7XG4gICAgICB2YXIgcmluZ0J1ZmZlciA9IHRoaXMucmluZ0J1ZmZlcjtcbiAgICAgIHZhciByaW5nTGVuZ3RoID0gcmluZ0J1ZmZlci5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucmluZ0J1ZmZlcltpXSA9IGZpbGw7XG4gICAgICB9dGhpcy5yaW5nSW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU2NhbGFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NjYWxhcihmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5kYXRhWzBdID0gdGhpcy5pbnB1dFNjYWxhcihmcmFtZS5kYXRhWzBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZm9yIHRoZSB1c2Ugb2YgYSBgTW92aW5nTWVkaWFuYCBvdXRzaWRlIGEgZ3JhcGggKGUuZy4gaW5zaWRlXG4gICAgICogYW5vdGhlciBub2RlKSwgaW4gdGhpcyBjYXNlIGBwcm9jZXNzU3RyZWFtUGFyYW1zYCBhbmQgYHJlc2V0U3RyZWFtYFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgbWFudWFsbHkgb24gdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBWYWx1ZSB0byBmZWVkIHRoZSBtb3ZpbmcgbWVkaWFuIHdpdGguXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIE1lZGlhbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICAgICAqXG4gICAgICogY29uc3QgbW92aW5nTWVkaWFuID0gbmV3IE1vdmluZ01lZGlhbih7IG9yZGVyOiA1IH0pO1xuICAgICAqIG1vdmluZ01lZGlhbi5pbml0U3RyZWFtKHsgZnJhbWVTaXplOiAxLCBmcmFtZVR5cGU6ICdzY2FsYXInIH0pO1xuICAgICAqXG4gICAgICogbW92aW5nTWVkaWFuLmlucHV0U2NhbGFyKDEpO1xuICAgICAqID4gMFxuICAgICAqIG1vdmluZ01lZGlhbi5pbnB1dFNjYWxhcigyKTtcbiAgICAgKiA+IDBcbiAgICAgKiBtb3ZpbmdNZWRpYW4uaW5wdXRTY2FsYXIoMyk7XG4gICAgICogPiAxXG4gICAgICogbW92aW5nTWVkaWFuLmlucHV0U2NhbGFyKDQpO1xuICAgICAqID4gMlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFNjYWxhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0U2NhbGFyKHZhbHVlKSB7XG4gICAgICB2YXIgcmluZ0luZGV4ID0gdGhpcy5yaW5nSW5kZXg7XG4gICAgICB2YXIgcmluZ0J1ZmZlciA9IHRoaXMucmluZ0J1ZmZlcjtcbiAgICAgIHZhciBzb3J0QnVmZmVyID0gdGhpcy5zb3J0QnVmZmVyO1xuICAgICAgdmFyIG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuICAgICAgdmFyIG1lZGlhbkluZGV4ID0gKG9yZGVyIC0gMSkgLyAyO1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuXG4gICAgICByaW5nQnVmZmVyW3JpbmdJbmRleF0gPSB2YWx1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWVkaWFuSW5kZXg7IGkrKykge1xuICAgICAgICB2YXIgbWluID0gK0luZmluaXR5O1xuICAgICAgICB2YXIgbWluSW5kZXggPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgb3JkZXI7IGorKykge1xuICAgICAgICAgIGlmIChpID09PSAwKSBzb3J0QnVmZmVyW2pdID0gcmluZ0J1ZmZlcltqXTtcblxuICAgICAgICAgIGlmIChzb3J0QnVmZmVyW2pdIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSBzb3J0QnVmZmVyW2pdO1xuICAgICAgICAgICAgbWluSW5kZXggPSBqO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN3YXAgbWluSW5kZXggYW5kIHN0YXJ0SW5kZXhcbiAgICAgICAgdmFyIGNhY2hlID0gc29ydEJ1ZmZlcltzdGFydEluZGV4XTtcbiAgICAgICAgc29ydEJ1ZmZlcltzdGFydEluZGV4XSA9IHNvcnRCdWZmZXJbbWluSW5kZXhdO1xuICAgICAgICBzb3J0QnVmZmVyW21pbkluZGV4XSA9IGNhY2hlO1xuXG4gICAgICAgIHN0YXJ0SW5kZXggKz0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lZGlhbiA9IHNvcnRCdWZmZXJbbWVkaWFuSW5kZXhdO1xuICAgICAgdGhpcy5yaW5nSW5kZXggPSAocmluZ0luZGV4ICsgMSkgJSBvcmRlcjtcblxuICAgICAgcmV0dXJuIG1lZGlhbjtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1ZlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICAgIHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGZvciB0aGUgdXNlIG9mIGEgYE1vdmluZ01lZGlhbmAgb3V0c2lkZSBhIGdyYXBoIChlLmcuIGluc2lkZVxuICAgICAqIGFub3RoZXIgbm9kZSksIGluIHRoaXMgY2FzZSBgcHJvY2Vzc1N0cmVhbVBhcmFtc2AgYW5kIGByZXNldFN0cmVhbWBcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIG1hbnVhbGx5IG9uIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gVmFsdWVzIHRvIGZlZWQgdGhlIG1vdmluZyBtZWRpYW4gd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IC0gTWVkaWFuIHZhbHVlcyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICAgKlxuICAgICAqIGNvbnN0IG1vdmluZ01lZGlhbiA9IG5ldyBNb3ZpbmdNZWRpYW4oeyBvcmRlcjogMywgZmlsbDogMCB9KTtcbiAgICAgKiBtb3ZpbmdNZWRpYW4uaW5pdFN0cmVhbSh7IGZyYW1lU2l6ZTogMywgZnJhbWVUeXBlOiAndmVjdG9yJyB9KTtcbiAgICAgKlxuICAgICAqIG1vdmluZ01lZGlhbi5pbnB1dEFycmF5KFsxLCAxXSk7XG4gICAgICogPiBbMCwgMF1cbiAgICAgKiBtb3ZpbmdNZWRpYW4uaW5wdXRBcnJheShbMiwgMl0pO1xuICAgICAqID4gWzEsIDFdXG4gICAgICogbW92aW5nTWVkaWFuLmlucHV0QXJyYXkoWzMsIDNdKTtcbiAgICAgKiA+IFsyLCAyXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFZlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0VmVjdG9yKHZhbHVlcykge1xuICAgICAgdmFyIG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuICAgICAgdmFyIHJpbmdCdWZmZXIgPSB0aGlzLnJpbmdCdWZmZXI7XG4gICAgICB2YXIgcmluZ0luZGV4ID0gdGhpcy5yaW5nSW5kZXg7XG4gICAgICB2YXIgc29ydEJ1ZmZlciA9IHRoaXMuc29ydEJ1ZmZlcjtcbiAgICAgIHZhciBvdXRGcmFtZSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICAgIHZhciBtaW5JbmRpY2VzID0gdGhpcy5taW5JbmRpY2VzO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBtZWRpYW5JbmRleCA9IE1hdGguZmxvb3Iob3JkZXIgLyAyKTtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWVkaWFuSW5kZXg7IGkrKykge1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZnJhbWVTaXplOyBqKyspIHtcbiAgICAgICAgICBvdXRGcmFtZVtqXSA9ICtJbmZpbml0eTtcbiAgICAgICAgICBtaW5JbmRpY2VzW2pdID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGsgPSBzdGFydEluZGV4OyBrIDwgb3JkZXI7IGsrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gayAqIGZyYW1lU2l6ZSArIGo7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSByaW5nIGJ1ZmZlciBjb3JyZXNwb25kaW5nIHRvIGN1cnJlbnRcbiAgICAgICAgICAgIGlmIChrID09PSByaW5nSW5kZXggJiYgaSA9PT0gMCkgcmluZ0J1ZmZlcltpbmRleF0gPSB2YWx1ZXNbal07XG5cbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWUgaW4gc29ydCBidWZmZXIgb24gZmlyc3QgcGFzc1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHNvcnRCdWZmZXJbaW5kZXhdID0gcmluZ0J1ZmZlcltpbmRleF07XG5cbiAgICAgICAgICAgIC8vIGZpbmQgbWluaXVtIGluIHRoZSByZW1haW5pbmcgYXJyYXlcbiAgICAgICAgICAgIGlmIChzb3J0QnVmZmVyW2luZGV4XSA8IG91dEZyYW1lW2pdKSB7XG4gICAgICAgICAgICAgIG91dEZyYW1lW2pdID0gc29ydEJ1ZmZlcltpbmRleF07XG4gICAgICAgICAgICAgIG1pbkluZGljZXNbal0gPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzd2FwIG1pbmltdW0gYW5kIGN1cmVudCBpbmRleFxuICAgICAgICAgIHZhciBzd2FwSW5kZXggPSBzdGFydEluZGV4ICogZnJhbWVTaXplICsgajtcbiAgICAgICAgICB2YXIgdiA9IHNvcnRCdWZmZXJbc3dhcEluZGV4XTtcbiAgICAgICAgICBzb3J0QnVmZmVyW3N3YXBJbmRleF0gPSBzb3J0QnVmZmVyW21pbkluZGljZXNbal1dO1xuICAgICAgICAgIHNvcnRCdWZmZXJbbWluSW5kaWNlc1tqXV0gPSB2O1xuXG4gICAgICAgICAgLy8gc3RvcmUgdGhpcyBtaW5pbXVtIHZhbHVlIGFzIGN1cnJlbnQgcmVzdWx0XG4gICAgICAgICAgb3V0RnJhbWVbal0gPSBzb3J0QnVmZmVyW3N3YXBJbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydEluZGV4ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmluZ0luZGV4ID0gKHJpbmdJbmRleCArIDEpICUgb3JkZXI7XG5cbiAgICAgIHJldHVybiB0aGlzLmZyYW1lLmRhdGE7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NGcmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgICAgdGhpcy5wcmVwcm9jZXNzRnJhbWUoKTtcbiAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKTtcblxuICAgICAgdmFyIG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuICAgICAgdmFyIHRpbWUgPSBmcmFtZS50aW1lO1xuICAgICAgLy8gc2hpZnQgdGltZSB0byB0YWtlIGFjY291bnQgb2YgdGhlIGFkZGVkIGxhdGVuY3lcbiAgICAgIGlmICh0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlKSB0aW1lIC09IDAuNSAqIChvcmRlciAtIDEpIC8gdGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlUmF0ZTtcblxuICAgICAgdGhpcy5mcmFtZS50aW1lID0gdGltZTtcbiAgICAgIHRoaXMuZnJhbWUubWV0YWRhdGEgPSBmcmFtZS5tZXRhZGF0YTtcblxuICAgICAgdGhpcy5wcm9wYWdhdGVGcmFtZSh0aW1lLCB0aGlzLm91dEZyYW1lLCBtZXRhZGF0YSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNb3ZpbmdNZWRpYW47XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTW92aW5nTWVkaWFuO1xuXG59LHtcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXRcIjoxOCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VMZm8yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgLy8gZmxvYXQgb3IgYXJyYXlcbiAgZmFjdG9yOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogMVxuICB9XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGEgZ2l2ZW4gc2lnbmFsIG9yIHZlY3RvciBieSBhIGdpdmVuIGZhY3Rvci4gT24gdmVjdG9yXG4gKiBzdHJlYW1zLCBgZmFjdG9yYCBjYW4gYmUgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIGFwcGx5IG9uIGVhY2ggZGltZW5zaW9uIG9mIHRoZVxuICogdmVjdG9yIGZyYW1lcy5cbiAqXG4gKiBfc3VwcG9ydCBgc3RhbmRhbG9uZWAgdXNhZ2VfXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvdmVycmlkZSBkZWZhdWx0IHZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLmZhY3Rvcj0xXSAtIGZhY3RvciBvciBhcnJheSBvZiBmYWN0b3IgdG9cbiAqICBhcHBseSBvbiB0aGUgaW5jb21taW5nIGZyYW1lLiBTZXR0aW5nIGFuIGFycmF5IGlzIG9ubHkgZGVmaW5lZCBpbiBjYXNlIG9mXG4gKiAgYSB2ZWN0b3Igc3RyZWFtLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tbW9uJztcbiAqXG4gKiBjb25zdCBldmVudEluID0gbmV3IGxmby5vcGVyYXRvci5FdmVudEluKHtcbiAqICAgdHlwZTogJ3ZlY3RvcicsXG4gKiAgIGZyYW1lU2l6ZTogMixcbiAqICAgZnJhbWVSYXRlOiAwLFxuICogfSk7XG4gKiBjb25zdCBzY2FsZXIgPSBuZXcgbGZvLm9wZXJhdG9yLk11bHRpcGxpZXIoeyBmYWN0b3I6IDAuMSB9KTtcbiAqXG4gKiBldmVudEluLmNvbm5lY3Qoc2NhbGVyKTtcbiAqXG4gKiBldmVudEluLnByb2Nlc3MobnVsbCwgWzIsIDNdKTtcbiAqID4gWzAuMiwgMC4zXVxuICovXG5cbnZhciBNdWx0aXBsaWVyID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKE11bHRpcGxpZXIsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBNdWx0aXBsaWVyKG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBNdWx0aXBsaWVyKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoTXVsdGlwbGllci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoTXVsdGlwbGllcikpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhlIGBNdWx0aXBsaWVyYCBvcGVyYXRvciBpbiBzdGFuZGFsb25lIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5fSBkYXRhIC0gSW5wdXQgdmVjdG9yXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFNjYWxlZCB2YWx1ZXNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgc2NhbGVyID0gbmV3IE11bHRpcGxpZXIoeyBmYWN0b3I6IFsyLCA0XSB9KTtcbiAgICogc2NhbGVyLmluaXRTdHJlYW0oeyBmcmFtZVR5cGU6ICd2ZWN0b3InLCBmcmFtZVNpemU6IDIgfSk7XG4gICAqXG4gICAqIHNjYWxlci5pbnB1dFZlY3RvcihbMywgMl0pO1xuICAgKiA+IFs2LCA4XVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE11bHRpcGxpZXIsIFt7XG4gICAga2V5OiAnaW5wdXRWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFZlY3RvcihkYXRhKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBmYWN0b3IgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZhY3RvcicpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmYWN0b3IpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbaV0gPSBkYXRhW2ldICogZmFjdG9yW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZnJhbWVTaXplOyBfaSsrKSB7XG4gICAgICAgICAgb3V0cHV0W19pXSA9IGRhdGFbX2ldICogZmFjdG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmVjdG9yKGZyYW1lKSB7XG4gICAgICB0aGlzLmZyYW1lLmRhdGEgPSB0aGlzLmlucHV0VmVjdG9yKGZyYW1lLmRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGUgYE11bHRpcGxpZXJgIG9wZXJhdG9yIGluIHN0YW5kYWxvbmUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5fSBkYXRhIC0gSW5wdXQgc2lnbmFsLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAtIFNjYWxlZCBzaWduYWwuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNjYWxlciA9IG5ldyBNdWx0aXBsaWVyKHsgZmFjdG9yOiAwLjEgfSk7XG4gICAgICogc2NhbGVyLmluaXRTdHJlYW0oeyBmcmFtZVR5cGU6ICdzaWduYWwnLCBmcmFtZVNpemU6IDIgfSk7XG4gICAgICpcbiAgICAgKiBzY2FsZXIuaW5wdXRWZWN0b3IoWzEsIDJdKTtcbiAgICAgKiA+IFswLjEsIDAuMl1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5wdXRTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFNpZ25hbChkYXRhKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBmYWN0b3IgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZhY3RvcicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKSB7XG4gICAgICAgIG91dHB1dFtpXSA9IGRhdGFbaV0gKiBmYWN0b3I7XG4gICAgICB9cmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICAgIHRoaXMuZnJhbWUuZGF0YSA9IHRoaXMuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNdWx0aXBsaWVyO1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpcGxpZXI7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBzdGF0ZToge1xuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBkZWZhdWx0OiAnb24nLFxuICAgIGxpc3Q6IFsnb24nLCAnb2ZmJ10sXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgT25PZmYgb3BlcmF0b3IgYWxsb3dzIHRvIHN0b3AgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBzdHJlYW0gaW4gYVxuICogc3ViZ3JhcGguIFdoZW4gXCJvblwiLCBmcmFtZXMgYXJlIHByb3BhZ2F0ZWQsIHdoZW4gXCJvZmZcIiB0aGUgcHJvcGFnYXRpb24gaXNcbiAqIHN0b3BwZWQuXG4gKlxuICogVGhlIGBzdHJlYW1QYXJhbXNgIHByb3BhZ2F0aW9uIGlzIG5ldmVyIGJ5cGFzc2VkIHNvIHRoZSBzdWJzZXF1ZW50IHN1YmdyYXBoXG4gKiBpcyBhbHdheXMgcmVhZHkgZm9yIGluY29tbWluZyBmcmFtZXMuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24ub3BlcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdGF0ZT0nb24nXSAtIERlZmF1bHQgc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tbW9uJztcbiAqXG4gKiBjb25zdCBmcmFtZXMgPSBbXG4gKiAgIHsgdGltZTogMCwgZGF0YTogWzEsIDJdIH0sXG4gKiAgIHsgdGltZTogMSwgZGF0YTogWzMsIDRdIH0sXG4gKiAgIHsgdGltZTogMiwgZGF0YTogWzUsIDZdIH0sXG4gKiBdO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgRXZlbnRJbih7XG4gKiAgIGZyYW1lU2l6ZTogMixcbiAqICAgZnJhbWVSYXRlOiAwLFxuICogICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICogfSk7XG4gKlxuICogY29uc3Qgb25PZmYgPSBuZXcgT25PZmYoKTtcbiAqXG4gKiBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHsgZGF0YTogdHJ1ZSB9KTtcbiAqXG4gKiBldmVudEluLmNvbm5lY3Qob25PZmYpO1xuICogb25PZmYuY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIGV2ZW50SW4uc3RhcnQoKTtcbiAqXG4gKiBldmVudEluLnByb2Nlc3NGcmFtZShmcmFtZXNbMF0pO1xuICogPiBbMCwgMV1cbiAqXG4gKiAvLyBieXBhc3Mgc3ViZ3JhcGhcbiAqIG9uT2ZmLnNldFN0YXRlKCdvZmYnKTtcbiAqIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKGZyYW1lc1sxXSk7XG4gKlxuICogLy8gcmUtb3BlbiBzdWJncmFwaFxuICogb25PZmYuc2V0U3RhdGUoJ29uJyk7XG4gKiBldmVudEluLnByb2Nlc3NGcmFtZShmcmFtZXNbMl0pO1xuICogPiBbNSwgNl1cbiAqL1xuXG52YXIgT25PZmYgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoT25PZmYsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBPbk9mZigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgT25PZmYpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoT25PZmYuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKE9uT2ZmKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5wYXJhbXMuZ2V0KCdzdGF0ZScpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBgT25PZmZgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGUgLSBOZXcgc3RhdGUgb2YgdGhlIG9wZXJhdG9yIChgb25gIG9yIGBvZmZgKVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE9uT2ZmLCBbe1xuICAgIGtleTogJ3NldFN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgIGlmIChkZWZpbml0aW9ucy5zdGF0ZS5saXN0LmluZGV4T2Yoc3RhdGUpID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN3aXRjaCBzdGF0ZSB2YWx1ZSBcIicgKyBzdGF0ZSArICdcIiBbdmFsaWQgdmFsdWVzOiBcIm9uXCIvXCJvZmZcIl0nKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cblxuICAgIC8vIGRlZmluZSBhbGwgcG9zc2libGUgc3RyZWFtIEFQSVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU2NhbGFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NjYWxhcigpIHt9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmVjdG9yKCkge31cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoKSB7fVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NGcmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdvbicpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcblxuICAgICAgICB0aGlzLmZyYW1lLnRpbWUgPSBmcmFtZS50aW1lO1xuICAgICAgICB0aGlzLmZyYW1lLm1ldGFkYXRhID0gZnJhbWUubWV0YWRhdGE7XG4gICAgICAgIHRoaXMuZnJhbWUuZGF0YSA9IGZyYW1lLmRhdGE7XG5cbiAgICAgICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT25PZmY7XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gT25PZmY7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBleHBvbmVudDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMVxuICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IGFuIGV4cG9uYW50IHBvd2VyIHRvIHRoZSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBleHBvbmVudCAtIEV4cG9uZW50XG4gKi9cblxudmFyIFBvd2VyID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFBvd2VyLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gUG93ZXIob3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFBvd2VyKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoUG93ZXIuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFBvd2VyKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoUG93ZXIsIFt7XG4gICAga2V5OiAnaW5wdXRWZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFZlY3RvcihkYXRhKSB7XG4gICAgICB2YXIgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB2YXIgZXhwb25lbnQgPSB0aGlzLnBhcmFtcy5nZXQoJ2V4cG9uZW50Jyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspIHtcbiAgICAgICAgb3V0RGF0YVtpXSA9IE1hdGgucG93KGRhdGFbaV0sIGV4cG9uZW50KTtcbiAgICAgIH1yZXR1cm4gb3V0RGF0YTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1ZlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICAgIHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5wdXRTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFNpZ25hbChkYXRhKSB7XG4gICAgICB2YXIgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB2YXIgZXhwb25lbnQgPSB0aGlzLnBhcmFtcy5nZXQoJ2V4cG9uZW50Jyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspIHtcbiAgICAgICAgb3V0RGF0YVtpXSA9IE1hdGgucG93KGRhdGFbaV0sIGV4cG9uZW50KTtcbiAgICAgIH1yZXR1cm4gb3V0RGF0YTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICAgIHRoaXMuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb3dlcjtcbn0oX0Jhc2VMZm8zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQb3dlcjtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3FydCA9IE1hdGguc3FydDtcblxudmFyIGRlZmluaXRpb25zID0ge1xuICBwb3dlcjoge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIFJvb3QgTWVhbiBTcXVhcmUgb2YgYSBgc2lnbmFsYC5cbiAqXG4gKiBfc3VwcG9ydCBgc3RhbmRhbG9uZWAgdXNhZ2VfXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24ub3BlcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucG93ZXI9ZmFsc2VdIC0gSWYgYHRydWVgIHJlbW92ZSB0aGUgXCJSXCIgb2YgdGhlXG4gKiAgXCJSbXNcIiBhbmQgcmV0dXJuIHRoZSBzcXVhcmVkIHJlc3VsdCAoaS5lLiBwb3dlcikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAqXG4gKiAvLyBhc3N1bWluZyBzb21lIGBBdWRpb0J1ZmZlcmBcbiAqIGNvbnN0IGF1ZGlvSW5CdWZmZXIgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luQnVmZmVyKHtcbiAqICAgYXVkaW9CdWZmZXI6IGF1ZGlvQnVmZmVyLFxuICogICBmcmFtZVNpemU6IDUxMixcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHJtcyA9IG5ldyBsZm8ub3BlcmF0b3IuUm1zKCk7XG4gKiBjb25zdCBsb2dnZXIgPSBuZXcgbGZvLnNpbmsuTG9nZ2VyKHsgZGF0YTogdHJ1ZSB9KTtcbiAqXG4gKiBhdWRpb0luQnVmZmVyLmNvbm5lY3Qocm1zKTtcbiAqIHJtcy5jb25uZWN0KGxvZ2dlcik7XG4gKlxuICogYXVkaW9JbkJ1ZmZlci5zdGFydCgpO1xuICovXG5cbnZhciBSbXMgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoUm1zLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gUm1zKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBSbXMpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChSbXMuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFJtcykpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoUm1zLCBbe1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gMTtcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICdzY2FsYXInO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBbJ3JtcyddO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbG93cyBmb3IgdGhlIHVzZSBvZiBhIGBSbXNgIG91dHNpZGUgYSBncmFwaCAoZS5nLiBpbnNpZGVcbiAgICAgKiBhbm90aGVyIG5vZGUpLiBSZXR1cm4gdGhlIHJtcyBvZiB0aGUgZ2l2ZW4gc2lnbmFsIGJsb2NrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpZ25hbCAtIFNpZ25hbCBibG9jayB0byBiZSBjb21wdXRlZC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gcm1zIG9mIHRoZSBpbnB1dCBzaWduYWwuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICAgKlxuICAgICAqIGNvbnN0IHJtcyA9IG5ldyBsZm8ub3BlcmF0b3IuUm1zKCk7XG4gICAgICogcm1zLmluaXRTdHJlYW0oeyBmcmFtZVR5cGU6ICdzaWduYWwnLCBmcmFtZVNpemU6IDEwMDAgfSk7XG4gICAgICpcbiAgICAgKiBjb25zdCByZXN1bHRzID0gcm1zLmlucHV0U2lnbmFsKFsuLi52YWx1ZXNdKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5wdXRTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFNpZ25hbChzaWduYWwpIHtcbiAgICAgIHZhciBwb3dlciA9IHRoaXMucGFyYW1zLmdldCgncG93ZXInKTtcbiAgICAgIHZhciBsZW5ndGggPSBzaWduYWwubGVuZ3RoO1xuICAgICAgdmFyIHJtcyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm1zICs9IHNpZ25hbFtpXSAqIHNpZ25hbFtpXTtcbiAgICAgIH1ybXMgPSBybXMgLyBsZW5ndGg7XG5cbiAgICAgIGlmICghcG93ZXIpIHJtcyA9IHNxcnQocm1zKTtcblxuICAgICAgcmV0dXJuIHJtcztcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICAgIHRoaXMuZnJhbWUuZGF0YVswXSA9IHRoaXMuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSbXM7XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm1zO1xuXG59LHtcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE2OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9nZXQyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldCcpO1xuXG52YXIgX2dldDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXQyKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VMZm8yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgdHlwZToge1xuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBsaXN0OiBbJ2xpbmVhciddLFxuICAgIGRlZmF1bHQ6ICdsaW5lYXInLFxuICAgIG1ldGFzOiB7XG4gICAgICBraW5kOiAnZHluYW1pYydcbiAgICB9XG4gIH0sXG4gIGlucHV0TWluOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbjogLUluZmluaXR5LFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIG1ldGFzOiB7XG4gICAgICBraW5kOiAnZHluYW1pYydcbiAgICB9XG4gIH0sXG4gIGlucHV0TWF4OiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbjogLUluZmluaXR5LFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIG1ldGFzOiB7XG4gICAgICBraW5kOiAnZHluYW1pYydcbiAgICB9XG4gIH0sXG4gIG91dHB1dE1pbjoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW46IC1JbmZpbml0eSxcbiAgICBtYXg6ICtJbmZpbml0eSxcbiAgICBtZXRhczoge1xuICAgICAga2luZDogJ2R5bmFtaWMnXG4gICAgfVxuICB9LFxuICBvdXRwdXRNYXg6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluOiAtSW5maW5pdHksXG4gICAgbWF4OiArSW5maW5pdHksXG4gICAgbWV0YXM6IHtcbiAgICAgIGtpbmQ6ICdkeW5hbWljJ1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIGxpbmVhciBzY2FsZSBvbiB0aGUgaW5jb21taW5nIHN0cmVhbS4gVGhlIG91dHB1dCBpcyBub3QgY2xpcHBlZC5cbiAgICpcbiAgICogQHRvZG8gLSBpbXBsZW1lbnQgbG9nIGFuZCBleHAgc2NhbGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmlucHV0TWluPTBdIC0gSW5wdXQgTWluaW11bVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaW5wdXRNYXg9MV0gLSBJbnB1dCBNYXhpbXVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vdXRwdXRNaW49MF0gLSBPdXRwdXQgTWluaW11bVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub3V0cHV0TWF4PTFdIC0gT3V0cHV0IE1heGltdW1cbiAgICovXG59O1xudmFyIFNjYWxlID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFNjYWxlLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gU2NhbGUob3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFNjYWxlKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKFNjYWxlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShTY2FsZSkpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnNjYWxlID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFNjYWxlLCBbe1xuICAgIGtleTogJ19zZXRTY2FsZUZ1bmN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNjYWxlRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5wdXRNaW4gPSB0aGlzLnBhcmFtcy5nZXQoJ2lucHV0TWluJyk7XG4gICAgICB2YXIgaW5wdXRNYXggPSB0aGlzLnBhcmFtcy5nZXQoJ2lucHV0TWF4Jyk7XG4gICAgICB2YXIgb3V0cHV0TWluID0gdGhpcy5wYXJhbXMuZ2V0KCdvdXRwdXRNaW4nKTtcbiAgICAgIHZhciBvdXRwdXRNYXggPSB0aGlzLnBhcmFtcy5nZXQoJ291dHB1dE1heCcpO1xuXG4gICAgICB2YXIgYSA9IChvdXRwdXRNYXggLSBvdXRwdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICAgICAgdmFyIGIgPSBvdXRwdXRNaW4gLSBhICogaW5wdXRNaW47XG5cbiAgICAgIHRoaXMuc2NhbGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gYSAqIHggKyBiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25QYXJhbVVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoU2NhbGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShTY2FsZS5wcm90b3R5cGUpLCAnb25QYXJhbVVwZGF0ZScsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgICAgaWYgKG5hbWUgIT09ICd0eXBlJykgdGhpcy5fc2V0U2NhbGVGdW5jdGlvbigpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIHRoaXMuX3NldFNjYWxlRnVuY3Rpb24oKTtcblxuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFZlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0VmVjdG9yKGRhdGEpIHtcbiAgICAgIHZhciBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspIHtcbiAgICAgICAgb3V0RGF0YVtpXSA9IHNjYWxlKGRhdGFbaV0pO1xuICAgICAgfXJldHVybiBvdXREYXRhO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5kYXRhID0gdGhpcy5pbnB1dFZlY3RvcihmcmFtZS5kYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFNpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0U2lnbmFsKGRhdGEpIHtcbiAgICAgIHZhciBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspIHtcbiAgICAgICAgb3V0RGF0YVtpXSA9IHNjYWxlKGRhdGFbaV0pO1xuICAgICAgfXJldHVybiBvdXREYXRhO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU2lnbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NpZ25hbChmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5kYXRhID0gdGhpcy5pbnB1dFZlY3RvcihmcmFtZS5kYXRhKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNjYWxlO1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNjYWxlO1xuXG59LHtcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXRcIjoxOCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE3MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9nZXQyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldCcpO1xuXG52YXIgX2dldDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXQyKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VMZm8yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvMik7XG5cbnZhciBfTW92aW5nQXZlcmFnZSA9IHJlcXVpcmUoJy4vTW92aW5nQXZlcmFnZScpO1xuXG52YXIgX01vdmluZ0F2ZXJhZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW92aW5nQXZlcmFnZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBtYXggPSBNYXRoLm1heDtcblxudmFyIGRlZmluaXRpb25zID0ge1xuICBsb2dJbnB1dDoge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfVxuICB9LFxuICBtaW5JbnB1dDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMC4wMDAwMDAwMDAwMDEsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH1cbiAgfSxcbiAgZmlsdGVyT3JkZXI6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogNSxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfVxuICB9LFxuICB0aHJlc2hvbGQ6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDMsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH1cbiAgfSxcbiAgb2ZmVGhyZXNob2xkOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAtSW5maW5pdHksXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH1cbiAgfSxcbiAgbWluSW50ZXI6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDAuMDUwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9XG4gIH0sXG4gIG1heER1cmF0aW9uOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiBJbmZpbml0eSxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBzZWdtZW50cyBiYXNlZCBvbiBhdHRhY2tzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sb2dJbnB1dD1mYWxzZV0gLSBBcHBseSBsb2cgb24gdGhlIGlucHV0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluSW5wdXQ9MC4wMDAwMDAwMDAwMDFdIC0gTWluaW11bSB2YWx1ZSB0byB1c2UgYXNcbiAgICogIGlucHV0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmlsdGVyT3JkZXI9NV0gLSBPcmRlciBvZiB0aGUgaW50ZXJuYWxseSB1c2VkIG1vdmluZ1xuICAgKiAgYXZlcmFnZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0zXSAtIFRocmVzaG9sZCB0aGF0IHRyaWdnZXJzIGEgc2VnbWVudFxuICAgKiAgc3RhcnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZUaHJlc2hvbGQ9LUluZmluaXR5XSAtIFRocmVzaG9sZCB0aGF0IHRyaWdnZXJzXG4gICAqICBhIHNlZ21lbnQgZW5kLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluSW50ZXI9MC4wNTBdIC0gTWluaW11bSBkZWxheSBiZXR3ZWVuIHR3byBzZW1nZW50cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heER1cmF0aW9uPUluZmluaXR5XSAtIE1heGltdW0gZHVyYXRpb24gb2YgYSBzZWdtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gICAqXG4gICAqIC8vIGFzc3VtaW5nIGEgc3RyZWFtIGZyb20gdGhlIG1pY3JvcGhvbmVcbiAgICogY29uc3Qgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG4gICAqXG4gICAqIGNvbnN0IGF1ZGlvSW5Ob2RlID0gbmV3IGxmby5zb3VyY2UuQXVkaW9Jbk5vZGUoe1xuICAgKiAgIHNvdXJjZU5vZGU6IHNvdXJjZSxcbiAgICogICBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCxcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IHNsaWNlciA9IG5ldyBsZm8ub3BlcmF0b3IuU2xpY2VyKHtcbiAgICogICBmcmFtZVNpemU6IGZyYW1lU2l6ZSxcbiAgICogICBob3BTaXplOiBob3BTaXplLFxuICAgKiAgIGNlbnRlcmVkVGltZVRhZ3M6IHRydWVcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IHBvd2VyID0gbmV3IGxmby5vcGVyYXRvci5STVMoe1xuICAgKiAgIHBvd2VyOiB0cnVlLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3Qgc2VnbWVudGVyID0gbmV3IGxmby5vcGVyYXRvci5TZWdtZW50ZXIoe1xuICAgKiAgIGxvZ0lucHV0OiB0cnVlLFxuICAgKiAgIGZpbHRlck9yZGVyOiA1LFxuICAgKiAgIHRocmVzaG9sZDogMyxcbiAgICogICBvZmZUaHJlc2hvbGQ6IC1JbmZpbml0eSxcbiAgICogICBtaW5JbnRlcjogMC4wNTAsXG4gICAqICAgbWF4RHVyYXRpb246IDAuMDUwLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IHRpbWU6IHRydWUgfSk7XG4gICAqXG4gICAqIGF1ZGlvSW5Ob2RlLmNvbm5lY3Qoc2xpY2VyKTtcbiAgICogc2xpY2VyLmNvbm5lY3QocG93ZXIpO1xuICAgKiBwb3dlci5jb25uZWN0KHNlZ21lbnRlcik7XG4gICAqIHNlZ21lbnRlci5jb25uZWN0KGxvZ2dlcik7XG4gICAqXG4gICAqIGF1ZGlvSW5Ob2RlLnN0YXJ0KCk7XG4gICAqL1xufTtcbnZhciBTZWdtZW50ZXIgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoU2VnbWVudGVyLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gU2VnbWVudGVyKG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTZWdtZW50ZXIpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoU2VnbWVudGVyLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShTZWdtZW50ZXIpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5pbnNpZGVTZWdtZW50ID0gZmFsc2U7XG4gICAgX3RoaXMub25zZXRUaW1lID0gLUluZmluaXR5O1xuXG4gICAgLy8gc3RhdHNcbiAgICBfdGhpcy5taW4gPSBJbmZpbml0eTtcbiAgICBfdGhpcy5tYXggPSAtSW5maW5pdHk7XG4gICAgX3RoaXMuc3VtID0gMDtcbiAgICBfdGhpcy5zdW1PZlNxdWFyZXMgPSAwO1xuICAgIF90aGlzLmNvdW50ID0gMDtcblxuICAgIHZhciBtaW5JbnB1dCA9IF90aGlzLnBhcmFtcy5nZXQoJ21pbklucHV0Jyk7XG4gICAgdmFyIGZpbGwgPSBtaW5JbnB1dDtcblxuICAgIGlmIChfdGhpcy5wYXJhbXMuZ2V0KCdsb2dJbnB1dCcpICYmIG1pbklucHV0ID4gMCkgZmlsbCA9IE1hdGgubG9nKG1pbklucHV0KTtcblxuICAgIF90aGlzLm1vdmluZ0F2ZXJhZ2UgPSBuZXcgX01vdmluZ0F2ZXJhZ2UyLmRlZmF1bHQoe1xuICAgICAgb3JkZXI6IF90aGlzLnBhcmFtcy5nZXQoJ2ZpbHRlck9yZGVyJyksXG4gICAgICBmaWxsOiBmaWxsXG4gICAgfSk7XG5cbiAgICBfdGhpcy5sYXN0TXZhdnJnID0gZmlsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShTZWdtZW50ZXIsIFt7XG4gICAga2V5OiAnb25QYXJhbVVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoU2VnbWVudGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoU2VnbWVudGVyLnByb3RvdHlwZSksICdvblBhcmFtVXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSwgbWV0YXMpO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ2ZpbHRlck9yZGVyJykgdGhpcy5tb3ZpbmdBdmVyYWdlLnBhcmFtcy5zZXQoJ29yZGVyJywgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3ZlY3Rvcic7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSA1O1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlID0gMDtcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uID0gWydkdXJhdGlvbicsICdtaW4nLCAnbWF4JywgJ21lYW4nLCAnc3RkZGV2J107XG5cbiAgICAgIHRoaXMubW92aW5nQXZlcmFnZS5pbml0U3RyZWFtKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0U3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTdHJlYW0oKSB7XG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoU2VnbWVudGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoU2VnbWVudGVyLnByb3RvdHlwZSksICdyZXNldFN0cmVhbScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1vdmluZ0F2ZXJhZ2UucmVzZXRTdHJlYW0oKTtcbiAgICAgIHRoaXMucmVzZXRTZWdtZW50KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmluYWxpemVTdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZVN0cmVhbShlbmRUaW1lKSB7XG4gICAgICBpZiAodGhpcy5pbnNpZGVTZWdtZW50KSB0aGlzLm91dHB1dFNlZ21lbnQoZW5kVGltZSk7XG5cbiAgICAgICgwLCBfZ2V0My5kZWZhdWx0KShTZWdtZW50ZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShTZWdtZW50ZXIucHJvdG90eXBlKSwgJ2ZpbmFsaXplU3RyZWFtJywgdGhpcykuY2FsbCh0aGlzLCBlbmRUaW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFNlZ21lbnQoKSB7XG4gICAgICB0aGlzLmluc2lkZVNlZ21lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMub25zZXRUaW1lID0gLUluZmluaXR5O1xuICAgICAgLy8gc3RhdHNcbiAgICAgIHRoaXMubWluID0gSW5maW5pdHk7XG4gICAgICB0aGlzLm1heCA9IC1JbmZpbml0eTtcbiAgICAgIHRoaXMuc3VtID0gMDtcbiAgICAgIHRoaXMuc3VtT2ZTcXVhcmVzID0gMDtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ291dHB1dFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXRTZWdtZW50KGVuZFRpbWUpIHtcbiAgICAgIHZhciBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgb3V0RGF0YVswXSA9IGVuZFRpbWUgLSB0aGlzLm9uc2V0VGltZTtcbiAgICAgIG91dERhdGFbMV0gPSB0aGlzLm1pbjtcbiAgICAgIG91dERhdGFbMl0gPSB0aGlzLm1heDtcblxuICAgICAgdmFyIG5vcm0gPSAxIC8gdGhpcy5jb3VudDtcbiAgICAgIHZhciBtZWFuID0gdGhpcy5zdW0gKiBub3JtO1xuICAgICAgdmFyIG1lYW5PZlNxdWFyZSA9IHRoaXMuc3VtT2ZTcXVhcmVzICogbm9ybTtcbiAgICAgIHZhciBzcXVhcmVPZm1lYW4gPSBtZWFuICogbWVhbjtcblxuICAgICAgb3V0RGF0YVszXSA9IG1lYW47XG4gICAgICBvdXREYXRhWzRdID0gMDtcblxuICAgICAgaWYgKG1lYW5PZlNxdWFyZSA+IHNxdWFyZU9mbWVhbikgb3V0RGF0YVs0XSA9IE1hdGguc3FydChtZWFuT2ZTcXVhcmUgLSBzcXVhcmVPZm1lYW4pO1xuXG4gICAgICB0aGlzLmZyYW1lLnRpbWUgPSB0aGlzLm9uc2V0VGltZTtcblxuICAgICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgICB2YXIgbG9nSW5wdXQgPSB0aGlzLnBhcmFtcy5nZXQoJ2xvZ0lucHV0Jyk7XG4gICAgICB2YXIgbWluSW5wdXQgPSB0aGlzLnBhcmFtcy5nZXQoJ21pbklucHV0Jyk7XG4gICAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5wYXJhbXMuZ2V0KCd0aHJlc2hvbGQnKTtcbiAgICAgIHZhciBtaW5JbnRlciA9IHRoaXMucGFyYW1zLmdldCgnbWluSW50ZXInKTtcbiAgICAgIHZhciBtYXhEdXJhdGlvbiA9IHRoaXMucGFyYW1zLmdldCgnbWF4RHVyYXRpb24nKTtcbiAgICAgIHZhciBvZmZUaHJlc2hvbGQgPSB0aGlzLnBhcmFtcy5nZXQoJ29mZlRocmVzaG9sZCcpO1xuICAgICAgdmFyIHJhd1ZhbHVlID0gZnJhbWUuZGF0YVswXTtcbiAgICAgIHZhciB0aW1lID0gZnJhbWUudGltZTtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KHJhd1ZhbHVlLCBtaW5JbnB1dCk7XG5cbiAgICAgIGlmIChsb2dJbnB1dCkgdmFsdWUgPSBNYXRoLmxvZyh2YWx1ZSk7XG5cbiAgICAgIHZhciBkaWZmID0gdmFsdWUgLSB0aGlzLmxhc3RNdmF2cmc7XG4gICAgICB0aGlzLmxhc3RNdmF2cmcgPSB0aGlzLm1vdmluZ0F2ZXJhZ2UuaW5wdXRTY2FsYXIodmFsdWUpO1xuXG4gICAgICAvLyB1cGRhdGUgZnJhbWUgbWV0YWRhdGFcbiAgICAgIHRoaXMuZnJhbWUubWV0YWRhdGEgPSBmcmFtZS5tZXRhZGF0YTtcblxuICAgICAgaWYgKGRpZmYgPiB0aHJlc2hvbGQgJiYgdGltZSAtIHRoaXMub25zZXRUaW1lID4gbWluSW50ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zaWRlU2VnbWVudCkgdGhpcy5vdXRwdXRTZWdtZW50KHRpbWUpO1xuXG4gICAgICAgIC8vIHN0YXJ0IHNlZ21lbnRcbiAgICAgICAgdGhpcy5pbnNpZGVTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbnNldFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLm1heCA9IC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5zaWRlU2VnbWVudCkge1xuICAgICAgICB0aGlzLm1pbiA9IG1pbih0aGlzLm1pbiwgcmF3VmFsdWUpO1xuICAgICAgICB0aGlzLm1heCA9IG1heCh0aGlzLm1heCwgcmF3VmFsdWUpO1xuICAgICAgICB0aGlzLnN1bSArPSByYXdWYWx1ZTtcbiAgICAgICAgdGhpcy5zdW1PZlNxdWFyZXMgKz0gcmF3VmFsdWUgKiByYXdWYWx1ZTtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuXG4gICAgICAgIGlmICh0aW1lIC0gdGhpcy5vbnNldFRpbWUgPj0gbWF4RHVyYXRpb24gfHwgdmFsdWUgPD0gb2ZmVGhyZXNob2xkKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRTZWdtZW50KHRpbWUpO1xuICAgICAgICAgIHRoaXMuaW5zaWRlU2VnbWVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc0ZyYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgICB0aGlzLnByZXBhcmVGcmFtZSgpO1xuICAgICAgdGhpcy5wcm9jZXNzRnVuY3Rpb24oZnJhbWUpO1xuICAgICAgLy8gZG8gbm90IHByb3BhZ2F0ZSBoZXJlIGFzIHRoZSBmcmFtZVJhdGUgaXMgbm93IHplcm9cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNlZ21lbnRlcjtcbn0oX0Jhc2VMZm8zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTZWdtZW50ZXI7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiLi9Nb3ZpbmdBdmVyYWdlXCI6MTYzLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldFwiOjE4LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTcxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2dldDIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0Jyk7XG5cbnZhciBfZ2V0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldDIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBpbmRleDoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgaW5kZXhlczoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZWxlY3Qgb25lIG9yIHNldmVyYWwgaW5kZXhlcyBmcm9tIGEgYHZlY3RvcmAgaW5wdXQuIElmIG9ubHkgb25lIGluZGV4IGlzXG4gKiBzZWxlY3RlZCwgdGhlIG91dHB1dCB3aWxsIGJlIG9mIHR5cGUgYHNjYWxhcmAsIG90aGVyd2lzZSB0aGUgb3V0cHV0IHdpbGxcbiAqIGJlIGEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIGluZGV4ZXMuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24ub3BlcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgdmFsdWVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuaW5kZXggLSBJbmRleCB0byBzZWxlY3QgZnJvbSB0aGUgaW5wdXQgZnJhbWUuXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IG9wdGlvbnMuaW5kZXhlcyAtIEluZGljZXMgdG8gc2VsZWN0IGZyb20gdGhlIGlucHV0XG4gKiAgZnJhbWUsIGlmIGRlZmluZWQsIHRha2UgcHJlY2VkYW5jZSBvdmVyIGBvcHRpb24uaW5kZXhgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICogICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICogICBmcmFtZVNpemU6IDMsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBzZWxlY3QgPSBuZXcgbGZvLm9wZXJhdG9yLlNlbGVjdCh7XG4gKiAgIGluZGV4ZXM6IFsyLCAwXSxcbiAqIH0pO1xuICpcbiAqIGV2ZW50SW4uc3RhcnQoKTtcbiAqIGV2ZW50SW4ucHJvY2VzcygwLCBbMCwgMiwgNF0pO1xuICogPiBbNCwgMF1cbiAqIGV2ZW50SW4ucHJvY2VzcygwLCBbMSwgMywgNV0pO1xuICogPiBbNSwgMV1cbiAqL1xuXG52YXIgU2VsZWN0ID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFNlbGVjdCwgX0Jhc2VMZm8pO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU2VsZWN0KTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoU2VsZWN0Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShTZWxlY3QpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFNlbGVjdCwgW3tcbiAgICBrZXk6ICdvblBhcmFtVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG1ldGFzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgKDAsIF9nZXQzLmRlZmF1bHQpKFNlbGVjdC5wcm90b3R5cGUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNlbGVjdC5wcm90b3R5cGUpLCAnb25QYXJhbVVwZGF0ZScsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5wYXJhbXMuZ2V0KCdpbmRleCcpO1xuICAgICAgdmFyIGluZGV4ZXMgPSB0aGlzLnBhcmFtcy5nZXQoJ2luZGV4ZXMnKTtcblxuICAgICAgdGhpcy5zZWxlY3QgPSBpbmRleGVzICE9PSBudWxsID8gaW5kZXhlcyA6IFtpbmRleF07XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMucGFyYW1zLmdldCgnaW5kZXgnKTtcbiAgICAgIHZhciBpbmRleGVzID0gdGhpcy5wYXJhbXMuZ2V0KCdpbmRleGVzJyk7XG5cbiAgICAgIHZhciBtYXggPSBpbmRleGVzICE9PSBudWxsID8gTWF0aC5tYXguYXBwbHkobnVsbCwgaW5kZXhlcykgOiBpbmRleDtcblxuICAgICAgaWYgKG1heCA+PSBwcmV2U3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBpbmRleCBcIicgKyBtYXggKyAnXCInKTtcblxuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gaW5kZXhlcyAhPT0gbnVsbCA/ICd2ZWN0b3InIDogJ3NjYWxhcic7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSBpbmRleGVzICE9PSBudWxsID8gaW5kZXhlcy5sZW5ndGggOiAxO1xuXG4gICAgICB0aGlzLnNlbGVjdCA9IGluZGV4ZXMgIT09IG51bGwgPyBpbmRleGVzIDogW2luZGV4XTtcblxuICAgICAgLy8gc3RlYWwgZGVzY3JpcHRpb24oKSBmcm9tIHBhcmVudFxuICAgICAgaWYgKHByZXZTdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgICAgICAgIF90aGlzMi5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb25baW5kZXhdID0gcHJldlN0cmVhbVBhcmFtcy5kZXNjcmlwdGlvblt2YWxdO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1ZlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICAgIHZhciBkYXRhID0gZnJhbWUuZGF0YTtcbiAgICAgIHZhciBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgdmFyIHNlbGVjdCA9IHRoaXMuc2VsZWN0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXREYXRhW2ldID0gZGF0YVtzZWxlY3RbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VsZWN0O1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNlbGVjdDtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0XCI6MTgsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfZ2V0MiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXQnKTtcblxudmFyIF9nZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Mik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmaW5pdGlvbnMgPSB7XG4gIGZyYW1lU2l6ZToge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiA1MTIsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfVxuICB9LFxuICBob3BTaXplOiB7IC8vIHNob3VsZCBiZSBudWxsYWJsZVxuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgY2VudGVyZWRUaW1lVGFnczoge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgYGZyYW1lU2l6ZWAgYW5kIGBob3BTaXplYCBvZiBhIGBzaWduYWxgIGlucHV0IGFjY29yZGluZyB0b1xuICAgKiB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogVGhpcyBvcGVyYXRvciB1cGRhdGVzIHRoZSBzdHJlYW0gcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gaXRzIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJhbWVTaXplPTUxMl0gLSBGcmFtZSBzaXplIG9mIHRoZSBvdXRwdXQgc2lnbmFsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaG9wU2l6ZT1udWxsXSAtIE51bWJlciBvZiBzYW1wbGVzIGJldHdlZW4gdHdvXG4gICAqICBjb25zZWN1dGl2ZSBmcmFtZXMuIElmIG51bGwsIGBob3BTaXplYCBpcyBzZXQgdG8gYGZyYW1lU2l6ZWAuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2VudGVyZWRUaW1lVGFnc10gLSBNb3ZlIHRoZSB0aW1lIHRhZyB0byB0aGUgbWlkZGxlXG4gICAqICBvZiB0aGUgZnJhbWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tbW9uJztcbiAgICpcbiAgICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICAgKiAgIGZyYW1lVHlwZTogJ3NpZ25hbCcsXG4gICAqICAgZnJhbWVTaXplOiAxMCxcbiAgICogICBzYW1wbGVSYXRlOiAyLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3Qgc2xpY2VyID0gbmV3IGxmby5vcGVyYXRvci5TbGljZXIoe1xuICAgKiAgIGZyYW1lU2l6ZTogNCxcbiAgICogICBob3BTaXplOiAyXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBsb2dnZXIgPSBuZXcgbGZvLnNpbmsuTG9nZ2VyKHsgdGltZTogdHJ1ZSwgZGF0YTogdHJ1ZSB9KTtcbiAgICpcbiAgICogZXZlbnRJbi5jb25uZWN0KHNsaWNlcik7XG4gICAqIHNsaWNlci5jb25uZWN0KGxvZ2dlcik7XG4gICAqIGV2ZW50SW4uc3RhcnQoKTtcbiAgICpcbiAgICogZXZlbnRJbi5wcm9jZXNzKDAsIFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XSk7XG4gICAqID4geyB0aW1lOiAwLCBkYXRhOiBbMCwgMSwgMiwgM10gfVxuICAgKiA+IHsgdGltZTogMSwgZGF0YTogWzIsIDMsIDQsIDVdIH1cbiAgICogPiB7IHRpbWU6IDIsIGRhdGE6IFs0LCA1LCA2LCA3XSB9XG4gICAqID4geyB0aW1lOiAzLCBkYXRhOiBbNiwgNywgOCwgOV0gfVxuICAgKi9cbn07XG52YXIgU2xpY2VyID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFNsaWNlciwgX0Jhc2VMZm8pO1xuXG4gIGZ1bmN0aW9uIFNsaWNlcigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU2xpY2VyKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKFNsaWNlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoU2xpY2VyKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuXG4gICAgdmFyIGhvcFNpemUgPSBfdGhpcy5wYXJhbXMuZ2V0KCdob3BTaXplJyk7XG4gICAgdmFyIGZyYW1lU2l6ZSA9IF90aGlzLnBhcmFtcy5nZXQoJ2ZyYW1lU2l6ZScpO1xuXG4gICAgaWYgKCFob3BTaXplKSBfdGhpcy5wYXJhbXMuc2V0KCdob3BTaXplJywgZnJhbWVTaXplKTtcblxuICAgIF90aGlzLnBhcmFtcy5hZGRMaXN0ZW5lcihfdGhpcy5vblBhcmFtVXBkYXRlLmJpbmQoX3RoaXMpKTtcblxuICAgIF90aGlzLmZyYW1lSW5kZXggPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoU2xpY2VyLCBbe1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgICAgdmFyIGhvcFNpemUgPSB0aGlzLnBhcmFtcy5nZXQoJ2hvcFNpemUnKTtcbiAgICAgIHZhciBmcmFtZVNpemUgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZyYW1lU2l6ZScpO1xuXG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSBmcmFtZVNpemU7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGUgPSBwcmV2U3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGUgLyBob3BTaXplO1xuXG4gICAgICBpZiAodGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID09PSAxKSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVR5cGUgPSAnc2NhbGFyJztlbHNlIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICdzaWduYWwnO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldFN0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0U3RyZWFtKCkge1xuICAgICAgKDAsIF9nZXQzLmRlZmF1bHQpKFNsaWNlci5wcm90b3R5cGUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNsaWNlci5wcm90b3R5cGUpLCAncmVzZXRTdHJlYW0nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluYWxpemVTdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZVN0cmVhbShlbmRUaW1lKSB7XG4gICAgICBpZiAodGhpcy5mcmFtZUluZGV4ID4gMCkge1xuICAgICAgICB2YXIgZnJhbWVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlO1xuICAgICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICAgICAgLy8gc2V0IHRoZSB0aW1lIG9mIHRoZSBsYXN0IGZyYW1lXG4gICAgICAgIHRoaXMuZnJhbWUudGltZSArPSAxIC8gZnJhbWVSYXRlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmZyYW1lSW5kZXg7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgICAgIGRhdGFbaV0gPSAwO1xuICAgICAgICB9dGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuICAgICAgfVxuXG4gICAgICAoMCwgX2dldDMuZGVmYXVsdCkoU2xpY2VyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoU2xpY2VyLnByb3RvdHlwZSksICdmaW5hbGl6ZVN0cmVhbScsIHRoaXMpLmNhbGwodGhpcywgZW5kVGltZSk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NGcmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcbiAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICAgIHZhciB0aW1lID0gZnJhbWUudGltZTtcbiAgICAgIHZhciBibG9jayA9IGZyYW1lLmRhdGE7XG4gICAgICB2YXIgbWV0YWRhdGEgPSBmcmFtZS5tZXRhZGF0YTtcblxuICAgICAgdmFyIGNlbnRlcmVkVGltZVRhZ3MgPSB0aGlzLnBhcmFtcy5nZXQoJ2NlbnRlcmVkVGltZVRhZ3MnKTtcbiAgICAgIHZhciBob3BTaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdob3BTaXplJyk7XG4gICAgICB2YXIgb3V0RnJhbWUgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgdmFyIHNhbXBsZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlO1xuICAgICAgdmFyIHNhbXBsZVBlcmlvZCA9IDEgLyBzYW1wbGVSYXRlO1xuICAgICAgdmFyIGJsb2NrU2l6ZSA9IGJsb2NrLmxlbmd0aDtcblxuICAgICAgdmFyIGZyYW1lSW5kZXggPSB0aGlzLmZyYW1lSW5kZXg7XG4gICAgICB2YXIgYmxvY2tJbmRleCA9IDA7XG5cbiAgICAgIHdoaWxlIChibG9ja0luZGV4IDwgYmxvY2tTaXplKSB7XG4gICAgICAgIHZhciBudW1Ta2lwID0gMDtcblxuICAgICAgICAvLyBza2lwIGJsb2NrIHNhbXBsZXMgZm9yIG5lZ2F0aXZlIGZyYW1lSW5kZXggKGZyYW1lU2l6ZSA8IGhvcFNpemUpXG4gICAgICAgIGlmIChmcmFtZUluZGV4IDwgMCkge1xuICAgICAgICAgIG51bVNraXAgPSAtZnJhbWVJbmRleDtcbiAgICAgICAgICBmcmFtZUluZGV4ID0gMDsgLy8gcmVzZXQgYGZyYW1lSW5kZXhgXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtU2tpcCA8IGJsb2NrU2l6ZSkge1xuICAgICAgICAgIGJsb2NrSW5kZXggKz0gbnVtU2tpcDsgLy8gc2tpcCBibG9jayBzZWdtZW50XG4gICAgICAgICAgLy8gY2FuIGNvcHkgYWxsIHRoZSByZXN0IG9mIHRoZSBpbmNvbWluZyBibG9ja1xuICAgICAgICAgIHZhciBudW1Db3B5ID0gYmxvY2tTaXplIC0gYmxvY2tJbmRleDtcbiAgICAgICAgICAvLyBjb25ub3QgY29weSBtb3JlIHRoYW4gd2hhdCBmaXRzIGludG8gdGhlIGZyYW1lXG4gICAgICAgICAgdmFyIG1heENvcHkgPSBmcmFtZVNpemUgLSBmcmFtZUluZGV4O1xuXG4gICAgICAgICAgaWYgKG51bUNvcHkgPj0gbWF4Q29weSkgbnVtQ29weSA9IG1heENvcHk7XG5cbiAgICAgICAgICAvLyBjb3B5IGJsb2NrIHNlZ21lbnQgaW50byBmcmFtZVxuICAgICAgICAgIHZhciBjb3B5ID0gYmxvY2suc3ViYXJyYXkoYmxvY2tJbmRleCwgYmxvY2tJbmRleCArIG51bUNvcHkpO1xuICAgICAgICAgIG91dEZyYW1lLnNldChjb3B5LCBmcmFtZUluZGV4KTtcbiAgICAgICAgICAvLyBhZHZhbmNlIGJsb2NrIGFuZCBmcmFtZSBpbmRleFxuICAgICAgICAgIGJsb2NrSW5kZXggKz0gbnVtQ29weTtcbiAgICAgICAgICBmcmFtZUluZGV4ICs9IG51bUNvcHk7XG5cbiAgICAgICAgICAvLyBzZW5kIGZyYW1lIHdoZW4gY29tcGxldGVkXG4gICAgICAgICAgaWYgKGZyYW1lSW5kZXggPT09IGZyYW1lU2l6ZSkge1xuICAgICAgICAgICAgLy8gZGVmaW5lIHRpbWUgdGFnIGZvciB0aGUgb3V0RnJhbWUgYWNjb3JkaW5nIHRvIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIGlmIChjZW50ZXJlZFRpbWVUYWdzKSB0aGlzLmZyYW1lLnRpbWUgPSB0aW1lICsgKGJsb2NrSW5kZXggLSBmcmFtZVNpemUgLyAyKSAqIHNhbXBsZVBlcmlvZDtlbHNlIHRoaXMuZnJhbWUudGltZSA9IHRpbWUgKyAoYmxvY2tJbmRleCAtIGZyYW1lU2l6ZSkgKiBzYW1wbGVQZXJpb2Q7XG5cbiAgICAgICAgICAgIHRoaXMuZnJhbWUubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgdG8gbmV4dCBub2Rlc1xuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuXG4gICAgICAgICAgICAvLyBzaGlmdCBmcmFtZSBsZWZ0XG4gICAgICAgICAgICBpZiAoaG9wU2l6ZSA8IGZyYW1lU2l6ZSkgb3V0RnJhbWUuc2V0KG91dEZyYW1lLnN1YmFycmF5KGhvcFNpemUsIGZyYW1lU2l6ZSksIDApO1xuXG4gICAgICAgICAgICBmcmFtZUluZGV4IC09IGhvcFNpemU7IC8vIGhvcCBmb3J3YXJkXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNraXAgZW50aXJlIGJsb2NrXG4gICAgICAgICAgdmFyIGJsb2NrUmVzdCA9IGJsb2NrU2l6ZSAtIGJsb2NrSW5kZXg7XG4gICAgICAgICAgZnJhbWVJbmRleCArPSBibG9ja1Jlc3Q7XG4gICAgICAgICAgYmxvY2tJbmRleCArPSBibG9ja1Jlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFtZUluZGV4ID0gZnJhbWVJbmRleDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNsaWNlcjtcbn0oX0Jhc2VMZm8zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTbGljZXI7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldFwiOjE4LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5cbi8qKlxuICogcGFwZXI6IGh0dHA6Ly9yZWNoZXJjaGUuaXJjYW0uZnIvZXF1aXBlcy9wY20vY2hldmVpZ24vcHNzLzIwMDJfSkFTQV9ZSU4ucGRmXG4gKiBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYXNob2tmZXJuYW5kZXovWWluLVBpdGNoLVRyYWNraW5nXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgdGhyZXNob2xkOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAwLjEsIC8vIGRlZmF1bHQgZnJvbSBwYXBlclxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgZG93blNhbXBsaW5nRXhwOiB7IC8vIGRvd25zYW1wbGluZyBmYWN0b3JcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogMixcbiAgICBtaW46IDAsXG4gICAgbWF4OiAzLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH1cbiAgfSxcbiAgbWluRnJlcTogeyAvL1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogNjAsIC8vIG1lYW4gNzM1IHNhbXBsZXNcbiAgICBtaW46IDAsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfVxuICB9XG5cbiAgLyoqXG4gICAqIFlpbiBmdW5kYW1lbnRhbCBmcmVxdWVuY3kgZXN0aW1hdG9yLCBiYXNlZCBvbiBhbGdvcml0aG0gZGVzY3JpYmVkIGluXG4gICAqIFtZSU4sIGEgZnVuZGFtZW50YWwgZnJlcXVlbmN5IGVzdGltYXRvciBmb3Igc3BlZWNoIGFuZCBtdXNpY10oaHR0cDovL3JlY2hlcmNoZS5pcmNhbS5mci9lcXVpcGVzL3BjbS9jaGV2ZWlnbi9wc3MvMjAwMl9KQVNBX1lJTi5wZGYpXG4gICAqIGJ5IENoZXZlaWduZSBhbmQgS2F3YWhhcmEuXG4gICAqIE9uIGVhY2ggZnJhbWUsIHRoaXMgb3BlcmF0b3IgcHJvcGFnYXRlIGEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZ1xuICAgKiB2YWx1ZXM6IGBmcmVxdWVuY3lgLCBgcHJvYmFiaWxpdHlgLlxuICAgKlxuICAgKiBGb3IgZ29vZCByZXN1bHRzIHRoZSBpbnB1dCBmcmFtZSBzaXplIHNob3VsZCBiZSBsYXJnZSAoMTAyNCBvciAyMDQ4KS5cbiAgICpcbiAgICogX3N1cHBvcnQgYHN0YW5kYWxvbmVgIHVzYWdlX1xuICAgKlxuICAgKiBAbm90ZSAtIEluIG5vZGUgZm9yIGEgZnJhbWUgb2YgMjA0OCBzYW1wbGVzLCBhdmVyYWdlIGNvbXB1dGF0aW9uIHRpbWUgaXM6XG4gICAqICAgICAgICAgMC4wMDAxNjc0MjI4MzMzOTk5MzM4OSBzZWNvbmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTAuMV0gLSBBYnNvbHV0ZSB0aHJlc2hvbGQgdG8gdGVzdCB0aGVcbiAgICogIG5vcm1hbGl6ZWQgZGlmZmVyZW5jZSAoc2VlIHBhcGVyIGZvciBtb3JlIGluZm9ybWF0aW9ucykuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kb3duU2FtcGxpbmdFeHA9Ml0gLSBEb3duIHNhbXBsZSB0aGUgaW5wdXQgZnJhbWUgYnlcbiAgICogIGEgZmFjdG9yIG9mIDIgYXQgdGhlIHBvd2VyIG9mIGBkb3duU2FtcGxpbmdFeHBgIChtaW49MCBhbmQgbWF4PTMpIGZvclxuICAgKiAgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluRnJlcT02MF0gLSBNaW5pbXVtIGZyZXF1ZW5jeSB0aGUgb3BlcmF0b3IgY2FuXG4gICAqICBzZWFyY2ggZm9yLiBUaGlzIHBhcmFtZXRlciBkZWZpbmVzIHRoZSBzaXplIG9mIHRoZSBhdXRvY29ycmVsYXRpb24gcGVyZm9ybWVkXG4gICAqICBvbiB0aGUgc2lnbmFsLCB0aGUgaW5wdXQgZnJhbWUgc2l6ZSBzaG91bGQgYmUgYXJvdW5kIDIgdGltZSB0aGlzIHNpemUgZm9yXG4gICAqICBnb29kIHJlc3VsdHMgKGkuZS4gYGlucHV0RnJhbWVTaXplIOKJiCAyICogKHNhbXBsaW5nUmF0ZSAvIG1pbkZyZXEpYCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICpcbiAgICogLy8gYXNzdW1pbmcgc29tZSBBdWRpb0J1ZmZlclxuICAgKiBjb25zdCBzb3VyY2UgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luQnVmZmVyKHtcbiAgICogICBhdWRpb0J1ZmZlcjogYXVkaW9CdWZmZXIsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBzbGljZXIgPSBuZXcgbGZvLm9wZXJhdG9yLlNsaWNlcih7XG4gICAqICAgZnJhbWVTaXplOiAyMDQ4LFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgeWluID0gbmV3IGxmby5vcGVyYXRvci5ZaW4oKTtcbiAgICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gICAqXG4gICAqIHNvdXJjZS5jb25uZWN0KHNsaWNlcik7XG4gICAqIHNsaWNlci5jb25uZWN0KHlpbik7XG4gICAqIHlpbi5jb25uZWN0KGxvZ2dlcik7XG4gICAqXG4gICAqIHNvdXJjZS5zdGFydCgpO1xuICAgKi9cbn07XG52YXIgWWluID0gZnVuY3Rpb24gKF9CYXNlTGZvKSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFlpbiwgX0Jhc2VMZm8pO1xuXG4gIGZ1bmN0aW9uIFlpbihvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgWWluKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKFlpbi5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoWWluKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucHJvYmFiaWxpdHkgPSAwO1xuICAgIF90aGlzLnBpdGNoID0gLTE7XG5cbiAgICBfdGhpcy50ZXN0ID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFlpbiwgW3tcbiAgICBrZXk6ICdfZG93bnNhbXBsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kb3duc2FtcGxlKGlucHV0LCBzaXplLCBvdXRwdXQsIGRvd25TYW1wbGluZ0V4cCkge1xuICAgICAgdmFyIG91dHB1dFNpemUgPSBzaXplID4+IGRvd25TYW1wbGluZ0V4cDtcbiAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgIGogPSB2b2lkIDA7XG5cbiAgICAgIHN3aXRjaCAoZG93blNhbXBsaW5nRXhwKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAvLyBubyBkb3duIHNhbXBsaW5nXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgICAgICAgfWJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyssIGogKz0gMikge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gMC41ICogKGlucHV0W2pdICsgaW5wdXRbaiArIDFdKTtcbiAgICAgICAgICB9YnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG91dHB1dFNpemU7IGkrKywgaiArPSA0KSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSAwLjI1ICogKGlucHV0W2pdICsgaW5wdXRbaiArIDFdICsgaW5wdXRbaiArIDJdICsgaW5wdXRbaiArIDNdKTtcbiAgICAgICAgICB9YnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG91dHB1dFNpemU7IGkrKywgaiArPSA4KSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSAwLjEyNSAqIChpbnB1dFtqXSArIGlucHV0W2ogKyAxXSArIGlucHV0W2ogKyAyXSArIGlucHV0W2ogKyAzXSArIGlucHV0W2ogKyA0XSArIGlucHV0W2ogKyA1XSArIGlucHV0W2ogKyA2XSArIGlucHV0W2ogKyA3XSk7XG4gICAgICAgICAgfWJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0U2l6ZTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVR5cGUgPSAndmVjdG9yJztcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IDI7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5kZXNjcmlwdGlvbiA9IFsnZnJlcXVlbmN5JywgJ2NvbmZpZGVuY2UnXTtcblxuICAgICAgdGhpcy5pbnB1dEZyYW1lU2l6ZSA9IHByZXZTdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgICAgLy8gaGFuZGxlIHBhcmFtc1xuICAgICAgdmFyIHNvdXJjZVNhbXBsZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlO1xuICAgICAgdmFyIGRvd25TYW1wbGluZ0V4cCA9IHRoaXMucGFyYW1zLmdldCgnZG93blNhbXBsaW5nRXhwJyk7XG4gICAgICB2YXIgZG93bkZhY3RvciA9IDEgPDwgZG93blNhbXBsaW5nRXhwOyAvLyAyXm5cbiAgICAgIHZhciBkb3duU1IgPSBzb3VyY2VTYW1wbGVSYXRlIC8gZG93bkZhY3RvcjtcbiAgICAgIHZhciBkb3duRnJhbWVTaXplID0gdGhpcy5pbnB1dEZyYW1lU2l6ZSAvIGRvd25GYWN0b3I7IC8vIG5fdGlja19kb3duIC8vIDEgLyAyXm5cblxuICAgICAgdmFyIG1pbkZyZXEgPSB0aGlzLnBhcmFtcy5nZXQoJ21pbkZyZXEnKTtcbiAgICAgIC8vIGxpbWl0IG1pbiBmcmVxLCBjZi4gcGFwZXIgSVYuIHNlbnNpdGl2aXR5IHRvIHBhcmFtZXRlcnNcbiAgICAgIHZhciBtaW5GcmVxTmJyU2FtcGxlcyA9IGRvd25TUiAvIG1pbkZyZXE7XG4gICAgICAvLyBjb25zdCBidWZmZXJTaXplID0gcHJldlN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICB0aGlzLmhhbGZCdWZmZXJTaXplID0gZG93bkZyYW1lU2l6ZSAvIDI7XG5cbiAgICAgIC8vIG1pbmltdW0gZXJyb3IgdG8gbm90IGNyYXNoIGJ1dCBub3QgZW5vdWdodCB0byBoYXZlIHJlc3VsdHNcbiAgICAgIGlmIChtaW5GcmVxTmJyU2FtcGxlcyA+IHRoaXMuaGFsZkJ1ZmZlclNpemUpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBmcmFtZSBzaXplLCB0b28gc21hbGwgZm9yIGdpdmVuIFwibWluRnJlcVwiJyk7XG5cbiAgICAgIHRoaXMuZG93blNhbXBsaW5nRXhwID0gZG93blNhbXBsaW5nRXhwO1xuICAgICAgdGhpcy5kb3duU2FtcGxpbmdSYXRlID0gZG93blNSO1xuICAgICAgdGhpcy5kb3duRnJhbWVTaXplID0gZG93bkZyYW1lU2l6ZTtcbiAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShkb3duRnJhbWVTaXplKTtcbiAgICAgIC8vIGF1dG9jb3JyZWxhdGlvbiBidWZmZXJcbiAgICAgIHRoaXMueWluQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmhhbGZCdWZmZXJTaXplKTtcblxuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2Rvd25zYW1wbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZG93bnNhbXBsZShpbnB1dCwgc2l6ZSwgb3V0cHV0LCBkb3duU2FtcGxpbmdFeHApIHtcbiAgICAgIHZhciBvdXRwdXRTaXplID0gc2l6ZSA+PiBkb3duU2FtcGxpbmdFeHA7XG4gICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICBqID0gdm9pZCAwO1xuXG4gICAgICBzd2l0Y2ggKGRvd25TYW1wbGluZ0V4cCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgLy8gbm8gZG93biBzYW1wbGluZ1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgICAgICAgIH1icmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgb3V0cHV0U2l6ZTsgaSsrLCBqICs9IDIpIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IDAuNSAqIChpbnB1dFtqXSArIGlucHV0W2ogKyAxXSk7XG4gICAgICAgICAgfWJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyssIGogKz0gNCkge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gMC4yNSAqIChpbnB1dFtqXSArIGlucHV0W2ogKyAxXSArIGlucHV0W2ogKyAyXSArIGlucHV0W2ogKyAzXSk7XG4gICAgICAgICAgfWJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyssIGogKz0gOCkge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gMC4xMjUgKiAoaW5wdXRbal0gKyBpbnB1dFtqICsgMV0gKyBpbnB1dFtqICsgMl0gKyBpbnB1dFtqICsgM10gKyBpbnB1dFtqICsgNF0gKyBpbnB1dFtqICsgNV0gKyBpbnB1dFtqICsgNl0gKyBpbnB1dFtqICsgN10pO1xuICAgICAgICAgIH1icmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dFNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RlcCAxLCAyIGFuZCAzIC0gU3F1YXJlZCBkaWZmZXJlbmNlIG9mIHRoZSBzaGlmdGVkIHNpZ25hbCB3aXRoIGl0c2VsZi5cbiAgICAgKiBjdW11bGF0aXZlIG1lYW4gbm9ybWFsaXplZCBkaWZmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX25vcm1hbGl6ZWREaWZmZXJlbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25vcm1hbGl6ZWREaWZmZXJlbmNlKGJ1ZmZlcikge1xuICAgICAgdmFyIGhhbGZCdWZmZXJTaXplID0gdGhpcy5oYWxmQnVmZmVyU2l6ZTtcbiAgICAgIHZhciB5aW5CdWZmZXIgPSB0aGlzLnlpbkJ1ZmZlcjtcbiAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAvLyBkaWZmZXJlbmNlIGZvciBkaWZmZXJlbnQgc2hpZnQgdmFsdWVzICh0YXUpXG4gICAgICBmb3IgKHZhciB0YXUgPSAwOyB0YXUgPCBoYWxmQnVmZmVyU2l6ZTsgdGF1KyspIHtcbiAgICAgICAgdmFyIHNxdWFyZWREaWZmZXJlbmNlID0gMDsgLy8gcmVzZXQgYnVmZmVyXG5cbiAgICAgICAgLy8gdGFrZSBkaWZmZXJlbmNlIG9mIHRoZSBzaWduYWwgd2l0aCBhIHNoaWZ0ZWQgdmVyc2lvbiBvZiBpdHNlbGYgdGhlblxuICAgICAgICAvLyBzcWF1cmUgdGhlIHJlc3VsdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbGZCdWZmZXJTaXplOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBidWZmZXJbaV0gLSBidWZmZXJbaSArIHRhdV07XG4gICAgICAgICAgc3F1YXJlZERpZmZlcmVuY2UgKz0gZGVsdGEgKiBkZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0ZXAgMyAtIG5vcm1hbGl6ZSB5aW5CdWZmZXJcbiAgICAgICAgaWYgKHRhdSA+IDApIHtcbiAgICAgICAgICBzdW0gKz0gc3F1YXJlZERpZmZlcmVuY2U7XG4gICAgICAgICAgeWluQnVmZmVyW3RhdV0gPSBzcXVhcmVkRGlmZmVyZW5jZSAqICh0YXUgLyBzdW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHlpbkJ1ZmZlclswXSA9IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RlcCA0IC0gZmluZCBmaXJzdCBiZXN0IHRhdSB0aGF0IGlzIHVuZGVyIHRoZSB0aHJlc29sZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19hYnNvbHV0ZVRocmVzaG9sZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hYnNvbHV0ZVRocmVzaG9sZCgpIHtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnBhcmFtcy5nZXQoJ3RocmVzaG9sZCcpO1xuICAgICAgdmFyIHlpbkJ1ZmZlciA9IHRoaXMueWluQnVmZmVyO1xuICAgICAgdmFyIGhhbGZCdWZmZXJTaXplID0gdGhpcy5oYWxmQnVmZmVyU2l6ZTtcbiAgICAgIHZhciB0YXUgPSB2b2lkIDA7XG5cbiAgICAgIGZvciAodGF1ID0gMTsgdGF1IDwgaGFsZkJ1ZmZlclNpemU7IHRhdSsrKSB7XG4gICAgICAgIGlmICh5aW5CdWZmZXJbdGF1XSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIGtlZXAgaW5jcmVhc2luZyB0YXUgaWYgbmV4dCB2YWx1ZSBpcyBiZXR0ZXJcbiAgICAgICAgICB3aGlsZSAodGF1ICsgMSA8IGhhbGZCdWZmZXJTaXplICYmIHlpbkJ1ZmZlclt0YXUgKyAxXSA8IHlpbkJ1ZmZlclt0YXVdKSB7XG4gICAgICAgICAgICB0YXUgKz0gMTtcbiAgICAgICAgICB9IC8vIGJlc3QgdGF1IGZvdW5kICwgeWluQnVmZmVyW3RhdV0gY2FuIGJlIHNlZW4gYXMgYW4gZXN0aW1hdGlvbiBvZlxuICAgICAgICAgIC8vIGFwZXJpb2RpY2l0eSB0aGVuOiBwZXJpb2RpY2l0eSA9IDEgLSBhcGVyaW9kaWNpdHlcbiAgICAgICAgICB0aGlzLnByb2JhYmlsaXR5ID0gMSAtIHlpbkJ1ZmZlclt0YXVdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybiAtMSBpZiBub3QgbWF0Y2ggZm91bmRcbiAgICAgIHJldHVybiB0YXUgPT09IGhhbGZCdWZmZXJTaXplID8gLTEgOiB0YXU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RlcCA1IC0gRmluZCBhIGJldHRlciBmcmFjdGlvbm5hbCBhcHByb3hpbWF0ZSBvZiB0YXUuXG4gICAgICogdGhpcyBjYW4gcHJvYmFibHkgYmUgc2ltcGxpZmllZC4uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BhcmFib2xpY0ludGVycG9sYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyYWJvbGljSW50ZXJwb2xhdGlvbih0YXVFc3RpbWF0ZSkge1xuICAgICAgdmFyIGhhbGZCdWZmZXJTaXplID0gdGhpcy5oYWxmQnVmZmVyU2l6ZTtcbiAgICAgIHZhciB5aW5CdWZmZXIgPSB0aGlzLnlpbkJ1ZmZlcjtcbiAgICAgIHZhciBiZXR0ZXJUYXUgPSB2b2lkIDA7XG4gICAgICAvLyBAbm90ZSAtIHRhdUVzdGltYXRlIGNhbm5vdCBiZSB6ZXJvIGFzIHRoZSBsb29wIHN0YXJ0IGF0IDEgaW4gc3RlcCA0XG4gICAgICB2YXIgeDAgPSB0YXVFc3RpbWF0ZSAtIDE7XG4gICAgICB2YXIgeDIgPSB0YXVFc3RpbWF0ZSA8IGhhbGZCdWZmZXJTaXplIC0gMSA/IHRhdUVzdGltYXRlICsgMSA6IHRhdUVzdGltYXRlO1xuXG4gICAgICAvLyBpZiBgdGF1RXN0aW1hdGVgIGlzIGxhc3QgaW5kZXgsIHdlIGNhbid0IGludGVycG9sYXRlXG4gICAgICBpZiAoeDIgPT09IHRhdUVzdGltYXRlKSB7XG4gICAgICAgIGJldHRlclRhdSA9IHRhdUVzdGltYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHMwID0geWluQnVmZmVyW3gwXTtcbiAgICAgICAgdmFyIHMxID0geWluQnVmZmVyW3RhdUVzdGltYXRlXTtcbiAgICAgICAgdmFyIHMyID0geWluQnVmZmVyW3gyXTtcblxuICAgICAgICAvLyBAbm90ZSAtIGRvbid0IGZ1bGx5IHVuZGVyc3RhbmQgdGhpcyBmb3JtdWxhIG5laXRoZXIuLi5cbiAgICAgICAgYmV0dGVyVGF1ID0gdGF1RXN0aW1hdGUgKyAoczIgLSBzMCkgLyAoMiAqICgyICogczEgLSBzMiAtIHMwKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiZXR0ZXJUYXU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBgWWluYCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGEgZ3JhcGgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheXxGbG9hdDMyQXJyYXl9IGlucHV0IC0gVGhlIHNpZ25hbCBmcmFnbWVudCB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAtIEFycmF5IGNvbnRhaW5pbmcgdGhlIGBmcmVxdWVuY3lgLCBgZW5lcmd5YCwgYHBlcmlvZGljaXR5YFxuICAgICAqICBhbmQgYEFDMWBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICAgICAqXG4gICAgICogY29uc3QgeWluID0gbmV3IGxmby5vcGVyYXRvci5ZaW4oKTtcbiAgICAgKiB5aW4uaW5pdFN0cmVhbSh7XG4gICAgICogICBmcmFtZVNpemU6IDIwNDgsXG4gICAgICogICBmcmFtZVR5cGU6ICdzaWduYWwnLFxuICAgICAqICAgc291cmNlU2FtcGxlUmF0ZTogNDQxMDBcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3VsdHMgPSB5aW4uaW5wdXRTaWduYWwoc2lnbmFsKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5wdXRTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFNpZ25hbChpbnB1dCkge1xuICAgICAgdGhpcy5waXRjaCA9IC0xO1xuICAgICAgdGhpcy5wcm9iYWJpbGl0eSA9IDA7XG5cbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgIHZhciBpbnB1dEZyYW1lU2l6ZSA9IHRoaXMuaW5wdXRGcmFtZVNpemU7XG4gICAgICB2YXIgZG93blNhbXBsaW5nRXhwID0gdGhpcy5kb3duU2FtcGxpbmdFeHA7XG4gICAgICB2YXIgc2FtcGxlUmF0ZSA9IHRoaXMuZG93blNhbXBsaW5nUmF0ZTtcbiAgICAgIHZhciBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgdmFyIHRhdUVzdGltYXRlID0gLTE7XG5cbiAgICAgIC8vIHN1YnNhbXBsaW5nXG4gICAgICB0aGlzLl9kb3duc2FtcGxlKGlucHV0LCBpbnB1dEZyYW1lU2l6ZSwgYnVmZmVyLCBkb3duU2FtcGxpbmdFeHApO1xuICAgICAgLy8gc3RlcCAxLCAyLCAzIC0gbm9ybWFsaXplZCBzcXVhcmVkIGRpZmZlcmVuY2Ugb2YgdGhlIHNpZ25hbCB3aXRoIGFcbiAgICAgIC8vIHNoaWZ0ZWQgdmVyc2lvbiBvZiBpdHNlbGZcbiAgICAgIHRoaXMuX25vcm1hbGl6ZWREaWZmZXJlbmNlKGJ1ZmZlcik7XG4gICAgICAvLyBzdGVwIDQgLSBmaW5kIGZpcnN0IGJlc3QgdGF1IGVzdGltYXRlIHRoYXQgaXMgb3ZlciB0aGUgdGhyZXNob2xkXG4gICAgICB0YXVFc3RpbWF0ZSA9IHRoaXMuX2Fic29sdXRlVGhyZXNob2xkKCk7XG5cbiAgICAgIGlmICh0YXVFc3RpbWF0ZSAhPT0gLTEpIHtcbiAgICAgICAgLy8gc3RlcCA1IC0gc28gZmFyIHRhdSBpcyBhbiBpbnRlZ2VyIHNoaWZ0IG9mIHRoZSBzaWduYWwsIGNoZWNrIGlmXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgYmV0dGVyIGZyYWN0aW9ubmFsIHZhbHVlIGFyb3VuZFxuICAgICAgICB0YXVFc3RpbWF0ZSA9IHRoaXMuX3BhcmFib2xpY0ludGVycG9sYXRpb24odGF1RXN0aW1hdGUpO1xuICAgICAgICB0aGlzLnBpdGNoID0gc2FtcGxlUmF0ZSAvIHRhdUVzdGltYXRlO1xuICAgICAgfVxuXG4gICAgICBvdXREYXRhWzBdID0gdGhpcy5waXRjaDtcbiAgICAgIG91dERhdGFbMV0gPSB0aGlzLnByb2JhYmlsaXR5O1xuXG4gICAgICByZXR1cm4gb3V0RGF0YTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NpZ25hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICAgIHRoaXMuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBZaW47XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gWWluO1xuXG59LHtcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE3NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQmlxdWFkID0gcmVxdWlyZSgnLi9CaXF1YWQnKTtcblxudmFyIF9CaXF1YWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmlxdWFkKTtcblxudmFyIF9DbGlwID0gcmVxdWlyZSgnLi9DbGlwJyk7XG5cbnZhciBfQ2xpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DbGlwKTtcblxudmFyIF9EY3QgPSByZXF1aXJlKCcuL0RjdCcpO1xuXG52YXIgX0RjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EY3QpO1xuXG52YXIgX0RlbHRhID0gcmVxdWlyZSgnLi9EZWx0YScpO1xuXG52YXIgX0RlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RlbHRhKTtcblxudmFyIF9GZnQgPSByZXF1aXJlKCcuL0ZmdCcpO1xuXG52YXIgX0ZmdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GZnQpO1xuXG52YXIgX01hZ25pdHVkZSA9IHJlcXVpcmUoJy4vTWFnbml0dWRlJyk7XG5cbnZhciBfTWFnbml0dWRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hZ25pdHVkZSk7XG5cbnZhciBfTWVhblN0ZGRldiA9IHJlcXVpcmUoJy4vTWVhblN0ZGRldicpO1xuXG52YXIgX01lYW5TdGRkZXYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVhblN0ZGRldik7XG5cbnZhciBfTWVsID0gcmVxdWlyZSgnLi9NZWwnKTtcblxudmFyIF9NZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVsKTtcblxudmFyIF9NZXJnZXIgPSByZXF1aXJlKCcuL01lcmdlcicpO1xuXG52YXIgX01lcmdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZXJnZXIpO1xuXG52YXIgX01mY2MgPSByZXF1aXJlKCcuL01mY2MnKTtcblxudmFyIF9NZmNjMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01mY2MpO1xuXG52YXIgX01pbk1heCA9IHJlcXVpcmUoJy4vTWluTWF4Jyk7XG5cbnZhciBfTWluTWF4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01pbk1heCk7XG5cbnZhciBfTW92aW5nQXZlcmFnZSA9IHJlcXVpcmUoJy4vTW92aW5nQXZlcmFnZScpO1xuXG52YXIgX01vdmluZ0F2ZXJhZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW92aW5nQXZlcmFnZSk7XG5cbnZhciBfTW92aW5nTWVkaWFuID0gcmVxdWlyZSgnLi9Nb3ZpbmdNZWRpYW4nKTtcblxudmFyIF9Nb3ZpbmdNZWRpYW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW92aW5nTWVkaWFuKTtcblxudmFyIF9Pbk9mZiA9IHJlcXVpcmUoJy4vT25PZmYnKTtcblxudmFyIF9Pbk9mZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Pbk9mZik7XG5cbnZhciBfUG93ZXIgPSByZXF1aXJlKCcuL1Bvd2VyJyk7XG5cbnZhciBfUG93ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG93ZXIpO1xuXG52YXIgX1JtcyA9IHJlcXVpcmUoJy4vUm1zJyk7XG5cbnZhciBfUm1zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jtcyk7XG5cbnZhciBfTXVsdGlwbGllciA9IHJlcXVpcmUoJy4vTXVsdGlwbGllcicpO1xuXG52YXIgX011bHRpcGxpZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTXVsdGlwbGllcik7XG5cbnZhciBfU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XG5cbnZhciBfU2NhbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2NhbGUpO1xuXG52YXIgX1NlZ21lbnRlciA9IHJlcXVpcmUoJy4vU2VnbWVudGVyJyk7XG5cbnZhciBfU2VnbWVudGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlZ21lbnRlcik7XG5cbnZhciBfU2VsZWN0ID0gcmVxdWlyZSgnLi9TZWxlY3QnKTtcblxudmFyIF9TZWxlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VsZWN0KTtcblxudmFyIF9TbGljZXIgPSByZXF1aXJlKCcuL1NsaWNlcicpO1xuXG52YXIgX1NsaWNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TbGljZXIpO1xuXG52YXIgX1lpbiA9IHJlcXVpcmUoJy4vWWluJyk7XG5cbnZhciBfWWluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1lpbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgQmlxdWFkOiBfQmlxdWFkMi5kZWZhdWx0LFxuICBDbGlwOiBfQ2xpcDIuZGVmYXVsdCxcbiAgRGN0OiBfRGN0Mi5kZWZhdWx0LFxuICBEZWx0YTogX0RlbHRhMi5kZWZhdWx0LFxuICBGZnQ6IF9GZnQyLmRlZmF1bHQsXG4gIE1hZ25pdHVkZTogX01hZ25pdHVkZTIuZGVmYXVsdCxcbiAgTWVhblN0ZGRldjogX01lYW5TdGRkZXYyLmRlZmF1bHQsXG4gIE1lbDogX01lbDIuZGVmYXVsdCxcbiAgTWVyZ2VyOiBfTWVyZ2VyMi5kZWZhdWx0LFxuICBNZmNjOiBfTWZjYzIuZGVmYXVsdCxcbiAgTWluTWF4OiBfTWluTWF4Mi5kZWZhdWx0LFxuICBNb3ZpbmdBdmVyYWdlOiBfTW92aW5nQXZlcmFnZTIuZGVmYXVsdCxcbiAgTW92aW5nTWVkaWFuOiBfTW92aW5nTWVkaWFuMi5kZWZhdWx0LFxuICBPbk9mZjogX09uT2ZmMi5kZWZhdWx0LFxuICBQb3dlcjogX1Bvd2VyMi5kZWZhdWx0LFxuICBSbXM6IF9SbXMyLmRlZmF1bHQsXG4gIE11bHRpcGxpZXI6IF9NdWx0aXBsaWVyMi5kZWZhdWx0LFxuICBTY2FsZTogX1NjYWxlMi5kZWZhdWx0LFxuICBTZWdtZW50ZXI6IF9TZWdtZW50ZXIyLmRlZmF1bHQsXG4gIFNlbGVjdDogX1NlbGVjdDIuZGVmYXVsdCxcbiAgU2xpY2VyOiBfU2xpY2VyMi5kZWZhdWx0LFxuICBZaW46IF9ZaW4yLmRlZmF1bHRcbn07XG5cbn0se1wiLi9CaXF1YWRcIjoxNTIsXCIuL0NsaXBcIjoxNTMsXCIuL0RjdFwiOjE1NCxcIi4vRGVsdGFcIjoxNTUsXCIuL0ZmdFwiOjE1NixcIi4vTWFnbml0dWRlXCI6MTU3LFwiLi9NZWFuU3RkZGV2XCI6MTU4LFwiLi9NZWxcIjoxNTksXCIuL01lcmdlclwiOjE2MCxcIi4vTWZjY1wiOjE2MSxcIi4vTWluTWF4XCI6MTYyLFwiLi9Nb3ZpbmdBdmVyYWdlXCI6MTYzLFwiLi9Nb3ZpbmdNZWRpYW5cIjoxNjQsXCIuL011bHRpcGxpZXJcIjoxNjUsXCIuL09uT2ZmXCI6MTY2LFwiLi9Qb3dlclwiOjE2NyxcIi4vUm1zXCI6MTY4LFwiLi9TY2FsZVwiOjE2OSxcIi4vU2VnbWVudGVyXCI6MTcwLFwiLi9TZWxlY3RcIjoxNzEsXCIuL1NsaWNlclwiOjE3MixcIi4vWWluXCI6MTczfV0sMTc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0Jhc2VMZm8nKTtcblxudmFyIF9CYXNlTGZvMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VMZm8yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBwcm9jZXNzRnJhbWU6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIGZpbmFsaXplU3RyZWFtOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJyaWRnZSBiZXR3ZWVuIHRoZSBncmFwaCBhbmQgYXBwbGljYXRpb24gbG9naWMuIEhhbmRsZSBgcHVzaGBcbiAqIGFuZCBgcHVsbGAgcGFyYWRpZ21zLlxuICpcbiAqIFRoaXMgc2luayBjYW4gaGFuZGxlIGFueSB0eXBlIG9mIGlucHV0IChgc2lnbmFsYCwgYHZlY3RvcmAsIGBzY2FsYXJgKVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLnNpbmtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnByb2Nlc3NGcmFtZT1udWxsXSAtIENhbGxiYWNrIGV4ZWN1dGVkIG9uIGVhY2hcbiAqICBgcHJvY2Vzc0ZyYW1lYCBjYWxsLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmluYWxpemVTdHJlYW09bnVsbF0gLSBDYWxsYmFjayBleGVjdXRlZCBvbiBlYWNoXG4gKiAgYGZpbmFsaXplU3RyZWFtYCBjYWxsLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJvY2Vzc0ZyYW1lfVxuICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzU3RyZWFtUGFyYW1zfVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gKlxuICogY29uc3QgZnJhbWVzID0gW1xuICogIHsgdGltZTogMCwgZGF0YTogWzAsIDFdIH0sXG4gKiAgeyB0aW1lOiAxLCBkYXRhOiBbMSwgMl0gfSxcbiAqIF07XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBFdmVudEluKHtcbiAqICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAqICAgZnJhbWVTaXplOiAyLFxuICogICBmcmFtZVJhdGU6IDEsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBicmlkZ2UgPSBuZXcgQnJpZGdlKHtcbiAqICAgcHJvY2Vzc0ZyYW1lOiAoZnJhbWUpID0+IGNvbnNvbGUubG9nKGZyYW1lKSxcbiAqIH0pO1xuICpcbiAqIGV2ZW50SW4uY29ubmVjdChicmlkZ2UpO1xuICogZXZlbnRJbi5zdGFydCgpO1xuICpcbiAqIC8vIGNhbGxiYWNrIGV4ZWN1dGVkIG9uIGVhY2ggZnJhbWVcbiAqIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKGZyYW1lWzBdKTtcbiAqID4geyB0aW1lOiAwLCBkYXRhOiBbMCwgMV0gfVxuICogZXZlbnRJbi5wcm9jZXNzRnJhbWUoZnJhbWVbMV0pO1xuICogPiB7IHRpbWU6IDEsIGRhdGE6IFsxLCAyXSB9XG4gKlxuICogLy8gcHVsbCBjdXJyZW50IGZyYW1lIHdoZW4gbmVlZGVkXG4gKiBjb25zb2xlLmxvZyhicmlkZ2UuZnJhbWUpO1xuICogPiB7IHRpbWU6IDEsIGRhdGE6IFsxLCAyXSB9XG4gKi9cblxudmFyIEJyaWRnZSA9IGZ1bmN0aW9uIChfQmFzZUxmbykge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShCcmlkZ2UsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBCcmlkZ2UoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEJyaWRnZSk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKEJyaWRnZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoQnJpZGdlKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShCcmlkZ2UsIFt7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgICB2YXIgcHJvY2Vzc1N0cmVhbVBhcmFtc0NhbGxiYWNrID0gdGhpcy5wYXJhbXMuZ2V0KCdwcm9jZXNzU3RyZWFtUGFyYW1zJyk7XG5cbiAgICAgIGlmIChwcm9jZXNzU3RyZWFtUGFyYW1zQ2FsbGJhY2sgIT09IG51bGwpIHByb2Nlc3NTdHJlYW1QYXJhbXNDYWxsYmFjayh0aGlzLnN0cmVhbVBhcmFtcyk7XG5cbiAgICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmFsaXplU3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemVTdHJlYW0oZW5kVGltZSkge1xuICAgICAgdmFyIGZpbmFsaXplU3RyZWFtQ2FsbGJhY2sgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZpbmFsaXplU3RyZWFtJyk7XG5cbiAgICAgIGlmIChmaW5hbGl6ZVN0cmVhbUNhbGxiYWNrICE9PSBudWxsKSBmaW5hbGl6ZVN0cmVhbUNhbGxiYWNrKGVuZFRpbWUpO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgYW55IHR5cGVcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NjYWxhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTY2FsYXIoKSB7fVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcigpIHt9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKCkge31cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzRnJhbWUoZnJhbWUpIHtcbiAgICAgIHRoaXMucHJlcGFyZUZyYW1lKCk7XG5cbiAgICAgIHZhciBwcm9jZXNzRnJhbWVDYWxsYmFjayA9IHRoaXMucGFyYW1zLmdldCgncHJvY2Vzc0ZyYW1lJyk7XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpcy5mcmFtZTtcbiAgICAgIG91dHB1dC5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUpO1xuICAgICAgLy8gcHVsbCBpbnRlcmZhY2UgKHdlIGNvcHkgZGF0YSBzaW5jZSB3ZSBkb24ndCBrbm93IHdoYXQgY291bGRcbiAgICAgIC8vIGJlIGRvbmUgb3V0c2lkZSB0aGUgZ3JhcGgpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTsgaSsrKSB7XG4gICAgICAgIG91dHB1dC5kYXRhW2ldID0gZnJhbWUuZGF0YVtpXTtcbiAgICAgIH1vdXRwdXQudGltZSA9IGZyYW1lLnRpbWU7XG4gICAgICBvdXRwdXQubWV0YWRhdGEgPSBmcmFtZS5tZXRhZGF0YTtcblxuICAgICAgLy8gYHB1c2hgIGludGVyZmFjZVxuICAgICAgaWYgKHByb2Nlc3NGcmFtZUNhbGxiYWNrICE9PSBudWxsKSBwcm9jZXNzRnJhbWVDYWxsYmFjayhvdXRwdXQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQnJpZGdlO1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJyaWRnZTtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmaW5pdGlvbnMgPSB7XG4gIHNlcGFyYXRlQXJyYXlzOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH0sXG4gIGNhbGxiYWNrOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlY29yZCBpbnB1dCBmcmFtZXMgZnJvbSBhIGdyYXBoLiBUaGlzIHNpbmsgY2FuIGhhbmRsZSBgc2lnbmFsYCwgYHZlY3RvcmBcbiAqIG9yIGBzY2FsYXJgIGlucHV0cy5cbiAqXG4gKiBXaGVuIHRoZSByZWNvcmRpbmcgaXMgc3RvcHBlZCAoZWl0aGVyIGJ5IGNhbGxpbmcgYHN0b3BgIG9uIHRoZSBub2RlIG9yIHdoZW5cbiAqIHRoZSBzdHJlYW0gaXMgZmluYWxpemVkKSwgdGhlIGNhbGxiYWNrIGdpdmVuIGFzIHBhcmFtZXRlciBpcyBleGVjdXRlZCB3aXRoXG4gKiB0aGUgcmVjb3JkZXIgZGF0YSBhcyBhcmd1bWVudC5cbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcGFyYXRlQXJyYXlzPWZhbHNlXSAtIEZvcm1hdCBvZiB0aGUgcmV0cmlldmVkXG4gKiAgdmFsdWVzOlxuICogIC0gd2hlbiBgZmFsc2VgLCBmb3JtYXQgaXMgW3sgdGltZSwgZGF0YSB9LCB7IHRpbWUsIGRhdGEgfSwgLi4uXVxuICogIC0gd2hlbiBgdHJ1ZWAsIGZvcm1hdCBpcyB7IHRpbWU6IFsuLi5dLCBkYXRhOiBbLi4uXSB9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja10gLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gYSBuZXcgcmVjb3JkXG4gKiAgaXMgZW5kZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuOlxuICogIC0gYHN0b3BgIGlzIGNhbGxlZCBvbiB0aGUgcmVjb3JkZXJcbiAqICAtIGBzdG9wYCBpcyBjYWxsZWQgb24gdGhlIHNvdXJjZS5cbiAqXG4gKiBAdG9kbyAtIEFkZCBhdXRvIHJlY29yZCBwYXJhbS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5zaW5rXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tbW9uJztcbiAqXG4gKiBjb25zdCBldmVudEluID0gbmV3IGxmby5zb3VyY2UuRXZlbnRJbih7XG4gKiAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAqICBmcmFtZVNpemU6IDIsXG4gKiAgZnJhbWVSYXRlOiAwLFxuICogfSk7XG4gKlxuICogY29uc3QgcmVjb3JkZXIgPSBuZXcgbGZvLnNpbmsuRGF0YVJlY29yZGVyKHtcbiAqICAgY2FsbGJhY2s6IChkYXRhKSA9PiBjb25zb2xlLmxvZyhkYXRhKSxcbiAqIH0pO1xuICpcbiAqIGV2ZW50SW4uY29ubmVjdChyZWNvcmRlcik7XG4gKiBldmVudEluLnN0YXJ0KCk7XG4gKiByZWNvcmRlci5zdGFydCgpO1xuICpcbiAqIGV2ZW50SW4ucHJvY2VzcygwLCBbMCwgMV0pO1xuICogZXZlbnRJbi5wcm9jZXNzKDEsIFsxLCAyXSk7XG4gKlxuICogcmVjb3JkZXIuc3RvcCgpO1xuICogPiBbeyB0aW1lOiAwLCBkYXRhOiBbMCwgMV0gfSwgeyB0aW1lOiAxLCBkYXRhOiBbMSwgMl0gfV07XG4gKi9cblxudmFyIERhdGFSZWNvcmRlciA9IGZ1bmN0aW9uIChfQmFzZUxmbykge1xuICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShEYXRhUmVjb3JkZXIsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBEYXRhUmVjb3JkZXIoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIERhdGFSZWNvcmRlcik7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgaWYgdGhlIG5vZGUgaXMgY3VycmVudGx5IHJlY29yZGluZy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBuYW1lIGlzUmVjb3JkaW5nXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzaW5rLlNpZ25hbFJlY29yZGVyXG4gICAgICovXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoRGF0YVJlY29yZGVyLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEYXRhUmVjb3JkZXIpKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5pc1JlY29yZGluZyA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoRGF0YVJlY29yZGVyLCBbe1xuICAgIGtleTogJ19pbml0U3RvcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFN0b3JlKCkge1xuICAgICAgdmFyIHNlcGFyYXRlQXJyYXlzID0gdGhpcy5wYXJhbXMuZ2V0KCdzZXBhcmF0ZUFycmF5cycpO1xuXG4gICAgICBpZiAoc2VwYXJhdGVBcnJheXMpIHRoaXMuX3N0b3JlID0geyB0aW1lOiBbXSwgZGF0YTogW10gfTtlbHNlIHRoaXMuX3N0b3JlID0gW107XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcbiAgICAgIHRoaXMuX2luaXRTdG9yZSgpO1xuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCByZWNvcmRpbmcuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y2xpZW50LnNpbmsuRGF0YVJlY29yZGVyI3N0b3B9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB0aGlzLmlzUmVjb3JkaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHJlY29yZGluZyBhbmQgZXhlY3V0ZSB0aGUgY2FsbGJhY2sgZGVmaW5lZCBpbiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNsaWVudC5zaW5rLkRhdGFSZWNvcmRlciNzdGFydH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAodGhpcy5pc1JlY29yZGluZykge1xuICAgICAgICB0aGlzLmlzUmVjb3JkaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMucGFyYW1zLmdldCgnY2FsbGJhY2snKTtcblxuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIGNhbGxiYWNrKHRoaXMuX3N0b3JlKTtcblxuICAgICAgICB0aGlzLl9pbml0U3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluYWxpemVTdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZVN0cmVhbSgpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBhbnkgaW5wdXQgdHlwZXNcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NjYWxhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTY2FsYXIoZnJhbWUpIHt9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTaWduYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7fVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzVmVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZlY3RvcihmcmFtZSkge31cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NGcmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlRnJhbWUoZnJhbWUpO1xuXG4gICAgICAgIHZhciBzZXBhcmF0ZUFycmF5cyA9IHRoaXMucGFyYW1zLmdldCgnc2VwYXJhdGVBcnJheXMnKTtcbiAgICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICAgIHRpbWU6IGZyYW1lLnRpbWUsXG4gICAgICAgICAgZGF0YTogbmV3IEZsb2F0MzJBcnJheShmcmFtZS5kYXRhKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghc2VwYXJhdGVBcnJheXMpIHtcbiAgICAgICAgICB0aGlzLl9zdG9yZS5wdXNoKGVudHJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zdG9yZS50aW1lLnB1c2goZW50cnkudGltZSk7XG4gICAgICAgICAgdGhpcy5fc3RvcmUuZGF0YS5wdXNoKGVudHJ5LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEYXRhUmVjb3JkZXI7XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YVJlY29yZGVyO1xuXG59LHtcIi4uLy4uL2NvcmUvQmFzZUxmb1wiOjE4MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiOjEwLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE3NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0Jhc2VMZm8yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9CYXNlTGZvJyk7XG5cbnZhciBfQmFzZUxmbzMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgdGltZToge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBkYXRhOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIG1ldGFkYXRhOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIHN0cmVhbVBhcmFtczoge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBmcmFtZUluZGV4OiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGBmcmFtZS50aW1lYCwgYGZyYW1lLmRhdGFgLCBgZnJhbWUubWV0YWRhdGFgIGFuZC9vclxuICAgKiBgc3RyZWFtQXR0cmlidXRlc2Agb2YgYW55IG5vZGUgaW4gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqIFRoaXMgc2luayBjYW4gaGFuZGxlIGFueSB0eXBlIGlmIGlucHV0IChgc2lnbmFsYCwgYHZlY3RvcmAsIGBzY2FsYXJgKVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIHBhcmFtZXRlcnMgZGVmYXVsdCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZT1mYWxzZV0gLSBMb2cgaW5jb21taW5nIGBmcmFtZS50aW1lYCBpZiBgdHJ1ZWAuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGF0YT1mYWxzZV0gLSBMb2cgaW5jb21taW5nIGBmcmFtZS5kYXRhYCBpZiBgdHJ1ZWAuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWV0YWRhdGE9ZmFsc2VdIC0gTG9nIGluY29tbWluZyBgZnJhbWUubWV0YWRhdGFgXG4gICAqICBpZiBgdHJ1ZWAuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RyZWFtUGFyYW1zPWZhbHNlXSAtIExvZyBgc3RyZWFtUGFyYW1zYCBvZiB0aGVcbiAgICogIHByZXZpb3VzIG5vZGUgd2hlbiBncmFwaCBpcyBzdGFydGVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZyYW1lSW5kZXg9ZmFsc2VdIC0gTG9nIGluZGV4IG9mIHRoZSBpbmNvbW1pbmdcbiAgICogIGBmcmFtZWAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLnNpbmtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jb21tb24nO1xuICAgKlxuICAgKiBjb25zdCBsb2dnZXIgPSBuZXcgbGZvLnNpbmsuTG9nZ2VyKHsgZGF0YTogdHJ1ZSB9KTtcbiAgICogd2hhdGV2ZXJPcGVyYXRvci5jb25uZWN0KGxvZ2dlcik7XG4gICAqL1xufTtcbnZhciBMb2dnZXIgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoTG9nZ2VyLCBfQmFzZUxmbyk7XG5cbiAgZnVuY3Rpb24gTG9nZ2VyKG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBMb2dnZXIpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChMb2dnZXIuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKExvZ2dlcikpLmNhbGwodGhpcywgZGVmaW5pdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoTG9nZ2VyLCBbe1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5nZXQoJ3N0cmVhbVBhcmFtcycpID09PSB0cnVlKSBjb25zb2xlLmxvZyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc0Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKSB7XG4gICAgICBpZiAodGhpcy5wYXJhbXMuZ2V0KCdmcmFtZUluZGV4JykgPT09IHRydWUpIGNvbnNvbGUubG9nKHRoaXMuZnJhbWVJbmRleCsrKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmdldCgndGltZScpID09PSB0cnVlKSBjb25zb2xlLmxvZyhmcmFtZS50aW1lKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmdldCgnZGF0YScpID09PSB0cnVlKSBjb25zb2xlLmxvZyhmcmFtZS5kYXRhKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmdldCgnbWV0YWRhdGEnKSA9PT0gdHJ1ZSkgY29uc29sZS5sb2coZnJhbWUubWV0YWRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTG9nZ2VyO1xufShfQmFzZUxmbzMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExvZ2dlcjtcblxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxNzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXNlTGZvMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbzIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmaW5pdGlvbnMgPSB7XG4gIGR1cmF0aW9uOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxMCxcbiAgICBtaW46IDAsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfVxuICB9LFxuICBjYWxsYmFjazoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgaWdub3JlTGVhZGluZ1plcm9zOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfVxuICB9LFxuICByZXRyaWV2ZUF1ZGlvQnVmZmVyOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH0sXG4gIGF1ZGlvQ29udGV4dDoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWVcbiAgfVxufTtcblxuLyoqXG4gKiBSZWNvcmQgYW4gYHNpZ25hbGAgaW5wdXQgc3RyZWFtIG9mIGFyYml0cmFyeSBkdXJhdGlvbiBhbmQgcmV0cmlldmUgaXRcbiAqIHdoZW4gZG9uZS5cbiAqXG4gKiBXaGVuIHJlY29yZGluZyBpcyBzdG9wcGVkIChlaXRoZXIgd2hlbiB0aGUgYHN0b3BgIG1ldGhvZCBpcyBjYWxsZWQsIHRoZVxuICogZGVmaW5lZCBkdXJhdGlvbiBoYXMgYmVlbiByZWNvcmRlZCwgb3IgdGhlIHNvdXJjZSBvZiB0aGUgZ3JhcGggZmluYWxpemVkXG4gKiB0aGUgc3RyZWFtKSwgdGhlIGNhbGxiYWNrIGdpdmVuIGFzIHBhcmFtZXRlciBpcyBleGVjdXRlZCAgd2l0aCB0aGVcbiAqIGBBdWRpb0J1ZmZlcmAgb3IgYEZsb2F0MzJBcnJheWAgY29udGFpbmluZyB0aGUgcmVjb3JkZWQgc2lnbmFsIGFzIGFyZ3VtZW50LlxuICpcbiAqIEB0b2RvIC0gYWRkIG9wdGlvbiB0byByZXR1cm4gb25seSB0aGUgRmxvYXQzMkFycmF5IGFuZCBub3QgYW4gYXVkaW8gYnVmZmVyXG4gKiAgKG5vZGUgY29tcGxpYW50KSBgcmV0cmlldmVBdWRpb0J1ZmZlcjogZmFsc2VgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb249MTBdIC0gTWF4aW11bSBkdXJhdGlvbiBvZiB0aGUgcmVjb3JkaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNhbGxiYWNrXSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBhIG5ldyByZWNvcmQgaXNcbiAqICBlbmRlZC4gVGhpcyBjYW4gaGFwcGVuOiBgc3RvcGAgaXMgY2FsbGVkIG9uIHRoZSByZWNvcmRlciwgYHN0b3BgIGlzIGNhbGxlZFxuICogIG9uIHRoZSBzb3VyY2Ugb3Igd2hlbiB0aGUgYnVmZmVyIGlzIGZ1bGwgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBgZHVyYXRpb25gLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmlnbm9yZUxlYWRpbmdaZXJvcz10cnVlXSAtIFN0YXJ0IHRoZSBlZmZlY3RpdmVcbiAqICByZWNvcmRpbmcgb24gdGhlIGZpcnN0IG5vbi16ZXJvIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXRyaWV2ZUF1ZGlvQnVmZmVyPWZhbHNlXSAtIERlZmluZSBpZiBhbiBgQXVkaW9CdWZmZXJgXG4gKiAgc2hvdWxkIGJlIHJldHJpZXZlZCBvciBvbmx5IHRoZSByYXcgRmxvYXQzMkFycmF5IG9mIGRhdGEuXG4gKiAgKHdvcmtzIG9ubHkgaW4gYnJvd3NlcilcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBbb3B0aW9ucy5hdWRpb0NvbnRleHQ9bnVsbF0gLSBJZlxuICogIGByZXRyaWV2ZUF1ZGlvQnVmZmVyYCBpcyBzZXQgdG8gYHRydWVgLCBhdWRpbyBjb250ZXh0IHRvIGJlIHVzZWRcbiAqICBpbiBvcmRlciB0byBjcmVhdGUgdGhlIGZpbmFsIGF1ZGlvIGJ1ZmZlci5cbiAqICAod29ya3Mgb25seSBpbiBicm93c2VyKVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLnNpbmtcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICpcbiAqIGNvbnN0IGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAqXG4gKiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gKiAgIC5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSB9KVxuICogICAudGhlbihpbml0KVxuICogICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIuc3RhY2spKTtcbiAqXG4gKiBmdW5jdGlvbiBpbml0KHN0cmVhbSkge1xuICogICBjb25zdCBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAqXG4gKiAgIGNvbnN0IGF1ZGlvSW5Ob2RlID0gbmV3IGxmby5zb3VyY2UuQXVkaW9Jbk5vZGUoe1xuICogICAgIHNvdXJjZU5vZGU6IHNvdXJjZSxcbiAqICAgICBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCxcbiAqICAgfSk7XG4gKlxuICogICBjb25zdCBzaWduYWxSZWNvcmRlciA9IG5ldyBsZm8uc2luay5TaWduYWxSZWNvcmRlcih7XG4gKiAgICAgZHVyYXRpb246IDYsXG4gKiAgICAgcmV0cmlldmVBdWRpb0J1ZmZlcjogdHJ1ZSxcbiAqICAgICBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCxcbiAqICAgICBjYWxsYmFjazogKGJ1ZmZlcikgPT4ge1xuICogICAgICAgY29uc3QgYnVmZmVyU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICogICAgICAgYnVmZmVyU291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAqICAgICAgIGJ1ZmZlclNvdXJjZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gKiAgICAgICBidWZmZXJTb3VyY2Uuc3RhcnQoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgYXVkaW9Jbk5vZGUuY29ubmVjdChzaWduYWxSZWNvcmRlcik7XG4gKiAgIGF1ZGlvSW5Ob2RlLnN0YXJ0KCk7XG4gKiAgIHNpZ25hbFJlY29yZGVyLnN0YXJ0KCk7XG4gKiB9KTtcbiAqL1xuXG52YXIgU2lnbmFsUmVjb3JkZXIgPSBmdW5jdGlvbiAoX0Jhc2VMZm8pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoU2lnbmFsUmVjb3JkZXIsIF9CYXNlTGZvKTtcblxuICBmdW5jdGlvbiBTaWduYWxSZWNvcmRlcigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU2lnbmFsUmVjb3JkZXIpO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIGlzIHRoZSBub2RlIGlzIGN1cnJlbnRseSByZWNvcmRpbmcgb3Igbm90LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQG5hbWUgaXNSZWNvcmRpbmdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNsaWVudC5zaW5rLlNpZ25hbFJlY29yZGVyXG4gICAgICovXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoU2lnbmFsUmVjb3JkZXIuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNpZ25hbFJlY29yZGVyKSkuY2FsbCh0aGlzLCBkZWZpbml0aW9ucywgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuaXNSZWNvcmRpbmcgPSBmYWxzZTtcblxuICAgIHZhciByZXRyaWV2ZUF1ZGlvQnVmZmVyID0gX3RoaXMucGFyYW1zLmdldCgncmV0cmlldmVBdWRpb0J1ZmZlcicpO1xuICAgIHZhciBhdWRpb0NvbnRleHQgPSBfdGhpcy5wYXJhbXMuZ2V0KCdhdWRpb0NvbnRleHQnKTtcbiAgICAvLyBuZWVkZWQgdG8gcmV0cmlldmUgYW4gQXVkaW9CdWZmZXJcbiAgICBpZiAocmV0cmlldmVBdWRpb0J1ZmZlciAmJiBhdWRpb0NvbnRleHQgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXIgXCJhdWRpb0NvbnRleHRcIjogYW4gQXVkaW9Db250ZXh0IG11c3QgYmUgcHJvdmlkZWQgd2hlbiBgcmV0cmlldmVBdWRpb0J1ZmZlcmAgaXMgc2V0IHRvIGB0cnVlYCcpO1xuXG4gICAgX3RoaXMuX2F1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICBfdGhpcy5faWdub3JlWmVyb3MgPSBmYWxzZTtcbiAgICBfdGhpcy5faXNJbmZpbml0ZUJ1ZmZlciA9IGZhbHNlO1xuICAgIF90aGlzLl9zdGFjayA9IFtdO1xuICAgIF90aGlzLl9idWZmZXIgPSBudWxsO1xuICAgIF90aGlzLl9idWZmZXJMZW5ndGggPSBudWxsO1xuICAgIF90aGlzLl9jdXJyZW50SW5kZXggPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFNpZ25hbFJlY29yZGVyLCBbe1xuICAgIGtleTogJ19pbml0QnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRCdWZmZXIoKSB7XG4gICAgICB0aGlzLl9idWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2J1ZmZlckxlbmd0aCk7XG4gICAgICB0aGlzLl9zdGFjay5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1N0cmVhbVBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBhcmFtcy5nZXQoJ2R1cmF0aW9uJyk7XG4gICAgICB2YXIgc2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG5cbiAgICAgIGlmIChpc0Zpbml0ZShkdXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5faXNJbmZpbml0ZUJ1ZmZlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9idWZmZXJMZW5ndGggPSBzYW1wbGVSYXRlICogZHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc0luZmluaXRlQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYnVmZmVyTGVuZ3RoID0gc2FtcGxlUmF0ZSAqIDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0QnVmZmVyKCk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHJlY29yZGluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMuaXNSZWNvcmRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5faWdub3JlWmVyb3MgPSB0aGlzLnBhcmFtcy5nZXQoJ2lnbm9yZUxlYWRpbmdaZXJvcycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgcmVjb3JkaW5nIGFuZCBleGVjdXRlIHRoZSBjYWxsYmFjayBkZWZpbmVkIGluIHBhcmFtZXRlcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcpIHtcbiAgICAgICAgLy8gaWdub3JlIG5leHQgaW5jb21taW5nIGZyYW1lXG4gICAgICAgIHRoaXMuaXNSZWNvcmRpbmcgPSBmYWxzZTtcblxuICAgICAgICB2YXIgcmV0cmlldmVBdWRpb0J1ZmZlciA9IHRoaXMucGFyYW1zLmdldCgncmV0cmlldmVBdWRpb0J1ZmZlcicpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLnBhcmFtcy5nZXQoJ2NhbGxiYWNrJyk7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG4gICAgICAgIHZhciBvdXRwdXQgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0luZmluaXRlQnVmZmVyKSB7XG4gICAgICAgICAgb3V0cHV0ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50SW5kZXgpO1xuICAgICAgICAgIG91dHB1dC5zZXQoYnVmZmVyLnN1YmFycmF5KDAsIGN1cnJlbnRJbmRleCksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBidWZmZXJMZW5ndGggPSB0aGlzLl9idWZmZXJMZW5ndGg7XG4gICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2s7XG5cbiAgICAgICAgICBvdXRwdXQgPSBuZXcgRmxvYXQzMkFycmF5KHN0YWNrLmxlbmd0aCAqIGJ1ZmZlckxlbmd0aCArIGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgICAvLyBjb3B5IGFsbCBzdGFja2VkIGJ1ZmZlcnNcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZEJ1ZmZlciA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgb3V0cHV0LnNldChzdGFja2VkQnVmZmVyLCBidWZmZXJMZW5ndGggKiBpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIGNvcHkgZGF0YSBjb250YWluZWQgaW4gY3VycmVudCBidWZmZXJcbiAgICAgICAgICBvdXRwdXQuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBjdXJyZW50SW5kZXgpLCBzdGFjay5sZW5ndGggKiBidWZmZXJMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHJpZXZlQXVkaW9CdWZmZXIgJiYgdGhpcy5fYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICAgICAgdmFyIHNhbXBsZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlO1xuICAgICAgICAgIHZhciBhdWRpb0J1ZmZlciA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgbGVuZ3RoLCBzYW1wbGVSYXRlKTtcbiAgICAgICAgICB2YXIgY2hhbm5lbERhdGEgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgICBjaGFubmVsRGF0YS5zZXQob3V0cHV0LCAwKTtcblxuICAgICAgICAgIGNhbGxiYWNrKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVpbml0IGJ1ZmZlciwgc3RhY2ssIGFuZCBjdXJyZW50SW5kZXhcbiAgICAgICAgdGhpcy5faW5pdEJ1ZmZlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmaW5hbGl6ZVN0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplU3RyZWFtKGVuZFRpbWUpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzU2lnbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NpZ25hbChmcmFtZSkge1xuICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKSByZXR1cm47XG5cbiAgICAgIHZhciBibG9jayA9IG51bGw7XG4gICAgICB2YXIgaW5wdXQgPSBmcmFtZS5kYXRhO1xuICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IHRoaXMuX2J1ZmZlckxlbmd0aDtcbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG5cbiAgICAgIGlmICh0aGlzLl9pZ25vcmVaZXJvcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgYmxvY2sgPSBuZXcgRmxvYXQzMkFycmF5KGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBpbmRleCB3aGVyZSB2YWx1ZSAhPT0gMFxuICAgICAgICB2YXIgaSA9IHZvaWQgMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaW5wdXRbaV0gIT09IDApIGJyZWFrO1xuICAgICAgICB9IC8vIGNvcHkgbm9uIHplcm8gc2VnbWVudFxuICAgICAgICBibG9jayA9IG5ldyBGbG9hdDMyQXJyYXkoaW5wdXQuc3ViYXJyYXkoaSkpO1xuICAgICAgICAvLyBkb24ndCByZXBlYXQgdGhpcyBsb2dpYyBvbmNlIGEgbm9uLXplcm8gdmFsdWUgaGFzIGJlZW4gZm91bmRcbiAgICAgICAgdGhpcy5faWdub3JlWmVyb3MgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBhdmFpbGFibGVTcGFjZSA9IGJ1ZmZlckxlbmd0aCAtIHRoaXMuX2N1cnJlbnRJbmRleDtcbiAgICAgICAgdmFyIGN1cnJlbnRCbG9jayA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoYXZhaWxhYmxlU3BhY2UgPCBibG9jay5sZW5ndGgpIGN1cnJlbnRCbG9jayA9IGJsb2NrLnN1YmFycmF5KDAsIGF2YWlsYWJsZVNwYWNlKTtlbHNlIGN1cnJlbnRCbG9jayA9IGJsb2NrO1xuXG4gICAgICAgIGJ1ZmZlci5zZXQoY3VycmVudEJsb2NrLCB0aGlzLl9jdXJyZW50SW5kZXgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggKz0gY3VycmVudEJsb2NrLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5faXNJbmZpbml0ZUJ1ZmZlciAmJiB0aGlzLl9jdXJyZW50SW5kZXggPT09IGJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3N0YWNrLnB1c2goYnVmZmVyKTtcblxuICAgICAgICAgIGN1cnJlbnRCbG9jayA9IGJsb2NrLnN1YmFycmF5KGF2YWlsYWJsZVNwYWNlKTtcbiAgICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5fYnVmZmVyLnNldChjdXJyZW50QmxvY2ssIDApO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IGN1cnJlbnRCbG9jay5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgc3RvcCBpZiB0aGUgYnVmZmVyIGlzIGZpbml0ZSBhbmQgZnVsbFxuICAgICAgICBpZiAoIXRoaXMuX2lzSW5maW5pdGVCdWZmZXIgJiYgdGhpcy5fY3VycmVudEluZGV4ID09PSBidWZmZXJMZW5ndGgpIHRoaXMuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2lnbmFsUmVjb3JkZXI7XG59KF9CYXNlTGZvMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU2lnbmFsUmVjb3JkZXI7XG5cbn0se1wiLi4vLi4vY29yZS9CYXNlTGZvXCI6MTgyLFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTksXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjIwfV0sMTc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaXNGaW5pdGUgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLWZpbml0ZScpO1xuXG52YXIgX2lzRmluaXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzRmluaXRlKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmFzZUxmbyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQmFzZUxmbycpO1xuXG52YXIgX0Jhc2VMZm8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZUxmbyk7XG5cbnZhciBfU291cmNlTWl4aW4yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Tb3VyY2VNaXhpbicpO1xuXG52YXIgX1NvdXJjZU1peGluMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NvdXJjZU1peGluMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc1NzU3OTAvZW52aXJvbm1lbnQtZGV0ZWN0aW9uLW5vZGUtanMtb3ItYnJvd3NlclxudmFyIGlzTm9kZSA9IG5ldyBGdW5jdGlvbigndHJ5IHsgcmV0dXJuIHRoaXMgPT09IGdsb2JhbDsgfSBjYXRjaChlKSB7IHJldHVybiBmYWxzZSB9Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRpbWUgaW4gc2Vjb25kcyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnRcbiAqIGVudmlyb25uZW1lbnQgKG5vZGUgb3IgYnJvd3NlcikuXG4gKiBJZiBydW5uaW5nIGluIG5vZGUgdGhlIHRpbWUgcmVseSBvbiBgcHJvY2Vzcy5ocnRpbWVgLCB3aGlsZSBpZiBpbiB0aGUgYnJvd3NlclxuICogaXQgaXMgcHJvdmlkZWQgYnkgdGhlIGBjdXJyZW50VGltZWAgb2YgYW4gYEF1ZGlvQ29udGV4dGAsIHRoaXMgY29udGV4dCBjYW5cbiAqIG9wdGlvbm5hbHkgYmUgcHJvdmlkZWQgdG8ga2VlcCB0aW1lIGNvbnNpc3RlbmN5IGJldHdlZW4gc2V2ZXJhbCBgRXZlbnRJbmBcbiAqIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBbYXVkaW9Db250ZXh0PW51bGxdIC0gT3B0aW9ubmFsIGF1ZGlvIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFRpbWVGdW5jdGlvbigpIHtcbiAgdmFyIGF1ZGlvQ29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICBpZiAoaXNOb2RlKCkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgICAgcmV0dXJuIHRbMF0gKyB0WzFdICogMWUtOTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGRlZmluaXRpb25zID0ge1xuICBhYnNvbHV0ZVRpbWU6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgY29uc3RhbnQ6IHRydWVcbiAgfSxcbiAgYXVkaW9Db250ZXh0OiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBudWxsYWJsZTogdHJ1ZVxuICB9LFxuICBmcmFtZVR5cGU6IHtcbiAgICB0eXBlOiAnZW51bScsXG4gICAgbGlzdDogWydzaWduYWwnLCAndmVjdG9yJywgJ3NjYWxhciddLFxuICAgIGRlZmF1bHQ6ICdzaWduYWwnLFxuICAgIGNvbnN0YW50OiB0cnVlXG4gIH0sXG4gIGZyYW1lU2l6ZToge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbjogMSxcbiAgICBtYXg6ICtJbmZpbml0eSwgLy8gbm90IHJlY29tbWVuZGVkLi4uXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfVxuICB9LFxuICBzYW1wbGVSYXRlOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG1pbjogMCxcbiAgICBtYXg6ICtJbmZpbml0eSwgLy8gc2FtZSBoZXJlXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfVxuICB9LFxuICBmcmFtZVJhdGU6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbWluOiAwLFxuICAgIG1heDogK0luZmluaXR5LCAvLyBzYW1lIGhlcmVcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9XG4gIH0sXG4gIGRlc2NyaXB0aW9uOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBjb25zdGFudDogdHJ1ZVxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgRXZlbnRJbmAgb3BlcmF0b3IgYWxsb3dzIHRvIG1hbnVhbGx5IGNyZWF0ZSBhIHN0cmVhbSBvZiBkYXRhIG9yIHRvIGZlZWRcbiAqIGEgc3RyZWFtIGZyb20gYW5vdGhlciBzb3VyY2UgKGUuZy4gc2Vuc29ycykgaW50byBhIHByb2Nlc3NpbmcgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBwYXJhbWV0ZXJzJyBkZWZhdWx0IHZhbHVlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mcmFtZVR5cGU9J3NpZ25hbCddIC0gVHlwZSBvZiB0aGUgaW5wdXQgLSBhbGxvd2VkXG4gKiB2YWx1ZXM6IGBzaWduYWxgLCAgYHZlY3RvcmAgb3IgYHNjYWxhcmAuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJhbWVTaXplPTFdIC0gU2l6ZSBvZiB0aGUgb3V0cHV0IGZyYW1lLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhbXBsZVJhdGU9bnVsbF0gLSBTYW1wbGUgcmF0ZSBvZiB0aGUgc291cmNlIHN0cmVhbSxcbiAqICBpZiBvZiB0eXBlIGBzaWduYWxgLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyYW1lUmF0ZT1udWxsXSAtIFJhdGUgb2YgdGhlIHNvdXJjZSBzdHJlYW0sIGlmIG9mXG4gKiAgdHlwZSBgdmVjdG9yYC5cbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl0gLSBPcHRpb25uYWwgZGVzY3JpcHRpb25cbiAqICBkZXNjcmliaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvdXRwdXQgZnJhbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWJzb2x1dGVUaW1lPWZhbHNlXSAtIERlZmluZSBpZiB0aW1lIHNob3VsZCBiZSB1c2VkXG4gKiAgYXMgZm9yd2FyZGVkIGFzIGdpdmVuIGluIHRoZSBwcm9jZXNzIG1ldGhvZCwgb3IgcmVsYXRpdmVseSB0byB0aGUgdGltZSBvZlxuICogIHRoZSBmaXJzdCBgcHJvY2Vzc2AgY2FsbCBhZnRlciBzdGFydC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5zb3VyY2VcbiAqXG4gKiBAdG9kbyAtIEFkZCBhIGBsb2dpY2FsVGltZWAgcGFyYW1ldGVyIHRvIHRhZyBmcmFtZSBhY2NvcmRpbmcgdG8gZnJhbWUgcmF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHtcbiAqICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAqICAgZnJhbWVTaXplOiAzLFxuICogICBmcmFtZVJhdGU6IDEgLyA1MCxcbiAqICAgZGVzY3JpcHRpb246IFsnYWxwaGEnLCAnYmV0YScsICdnYW1tYSddLFxuICogfSk7XG4gKlxuICogLy8gY29ubmVjdCBzb3VyY2UgdG8gb3BlcmF0b3JzIGFuZCBzaW5rKHMpXG4gKlxuICogLy8gaW5pdGlhbGl6ZSBhbmQgc3RhcnQgdGhlIGdyYXBoXG4gKiBldmVudEluLnN0YXJ0KCk7XG4gKlxuICogLy8gZmVlZCBgZGV2aWNlb3JpZW50YXRpb25gIGRhdGEgaW50byB0aGUgZ3JhcGhcbiAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VvcmllbnRhdGlvbicsIChlKSA9PiB7XG4gKiAgIGNvbnN0IGZyYW1lID0ge1xuICogICAgIHRpbWU6IHdpbmRvdy5wZXJmb3JtYWNlLm5vdygpIC8gMTAwMCxcbiAqICAgICBkYXRhOiBbZS5hbHBoYSwgZS5iZXRhLCBlLmdhbW1hXSxcbiAqICAgfTtcbiAqXG4gKiAgIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKGZyYW1lKTtcbiAqIH0sIGZhbHNlKTtcbiAqL1xuXG52YXIgRXZlbnRJbiA9IGZ1bmN0aW9uIChfU291cmNlTWl4aW4pIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoRXZlbnRJbiwgX1NvdXJjZU1peGluKTtcblxuICBmdW5jdGlvbiBFdmVudEluKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBFdmVudEluKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKEV2ZW50SW4uX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEV2ZW50SW4pKS5jYWxsKHRoaXMsIGRlZmluaXRpb25zLCBvcHRpb25zKSk7XG5cbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gX3RoaXMucGFyYW1zLmdldCgnYXVkaW9Db250ZXh0Jyk7XG4gICAgX3RoaXMuX2dldFRpbWUgPSBnZXRUaW1lRnVuY3Rpb24oYXVkaW9Db250ZXh0KTtcbiAgICBfdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcbiAgICBfdGhpcy5fc3lzdGVtVGltZSA9IG51bGw7XG4gICAgX3RoaXMuX2Fic29sdXRlVGltZSA9IF90aGlzLnBhcmFtcy5nZXQoJ2Fic29sdXRlVGltZScpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGUgdGhlIGBzdHJlYW1QYXJhbXNgIGluIHRoZSBncmFwaCBhbmQgYWxsb3cgdG8gcHVzaCBmcmFtZXMgaW50b1xuICAgKiB0aGUgZ3JhcGguIEFueSBjYWxsIHRvIGBwcm9jZXNzYCBvciBgcHJvY2Vzc0ZyYW1lYCBiZWZvcmUgYHN0YXJ0YCB3aWxsIGJlXG4gICAqIGlnbm9yZWQuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJvY2Vzc1N0cmVhbVBhcmFtc31cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNyZXNldFN0cmVhbX1cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvbW1vbi5zb3VyY2UuRXZlbnRJbiNzdG9wfVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKEV2ZW50SW4sIFt7XG4gICAga2V5OiAnc3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhcnRUaW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdFByb21pc2UgPT09IG51bGwpIC8vIGluaXQgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWRcbiAgICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5zdGFydChzdGFydFRpbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgdGhpcy5fc3lzdGVtVGltZSA9IG51bGw7IC8vIHZhbHVlIHNldCBpbiB0aGUgZmlyc3QgYHByb2Nlc3NgIGNhbGxcblxuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZSB0aGUgc3RyZWFtIGFuZCBzdG9wIHRoZSB3aG9sZSBncmFwaC4gQW55IGNhbGwgdG8gYHByb2Nlc3NgIG9yXG4gICAgICogYHByb2Nlc3NGcmFtZWAgYWZ0ZXIgYHN0b3BgIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jZmluYWxpemVTdHJlYW19XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvbW1vbi5zb3VyY2UuRXZlbnRJbiNzdGFydH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGVkICYmIHRoaXMuX3N0YXJ0VGltZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLl9nZXRUaW1lKCk7XG4gICAgICAgIHZhciBlbmRUaW1lID0gdGhpcy5mcmFtZS50aW1lICsgKGN1cnJlbnRUaW1lIC0gdGhpcy5fc3lzdGVtVGltZSk7XG5cbiAgICAgICAgdGhpcy5maW5hbGl6ZVN0cmVhbShlbmRUaW1lKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKCkge1xuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnZnJhbWVTaXplJyk7XG4gICAgICB2YXIgZnJhbWVUeXBlID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVR5cGUnKTtcbiAgICAgIHZhciBzYW1wbGVSYXRlID0gdGhpcy5wYXJhbXMuZ2V0KCdzYW1wbGVSYXRlJyk7XG4gICAgICB2YXIgZnJhbWVSYXRlID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVJhdGUnKTtcbiAgICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyYW1zLmdldCgnZGVzY3JpcHRpb24nKTtcblxuICAgICAgLy8gaW5pdCBvcGVyYXRvcidzIHN0cmVhbSBwYXJhbXNcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IGZyYW1lVHlwZSA9PT0gJ3NjYWxhcicgPyAxIDogZnJhbWVTaXplO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gZnJhbWVUeXBlO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcblxuICAgICAgaWYgKGZyYW1lVHlwZSA9PT0gJ3NpZ25hbCcpIHtcbiAgICAgICAgaWYgKHNhbXBsZVJhdGUgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIFwic2FtcGxlUmF0ZVwiIGZvciBcInNpZ25hbFwiIHN0cmVhbScpO1xuXG4gICAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICAgICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGUgPSBzYW1wbGVSYXRlIC8gZnJhbWVTaXplO1xuICAgICAgICB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVDb3VudCA9IGZyYW1lU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVUeXBlID09PSAndmVjdG9yJyB8fCBmcmFtZVR5cGUgPT09ICdzY2FsYXInKSB7XG4gICAgICAgIGlmIChmcmFtZVJhdGUgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIFwiZnJhbWVSYXRlXCIgZm9yIFwiJyArIGZyYW1lVHlwZSArICdcIiBzdHJlYW0nKTtcblxuICAgICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGUgPSBmcmFtZVJhdGU7XG4gICAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGUgPSBmcmFtZVJhdGU7XG4gICAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZUNvdW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc0Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLl9nZXRUaW1lKCk7XG4gICAgICB2YXIgaW5EYXRhID0gZnJhbWUuZGF0YS5sZW5ndGggPyBmcmFtZS5kYXRhIDogW2ZyYW1lLmRhdGFdO1xuICAgICAgdmFyIG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgICAvLyBpZiBubyB0aW1lIHByb3ZpZGVkLCB1c2Ugc3lzdGVtIHRpbWVcbiAgICAgIHZhciB0aW1lID0gKDAsIF9pc0Zpbml0ZTIuZGVmYXVsdCkoZnJhbWUudGltZSkgPyBmcmFtZS50aW1lIDogY3VycmVudFRpbWU7XG5cbiAgICAgIGlmICh0aGlzLl9zdGFydFRpbWUgPT09IG51bGwpIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG5cbiAgICAgIGlmICh0aGlzLl9hYnNvbHV0ZVRpbWUgPT09IGZhbHNlKSB0aW1lID0gdGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgb3V0RGF0YVtpXSA9IGluRGF0YVtpXTtcbiAgICAgIH10aGlzLmZyYW1lLnRpbWUgPSB0aW1lO1xuICAgICAgdGhpcy5mcmFtZS5tZXRhZGF0YSA9IGZyYW1lLm1ldGFkYXRhO1xuICAgICAgLy8gc3RvcmUgY3VycmVudCB0aW1lIHRvIGNvbXB1dGUgYGVuZFRpbWVgIG9uIHN0b3BcbiAgICAgIHRoaXMuX3N5c3RlbVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbHRlcm5hdGl2ZSBpbnRlcmZhY2UgdG8gcHJvcGFnYXRlIGEgZnJhbWUgaW4gdGhlIGdyYXBoLiBQYWNrIGB0aW1lYCxcbiAgICAgKiBgZGF0YWAgYW5kIGBtZXRhZGF0YWAgaW4gYSBmcmFtZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIEZyYW1lIHRpbWUuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXl9IGRhdGEgLSBGcmFtZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YSAtIE9wdGlvbm5hbCBmcmFtZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZXZlbnRJbi5wcm9jZXNzKDEsIFswLCAxLCAyXSk7XG4gICAgICogLy8gaXMgZXF1aXZhbGVudCB0b1xuICAgICAqIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKHsgdGltZTogMSwgZGF0YTogWzAsIDEsIDJdIH0pO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyh0aW1lLCBkYXRhKSB7XG4gICAgICB2YXIgbWV0YWRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgICAgIHRoaXMucHJvY2Vzc0ZyYW1lKHsgdGltZTogdGltZSwgZGF0YTogZGF0YSwgbWV0YWRhdGE6IG1ldGFkYXRhIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3BhZ2F0ZSBhIGZyYW1lIG9iamVjdCBpbiB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZnJhbWUgLSBJbnB1dCBmcmFtZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWUudGltZSAtIEZyYW1lIHRpbWUuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXl9IGZyYW1lLmRhdGEgLSBGcmFtZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZnJhbWUubWV0YWRhdGE9dW5kZWZpbmVkXSAtIE9wdGlvbm5hbCBmcmFtZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZXZlbnRJbi5wcm9jZXNzRnJhbWUoeyB0aW1lOiAxLCBkYXRhOiBbMCwgMSwgMl0gfSk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NGcmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHJldHVybjtcblxuICAgICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcbiAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKTtcbiAgICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEV2ZW50SW47XG59KCgwLCBfU291cmNlTWl4aW4zLmRlZmF1bHQpKF9CYXNlTGZvMi5kZWZhdWx0KSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50SW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCIuLi8uLi9jb3JlL0Jhc2VMZm9cIjoxODIsXCIuLi8uLi9jb3JlL1NvdXJjZU1peGluXCI6MTgzLFwiX3Byb2Nlc3NcIjoxODgsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLWZpbml0ZVwiOjUsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiOjE1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI6MTYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIjoxOSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI6MjB9XSwxODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyBzaG9ydGN1dHMgLyBoZWxwZXJzXG52YXIgUEkgPSBNYXRoLlBJO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbi8vIHdpbmRvdyBjcmVhdGlvbiBmdW5jdGlvbnNcbmZ1bmN0aW9uIGluaXRIYW5uV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKSB7XG4gIHZhciBsaW5TdW0gPSAwO1xuICB2YXIgcG93U3VtID0gMDtcbiAgdmFyIHN0ZXAgPSAyICogUEkgLyBzaXplO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdmFyIHBoaSA9IGkgKiBzdGVwO1xuICAgIHZhciB2YWx1ZSA9IDAuNSAtIDAuNSAqIGNvcyhwaGkpO1xuXG4gICAgYnVmZmVyW2ldID0gdmFsdWU7XG5cbiAgICBsaW5TdW0gKz0gdmFsdWU7XG4gICAgcG93U3VtICs9IHZhbHVlICogdmFsdWU7XG4gIH1cblxuICBub3JtQ29lZnMubGluZWFyID0gc2l6ZSAvIGxpblN1bTtcbiAgbm9ybUNvZWZzLnBvd2VyID0gc3FydChzaXplIC8gcG93U3VtKTtcbn1cblxuZnVuY3Rpb24gaW5pdEhhbW1pbmdXaW5kb3coYnVmZmVyLCBzaXplLCBub3JtQ29lZnMpIHtcbiAgdmFyIGxpblN1bSA9IDA7XG4gIHZhciBwb3dTdW0gPSAwO1xuICB2YXIgc3RlcCA9IDIgKiBQSSAvIHNpemU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB2YXIgcGhpID0gaSAqIHN0ZXA7XG4gICAgdmFyIHZhbHVlID0gMC41NCAtIDAuNDYgKiBjb3MocGhpKTtcblxuICAgIGJ1ZmZlcltpXSA9IHZhbHVlO1xuXG4gICAgbGluU3VtICs9IHZhbHVlO1xuICAgIHBvd1N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICB9XG5cbiAgbm9ybUNvZWZzLmxpbmVhciA9IHNpemUgLyBsaW5TdW07XG4gIG5vcm1Db2Vmcy5wb3dlciA9IHNxcnQoc2l6ZSAvIHBvd1N1bSk7XG59XG5cbmZ1bmN0aW9uIGluaXRCbGFja21hbldpbmRvdyhidWZmZXIsIHNpemUsIG5vcm1Db2Vmcykge1xuICB2YXIgbGluU3VtID0gMDtcbiAgdmFyIHBvd1N1bSA9IDA7XG4gIHZhciBzdGVwID0gMiAqIFBJIC8gc2l6ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHZhciBwaGkgPSBpICogc3RlcDtcbiAgICB2YXIgdmFsdWUgPSAwLjQyIC0gMC41ICogY29zKHBoaSkgKyAwLjA4ICogY29zKDIgKiBwaGkpO1xuXG4gICAgYnVmZmVyW2ldID0gdmFsdWU7XG5cbiAgICBsaW5TdW0gKz0gdmFsdWU7XG4gICAgcG93U3VtICs9IHZhbHVlICogdmFsdWU7XG4gIH1cblxuICBub3JtQ29lZnMubGluZWFyID0gc2l6ZSAvIGxpblN1bTtcbiAgbm9ybUNvZWZzLnBvd2VyID0gc3FydChzaXplIC8gcG93U3VtKTtcbn1cblxuZnVuY3Rpb24gaW5pdEJsYWNrbWFuSGFycmlzV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKSB7XG4gIHZhciBsaW5TdW0gPSAwO1xuICB2YXIgcG93U3VtID0gMDtcbiAgdmFyIGEwID0gMC4zNTg3NTtcbiAgdmFyIGExID0gMC40ODgyOTtcbiAgdmFyIGEyID0gMC4xNDEyODtcbiAgdmFyIGEzID0gMC4wMTE2ODtcbiAgdmFyIHN0ZXAgPSAyICogUEkgLyBzaXplO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdmFyIHBoaSA9IGkgKiBzdGVwO1xuICAgIHZhciB2YWx1ZSA9IGEwIC0gYTEgKiBjb3MocGhpKSArIGEyICogY29zKDIgKiBwaGkpOy1hMyAqIGNvcygzICogcGhpKTtcblxuICAgIGJ1ZmZlcltpXSA9IHZhbHVlO1xuXG4gICAgbGluU3VtICs9IHZhbHVlO1xuICAgIHBvd1N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICB9XG5cbiAgbm9ybUNvZWZzLmxpbmVhciA9IHNpemUgLyBsaW5TdW07XG4gIG5vcm1Db2Vmcy5wb3dlciA9IHNxcnQoc2l6ZSAvIHBvd1N1bSk7XG59XG5cbmZ1bmN0aW9uIGluaXRTaW5lV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKSB7XG4gIHZhciBsaW5TdW0gPSAwO1xuICB2YXIgcG93U3VtID0gMDtcbiAgdmFyIHN0ZXAgPSBQSSAvIHNpemU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB2YXIgcGhpID0gaSAqIHN0ZXA7XG4gICAgdmFyIHZhbHVlID0gc2luKHBoaSk7XG5cbiAgICBidWZmZXJbaV0gPSB2YWx1ZTtcblxuICAgIGxpblN1bSArPSB2YWx1ZTtcbiAgICBwb3dTdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgfVxuXG4gIG5vcm1Db2Vmcy5saW5lYXIgPSBzaXplIC8gbGluU3VtO1xuICBub3JtQ29lZnMucG93ZXIgPSBzcXJ0KHNpemUgLyBwb3dTdW0pO1xufVxuXG5mdW5jdGlvbiBpbml0UmVjdGFuZ2xlV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYnVmZmVyW2ldID0gMTtcbiAgfSAvLyBAdG9kbyAtIGNoZWNrIGlmIHRoZXNlIGFyZSBwcm9wZXIgdmFsdWVzXG4gIG5vcm1Db2Vmcy5saW5lYXIgPSAxO1xuICBub3JtQ29lZnMucG93ZXIgPSAxO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGJ1ZmZlciB3aXRoIHdpbmRvdyBzaWduYWwuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24udXRpbHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHdpbmRvdy5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBidWZmZXIgLSBCdWZmZXIgdG8gYmUgcG9wdWxhdGVkIHdpdGggdGhlIHdpbmRvdyBzaWduYWwuXG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIFNpemUgb2YgdGhlIGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBub3JtQ29lZnMgLSBPYmplY3QgdG8gYmUgcG9wdWxhdGVkIHdpdGggdGhlIG5vcm1haWx6YXRpb25cbiAqICBjb2VmZmljaWVudHMuXG4gKi9cbmZ1bmN0aW9uIGluaXRXaW5kb3cobmFtZSwgYnVmZmVyLCBzaXplLCBub3JtQ29lZnMpIHtcbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdoYW5uJzpcbiAgICBjYXNlICdoYW5uaW5nJzpcbiAgICAgIGluaXRIYW5uV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2hhbW1pbmcnOlxuICAgICAgaW5pdEhhbW1pbmdXaW5kb3coYnVmZmVyLCBzaXplLCBub3JtQ29lZnMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmxhY2ttYW4nOlxuICAgICAgaW5pdEJsYWNrbWFuV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JsYWNrbWFuaGFycmlzJzpcbiAgICAgIGluaXRCbGFja21hbkhhcnJpc1dpbmRvdyhidWZmZXIsIHNpemUsIG5vcm1Db2Vmcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzaW5lJzpcbiAgICAgIGluaXRTaW5lV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3RhbmdsZSc6XG4gICAgICBpbml0UmVjdGFuZ2xlV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGluaXRXaW5kb3c7XG5cbn0se31dLDE4MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlY29kZXJzID0gZXhwb3J0cy5lbmNvZGVycyA9IGV4cG9ydHMub3Bjb2RlcyA9IHVuZGVmaW5lZDtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnknKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg2MDkyODkvY29udmVydC1hLWJpbmFyeS1ub2RlanMtYnVmZmVyLXRvLWphdmFzY3JpcHQtYXJyYXlidWZmZXJcbi8vIGNvbnZlcnRzIGEgbm9kZWpzIEJ1ZmZlciB0byBBcnJheUJ1ZmZlclxuLy8gZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4vLyAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuLy8gICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXG4vLyAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKVxuLy8gICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG5cbi8vICAgcmV0dXJuIGFiO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0J1ZmZlcihhcnJheUJ1ZmZlcikge1xuLy8gICBjb25zdCBidWZmZXIgPSBuZXcgQnVmZmVyKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuLy8gICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXG4vLyAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKVxuLy8gICAgIGJ1ZmZlcltpXSA9IHZpZXdbaV07XG5cbi8vICAgcmV0dXJuIGJ1ZmZlcjtcbi8vIH1cblxuLy8gaHR0cDovL3VwZGF0ZXMuaHRtbDVyb2Nrcy5jb20vMjAxMi8wNi9Ib3ctdG8tY29udmVydC1BcnJheUJ1ZmZlci10by1hbmQtZnJvbS1TdHJpbmdcbmZ1bmN0aW9uIFVpbnQxNkFycmF5Mmpzb24oYXJyKSB7XG4gIHZhciBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycik7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0ci5yZXBsYWNlKC9cXHUwMDAwL2csICcnKSk7XG59XG5cbmZ1bmN0aW9uIGpzb24yVWludDE2QXJyYXkoanNvbikge1xuICB2YXIgc3RyID0gKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKGpzb24pO1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHN0ci5sZW5ndGggKiAyKTsgLy8gMiBieXRlcyBmb3IgZWFjaCBjaGFyXG4gIHZhciBidWZmZXJWaWV3ID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYnVmZmVyVmlld1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9cmV0dXJuIGJ1ZmZlclZpZXc7XG59XG5cbnZhciBvcGNvZGVzID0gZXhwb3J0cy5vcGNvZGVzID0ge1xuICBJTklUX01PRFVMRV9SRVE6IDEwLFxuICBJTklUX01PRFVMRV9BQ0s6IDExLFxuICBQUk9DRVNTX1NUUkVBTV9QQVJBTVM6IDEyLFxuICBSRVNFVF9TVFJFQU06IDEzLFxuICBGSU5BTElaRV9TVFJFQU06IDE0LFxuICBQUk9DRVNTX0ZSQU1FOiAxNVxuXG4gIC8vXG59O3ZhciBlbmNvZGVycyA9IGV4cG9ydHMuZW5jb2RlcnMgPSB7XG4gIG9wY29kZTogZnVuY3Rpb24gb3Bjb2RlKG5hbWUpIHtcbiAgICB2YXIgb3Bjb2RlID0gb3Bjb2Rlc1tuYW1lXTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KDEpO1xuICAgIGJ1ZmZlclswXSA9IG9wY29kZTtcblxuICAgIHJldHVybiBidWZmZXI7XG4gIH0sXG5cbiAgLy8gYG9wY29kZWAgICAgMiBieXRlcyAoVWludDE2KSB8XG4gIGluaXRNb2R1bGVSZXE6IGZ1bmN0aW9uIGluaXRNb2R1bGVSZXEoKSB7XG4gICAgdmFyIHBheWxvYWQgPSBlbmNvZGVycy5vcGNvZGUoJ0lOSVRfTU9EVUxFX1JFUScpO1xuICAgIHJldHVybiBwYXlsb2FkLmJ1ZmZlcjtcbiAgfSxcbiAgLy8gYG9wY29kZWAgICAgMiBieXRlcyAoVWludDE2KSB8XG4gIGluaXRNb2R1bGVBY2s6IGZ1bmN0aW9uIGluaXRNb2R1bGVBY2soKSB7XG4gICAgdmFyIHBheWxvYWQgPSBlbmNvZGVycy5vcGNvZGUoJ0lOSVRfTU9EVUxFX0FDSycpO1xuICAgIHJldHVybiBwYXlsb2FkLmJ1ZmZlcjtcbiAgfSxcbiAgLy8gYG9wY29kZWAgICAgMiBieXRlcyAoVWludDE2KSB8XG4gIC8vIGBzdHJlYW1QYXJhbXNgICBuIGJ5dGVzIChVaW50MTYpXG4gIHN0cmVhbVBhcmFtczogZnVuY3Rpb24gc3RyZWFtUGFyYW1zKF9zdHJlYW1QYXJhbXMpIHtcbiAgICB2YXIgb3Bjb2RlID0gZW5jb2RlcnMub3Bjb2RlKCdQUk9DRVNTX1NUUkVBTV9QQVJBTVMnKTtcbiAgICB2YXIgc3RyZWFtUGFyYW1zQnVmZmVyID0ganNvbjJVaW50MTZBcnJheShfc3RyZWFtUGFyYW1zKTtcblxuICAgIHZhciBwYXlsb2FkID0gbmV3IFVpbnQxNkFycmF5KDEgKyBzdHJlYW1QYXJhbXNCdWZmZXIubGVuZ3RoKTtcbiAgICBwYXlsb2FkLnNldChvcGNvZGUsIDApO1xuICAgIHBheWxvYWQuc2V0KHN0cmVhbVBhcmFtc0J1ZmZlciwgMSk7XG5cbiAgICByZXR1cm4gcGF5bG9hZC5idWZmZXI7XG4gIH0sXG4gIC8vIGBvcGNvZGVgICAgIDIgYnl0ZXMgKFVpbnQxNikgfFxuICByZXNldFN0cmVhbTogZnVuY3Rpb24gcmVzZXRTdHJlYW0oKSB7XG4gICAgdmFyIHBheWxvYWQgPSBlbmNvZGVycy5vcGNvZGUoJ1JFU0VUX1NUUkVBTScpO1xuICAgIHJldHVybiBwYXlsb2FkLmJ1ZmZlcjtcbiAgfSxcbiAgLy8gYG9wY29kZWAgICAgMiBieXRlcyAoVWludDE2KSB8XG4gIC8vIGBlbmRUaW1lYCAgIDggYnl0ZXMgKEZsb2F0NjQpXG4gIGZpbmFsaXplU3RyZWFtOiBmdW5jdGlvbiBmaW5hbGl6ZVN0cmVhbShlbmRUaW1lKSB7XG4gICAgdmFyIG9wY29kZSA9IGVuY29kZXJzLm9wY29kZSgnUkVTRVRfU1RSRUFNJyk7XG5cbiAgICB2YXIgZW5kVGltZUJ1ZmZlciA9IG5ldyBGbG9hdDY0QXJyYXkoMSk7XG4gICAgZW5kVGltZUJ1ZmZlclswXSA9IGVuZFRpbWU7XG5cbiAgICB2YXIgcGF5bG9hZCA9IG5ldyBVaW50MTZBcnJheSgxICsgNCk7XG4gICAgcGF5bG9hZC5zZXQob3Bjb2RlLCAwKTtcbiAgICBwYXlsb2FkLnNldChuZXcgVWludDE2QXJyYXkoZW5kVGltZUJ1ZmZlci5idWZmZXIpLCAxKTtcblxuICAgIHJldHVybiBwYXlsb2FkLmJ1ZmZlcjtcbiAgfSxcbiAgLy8gYG9wY29kZWAgICAgMiBieXRlcyAoVWludDE2KSB8XG4gIC8vIGB0aW1lYCAgICAgIDggYnl0ZXMgKEZsb2F0NjQpIHxcbiAgLy8gYGRhdGFgICAgICAgZnJhbWVTaXplICogNCAoRmxvYXQzMikgfFxuICAvLyBgbWV0YWRhdGFgICBuIGJ5dGVzIChVaW50MTYpXG4gIHByb2Nlc3NGcmFtZTogZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lKGZyYW1lLCBmcmFtZVNpemUpIHtcbiAgICB2YXIgb3Bjb2RlID0gZW5jb2RlcnMub3Bjb2RlKCdQUk9DRVNTX0ZSQU1FJyk7XG5cbiAgICB2YXIgdGltZSA9IG5ldyBGbG9hdDY0QXJyYXkoMSk7XG4gICAgdGltZVswXSA9IGZyYW1lLnRpbWU7XG5cbiAgICB2YXIgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZnJhbWVTaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gZnJhbWUuZGF0YVtpXTtcbiAgICB9dmFyIG1ldGFkYXRhID0ganNvbjJVaW50MTZBcnJheShmcmFtZS5tZXRhZGF0YSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gMSArIDQgKyAyICogZnJhbWVTaXplICsgbWV0YWRhdGEubGVuZ3RoO1xuICAgIHZhciBwYXlsb2FkID0gbmV3IFVpbnQxNkFycmF5KGxlbmd0aCk7XG4gICAgcGF5bG9hZC5zZXQob3Bjb2RlLCAwKTtcbiAgICBwYXlsb2FkLnNldChuZXcgVWludDE2QXJyYXkodGltZS5idWZmZXIpLCAxKTtcbiAgICBwYXlsb2FkLnNldChuZXcgVWludDE2QXJyYXkoZGF0YS5idWZmZXIpLCAxICsgNCk7XG4gICAgcGF5bG9hZC5zZXQobWV0YWRhdGEsIDEgKyA0ICsgMiAqIGZyYW1lU2l6ZSk7XG5cbiAgICByZXR1cm4gcGF5bG9hZC5idWZmZXI7XG4gIH1cbn07XG5cbnZhciBkZWNvZGVycyA9IGV4cG9ydHMuZGVjb2RlcnMgPSB7XG4gIG9wY29kZTogZnVuY3Rpb24gb3Bjb2RlKGFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShhcnJheUJ1ZmZlcilbMF07XG4gIH0sXG5cbiAgLy8gYG9wY29kZWAgICAgMiBieXRlcyAoVWludDE2KSB8XG4gIC8vIGBzdHJlYW1QYXJhbXNgICBuIGJ5dGVzIChVaW50MTYpXG4gIHN0cmVhbVBhcmFtczogZnVuY3Rpb24gc3RyZWFtUGFyYW1zKGFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHBheWxvYWQgPSBuZXcgVWludDE2QXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoMikpO1xuICAgIHZhciBwcmV2U3RyZWFtUGFyYW1zID0gVWludDE2QXJyYXkyanNvbihwYXlsb2FkKTtcbiAgICByZXR1cm4gcHJldlN0cmVhbVBhcmFtcztcbiAgfSxcblxuICAvLyBgb3Bjb2RlYCAgICAyIGJ5dGVzIChVaW50MTYpIHxcbiAgLy8gYGVuZFRpbWVgICAgOCBieXRlcyAoRmxvYXQ2NClcbiAgZmluYWxpemVTdHJlYW06IGZ1bmN0aW9uIGZpbmFsaXplU3RyZWFtKGFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoMikpWzBdO1xuICB9LFxuXG4gIC8vIGBvcGNvZGVgICAgIDIgYnl0ZXMgKFVpbnQxNikgfFxuICAvLyBgdGltZWAgICAgICA4IGJ5dGVzIChGbG9hdDY0KSB8XG4gIC8vIGBkYXRhYCAgICAgIGZyYW1lU2l6ZSAqIDQgKEZsb2F0MzIpIHxcbiAgLy8gYG1ldGFkYXRhYCAgbiBieXRlcyAoVWludDE2KVxuICBwcm9jZXNzRnJhbWU6IGZ1bmN0aW9uIHByb2Nlc3NGcmFtZShhcnJheUJ1ZmZlciwgZnJhbWVTaXplKSB7XG4gICAgLy8gMSAqIDggYnl0ZXNcbiAgICB2YXIgdGltZVN0YXJ0ID0gMjtcbiAgICB2YXIgdGltZUVuZCA9IHRpbWVTdGFydCArIDg7XG4gICAgdmFyIHRpbWUgPSBuZXcgRmxvYXQ2NEFycmF5KGFycmF5QnVmZmVyLnNsaWNlKHRpbWVTdGFydCwgdGltZUVuZCkpWzBdO1xuICAgIC8vIGZyYW1lU2l6ZSAqIDQgYnl0ZXNcbiAgICB2YXIgZGF0YVN0YXJ0ID0gdGltZUVuZDtcbiAgICB2YXIgZGF0YUVuZCA9IGRhdGFTdGFydCArIDQgKiBmcmFtZVNpemU7XG4gICAgdmFyIGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmZmVyLnNsaWNlKGRhdGFTdGFydCwgZGF0YUVuZCkpO1xuICAgIC8vIHJlc3Qgb2YgcGF5bG9hZFxuICAgIHZhciBtZXRhU3RhcnQgPSBkYXRhRW5kO1xuICAgIHZhciBtZXRhQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGFycmF5QnVmZmVyLnNsaWNlKG1ldGFTdGFydCkpO1xuICAgIHZhciBtZXRhZGF0YSA9IFVpbnQxNkFycmF5Mmpzb24obWV0YUJ1ZmZlcik7XG5cbiAgICByZXR1cm4geyB0aW1lOiB0aW1lLCBkYXRhOiBkYXRhLCBtZXRhZGF0YTogbWV0YWRhdGEgfTtcbiAgfVxufTtcblxufSx7XCJiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnlcIjozfV0sMTgyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbicpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZScpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3BhcmFtZXRlcnMgPSByZXF1aXJlKCdAaXJjYW0vcGFyYW1ldGVycycpO1xuXG52YXIgX3BhcmFtZXRlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyYW1ldGVycyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpZCA9IDA7XG5cbi8qKlxuICogQmFzZSBgbGZvYCBjbGFzcyB0byBiZSBleHRlbmRlZCBpbiBvcmRlciB0byBjcmVhdGUgbmV3IG5vZGVzLlxuICpcbiAqIE5vZGVzIGFyZSBkaXZpZGVkIGluIDMgY2F0ZWdvcmllczpcbiAqIC0gKipgc291cmNlYCoqIGFyZSByZXNwb25zaWJsZSBmb3IgYWNxdWVyaW5nIGEgc2lnbmFsIGFuZCBpdHMgcHJvcGVydGllc1xuICogICAoZnJhbWVSYXRlLCBmcmFtZVNpemUsIGV0Yy4pXG4gKiAtICoqYHNpbmtgKiogYXJlIGVuZHBvaW50cyBvZiB0aGUgZ3JhcGgsIHN1Y2ggbm9kZXMgY2FuIGJlIHJlY29yZGVycyxcbiAqICAgdmlzdWFsaXplcnMsIGV0Yy5cbiAqIC0gKipgb3BlcmF0b3JgKiogYXJlIHVzZWQgdG8gbWFrZSBjb21wdXRhdGlvbiBvbiB0aGUgaW5wdXQgc2lnbmFsIGFuZFxuICogICBmb3J3YXJkIHRoZSByZXN1bHRzIGJlbG93IGluIHRoZSBncmFwaC5cbiAqXG4gKiBJbiBtb3N0IGNhc2VzIHRoZSBtZXRob2RzIHRvIG92ZXJyaWRlIC8gZXh0ZW5kIGFyZTpcbiAqIC0gdGhlICoqYGNvbnN0cnVjdG9yYCoqIHRvIGRlZmluZSB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbmV3IGxmbyBub2RlLlxuICogLSB0aGUgKipgcHJvY2Vzc1N0cmVhbVBhcmFtc2AqKiBtZXRob2QgdG8gZGVmaW5lIGhvdyB0aGUgbm9kZSBtb2RpZnkgdGhlXG4gKiAgIHN0cmVhbSBhdHRyaWJ1dGVzIChlLmcuIGJ5IGNoYW5naW5nIHRoZSBmcmFtZSBzaXplKVxuICogLSB0aGUgKipgcHJvY2Vzc3tGcmFtZVR5cGV9YCoqIG1ldGhvZCB0byBkZWZpbmUgdGhlIG9wZXJhdGlvbnMgdGhhdCB0aGVcbiAqICAgbm9kZSBhcHBseSBvbiB0aGUgc3RyZWFtLiBUaGUgdHlwZSBvZiBpbnB1dCBhIG5vZGUgY2FuIGhhbmRsZSBpcyBkZWZpbmVkXG4gKiAgIGJ5IGl0cyBpbXBsZW1lbnRlZCBpbnRlcmZhY2UsIGlmIGl0IGltcGxlbWVudHMgYHByb2Nlc3NTaWduYWxgLCBhIHN0cmVhbVxuICogICBvZiB0eXBlIGBzaWduYWxgIGNhbiBiZSBwcm9jZXNzZWQsIGBwcm9jZXNzVmVjdG9yYCB0byBoYW5kbGVcbiAqICAgYW4gaW5wdXQgb2YgdHlwZSBgdmVjdG9yYC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5fVGhpcyBjbGFzcyBzaG91bGQgYmUgY29uc2lkZXJlZCBhYnN0cmFjdCBhbmQgb25seVxuICogYmUgdXNlZCBhcyBhIGJhc2UgY2xhc3MgdG8gZXh0ZW5kLl88L3NwYW4+XG4gKlxuICogIyMjIyBvdmVydmlldyBvZiB0aGUgaW50ZXJmYWNlXG4gKlxuICogKippbml0TW9kdWxlKipcbiAqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG1vZHVsZSBpcyBpbml0aWFsaXplZC4gSXNcbiAqIGVzcGVjaWFsbHkgaW1wb3J0YW50IGZvciBtb2R1bGVzIHRoYXQgcmVseSBvbiBhc3luY2hyb25vdXMgdW5kZXJseWluZyBBUElzLlxuICpcbiAqICoqcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSoqXG4gKlxuICogYGJhc2VgIGNsYXNzIChkZWZhdWx0IGltcGxlbWVudGF0aW9uKVxuICogLSBjYWxsIGBwcmVwYXJlU3RyZWFtUGFyYW1zYFxuICogLSBjYWxsIGBwcm9wYWdhdGVTdHJlYW1QYXJhbXNgXG4gKlxuICogYGNoaWxkYCBjbGFzc1xuICogLSBvdmVycmlkZSBzb21lIG9mIHRoZSBpbmhlcml0ZWQgYHN0cmVhbVBhcmFtc2BcbiAqIC0gY3JlYXRlcyB0aGUgYW55IHJlbGF0ZWQgbG9naWMgYnVmZmVyc1xuICogLSBjYWxsIGBwcm9wYWdhdGVTdHJlYW1QYXJhbXNgXG4gKlxuICogX3Nob3VsZCBub3QgY2FsbCBgc3VwZXIucHJvY2Vzc1N0cmVhbVBhcmFtc2BfXG4gKlxuICogKipwcmVwYXJlU3RyZWFtUGFyYW1zKCkqKlxuICpcbiAqIC0gYXNzaWduIHByZXZTdHJlYW1QYXJhbXMgdG8gdGhpcy5zdHJlYW1QYXJhbXNcbiAqIC0gY2hlY2sgaWYgdGhlIGNsYXNzIGltcGxlbWVudHMgdGhlIGNvcnJlY3QgYHByb2Nlc3NJbnB1dGAgbWV0aG9kXG4gKlxuICogX3Nob3VsZG4ndCBiZSBleHRlbmRlZCwgb25seSBjb25zdW1lZCBpbiBgcHJvY2Vzc1N0cmVhbVBhcmFtc2BfXG4gKlxuICogKipwcm9wYWdhdGVTdHJlYW1QYXJhbXMoKSoqXG4gKlxuICogLSBjcmVhdGVzIHRoZSBgZnJhbWVEYXRhYCBidWZmZXJcbiAqIC0gcHJvcGFnYXRlIGBzdHJlYW1QYXJhbXNgIHRvIGNoaWxkcmVuXG4gKlxuICogX3Nob3VsZG4ndCBiZSBleHRlbmRlZCwgb25seSBjb25zdW1lZCBpbiBgcHJvY2Vzc1N0cmVhbVBhcmFtc2BfXG4gKlxuICogKipwcm9jZXNzRnJhbWUoKSoqXG4gKlxuICogYGJhc2VgIGNsYXNzIChkZWZhdWx0IGltcGxlbWVudGF0aW9uKVxuICogLSBjYWxsIGBwcmVwYXJlRnJhbWVgXG4gKiAtIGFzc2lnbiBmcmFtZVRpbWUgYW5kIGZyYW1lTWV0YWRhdGEgdG8gaWRlbnRpdHlcbiAqIC0gY2FsbCB0aGUgcHJvcGVyIGZ1bmN0aW9uIGFjY29yZGluZyB0byBpbnB1dFR5cGVcbiAqIC0gY2FsbCBgcHJvcGFnYXRlRnJhbWVgXG4gKlxuICogYGNoaWxkYCBjbGFzc1xuICogLSBjYWxsIGBwcmVwYXJlRnJhbWVgXG4gKiAtIGRvIHdoYXRldmVyIHlvdSB3YW50IHdpdGggaW5jb21taW5nIGZyYW1lXG4gKiAtIGNhbGwgYHByb3BhZ2F0ZUZyYW1lYFxuICpcbiAqIF9zaG91bGQgbm90IGNhbGwgYHN1cGVyLnByb2Nlc3NGcmFtZWBfXG4gKlxuICogKipwcmVwYXJlRnJhbWUoKSoqXG4gKlxuICogLSBpZiBgcmVpbml0YCBhbmQgdHJpZ2dlciBgcHJvY2Vzc1N0cmVhbVBhcmFtc2AgaWYgbmVlZGVkXG4gKlxuICogX3Nob3VsZG4ndCBiZSBleHRlbmRlZCwgb25seSBjb25zdW1lZCBpbiBgcHJvY2Vzc0ZyYW1lYF9cbiAqXG4gKiAqKnByb3BhZ2F0ZUZyYW1lKCkqKlxuICpcbiAqIC0gcHJvcGFnYXRlIGZyYW1lIHRvIGNoaWxkcmVuXG4gKlxuICogX3Nob3VsZG4ndCBiZSBleHRlbmRlZCwgb25seSBjb25zdW1lZCBpbiBgcHJvY2Vzc0ZyYW1lYF9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmVcbiAqL1xuXG52YXIgQmFzZUxmbyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUxmbygpIHtcbiAgICB2YXIgZGVmaW5pdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBCYXNlTGZvKTtcblxuICAgIHRoaXMuY2lkID0gaWQrKztcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlciBiYWcgY29udGFpbmluZyBwYXJhbWV0ZXIgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbmFtZSBwYXJhbXNcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQmFzZUxmb1xuICAgICAqL1xuICAgIHRoaXMucGFyYW1zID0gKDAsIF9wYXJhbWV0ZXJzMi5kZWZhdWx0KShkZWZpbml0aW9ucywgb3B0aW9ucyk7XG4gICAgLy8gbGlzdGVuIGZvciBwYXJhbSB1cGRhdGVzXG4gICAgdGhpcy5wYXJhbXMuYWRkTGlzdGVuZXIodGhpcy5vblBhcmFtVXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb24gb2YgdGhlIHN0cmVhbSBvdXRwdXQgb2YgdGhlIG5vZGUuXG4gICAgICogU2V0IHRvIGBudWxsYCB3aGVuIHRoZSBub2RlIGlzIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyYW1lU2l6ZSAtIEZyYW1lIHNpemUgYXQgdGhlIG91dHB1dCBvZiB0aGUgbm9kZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJhbWVSYXRlIC0gRnJhbWUgcmF0ZSBhdCB0aGUgb3V0cHV0IG9mIHRoZSBub2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmcmFtZVR5cGUgLSBGcmFtZSB0eXBlIGF0IHRoZSBvdXRwdXQgb2YgdGhlIG5vZGUsXG4gICAgICogIHBvc3NpYmxlIHZhbHVlcyBhcmUgYHNpZ25hbGAsIGB2ZWN0b3JgIG9yIGBzY2FsYXJgLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl8U3RyaW5nfSBkZXNjcmlwdGlvbiAtIElmIHR5cGUgaXMgYHZlY3RvcmAsIGRlc2NyaWJlXG4gICAgICogIHRoZSBkaW1lbnNpb24ocykgb2Ygb3V0cHV0IHN0cmVhbS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc291cmNlU2FtcGxlUmF0ZSAtIFNhbXBsZSByYXRlIG9mIHRoZSBzb3VyY2Ugb2YgdGhlXG4gICAgICogIGdyYXBoLiBfVGhlIHZhbHVlIHNob3VsZCBiZSBkZWZpbmVkIGJ5IHNvdXJjZXMgYW5kIG5ldmVyIG1vZGlmaWVkXy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc291cmNlU2FtcGxlQ291bnQgLSBOdW1iZXIgb2YgY29uc2VjdXRpdmUgZGlzY3JldGVcbiAgICAgKiAgdGltZSB2YWx1ZXMgY29udGFpbmVkIGluIHRoZSBkYXRhIGZyYW1lIG91dHB1dCBieSB0aGUgc291cmNlLlxuICAgICAqICBfVGhlIHZhbHVlIHNob3VsZCBiZSBkZWZpbmVkIGJ5IHNvdXJjZXMgYW5kIG5ldmVyIG1vZGlmaWVkXy5cbiAgICAgKlxuICAgICAqIEBuYW1lIHN0cmVhbVBhcmFtc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5CYXNlTGZvXG4gICAgICovXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMgPSB7XG4gICAgICBmcmFtZVR5cGU6IG51bGwsXG4gICAgICBmcmFtZVNpemU6IDEsXG4gICAgICBmcmFtZVJhdGU6IDAsXG4gICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgIHNvdXJjZVNhbXBsZVJhdGU6IDAsXG4gICAgICBzb3VyY2VTYW1wbGVDb3VudDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGZyYW1lLiBUaGlzIG9iamVjdCBhbmQgaXRzIGRhdGEgYXJlIHVwZGF0ZWQgYXQgZWFjaCBpbmNvbW1pbmdcbiAgICAgKiBmcmFtZSB3aXRob3V0IHJlYWxsb2NhdGluZyBtZW1vcnkuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBuYW1lIGZyYW1lXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWUgLSBUaW1lIG9mIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBkYXRhIC0gRGF0YSBvZiB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gbWV0YWRhdGEgLSBNZXRhZGF0YSBhc3NvY2l0ZWQgdG8gdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkJhc2VMZm9cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lID0ge1xuICAgICAgdGltZTogMCxcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBtZXRhZGF0YToge31cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBub2RlcyBjb25uZWN0ZWQgdG8gdGhlIG91cHV0IG9mIHRoZSBub2RlIChsb3dlciBpbiB0aGUgZ3JhcGgpLlxuICAgICAqIEF0IGVhY2ggZnJhbWUsIHRoZSBub2RlIGZvcndhcmQgaXRzIGBmcmFtZWAgdG8gdG8gYWxsIGl0cyBgbmV4dE1vZHVsZXNgLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PEJhc2VMZm8+fVxuICAgICAqIEBuYW1lIG5leHRNb2R1bGVzXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkJhc2VMZm9cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI2Nvbm5lY3R9XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNkaXNjb25uZWN0fVxuICAgICAqL1xuICAgIHRoaXMubmV4dE1vZHVsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlIGZyb20gd2hpY2ggdGhlIG5vZGUgcmVjZWl2ZSB0aGUgZnJhbWVzICh1cHBlciBpbiB0aGUgZ3JhcGgpLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jhc2VMZm99XG4gICAgICogQG5hbWUgcHJldk1vZHVsZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5CYXNlTGZvXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNjb25uZWN0fVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jZGlzY29ubmVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZNb2R1bGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSXMgc2V0IHRvIHRydWUgd2hlbiBhIHN0YXRpYyBwYXJhbWV0ZXIgaXMgdXBkYXRlZC4gT24gdGhlIG5leHQgaW5wdXRcbiAgICAgKiBmcmFtZSBhbGwgdGhlIHN1YmdyYXBoIHN0cmVhbVBhcmFtcyBzdGFydGluZyBmcm9tIHRoaXMgbm9kZSB3aWxsIGJlXG4gICAgICogdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBuYW1lIF9yZWluaXRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQmFzZUxmb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVpbml0ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgZGVzY3JpYmluZyBlYWNoIGF2YWlsYWJsZSBwYXJhbWV0ZXIgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShCYXNlTGZvLCBbe1xuICAgIGtleTogJ2dldFBhcmFtc0Rlc2NyaXB0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyYW1zRGVzY3JpcHRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMuZ2V0RGVmaW5pdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBhbGwgcGFyYW1ldGVycyB0byB0aGVpciBpbml0aWFsIHZhbHVlIChhcyBkZWZpbmVkIG9uIGluc3RhbnRpY2F0aW9uKVxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNzdHJlYW1QYXJhbXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0UGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRQYXJhbXMoKSB7XG4gICAgICB0aGlzLnBhcmFtcy5yZXNldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgcGFyYW0gaXMgdXBkYXRlZC4gQnkgZGVmYXVsdCBzZXQgdGhlIGBfcmVpbml0YFxuICAgICAqIGZsYWcgdG8gYHRydWVgIGlmIHRoZSBwYXJhbSBpcyBgc3RhdGljYCBvbmUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxuICAgICAqIGV4dGVuZGVkIHRvIGhhbmRsZSBwYXJ0aWN1bGFyIGxvZ2ljIGJvdW5kIHRvIGEgc3BlY2lmaWMgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBWYWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhcyAtIE1ldGFkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIHBhcmFtZXRlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25QYXJhbVVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBtZXRhcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGlmIChtZXRhcy5raW5kID09PSAnc3RhdGljJykgdGhpcy5fcmVpbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRoZSBjdXJyZW50IG5vZGUgKGBwcmV2TW9kdWxlYCkgdG8gYW5vdGhlciBub2RlIChgbmV4dE9wYCkuXG4gICAgICogQSBnaXZlbiBub2RlIGNhbiBiZSBjb25uZWN0ZWQgdG8gc2V2ZXJhbCBvcGVyYXRvcnMgYW5kIHByb3BhZ2F0ZSBmcmFtZXNcbiAgICAgKiB0byBlYWNoIG9mIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jhc2VMZm99IG5leHQgLSBOZXh0IG9wZXJhdG9yIGluIHRoZSBncmFwaC5cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NGcmFtZX1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI2Rpc2Nvbm5lY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Nvbm5lY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KG5leHQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnN0cmVhbVBhcmFtcyA9PT0gbnVsbCB8fCBuZXh0LnN0cmVhbVBhcmFtcyA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbm5lY3Rpb246IGNhbm5vdCBjb25uZWN0IGEgZGVhZCBub2RlJyk7XG5cbiAgICAgIGlmICh0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gZ3JhcGggaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkXG4gICAgICAgIC8vIG5leHQucHJvY2Vzc1N0cmVhbVBhcmFtcyh0aGlzLnN0cmVhbVBhcmFtcyk7XG4gICAgICAgIG5leHQuaW5pdE1vZHVsZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG5leHQucHJvY2Vzc1N0cmVhbVBhcmFtcyhfdGhpcy5zdHJlYW1QYXJhbXMpO1xuICAgICAgICAgIC8vIHdlIGNhbiBmb3J3YXJkIGZyYW1lIGZyb20gbm93XG4gICAgICAgICAgX3RoaXMubmV4dE1vZHVsZXMucHVzaChuZXh0KTtcbiAgICAgICAgICBuZXh0LnByZXZNb2R1bGUgPSBfdGhpcztcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5leHRNb2R1bGVzLnB1c2gobmV4dCk7XG4gICAgICAgIG5leHQucHJldk1vZHVsZSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBnaXZlbiBvcGVyYXRvciBmcm9tIGl0cyBwcmV2aW91cyBvcGVyYXRvcnMnIGBuZXh0TW9kdWxlc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jhc2VMZm99IFtuZXh0PW51bGxdIC0gVGhlIG9wZXJhdG9yIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudFxuICAgICAqICBvcGVyYXRvci4gSWYgYG51bGxgIGRpc2Nvbm5lY3QgYWxsIHRoZSBuZXh0IG9wZXJhdG9ycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzY29ubmVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG5leHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubmV4dE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuZGlzY29ubmVjdChuZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm5leHRNb2R1bGVzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHRoaXMubmV4dE1vZHVsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgbmV4dC5wcmV2TW9kdWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFsbCB0aGUgbm9kZXMgaW4gdGhlIHN1Yi1ncmFwaCBzdGFydGluZyBmcm9tIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICogV2hlbiBkZXRyb3llZCwgdGhlIGBzdHJlYW1QYXJhbXNgIG9mIHRoZSBub2RlIGFyZSBzZXQgdG8gYG51bGxgLCB0aGVcbiAgICAgKiBvcGVyYXRvciBpcyB0aGVuIGNvbnNpZGVyZWQgYXMgYGRlYWRgIGFuZCBjYW5ub3QgYmUgcmVjb25uZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI2Nvbm5lY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgLy8gZGVzdHJveSBhbGwgY2hpZHJlblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5uZXh0TW9kdWxlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHRoaXMubmV4dE1vZHVsZXNbaW5kZXhdLmRlc3Ryb3koKTtcbiAgICAgIH0gLy8gZGlzY29ubmVjdCBpdHNlbGYgZnJvbSB0aGUgcHJldmlvdXMgb3BlcmF0b3JcbiAgICAgIGlmICh0aGlzLnByZXZNb2R1bGUpIHRoaXMucHJldk1vZHVsZS5kaXNjb25uZWN0KHRoaXMpO1xuXG4gICAgICAvLyBtYXJrIHRoZSBvYmplY3QgYXMgZGVhZFxuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmUgd2hlbiB0aGUgbW9kdWxlIGlzIHJlYWR5IHRvIGJlIGNvbnN1bWVkLlxuICAgICAqIFNvbWUgbW9kdWxlcyByZWxpZXMgb24gYXN5bmNocm9ub3VzIEFQSXMgYXQgaW5pdGlhbGl6YXRpb24gYW5kIHRodXMgY291bGRcbiAgICAgKiBiZSBub3QgcmVhZHkgdG8gYmUgY29uc3VtZWQgd2hlbiB0aGUgZ3JhcGggc3RhcnRzLlxuICAgICAqIEEgbW9kdWxlIHNob3VsZCBiZSBjb25zaWRlciBhcyBpbml0aWFsaXplZCB3aGVuIGFsbCBuZXh0IG1vZHVsZXMgKGNoaWxkcmVuKVxuICAgICAqIGFyZSB0aGVtc2VsdmVzIGluaXRpYWxpemVkLiBUaGUgZXZlbnQgYnViYmxlcyB1cCBmcm9tIHNpbmtzIHRvIHNvdXJjZXMuXG4gICAgICogV2hlbiBhbGwgaXRzIG5leHQgb3BlcmF0b3JzIGFyZSByZWFkeSwgYSBzb3VyY2UgY2FuIGNvbnNpZGVyIHRoZSB3aG9sZSBncmFwaFxuICAgICAqIGFzIHJlYWR5IGFuZCB0aGVuIHN0YXJ0IHRvIHByb2R1Y2UgZnJhbWVzLlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJlc29sdmVzIHdoZW4gYWxsIG5leHQgb3BlcmF0b3JzIGFyZSByZXNvbHZlZFxuICAgICAqIHRoZW1zZWx2ZXMuXG4gICAgICogQW4gb3BlcmF0b3IgcmVseWluZyBvbiBleHRlcm5hbCBhc3luYyBBUEkgbXVzdCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0b1xuICAgICAqIHJlc29sdmUgb25seSB3aGVuIGl0cyBkZXBlbmRlY3kgaXMgcmVhZHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFByb21pc2VcbiAgICAgKiBAdG9kbyAtIEhhbmRsZSBkeW5hbWljIGNvbm5lY3Rpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0TW9kdWxlKCkge1xuICAgICAgdmFyIG5leHRQcm9taXNlcyA9IHRoaXMubmV4dE1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5pbml0TW9kdWxlKCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF9wcm9taXNlMi5kZWZhdWx0LmFsbChuZXh0UHJvbWlzZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byBpbml0aWFsaXplIHRoZSBzdHJlYW0gaW4gc3RhbmRhbG9uZSBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHJlYW1QYXJhbXM9e31dIC0gUGFyYW1ldGVycyBvZiB0aGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzU3RyZWFtUGFyYW1zfVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcmVzZXRTdHJlYW19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRTdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0U3RyZWFtKCkge1xuICAgICAgdmFyIHN0cmVhbVBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHRoaXMucHJvY2Vzc1N0cmVhbVBhcmFtcyhzdHJlYW1QYXJhbXMpO1xuICAgICAgdGhpcy5yZXNldFN0cmVhbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBgZnJhbWUuZGF0YWAgYnVmZmVyIGJ5IHNldHRpbmcgYWxsIGl0cyB2YWx1ZXMgdG8gMC5cbiAgICAgKiBBIHNvdXJjZSBvcGVyYXRvciBzaG91bGQgY2FsbCBgcHJvY2Vzc1N0cmVhbVBhcmFtc2AgYW5kIGByZXNldFN0cmVhbWAgd2hlblxuICAgICAqIHN0YXJ0ZWQsIGVhY2ggb2YgdGhlc2UgbWV0aG9kIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSBncmFwaCBhdXRvbWF0aWNhbHkuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NTdHJlYW1QYXJhbXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0U3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTdHJlYW0oKSB7XG4gICAgICAvLyBidXR0b20gdXBcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5uZXh0TW9kdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5uZXh0TW9kdWxlc1tpXS5yZXNldFN0cmVhbSgpO1xuICAgICAgfSAvLyBubyBidWZmZXIgZm9yIGBzY2FsYXJgIHR5cGUgb3Igc2luayBub2RlXG4gICAgICAvLyBAbm90ZSAtIHRoaXMgc2hvdWxkIGJlIHJldmlld2VkXG4gICAgICBpZiAodGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlICE9PSAnc2NhbGFyJyAmJiB0aGlzLmZyYW1lLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZyYW1lU2l6ZTsgX2krKykge1xuICAgICAgICAgIGRhdGFbX2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmFsaXplIHRoZSBzdHJlYW0uIEEgc291cmNlIG5vZGUgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2Qgd2hlbiBzdG9wcGVkLFxuICAgICAqIGBmaW5hbGl6ZVN0cmVhbWAgaXMgYXV0b21hdGljYWxseSBwcm9wYWdhdGVkIHRocm91Z2h0IHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRUaW1lIC0gTG9naWNhbCB0aW1lIGF0IHdoaWNoIHRoZSBncmFwaCBpcyBzdG9wcGVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmaW5hbGl6ZVN0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplU3RyZWFtKGVuZFRpbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5uZXh0TW9kdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5uZXh0TW9kdWxlc1tpXS5maW5hbGl6ZVN0cmVhbShlbmRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIG9yIHVwZGF0ZSB0aGUgb3BlcmF0b3IncyBgc3RyZWFtUGFyYW1zYCBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICogcHJldmlvdXMgb3BlcmF0b3JzIGBzdHJlYW1QYXJhbXNgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFdoZW4gaW1wbGVtZW50aW5nIGEgbmV3IG9wZXJhdG9yIHRoaXMgbWV0aG9kIHNob3VsZDpcbiAgICAgKiAxLiBjYWxsIGB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXNgIHdpdGggdGhlIGdpdmVuIGBwcmV2U3RyZWFtUGFyYW1zYFxuICAgICAqIDIuIG9wdGlvbm5hbGx5IGNoYW5nZSB2YWx1ZXMgdG8gYHRoaXMuc3RyZWFtUGFyYW1zYCBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICogICAgbG9naWMgcGVyZm9ybWVkIGJ5IHRoZSBvcGVyYXRvci5cbiAgICAgKiAzLiBvcHRpb25uYWxseSBhbGxvY2F0ZSBtZW1vcnkgZm9yIHJpbmcgYnVmZmVycywgZXRjLlxuICAgICAqIDQuIGNhbGwgYHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zYCB0byB0cmlnZ2VyIHRoZSBtZXRob2Qgb24gdGhlIG5leHRcbiAgICAgKiAgICBvcGVyYXRvcnMgaW4gdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHJlYW1QYXJhbXMgLSBgc3RyZWFtUGFyYW1zYCBvZiB0aGUgcHJldmlvdXMgb3BlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3ByZXBhcmVTdHJlYW1QYXJhbXN9XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9wYWdhdGVTdHJlYW1QYXJhbXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU3RyZWFtUGFyYW1zKCkge1xuICAgICAgdmFyIHByZXZTdHJlYW1QYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbW1vbiBsb2dpYyB0byBkbyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBgcHJvY2Vzc1N0cmVhbVBhcmFtYCwgbXVzdCBiZVxuICAgICAqIGNhbGxlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFueSBgcHJvY2Vzc1N0cmVhbVBhcmFtYCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgbWFpbmx5IGNoZWNrIGlmIHRoZSBjdXJyZW50IG5vZGUgaW1wbGVtZW50IHRoZSBpbnRlcmZhY2UgdG9cbiAgICAgKiBoYW5kbGUgdGhlIHR5cGUgb2YgZnJhbWUgcHJvcGFnYXRlZCBieSBpdCdzIHBhcmVudDpcbiAgICAgKiAtIHRvIGhhbmRsZSBhIGB2ZWN0b3JgIGZyYW1lIHR5cGUsIHRoZSBjbGFzcyBtdXN0IGltcGxlbWVudCBgcHJvY2Vzc1ZlY3RvcmBcbiAgICAgKiAtIHRvIGhhbmRsZSBhIGBzaWduYWxgIGZyYW1lIHR5cGUsIHRoZSBjbGFzcyBtdXN0IGltcGxlbWVudCBgcHJvY2Vzc1NpZ25hbGBcbiAgICAgKiAtIGluIGNhc2Ugb2YgYSAnc2NhbGFyJyBmcmFtZSB0eXBlLCB0aGUgY2xhc3MgY2FuIGltcGxlbWVudCBhbnkgb2YgdGhlXG4gICAgICogZm9sbG93aW5nIGJ5IG9yZGVyIG9mIHByZWZlcmVuY2U6IGBwcm9jZXNzU2NhbGFyYCwgYHByb2Nlc3NWZWN0b3JgLFxuICAgICAqIGBwcm9jZXNzU2lnbmFsYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3RyZWFtUGFyYW1zIC0gYHN0cmVhbVBhcmFtc2Agb2YgdGhlIHByZXZpb3VzIG9wZXJhdG9yLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzU3RyZWFtUGFyYW1zfVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJvcGFnYXRlU3RyZWFtUGFyYW1zfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcmVwYXJlU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZVN0cmVhbVBhcmFtcygpIHtcbiAgICAgIHZhciBwcmV2U3RyZWFtUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgKDAsIF9hc3NpZ24yLmRlZmF1bHQpKHRoaXMuc3RyZWFtUGFyYW1zLCBwcmV2U3RyZWFtUGFyYW1zKTtcbiAgICAgIHZhciBwcmV2RnJhbWVUeXBlID0gcHJldlN0cmVhbVBhcmFtcy5mcmFtZVR5cGU7XG5cbiAgICAgIHN3aXRjaCAocHJldkZyYW1lVHlwZSkge1xuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NTY2FsYXIpIHRoaXMucHJvY2Vzc0Z1bmN0aW9uID0gdGhpcy5wcm9jZXNzU2NhbGFyO2Vsc2UgaWYgKHRoaXMucHJvY2Vzc1ZlY3RvcikgdGhpcy5wcm9jZXNzRnVuY3Rpb24gPSB0aGlzLnByb2Nlc3NWZWN0b3I7ZWxzZSBpZiAodGhpcy5wcm9jZXNzU2lnbmFsKSB0aGlzLnByb2Nlc3NGdW5jdGlvbiA9IHRoaXMucHJvY2Vzc1NpZ25hbDtlbHNlIHRocm93IG5ldyBFcnJvcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnIC0gbm8gXCJwcm9jZXNzXCIgZnVuY3Rpb24gZm91bmQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVjdG9yJzpcbiAgICAgICAgICBpZiAoISgncHJvY2Vzc1ZlY3RvcicgaW4gdGhpcykpIHRocm93IG5ldyBFcnJvcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnIC0gXCJwcm9jZXNzVmVjdG9yXCIgaXMgbm90IGRlZmluZWQnKTtcblxuICAgICAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uID0gdGhpcy5wcm9jZXNzVmVjdG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaWduYWwnOlxuICAgICAgICAgIGlmICghKCdwcm9jZXNzU2lnbmFsJyBpbiB0aGlzKSkgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgLSBcInByb2Nlc3NTaWduYWxcIiBpcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgICAgICAgdGhpcy5wcm9jZXNzRnVuY3Rpb24gPSB0aGlzLnByb2Nlc3NTaWduYWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gZGVmYXVsdHMgdG8gcHJvY2Vzc0Z1bmN0aW9uXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBgdGhpcy5mcmFtZS5kYXRhYCBidWZmZXIgYW5kIGZvcndhcmQgdGhlIG9wZXJhdG9yJ3MgYHN0cmVhbVBhcmFtYFxuICAgICAqIHRvIGFsbCBpdHMgbmV4dCBvcGVyYXRvcnMsIG11c3QgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW55XG4gICAgICogYHByb2Nlc3NTdHJlYW1QYXJhbXNgIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzU3RyZWFtUGFyYW1zfVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJlcGFyZVN0cmVhbVBhcmFtc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvcGFnYXRlU3RyZWFtUGFyYW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcGFnYXRlU3RyZWFtUGFyYW1zKCkge1xuICAgICAgdGhpcy5mcmFtZS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubmV4dE1vZHVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMubmV4dE1vZHVsZXNbaV0ucHJvY2Vzc1N0cmVhbVBhcmFtcyh0aGlzLnN0cmVhbVBhcmFtcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIHRoZSBwYXJ0aWN1bGFyIGxvZ2ljIHRoZSBvcGVyYXRvciBhcHBsaWVzIHRvIHRoZSBzdHJlYW0uXG4gICAgICogQWNjb3JkaW5nIHRvIHRoZSBmcmFtZSB0eXBlIG9mIHRoZSBwcmV2aW91cyBub2RlLCB0aGUgbWV0aG9kIGNhbGxzIG9uZVxuICAgICAqIG9mIHRoZSBmb2xsb3dpbmcgbWV0aG9kIGBwcm9jZXNzVmVjdG9yYCwgYHByb2Nlc3NTaWduYWxgIG9yIGBwcm9jZXNzU2NhbGFyYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZyYW1lIC0gRnJhbWUgKHRpbWUsIGRhdGEsIGFuZCBtZXRhZGF0YSkgYXMgZ2l2ZW4gYnkgdGhlXG4gICAgICogIHByZXZpb3VzIG9wZXJhdG9yLiBUaGUgaW5jb21taW5nIGZyYW1lIHNob3VsZCBuZXZlciBiZSBtb2RpZmllZCBieVxuICAgICAqICB0aGUgb3BlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3ByZXBhcmVGcmFtZX1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb3BhZ2F0ZUZyYW1lfVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJvY2Vzc1N0cmVhbVBhcmFtc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc0ZyYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgICB0aGlzLnByZXBhcmVGcmFtZSgpO1xuXG4gICAgICAvLyBmcmFtZVRpbWUgYW5kIGZyYW1lTWV0YWRhdGEgZGVmYXVsdHMgdG8gaWRlbnRpdHlcbiAgICAgIHRoaXMuZnJhbWUudGltZSA9IGZyYW1lLnRpbWU7XG4gICAgICB0aGlzLmZyYW1lLm1ldGFkYXRhID0gZnJhbWUubWV0YWRhdGE7XG5cbiAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKTtcbiAgICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2ludGVyIHRvIHRoZSBtZXRob2QgY2FsbGVkIGluIGBwcm9jZXNzRnJhbWVgIGFjY29yZGluZyB0byB0aGVcbiAgICAgKiBmcmFtZSB0eXBlIG9mIHRoZSBwcmV2aW91cyBvcGVyYXRvci4gSXMgZHluYW1pY2FsbHkgYXNzaWduZWQgaW5cbiAgICAgKiBgcHJlcGFyZVN0cmVhbVBhcmFtc2AuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3ByZXBhcmVTdHJlYW1QYXJhbXN9XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzRnJhbWV9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NGdW5jdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGdW5jdGlvbihmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbW1vbiBsb2dpYyB0byBwZXJmb3JtIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGBwcm9jZXNzRnJhbWVgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzRnJhbWV9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ByZXBhcmVGcmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVGcmFtZSgpIHtcbiAgICAgIGlmICh0aGlzLl9yZWluaXQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIHN0cmVhbVBhcmFtcyA9IHRoaXMucHJldk1vZHVsZSAhPT0gbnVsbCA/IHRoaXMucHJldk1vZHVsZS5zdHJlYW1QYXJhbXMgOiB7fTtcbiAgICAgICAgdGhpcy5pbml0U3RyZWFtKHN0cmVhbVBhcmFtcyk7XG4gICAgICAgIHRoaXMuX3JlaW5pdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcndhcmQgdGhlIGN1cnJlbnQgYGZyYW1lYCB0byB0aGUgbmV4dCBvcGVyYXRvcnMsIGlzIGNhbGxlZCBhdCB0aGUgZW5kIG9mXG4gICAgICogYHByb2Nlc3NGcmFtZWAuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NGcmFtZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvcGFnYXRlRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wYWdhdGVGcmFtZSgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5uZXh0TW9kdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5uZXh0TW9kdWxlc1tpXS5wcm9jZXNzRnJhbWUodGhpcy5mcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCYXNlTGZvO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlTGZvO1xuXG59LHtcIkBpcmNhbS9wYXJhbWV0ZXJzXCI6MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCI6NixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCI6MTIsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxNSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjE2fV0sMTgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIik7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEludGVyZmFjZSBhZGRlZCB0byBgTGZvQ29yZSB0byBpbXBsZW1lbnQgc291cmNlXG4gKlxuICogU291cmNlIGhhdmUgc29tZSByZXNwb25zYWJpbGl0eSBvbiBncmFwaCBhcyB0aGV5IG1vc3RseSBjb250cm9sIGl0cyB3aG9sZVxuICogbGlmZWN5Y2xlLiBUaGV5IG11c3QgaW1wbGVtZW50IHRoZSBzdGFydCBhbmQgc3RvcCBtZXRob2QgaW4gb3JkZXIgdG9cbiAqIG1ha2Ugc3VyZSB0aGUgZ3JhcGggaXMgaW5pdGlhbGl6ZWQgYW5kIHNldCBgc3RhcnRlZGAgdG8gdHJ1ZS5cbiAqIEEgc291cmNlIHNob3VsZCBuZXZlciBhY2NlcHQgYW5kIHByb3BhZ2F0ZSBpbmNvbW1pbmcgZnJhbWVzIHVudGlsIGBzdGFydGVkYFxuICogaXMgc2V0IHRvIGB0cnVlYC5cbiAqXG4gKiBAbmFtZSBTb3VyY2VNaXhpblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlXG4gKiBAbWl4aW5cbiAqXG4gKiBAZXhhbXBsZVxuICogY2xhc3MgTXlTb3VyY2UgZXh0ZW5kcyBTb3VyY2VNaXhpbihCYXNlTGZvKSB7fVxuICovXG52YXIgU291cmNlTWl4aW4gPSBmdW5jdGlvbiBTb3VyY2VNaXhpbihzdXBlcmNsYXNzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX3N1cGVyY2xhc3MpIHtcbiAgICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShfY2xhc3MsIF9zdXBlcmNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBfY2xhc3MpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChfcmVmID0gX2NsYXNzLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShfY2xhc3MpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKTtcblxuICAgICAgX3RoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIF90aGlzLmluaXRQcm9taXNlID0gbnVsbDtcbiAgICAgIF90aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgX3RoaXMuc3RhcnQgPSBfdGhpcy5zdGFydC5iaW5kKF90aGlzKTtcbiAgICAgIF90aGlzLnN0b3AgPSBfdGhpcy5zdG9wLmJpbmQoX3RoaXMpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGdyYXBoIGJ5IGNhbGxpbmcgYGluaXRNb2R1bGVgLiBXaGVuIHRoZSByZXR1cm5lZCBgUHJvbWlzZWBcbiAgICAgKiBmdWxmaWxscywgdGhlIGdyYXBoIGNhbiBiZSBjb25zaWRlcmVkIGFzIGluaXRpYWxpemVkIGFuZCBgc3RhcnRgIGNhbiBiZVxuICAgICAqIGNhbGxlZCBzYWZlbHkuIElmIGBzdGFydGAgaXMgY2FsbGVkIHdoaXRob3V0IGV4cGxpY2l0IGBpbml0YCwgYGluaXRgIGlzXG4gICAgICogbWFkZSBpbnRlcm5hbGx5LCBhY3R1YWwgc3RhcnQgb2YgdGhlIGdyYXBoIGlzIHRoZW4gbm90IGdhcmFudGVlZCB0byBiZVxuICAgICAqIHN5bmNocm9ub3VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLlNvdXJjZU1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG5hbWUgaW5pdFxuICAgICAqXG4gICAgICogQHJldHVybiBQcm9taXNlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHNhZmUgaW5pdGlhbGl6YXRpb24gYW5kIHN0YXJ0XG4gICAgICogc291cmNlLmluaXQoKS50aGVuKCgpID0+IHNvdXJjZS5zdGFydCgpKVxuICAgICAqIC8vIHNhZmUgaW5pdGlhbGl6YXRpb24gYW5kIHN0YXJ0XG4gICAgICogc291cmNlLnN0YXJ0KCk7XG4gICAgICovXG5cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKF9jbGFzcywgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IHRoaXMuaW5pdE1vZHVsZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5pbml0U3RyZWFtKCk7IC8vIHRoaXMgaXMgc3luY2hyb25vdXNcbiAgICAgICAgICBfdGhpczIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbnRlcmZhY2UgbWV0aG9kIHRvIGltcGxlbWVudCB0aGF0IHN0YXJ0cyB0aGUgZ3JhcGguXG4gICAgICAgKlxuICAgICAgICogVGhlIG1ldGhvZCBtYWluIHB1cnBvc2UgaXMgdG8gbWFrZSBzdXJlIHRha2UgdmVyaWZ5IGluaXRpYWxpemF0aW9uIHN0ZXAgYW5kXG4gICAgICAgKiBzZXQgYHN0YXJ0ZWRgIHRvIGB0cnVlYCB3aGVuIGRvbmUuXG4gICAgICAgKiBTaG91bGQgYmVoYXZlIHN5bmNocm9ub3VzbHkgd2hlbiBjYWxsZWQgaW5zaWRlIGBpbml0KCkudGhlbigpYCBhbmQgYXN5bmNcbiAgICAgICAqIGlmIGNhbGxlZCB3aXRob3V0IGluaXQgc3RlcC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuU291cmNlTWl4aW5cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG5hbWUgc3RhcnRcbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogLy8gYmFzaWMgYHN0YXJ0YCBpbXBsZW1lbnRhdGlvblxuICAgICAgICogc3RhcnQoKSB7XG4gICAgICAgKiAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSBmYWxzZSkge1xuICAgICAgICogICAgIGlmICh0aGlzLmluaXRQcm9taXNlID09PSBudWxsKSAvLyBpbml0IGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkXG4gICAgICAgKiAgICAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0KCk7XG4gICAgICAgKlxuICAgICAgICogICAgIHRoaXMuaW5pdFByb21pc2UudGhlbih0aGlzLnN0YXJ0KTtcbiAgICAgICAqICAgICByZXR1cm47XG4gICAgICAgKiAgIH1cbiAgICAgICAqXG4gICAgICAgKiAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgKiB9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cblxuICAgICAgLyoqXG4gICAgICAgKiBJbnRlcmZhY2UgbWV0aG9kIHRvIGltcGxlbWVudCB0aGF0IHN0b3BzIHRoZSBncmFwaC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuU291cmNlTWl4aW5cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG5hbWUgc3RvcFxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAvLyBiYXNpYyBgc3RvcGAgaW1wbGVtZW50YXRpb25cbiAgICAgICAqIHN0b3AoKSB7XG4gICAgICAgKiAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICogfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RvcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgbmV2ZXIgYWxsb3cgaW5jb21taW5nIGZyYW1lc1xuICAgICAgICogaWYgYHRoaXMuc3RhcnRlZGAgaXMgbm90IGB0cnVlYC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuU291cmNlTWl4aW5cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG5hbWUgcHJvY2Vzc0ZyYW1lXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZyYW1lXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIC8vIGJhc2ljIGBwcm9jZXNzRnJhbWVgIGltcGxlbWVudGF0aW9uXG4gICAgICAgKiBwcm9jZXNzRnJhbWUoZnJhbWUpIHtcbiAgICAgICAqICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICogICAgIHRoaXMucHJlcGFyZUZyYW1lKCk7XG4gICAgICAgKiAgICAgdGhpcy5wcm9jZXNzRnVuY3Rpb24oZnJhbWUpO1xuICAgICAgICogICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgICAgICAqICAgfVxuICAgICAgICogfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc0ZyYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7fVxuICAgIH1dKTtcbiAgICByZXR1cm4gX2NsYXNzO1xuICB9KHN1cGVyY2xhc3MpO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU291cmNlTWl4aW47XG5cbn0se1wiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6MTAsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiOjEyLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTUsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxNixcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjE5LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoyMH1dLDE4NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQmFzZUxmbyA9IHJlcXVpcmUoJy4vQmFzZUxmbycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Jhc2VMZm8nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlTGZvKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Tb3VyY2VNaXhpbiA9IHJlcXVpcmUoJy4vU291cmNlTWl4aW4nKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTb3VyY2VNaXhpbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NvdXJjZU1peGluKS5kZWZhdWx0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHZlcnNpb24gPSBleHBvcnRzLnZlcnNpb24gPSAnMS4xLjYnO1xuXG59LHtcIi4vQmFzZUxmb1wiOjE4MixcIi4vU291cmNlTWl4aW5cIjoxODN9XSwxODU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCl7XG4gIHZhciBTb2NrZXQsIG15b0xpc3QgPSB7fTtcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgIGlmKCEoXCJXZWJTb2NrZXRcIiBpbiB3aW5kb3cpKSB0aHJvdyBcIk1ZTzogV2Vic29ja2V0cyBhcmUgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXIgOihcIjtcbiAgICBTb2NrZXQgPSBXZWJTb2NrZXQ7XG4gIH1cbiAgXG4gIHZhciBNeW8gPSB7XG4gICAgZGVmYXVsdHMgOiB7XG4gICAgICBhcGlfdmVyc2lvbiA6IDMsXG4gICAgICBzb2NrZXRfdXJsICA6IFwid3M6Ly8xMjcuMC4wLjE6MTAxMzgvbXlvL1wiLFxuICAgICAgYXBwX2lkICAgICAgOiAnY29tLm15b2pzLmRlZmF1bHQnXG4gICAgfSxcbiAgICBsb2NraW5nUG9saWN5IDogJ3N0YW5kYXJkJyxcbiAgICBldmVudHMgOiBbXSxcbiAgICBteW9zIDogW10sXG4gICAgXG4gICAgb25FcnJvciA6IGZ1bmN0aW9uKCl7XG4gICAgICB0aHJvdyAnTVlPOiBFcnJvciB3aXRoIHRoZSBzb2NrZXQgY29ubmVjdGlvbi4gTXlvIENvbm5lY3QgbWlnaHQgbm90IGJlIHJ1bm5pbmcuIElmIGl0IGlzLCBkb3VibGUgY2hlY2sgdGhlIEFQSSB2ZXJzaW9uLic7XG4gICAgfSxcbiAgICBzZXRMb2NraW5nUG9saWN5OiBmdW5jdGlvbihwb2xpY3kpIHtcbiAgICAgIE15by5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShbJ2NvbW1hbmQnLHtcbiAgICAgICAgXCJjb21tYW5kXCI6IFwic2V0X2xvY2tpbmdfcG9saWN5XCIsXG4gICAgICAgIFwidHlwZVwiOiBwb2xpY3lcbiAgICAgIH1dKSk7XG4gICAgICBNeW8ubG9ja2luZ1BvbGljeSA9IHBvbGljeTtcbiAgICAgIHJldHVybiBNeW87XG4gICAgfSxcbiAgICB0cmlnZ2VyIDogZnVuY3Rpb24oZXZlbnROYW1lKXtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykuc2xpY2UoMSk7XG4gICAgICBlbWl0dGVyLnRyaWdnZXIuY2FsbChNeW8sIE15by5ldmVudHMsIGV2ZW50TmFtZSwgYXJncyk7XG4gICAgICByZXR1cm4gTXlvO1xuICAgIH0sXG4gICAgb24gOiBmdW5jdGlvbihldmVudE5hbWUsIGZuKXtcbiAgICAgIHJldHVybiBlbWl0dGVyLm9uKE15by5ldmVudHMsIGV2ZW50TmFtZSwgZm4pO1xuICAgIH0sXG4gICAgb2ZmIDogZnVuY3Rpb24oZXZlbnROYW1lKXtcbiAgICAgIE15by5ldmVudHMgPSBlbWl0dGVyLm9mZihNeW8uZXZlbnRzLCBldmVudE5hbWUpO1xuICAgICAgcmV0dXJuIE15bztcbiAgICB9LFxuICAgIFxuICAgIGNvbm5lY3QgOiBmdW5jdGlvbihhcHBJZCwgc29ja2V0TGliKXtcbiAgICAgIGlmKHNvY2tldExpYikgU29ja2V0ID0gc29ja2V0TGliO1xuICAgICAgaWYoIVNvY2tldCkgdGhyb3cgXCJNWU86IE11c3QgcHJvdmlkZSBhIHNvY2tldCBsaWJyYXJ5IHRvIHVzZS4gVHJ5ICdNeW8uc2V0U29ja2V0TGliKCdpZCcsIHJlcXVpcmUoJ3dzJykpJyBiZWZvcmUgeW91IGNvbm5lY3QuXCI7XG4gICAgICBpZihhcHBJZCl7XG4gICAgICAgIE15by5kZWZhdWx0cy5hcHBfaWQgPSBhcHBJZDtcbiAgICAgIH1cbiAgICAgIE15by5zb2NrZXQgPSBuZXcgU29ja2V0KE15by5kZWZhdWx0cy5zb2NrZXRfdXJsICsgTXlvLmRlZmF1bHRzLmFwaV92ZXJzaW9uICsgJz9hcHBpZD0nICsgTXlvLmRlZmF1bHRzLmFwcF9pZCk7XG4gICAgICBNeW8uc29ja2V0Lm9ubWVzc2FnZSA9IE15by5oYW5kbGVNZXNzYWdlO1xuICAgICAgTXlvLnNvY2tldC5vbm9wZW4gPSBNeW8udHJpZ2dlci5iaW5kKE15bywgJ3JlYWR5Jyk7XG4gICAgICBNeW8uc29ja2V0Lm9uY2xvc2UgPSBNeW8udHJpZ2dlci5iaW5kKE15bywgJ3NvY2tldF9jbG9zZWQnKTtcbiAgICAgIE15by5zb2NrZXQub25lcnJvciA9IE15by5vbkVycm9yO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdCA6IGZ1bmN0aW9uKCl7XG4gICAgICBNeW8uc29ja2V0LmNsb3NlKCk7XG4gICAgfSxcbiAgICBcbiAgICBoYW5kbGVNZXNzYWdlIDogZnVuY3Rpb24obXNnKXtcbiAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShtc2cuZGF0YSlbMV07XG4gICAgICBpZighZGF0YS50eXBlIHx8IHR5cGVvZihkYXRhLm15bykgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICBpZihkYXRhLnR5cGUgPT0gJ3BhaXJlZCcpe1xuICAgICAgICB2YXIgZXhpc3RzID0gTXlvLm15b3Muc29tZShmdW5jdGlvbihteW8pIHtcbiAgICAgICAgICByZXR1cm4gbXlvLm1hY0FkZHJlc3MgPT0gZGF0YS5tYWNfYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgIE15by5teW9zLnB1c2goTXlvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtYWNBZGRyZXNzICAgICAgOiBkYXRhLm1hY19hZGRyZXNzLFxuICAgICAgICAgICAgbmFtZSAgICAgICAgICAgIDogZGF0YS5uYW1lLFxuICAgICAgICAgICAgY29ubmVjdEluZGV4ICAgIDogZGF0YS5teW9cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgTXlvLm15b3MubWFwKGZ1bmN0aW9uKG15byl7XG4gICAgICAgIGlmKG15by5jb25uZWN0SW5kZXggPT09IGRhdGEubXlvKXtcbiAgICAgICAgICB2YXIgaXNTdGF0dXNFdmVudCA9IHRydWU7XG4gICAgICAgICAgaWYoZXZlbnRUYWJsZVtkYXRhLnR5cGVdKXtcbiAgICAgICAgICAgIGlzU3RhdHVzRXZlbnQgPSBldmVudFRhYmxlW2RhdGEudHlwZV0obXlvLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIWV2ZW50VGFibGVbZGF0YS50eXBlXSB8fCBpc1N0YXR1c0V2ZW50KXtcbiAgICAgICAgICAgIG15by50cmlnZ2VyKGRhdGEudHlwZSwgZGF0YSwgZGF0YS50aW1lc3RhbXApO1xuICAgICAgICAgICAgbXlvLnRyaWdnZXIoJ3N0YXR1cycsIGRhdGEsIGRhdGEudGltZXN0YW1wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBcbiAgICBjcmVhdGUgOiBmdW5jdGlvbihwcm9wcyl7XG4gICAgICB2YXIgbXlvUHJvcHMgPSB1dGlscy5tZXJnZSh7XG4gICAgICAgIG1hY0FkZHJlc3MgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmFtZSAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBjb25uZWN0SW5kZXggICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGxvY2tlZCAgICAgICAgICA6IHRydWUsXG4gICAgICAgIGNvbm5lY3RlZCAgICAgICA6IGZhbHNlLFxuICAgICAgICBzeW5jZWQgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgYmF0dGVyeUxldmVsICAgIDogMCxcbiAgICAgICAgbGFzdElNVSAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBhcm0gICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGRpcmVjdGlvbiAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgd2FybXVwU3RhdGUgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBvcmllbnRhdGlvbk9mZnNldCA6IHt4IDogMCx5IDogMCx6IDogMCx3IDogMX0sXG4gICAgICAgIGV2ZW50cyA6IFtdLFxuICAgICAgfSwgcHJvcHMgfHwge30pO1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKE9iamVjdC5jcmVhdGUoTXlvLm1ldGhvZHMpLCBteW9Qcm9wcyk7XG4gICAgfSxcbiAgICBcbiAgICBtZXRob2RzIDoge1xuICAgICAgdHJpZ2dlciA6IGZ1bmN0aW9uKGV2ZW50TmFtZSl7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykuc2xpY2UoMSk7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlci5jYWxsKHRoaXMsIE15by5ldmVudHMsIGV2ZW50TmFtZSwgYXJncyk7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlci5jYWxsKHRoaXMsIHRoaXMuZXZlbnRzLCBldmVudE5hbWUsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBfdHJpZ2dlciA6IGZ1bmN0aW9uKGV2ZW50TmFtZSl7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykuc2xpY2UoMSk7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlci5jYWxsKHRoaXMsIHRoaXMuZXZlbnRzLCBldmVudE5hbWUsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbiA6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZm4pe1xuICAgICAgICByZXR1cm4gZW1pdHRlci5vbih0aGlzLmV2ZW50cywgZXZlbnROYW1lLCBmbik7XG4gICAgICB9LFxuICAgICAgb2ZmIDogZnVuY3Rpb24oZXZlbnROYW1lKXtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBlbWl0dGVyLm9mZih0aGlzLmV2ZW50cywgZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbG9jayA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIE15by5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShbXCJjb21tYW5kXCIsIHtcbiAgICAgICAgICBcImNvbW1hbmRcIjogXCJsb2NrXCIsXG4gICAgICAgICAgXCJteW9cIjogdGhpcy5jb25uZWN0SW5kZXhcbiAgICAgICAgfV0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgdW5sb2NrIDogZnVuY3Rpb24oaG9sZCl7XG4gICAgICAgIE15by5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShbXCJjb21tYW5kXCIsIHtcbiAgICAgICAgICBcImNvbW1hbmRcIjogXCJ1bmxvY2tcIixcbiAgICAgICAgICBcIm15b1wiOiB0aGlzLmNvbm5lY3RJbmRleCxcbiAgICAgICAgICBcInR5cGVcIjogKGhvbGQgPyBcImhvbGRcIiA6IFwidGltZWRcIilcbiAgICAgICAgfV0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgemVyb09yaWVudGF0aW9uIDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbk9mZnNldCA9IHV0aWxzLnF1YXRJbnZlcnNlKHRoaXMubGFzdFF1YW50KTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd6ZXJvX29yaWVudGF0aW9uJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHZpYnJhdGUgOiBmdW5jdGlvbihpbnRlbnNpdHkpe1xuICAgICAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkgfHwgJ21lZGl1bSc7XG4gICAgICAgIE15by5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShbJ2NvbW1hbmQnLHtcbiAgICAgICAgICBcImNvbW1hbmRcIjogXCJ2aWJyYXRlXCIsXG4gICAgICAgICAgXCJteW9cIjogdGhpcy5jb25uZWN0SW5kZXgsXG4gICAgICAgICAgXCJ0eXBlXCI6IGludGVuc2l0eVxuICAgICAgICB9XSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0Qmx1ZXRvb3RoU3RyZW5ndGggOiBmdW5jdGlvbigpe1xuICAgICAgICBNeW8uc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoWydjb21tYW5kJyx7XG4gICAgICAgICAgXCJjb21tYW5kXCI6IFwicmVxdWVzdF9yc3NpXCIsXG4gICAgICAgICAgXCJteW9cIjogdGhpcy5jb25uZWN0SW5kZXhcbiAgICAgICAgfV0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEJhdHRlcnlMZXZlbCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIE15by5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShbJ2NvbW1hbmQnLHtcbiAgICAgICAgICBcImNvbW1hbmRcIjogXCJyZXF1ZXN0X2JhdHRlcnlfbGV2ZWxcIixcbiAgICAgICAgICBcIm15b1wiOiB0aGlzLmNvbm5lY3RJbmRleFxuICAgICAgICB9XSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzdHJlYW1FTUcgOiBmdW5jdGlvbihlbmFibGVkKXtcbiAgICAgICAgTXlvLnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KFsnY29tbWFuZCcse1xuICAgICAgICAgIFwiY29tbWFuZFwiOiBcInNldF9zdHJlYW1fZW1nXCIsXG4gICAgICAgICAgXCJteW9cIjogdGhpcy5jb25uZWN0SW5kZXgsXG4gICAgICAgICAgXCJ0eXBlXCIgOiAoZW5hYmxlZCA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCcpXG4gICAgICAgIH1dKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXG4gIHZhciBldmVudFRhYmxlID0ge1xuICAgIC8vU3RyZWFtIEV2ZW50c1xuICAgICdwb3NlJyA6IGZ1bmN0aW9uKG15bywgZGF0YSl7XG4gICAgICBpZihteW8ubGFzdFBvc2Upe1xuICAgICAgICBteW8udHJpZ2dlcihteW8ubGFzdFBvc2UgKyAnX29mZicpO1xuICAgICAgICBteW8udHJpZ2dlcigncG9zZV9vZmYnLCBteW8ubGFzdFBvc2UpO1xuICAgICAgfVxuICAgICAgaWYoZGF0YS5wb3NlID09ICdyZXN0Jyl7XG4gICAgICAgIG15by50cmlnZ2VyKCdyZXN0Jyk7XG4gICAgICAgIG15by5sYXN0UG9zZSA9IG51bGw7XG4gICAgICAgIGlmKE15by5sb2NraW5nUG9saWN5ID09PSAnc3RhbmRhcmQnKSBteW8udW5sb2NrKCk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbXlvLnRyaWdnZXIoZGF0YS5wb3NlKTtcbiAgICAgICAgbXlvLnRyaWdnZXIoJ3Bvc2UnLCBkYXRhLnBvc2UpO1xuICAgICAgICBteW8ubGFzdFBvc2UgPSBkYXRhLnBvc2U7XG4gICAgICAgIGlmKE15by5sb2NraW5nUG9saWN5ID09PSAnc3RhbmRhcmQnKSBteW8udW5sb2NrKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ29yaWVudGF0aW9uJyA6IGZ1bmN0aW9uKG15bywgZGF0YSl7XG4gICAgICBteW8ubGFzdFF1YW50ID0gZGF0YS5vcmllbnRhdGlvbjtcbiAgICAgIHZhciBvcmkgPSB1dGlscy5xdWF0Um90YXRlKG15by5vcmllbnRhdGlvbk9mZnNldCwgZGF0YS5vcmllbnRhdGlvbik7XG4gICAgICB2YXIgaW11X2RhdGEgPSB7XG4gICAgICAgIG9yaWVudGF0aW9uIDogb3JpLFxuICAgICAgICBhY2NlbGVyb21ldGVyIDoge1xuICAgICAgICAgIHggOiBkYXRhLmFjY2VsZXJvbWV0ZXJbMF0sXG4gICAgICAgICAgeSA6IGRhdGEuYWNjZWxlcm9tZXRlclsxXSxcbiAgICAgICAgICB6IDogZGF0YS5hY2NlbGVyb21ldGVyWzJdXG4gICAgICAgIH0sXG4gICAgICAgIGd5cm9zY29wZSA6IHtcbiAgICAgICAgICB4IDogZGF0YS5neXJvc2NvcGVbMF0sXG4gICAgICAgICAgeSA6IGRhdGEuZ3lyb3Njb3BlWzFdLFxuICAgICAgICAgIHogOiBkYXRhLmd5cm9zY29wZVsyXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYoIW15by5sYXN0SU1VKSBteW8ubGFzdElNVSA9IGltdV9kYXRhO1xuICAgICAgbXlvLnRyaWdnZXIoJ29yaWVudGF0aW9uJywgICBpbXVfZGF0YS5vcmllbnRhdGlvbiwgZGF0YS50aW1lc3RhbXApO1xuICAgICAgbXlvLnRyaWdnZXIoJ2FjY2VsZXJvbWV0ZXInLCBpbXVfZGF0YS5hY2NlbGVyb21ldGVyLCBkYXRhLnRpbWVzdGFtcCk7XG4gICAgICBteW8udHJpZ2dlcignZ3lyb3Njb3BlJywgICAgIGltdV9kYXRhLmd5cm9zY29wZSwgZGF0YS50aW1lc3RhbXApO1xuICAgICAgbXlvLnRyaWdnZXIoJ2ltdScsICAgICAgICAgICBpbXVfZGF0YSwgZGF0YS50aW1lc3RhbXApO1xuICAgICAgbXlvLmxhc3RJTVUgPSBpbXVfZGF0YTtcbiAgICB9LFxuICAgICdlbWcnIDogZnVuY3Rpb24obXlvLCBkYXRhKXtcbiAgICAgIG15by50cmlnZ2VyKGRhdGEudHlwZSwgZGF0YS5lbWcsIGRhdGEudGltZXN0YW1wKTtcbiAgICB9LFxuICAgIFxuICAgIFxuICAgIC8vU3RhdHVzIEV2ZW50c1xuICAgICdhcm1fc3luY2VkJyA6IGZ1bmN0aW9uKG15bywgZGF0YSl7XG4gICAgICBteW8uYXJtID0gZGF0YS5hcm07XG4gICAgICBteW8uZGlyZWN0aW9uID0gZGF0YS54X2RpcmVjdGlvbjtcbiAgICAgIG15by53YXJtdXBTdGF0ZSA9IGRhdGEud2FybXVwX3N0YXRlO1xuICAgICAgbXlvLnN5bmNlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgICdhcm1fdW5zeW5jZWQnIDogZnVuY3Rpb24obXlvLCBkYXRhKXtcbiAgICAgIG15by5hcm0gPSB1bmRlZmluZWQ7XG4gICAgICBteW8uZGlyZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgbXlvLndhcm11cFN0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgbXlvLnN5bmNlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAnY29ubmVjdGVkJyA6IGZ1bmN0aW9uKG15bywgZGF0YSl7XG4gICAgICBteW8uY29ubmVjdFZlcnNpb24gPSBkYXRhLnZlcnNpb24uam9pbignLicpO1xuICAgICAgbXlvLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgICdkaXNjb25uZWN0ZWQnIDogZnVuY3Rpb24obXlvLCBkYXRhKXtcbiAgICAgIG15by5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgJ2xvY2tlZCcgOiBmdW5jdGlvbihteW8sIGRhdGEpe1xuICAgICAgbXlvLmxvY2tlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgICd1bmxvY2tlZCcgOiBmdW5jdGlvbihteW8sIGRhdGEpe1xuICAgICAgbXlvLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAnd2FybXVwX2NvbXBsZXRlZCcgOiBmdW5jdGlvbihteW8sIGRhdGEpe1xuICAgICAgbXlvLndhcm11cFN0YXRlID0gJ3dhcm0nO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBcbiAgICAncnNzaScgOiBmdW5jdGlvbihteW8sIGRhdGEpe1xuICAgICAgZGF0YS5ibHVldG9vdGhfc3RyZW5ndGggPSAgdXRpbHMuZ2V0U3RyZW5ndGhGcm9tUnNzaShkYXRhLnJzc2kpO1xuICAgICAgbXlvLnRyaWdnZXIoJ2JsdWV0b290aF9zdHJlbmd0aCcsIGRhdGEuYmx1ZXRvb3RoX3N0cmVuZ3RoLCBkYXRhLnRpbWVzdGFtcCk7XG4gICAgICBteW8udHJpZ2dlcigncnNzaScsIGRhdGEucnNzaSwgZGF0YS50aW1lc3RhbXApO1xuICAgICAgbXlvLnRyaWdnZXIoJ3N0YXR1cycsIGRhdGEsIGRhdGEudGltZXN0YW1wKTtcbiAgICB9LFxuICAgICdiYXR0ZXJ5X2xldmVsJyA6IGZ1bmN0aW9uKG15bywgZGF0YSl7XG4gICAgICBteW8uYmF0dGVyeUxldmVsID0gZGF0YS5iYXR0ZXJ5X2xldmVsO1xuICAgICAgbXlvLnRyaWdnZXIoJ2JhdHRlcnlfbGV2ZWwnLCBkYXRhLmJhdHRlcnlfbGV2ZWwsIGRhdGEudGltZXN0YW1wKTtcbiAgICAgIG15by50cmlnZ2VyKCdzdGF0dXMnLCBkYXRhLCBkYXRhLnRpbWVzdGFtcCk7XG4gICAgfSxcbiAgfTtcbiAgXG4gIFxuICB2YXIgZW1pdHRlciA9IHtcbiAgICBldmVudENvdW50ZXIgOiAwLFxuICAgIHRyaWdnZXIgOiBmdW5jdGlvbihldmVudHMsIGV2ZW50TmFtZSwgYXJncyl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBldmVudHMubWFwKGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQubmFtZSA9PSBldmVudE5hbWUpIGV2ZW50LmZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICBpZihldmVudC5uYW1lID09ICcqJyl7XG4gICAgICAgICAgdmFyIGFyZ3NfdGVtcCA9IGFyZ3Muc2xpY2UoMCk7XG4gICAgICAgICAgYXJnc190ZW1wLnVuc2hpZnQoZXZlbnROYW1lKTtcbiAgICAgICAgICBldmVudC5mbi5hcHBseShzZWxmLCBhcmdzX3RlbXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb24gOiBmdW5jdGlvbihldmVudHMsIG5hbWUsIGZuKXtcbiAgICAgIHZhciBpZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgXCJcIiArIGVtaXR0ZXIuZXZlbnRDb3VudGVyKys7XG4gICAgICBldmVudHMucHVzaCh7XG4gICAgICAgIGlkICAgOiBpZCxcbiAgICAgICAgbmFtZSA6IG5hbWUsXG4gICAgICAgIGZuICAgOiBmblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSxcbiAgICBvZmYgOiBmdW5jdGlvbihldmVudHMsIG5hbWUpe1xuICAgICAgZXZlbnRzID0gZXZlbnRzLnJlZHVjZShmdW5jdGlvbihyZXN1bHQsIGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQubmFtZSA9PSBuYW1lIHx8IGV2ZW50LmlkID09IG5hbWUgfHwgIW5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIFtdKTtcbiAgICAgIHJldHVybiBldmVudHM7XG4gICAgfSxcbiAgfTtcbiAgXG4gIHZhciB1dGlscyA9IHtcbiAgICBtZXJnZSA6IGZ1bmN0aW9uKG9iajEsb2JqMil7XG4gICAgICBmb3IodmFyIGF0dHJuYW1lIGluIG9iajIpIHsgb2JqMVthdHRybmFtZV0gPSBvYmoyW2F0dHJuYW1lXTsgfVxuICAgICAgcmV0dXJuIG9iajE7XG4gICAgfSxcbiAgICBxdWF0SW52ZXJzZSA6IGZ1bmN0aW9uKHEpIHtcbiAgICAgIHZhciBsZW4gPSBNYXRoLnNxcnQocS54ICogcS54ICsgcS55ICogcS55ICsgcS56ICogcS56ICsgcS53ICogcS53KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHEudy9sZW4sXG4gICAgICAgIHg6IC1xLngvbGVuLFxuICAgICAgICB5OiAtcS55L2xlbixcbiAgICAgICAgejogLXEuei9sZW5cbiAgICAgIH07XG4gICAgfSxcbiAgICBxdWF0Um90YXRlIDogZnVuY3Rpb24ocSwgcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdzogcS53ICogci53IC0gcS54ICogci54IC0gcS55ICogci55IC0gcS56ICogci56LFxuICAgICAgICB4OiBxLncgKiByLnggKyBxLnggKiByLncgKyBxLnkgKiByLnogLSBxLnogKiByLnksXG4gICAgICAgIHk6IHEudyAqIHIueSAtIHEueCAqIHIueiArIHEueSAqIHIudyArIHEueiAqIHIueCxcbiAgICAgICAgejogcS53ICogci56ICsgcS54ICogci55IC0gcS55ICogci54ICsgcS56ICogci53XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U3RyZW5ndGhGcm9tUnNzaSA6IGZ1bmN0aW9uKHJzc2kpe1xuICAgICAgdmFyIG1pbiA9IC05NTtcbiAgICAgIHZhciBtYXggPSAtNDA7XG4gICAgICByc3NpID0gKHJzc2kgPCBtaW4pID8gbWluIDogcnNzaTtcbiAgICAgIHJzc2kgPSAocnNzaSA+IG1heCkgPyBtYXggOiByc3NpO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKChyc3NpLW1pbikqMTAwKS8obWF4LW1pbikgKiAxMDApLzEwMDtcbiAgICB9LFxuICB9O1xuICBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgd2luZG93Lk15byA9IE15bztcbiAgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gTXlvO1xufSkoKTtcblxufSx7fV0sMTg2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qaW1wb3J0ICogYXMgbGZvICBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbmltcG9ydCAqIGFzIE15byBmcm9tICdkaXN0L2NsaWVudC9qcy9teW8nO1xuaW1wb3J0ICogYXMgU0cgZnJvbSAnbWwtc2F2aXR6a3ktZ29sYXknO1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gJy4uLy4uL2NvbmZpZy9kZWZhdWx0JzsqL1xuXG52YXIgbGZvID0gcmVxdWlyZSggJ3dhdmVzLWxmby9jbGllbnQnKTtcbnZhciBNeW8gPSByZXF1aXJlKCAnLi9teW8nKTtcbnZhciBTRyA9IHJlcXVpcmUoJ21sLXNhdml0emt5LWdvbGF5Jyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSggJy4uLy4uL2NvbmZpZy9kZWZhdWx0Jyk7XG5cbi8vR3Jhdml0eSBjb25zdGFudFxuY29uc3QgZyA9IDkuODE7XG5cbi8vQ29uc3RhbnQgZm9yIHdpbmRvdyBMZW5ndGggdXNlZFxudmFyIEVNR1dpbmRvd0xlbmd0aCA9IDUwMDtcbnZhciBhY2NlbGVyb1dpbmRvd0xlbmd0aCA9IDMwO1xuLy9Nb2RpZmljYXRpb24gZW4gZGlyZWN0XG52YXIgc3BlZWRSYXRlV2luZG93TGVuZ3RoID0gMTA7XG52YXIgYW1wbGl0dWRlV2luZG93TGVuZ3RoID0gMTA7XG52YXIgU0dXaW5kb3dMZW5ndGggPSAyMjtcblxuXG5cbi8vVGltZSBmb3IgdGhlIGJwZkRpc3BsYXlcbmxldCB0aW1lID0gMDtcbmNvbnN0IGR0ID0gMC4wMTtcbmxldCB0aW1lRU1HID0gMDtcbmNvbnN0IGR0RU1HID0gMC4wMTtcblxuLy9Tb2NrZWQgdG8gc2VuZCBkYXRhIHRvIG5vZGVcbmNvbnN0IHNvY2tldFNlbmRKZXJraW5lc3MgPSBuZXcgbGZvLnNpbmsuU29ja2V0U2VuZCh7IHBvcnQ6IGNvbmZpZy5zb2NrZXRDbGllbnRUb1NlcnZlci5wb3J0IH0pO1xuXG4vL1N0YXJ0aW5nIG15b1xuTXlvLmNvbm5lY3QoJ2NvbS5zdG9sa3Nkb3JmLm15QXdlc29tZUFwcCcpO1xubGV0IG15TXlvO1xuXG5cbi8vQ3JlYXRpb24gb2YgZ3JhcGhcbmNvbnN0IGV2ZW50SW5BY2NlbGVybyA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICBmcmFtZVNpemU6IDMsXG4gIGZyYW1lUmF0ZTogMC4wMSxcbiAgZGVzY3JpcHRpb246IFsnYWNjZWxlcm9YJywgJ2FjY2VsZXJvWScsICdhY2NlbGVyb1onXSxcbn0pO1xuY29uc3QgZXZlbnRJblNtb290aG5lc3MgPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHtcbiAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAgZnJhbWVTaXplOiAxLFxuICBmcmFtZVJhdGU6IDAuMDEsXG4gIGRlc2NyaXB0aW9uOiBbJ3Ntb290aFgnLCAnc21vb3RoWScsICdzbW9vdGhaJ10sXG59KTtcbmNvbnN0IGV2ZW50SW5HeXJvID0gbmV3IGxmby5zb3VyY2UuRXZlbnRJbih7XG4gIGZyYW1lVHlwZTogJ3ZlY3RvcicsXG4gIGZyYW1lU2l6ZTogMyxcbiAgZnJhbWVSYXRlOiAwLjAxLFxuICBkZXNjcmlwdGlvbjogWydneXJvWCcsICdneXJvWScsICdneXJvWiddLFxufSk7XG5jb25zdCBldmVudEluRU1HID0gbmV3IGxmby5zb3VyY2UuRXZlbnRJbih7XG4gIGZyYW1lVHlwZTogJ3ZlY3RvcicsXG4gIGZyYW1lU2l6ZTogOCxcbiAgZnJhbWVSYXRlOiAwLjAxLFxuICBkZXNjcmlwdGlvbjogWydlbWcnLCAnZW1nJywgJ2VtZycsJ2VtZycsICdlbWcnLCAnZW1nJywnZW1nJywgJ2VtZyddLFxufSk7XG5jb25zdCBldmVudEluRU1HU2xpZGluZyA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICBmcmFtZVNpemU6IDEsXG4gIGZyYW1lUmF0ZTogMC4wMSxcbiAgZGVzY3JpcHRpb246IFsnZW1nU2xpZGluZyddLFxufSk7XG5jb25zdCBldmVudEluU21vb3RobmVzc1JlY29yZGVkID0gbmV3IGxmby5zb3VyY2UuRXZlbnRJbih7XG4gIGZyYW1lVHlwZTogJ3ZlY3RvcicsXG4gIGZyYW1lU2l6ZTogMSxcbiAgZnJhbWVSYXRlOiAwLjAxLFxuICBkZXNjcmlwdGlvbjogWydzbW9vdGhYJ10sXG59KTtcblxuLy8gaW5pdGlhbGl6ZSBhbmQgc3RhcnQgdGhlIGRpZmZlcmVudCBncmFwaCB1c2VkXG5mdW5jdGlvbiBpbml0R3JhcGgoKXtcbi8vZXZlbnRJbkFjY2VsZXJvLnN0YXJ0KCk7XG4vL2V2ZW50SW5HeXJvLnN0YXJ0KCk7XG4vL2V2ZW50SW5FTUdTbGlkaW5nLnN0YXJ0KCk7XG4vL2V2ZW50SW5FTUcuc3RhcnQoKTtcbiAgZXZlbnRJblNtb290aG5lc3NSZWNvcmRlZC5zdGFydCgpO1xuICBldmVudEluU21vb3RobmVzcy5zdGFydCgpO1xuICBcbiAgY29uc29sZS5sb2coXCJldmVudCBpbiBzdGFydGVkXCIpO1xuICAvKkFDQ0VMRVJPKi9cbiAgLy9ldmVudEluQWNjZWxlcm8uY29ubmVjdChicGZEaXNwbGF5QWNjZWxlcm8pO1xuICAvKkpFUktJTkVTUyBSQVRFKi9cbiAgLy9ldmVudEluU21vb3RobmVzcy5jb25uZWN0KGJwZkRpc3BsYXlKZXJraW5lc3MpO1xuICBldmVudEluU21vb3RobmVzcy5jb25uZWN0KHNvY2tldFNlbmRKZXJraW5lc3MpO1xuICAvKkVNRyovXG4gIC8vZXZlbnRJbkVNRy5jb25uZWN0KGJwZkRpc3BsYXlFTUcpO1xuICAvKkVNR1MgU0xJRElORyBXSU5ET1cqL1xuICAvL2V2ZW50SW5FTUdTbGlkaW5nLmNvbm5lY3QoYnBmRGlzcGxheUVNR1NsaW5kaW5nKTtcbn1cblxuXG4vKk1ZTyBzdGFydGluZyBldmVudCBoYW5kbGVyKi9cbk15by5vbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLmxvZyhcIkNvdWxkbid0IGNvbm5lY3QgdG8gTXlvIENvbm5lY3RcIik7XG59O1xuXG5NeW8ub24oJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKCl7XG4gIG15TXlvID0gdGhpcztcbiAgLy9teU15by5zZXRMb2NraW5nUG9saWN5KFwiTWFudWFsXCIpO1xuICBhZGRFdmVudHMobXlNeW8pO1xuICBcbn0pO1xuXG5sZXQgYWRkRXZlbnRzID0gZnVuY3Rpb24obXlvKXtcbiAgXG4gIG15TXlvLnN0cmVhbUVNRyh0cnVlKTtcbiAgTXlvLm9uKCdlbWcnLCBmdW5jdGlvbihkYXRhKXtcbiAgICAgIC8vZGlzcGxheUVNR1dpbmRvdyhFTUdXaW5kb3dMZW5ndGgsZGF0YSk7XG4gIH0pO1xuICBcbiAgY29uc3QgYnBmRGlzcGxheUFjY2VsZXJvID0gbmV3IGxmby5zaW5rLkJwZkRpc3BsYXkoe1xuICAgIGNhbnZhczogJyNjYW52YXNCUEZBY2NlbGVybycsXG4gICAgd2lkdGg6IDQwMCxcbiAgICBoZWlnaHQ6IDI1MCxcbiAgICBkdXJhdGlvbjogNSxcbiAgICBtYXg6IDksXG4gICAgbWluOiAtOVxuICB9KTtcbiAgY29uc3QgYnBmRGlzcGxheUplcmtpbmVzcyA9IG5ldyBsZm8uc2luay5CcGZEaXNwbGF5KHtcbiAgICBjYW52YXM6ICcjYnBmRGlzcGxheUplcmtpbmVzcycsXG4gICAgd2lkdGg6IDQwMCxcbiAgICBoZWlnaHQ6IDI1MCxcbiAgICBkdXJhdGlvbjogNSxcbiAgICBtYXg6IDEsXG4gICAgbWluOiAtMVxuICB9KTtcbiAgY29uc3QgYnBmRGlzcGxheUVNRyA9IG5ldyBsZm8uc2luay5CcGZEaXNwbGF5KHtcbiAgICBjYW52YXM6ICcjY2FudmFzRU1HMScsXG4gICAgd2lkdGg6IDQwMCxcbiAgICBoZWlnaHQ6IDI1MCxcbiAgICBkdXJhdGlvbjogNSxcbiAgICBtYXg6IDEyOCxcbiAgICBtaW46IC0xMjhcbiAgfSk7XG4gIGNvbnN0IGJwZkRpc3BsYXlFTUdTbGluZGluZyA9IG5ldyBsZm8uc2luay5CcGZEaXNwbGF5KHtcbiAgICBjYW52YXM6ICcjY2FudmFzRU1HMicsXG4gICAgd2lkdGg6IDQwMCxcbiAgICBoZWlnaHQ6IDI1MCxcbiAgICBkdXJhdGlvbjogNSxcbiAgICBtYXg6IDEsXG4gICAgbWluOiAtMVxuICB9KTtcbiAgXG4gIC8vTGUgbG93IHBhc3MgbmUgbWFyY2hlIHBhcyBldCBqZSBuZSBzYWlzIHRvdWpvdXJzIHBhcyBwb3VycXVvaS4gUHJvYmxlbWUgZGUgY29uZmlnP1xuICBjb25zdCBiaXF1YWQgPSBuZXcgbGZvLm9wZXJhdG9yLkJpcXVhZCh7XG4gICAgdHlwZTogJ2xvd3Bhc3MnLFxuICAgIGYwOiA1MCxcbiAgICBnYWluOiAzLFxuICAgIHE6IDEyLFxuICB9KTtcbiAgXG4gIGNvbnN0IGJpcXVhZDIgPSBuZXcgbGZvLm9wZXJhdG9yLkJpcXVhZCh7XG4gICAgdHlwZTogJ2xvd3Bhc3MnLFxuICAgIGYwOiA1MDAsXG4gICAgZ2FpbjogMyxcbiAgICBxOiAxMixcbiAgfSk7XG4gIFxuICBjb25zdCBtb3ZpbmdBdmVyYWdlID0gbmV3IGxmby5vcGVyYXRvci5Nb3ZpbmdBdmVyYWdlKHtcbiAgICBvcmRlcjogNSxcbiAgICBmaWxsOiAwXG4gIH0pO1xuICBcbiAgLy9Jbml0IHRoZSBkaWZmZXJlbnQgZ3JhcGggdXNlZCBhbmQgY2hvb3NlIHdpY2ggb25lIHRvIGRpc3BsYXlcbiAgaW5pdEdyYXBoKCk7XG4gIE15by5vbignaW11JywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBteU15by5sb2NrKCk7XG4gICAgZGlzcGxheVdpbmRvdyhkYXRhKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkaXNwbGF5V2luZG93KGRhdGEpe1xuICAvL2Rpc3BsYXlBY2NlbGVyb1dpbmRvd1NwZWVkKGFjY2VsZXJvV2luZG93TGVuZ3RoLGRhdGEpO1xuICBkaXNwbGF5U21vb3RobmVzcyhTR1dpbmRvd0xlbmd0aCxkYXRhKTtcbiAgLy9kaXNwbGF5RU1HV2luZG93KFNHV2luZG93TGVuZ3RoLGRhdGEpO1xufVxuXG5cblxuXG5cbi8qTWV0aG9kIHNsaWRpbmcgd2luZG93IGNvbXB1dGF0aW9uLCByZXF1aXJlIGxlc3MgY29tcHV0YXRpb24gdGhhbiB0aGUgbmFpdmUgb25lKi9cbnZhciBhbnNYID0gW107XG52YXIgYW5zWSA9IFtdO1xudmFyIGFuc1ogPSBbXTtcbnZhciBjb21wdXRlZFNwZWVkUmF0ZSA9IDA7XG52YXIgc3VtTGFzdEVsZW0gPSAwO1xudmFyIHN1bUZpcnN0RWxlbSA9IDA7XG5mdW5jdGlvbiBjb21wdXRlU3BlZWRSYXRlQWRhcHRhdGl2ZVdpbmRvdyh3aW5kb3dMZW5ndGgsIG5ld1gsbmV3WSxuZXdaKSB7XG4gIGlmIChhbnNYLmxlbmd0aCA+PSB3aW5kb3dMZW5ndGgpIHtcbiAgICB2YXIgZmlyc3RFbGVtZW50WCA9IGFuc1guc2hpZnQoKTtcbiAgICB2YXIgZmlyc3RFbGVtZW50WSA9IGFuc1kuc2hpZnQoKTtcbiAgICB2YXIgZmlyc3RFbGVtZW50WiA9IGFuc1ouc2hpZnQoKTtcbiAgICBzdW1GaXJzdEVsZW0gPSAoZmlyc3RFbGVtZW50WCApICsgKGZpcnN0RWxlbWVudFkgKSArIChmaXJzdEVsZW1lbnRaICk7XG4gIH1cbiAgICBsZXQgeCA9IE1hdGguYWJzKG5ld1gvZyk7XG4gICAvLyBsZXQgeCA9IChuZXdYL2cpO1xuICAgIGFuc1gucHVzaCh4KTtcbiAgICBsZXQgeSA9IE1hdGguYWJzKG5ld1kvZyk7XG4gICAvLyBsZXQgeSA9IChuZXdZL2cpO1xuICAgIGFuc1kucHVzaCh5KTtcbiAgICBsZXQgeiA9IE1hdGguYWJzKG5ld1ovZyk7XG4gICAgLy9sZXQgeiA9IChuZXdaL2cpO1xuICAgIGFuc1oucHVzaCh6KTtcbiAgXG4gICAgc3VtTGFzdEVsZW0gPSAoeCkrKHkpKyh6KTtcbiAgICBjb21wdXRlZFNwZWVkUmF0ZSA9IGNvbXB1dGVkU3BlZWRSYXRlIC0gc3VtRmlyc3RFbGVtICsgc3VtTGFzdEVsZW07XG4gIFxuICByZXR1cm4gY29tcHV0ZWRTcGVlZFJhdGU7XG59XG5cblxuLy9BbGdvcml0aG0gZGUgY2FsY3VsIG5haWYgZGUgbGEgdml0ZXNzZSBzZWxvbiB1bmUgZmVuZXRyZTogcmV0b3VybmUgbGUgbWVtZSByZXN1bHRhdCBxdWUgbCdhbGdvcml0aG1lIGV2b2x1w6lcbnZhciBhbnNYTmFpZiA9IFtdO1xudmFyIGFuc1lOYWlmID0gW107XG52YXIgYW5zWk5haWYgPSBbXTtcbmZ1bmN0aW9uIGNvbXB1dGVTcGVlZFJhdGVBZGFwdGF0aXZlV2luZG93TmFpZih3aW5kb3dMZW5ndGgseCx5LHope1xuICBjb25zb2xlLmxvZyhcIlRoZSBmdW5jdGlvbiBjb21wdXRlU3BlZWRSYXRlQWRhcHRhdGl2ZVdpbmRvd05haWYgaXMgZGVwcmVjYXRlZCwgdXNlIGNvbXB1dGVTcGVlZFJhdGVBZGFwdGF0aXZlV2luZG93IGluc3RlYWQuXCIpO1xuICBpZiAoYW5zWE5haWYubGVuZ3RoID49IHdpbmRvd0xlbmd0aCkge1xuICAgIGFuc1hOYWlmLnNoaWZ0KCk7XG4gICAgYW5zWU5haWYuc2hpZnQoKTtcbiAgICBhbnNaTmFpZi5zaGlmdCgpO1xuICB9XG4gIGFuc1hOYWlmLnB1c2goeC9nKTtcbiAgYW5zWU5haWYucHVzaCh5L2cpO1xuICBhbnNaTmFpZi5wdXNoKHovZyk7XG4gIFxuICBsZXQgIHNwZWVkUmF0ZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZG93TGVuZ3RoIDsgaSsrKSB7XG4gICAgICBzcGVlZFJhdGUgKz0gKGFuc1hOYWlmW2ldKSArIChhbnNZTmFpZltpXSkgKyAoYW5zWk5haWZbaV0pO1xuICAgICAgLy9zcGVlZFJhdGUgKz0gTWF0aC5hYnMoYW5zWFtpXS9nKSsgTWF0aC5hYnMoYW5zWVtpXS9nKSArICBNYXRoLmFicyhhbnNaW2ldL2cpO1xuICAgICAvLyBzcGVlZFJhdGUgKz1NYXRoLnNxcnQoTWF0aC5wb3coIE1hdGguYWJzKGFuc1hbaV0vZykgLDIpKyBNYXRoLnBvdyggIE1hdGguYWJzKGFuc1lbaV0vZyksMikgKyBNYXRoLnBvdyggTWF0aC5hYnMoYW5zWltpXS9nKSwyKSk7XG4gIH1cbiAgcmV0dXJuIHNwZWVkUmF0ZTtcbn1cblxuZnVuY3Rpb24gZGlzcGxheUFjY2VsZXJvV2luZG93U3BlZWQod2luZG93TGVuZ3RoLCBkYXRhKXtcbiAgdGltZSArPSBkdDtcbiAgbGV0IHNwZWVkUmF0ZSA9IGNvbXB1dGVTcGVlZFJhdGVBZGFwdGF0aXZlV2luZG93KHdpbmRvd0xlbmd0aCxkYXRhLmFjY2VsZXJvbWV0ZXIueCwgZGF0YS5hY2NlbGVyb21ldGVyLnksIGRhdGEuYWNjZWxlcm9tZXRlci56KTtcbiAgY29uc3QgZnJhbWVBY2NlbGVybyA9IHtcbiAgICB0aW1lOiB0aW1lLFxuICAgIGRhdGE6IFtkYXRhLmFjY2VsZXJvbWV0ZXIueCooc3BlZWRSYXRlKSwgZGF0YS5hY2NlbGVyb21ldGVyLnkqKHNwZWVkUmF0ZSksIGRhdGEuYWNjZWxlcm9tZXRlci56KihzcGVlZFJhdGUpXSxcbiAgICBtZXRhZGF0YTp0cnVlLFxuICB9O1xuICBldmVudEluQWNjZWxlcm8ucHJvY2Vzc0ZyYW1lKGZyYW1lQWNjZWxlcm8pO1xufVxuXG5cbi8vRm9yIHRoZSBzbGlkaW5nIHdpbmRvdyBvZiBraW5lc3RldGljIGF3YXJlbmVzcyByZXBsaWNhdGlvblxubGV0IHNsaWRpbmdXaW5kb3cgPSBbXTtcbmZ1bmN0aW9uIGRpc3BsYXlFTUdXaW5kb3cod2luZG93TGVuZ3RoLCBkYXRhKXtcbiAgdGltZUVNRyArPSBkdEVNRztcbiAgLy9TbGluZGluZyB3aW5kb3cgb2YgRU1HXG4gIGlmKHNsaWRpbmdXaW5kb3cubGVuZ3RoID4gd2luZG93TGVuZ3RoKXtcbiAgICBzbGlkaW5nV2luZG93LnNoaWZ0KCk7XG4gIH1cbiAgc2xpZGluZ1dpbmRvdy5wdXNoKE1hdGgubWF4KC4uLmRhdGEpKTtcbiAgbGV0IG1heFNsaWRpbmcgPSBNYXRoLm1heCguLi5zbGlkaW5nV2luZG93KTtcbiAgY29uc3QgZnJhbWVFTUdTbGlkaW5nID0ge1xuICAgIHRpbWU6IHRpbWVFTUcsXG4gICAgZGF0YTogc2xpZGluZ1dpbmRvd1tzbGlkaW5nV2luZG93Lmxlbmd0aC0xXS9tYXhTbGlkaW5nLFxuICB9O1xuICBcbiAgY29uc3QgZnJhbWVFTUcgPSB7XG4gICAgdGltZTogdGltZUVNRyxcbiAgICBkYXRhOiBkYXRhLFxuICB9O1xuICBldmVudEluRU1HU2xpZGluZy5wcm9jZXNzRnJhbWUoZnJhbWVFTUdTbGlkaW5nKTtcbiAgZXZlbnRJbkVNRy5wcm9jZXNzRnJhbWUoZnJhbWVFTUcpO1xufVxuXG5cbi8vdmFyaWFibGVzIGZvciB0aGUgc2F2aXR6a3ktZ29sYXkgZmlsdGVyXG5sZXQgYXJyYXlGaWx0ZXJpbmdYID0gW107XG5sZXQgYXJyYXlGaWx0ZXJpbmdZID0gW107XG5sZXQgYXJyYXlGaWx0ZXJpbmdaID0gW107XG5sZXQgYW5zeCA9IFtdO1xubGV0IGFuc3kgPSBbXTtcbmxldCBhbnN6ID0gW107XG52YXIgb3B0aW9ucyA9IHtkZXJpdmF0aXZlOiAxLHdpbmRvd1NpemU6IFNHV2luZG93TGVuZ3RoLTF9O1xubGV0IG9wdGlvbnNHb2xheUxvd1Bhc3MgPSB7ZGVyaXZhdGl2ZTogMH07XG5mdW5jdGlvbiBkaXNwbGF5U21vb3RobmVzcyh3aW5kb3dMZW5ndGhTRywgZGF0YSApe1xuICAvL0NhbGN1bGluZyBzbW9vdGhuZXNzXG4gIGFycmF5RmlsdGVyaW5nWC5wdXNoKGRhdGEuYWNjZWxlcm9tZXRlci54KTtcbiAgYXJyYXlGaWx0ZXJpbmdZLnB1c2goZGF0YS5hY2NlbGVyb21ldGVyLnkpO1xuICBhcnJheUZpbHRlcmluZ1oucHVzaChkYXRhLmFjY2VsZXJvbWV0ZXIueik7XG4gIFxuICAvL3RhaWxsZSBkZSBsYSBmZW5ldHJlIGRlIGNhbGN1bGUgZGUgbCdhbGdvcml0aG1lXG4gIGlmKGFycmF5RmlsdGVyaW5nWi5sZW5ndGggPj0gd2luZG93TGVuZ3RoU0cgKXtcbiAgICBhcnJheUZpbHRlcmluZ1guc2hpZnQoKTtcbiAgICBhcnJheUZpbHRlcmluZ1kuc2hpZnQoKTtcbiAgICBhcnJheUZpbHRlcmluZ1ouc2hpZnQoKTtcbiAgICBcbiAgICAvL2FwbGxpY2F0aW9uIGRlIHNhdml0emt5LWdvbGF5IGZpbHRlclxuICAgIGFuc3ggPSAgU0coYXJyYXlGaWx0ZXJpbmdYLCAxLCBvcHRpb25zKTtcbiAgICBhbnN5ID0gIFNHKGFycmF5RmlsdGVyaW5nWSwgMSwgb3B0aW9ucyk7XG4gICAgYW5zeiA9ICBTRyhhcnJheUZpbHRlcmluZ1osIDEsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vbm9ybWFsaXNpbmcgZGF0YVxuICAgIGxldCBub3JtYWxpc2VEYXRhID0gTWF0aC5zcXJ0KE1hdGgucG93KGFuc3hbYW5zeC5sZW5ndGggLSAxXSwyKStNYXRoLnBvdyhhbnN5W2Fuc3kubGVuZ3RoIC0gMV0sMikrTWF0aC5wb3coYW5zelthbnN6Lmxlbmd0aCAtIDFdLDIpKTtcbiAgICBsZXQgYW1wbGl0dWRlRGF0YSA9IGNvbXB1dGVBbXBsaXR1ZGVXaW5kb3coYW1wbGl0dWRlV2luZG93TGVuZ3RoLG5vcm1hbGlzZURhdGEpO1xuICAgIGxldCBzcGVlZFJhdGUgPSBjb21wdXRlU3BlZWRSYXRlQWRhcHRhdGl2ZVdpbmRvdyhzcGVlZFJhdGVXaW5kb3dMZW5ndGgsZGF0YS5hY2NlbGVyb21ldGVyLngsZGF0YS5hY2NlbGVyb21ldGVyLnksZGF0YS5hY2NlbGVyb21ldGVyLnopO1xuICAgLy8gY29uc29sZS5sb2coXCJzcGVlZFJhdGUgOiBcIiArIHNwZWVkUmF0ZSk7XG4gIFxuICAgIGlmKHJlY29yZGluZyl7XG4gICAgICBhcnJheVJlY29yZGVkLnB1c2gobm9ybWFsaXNlRGF0YSk7XG4gICAgICBjb25zb2xlLmxvZyhcImFycmF5UmVjb3JkZWQgOiBcIiArIGFycmF5UmVjb3JkZWQubGVuZ3RoKTtcbiAgICB9XG4gIFxuICAgIGxldCBmcmFtZVNtb290aG5lc3MgPSB7XG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgZGF0YTogYW1wbGl0dWRlRGF0YSxcbiAgICAgIC8vZGF0YTogbm9ybWFsaXNlRGF0YSxcbiAgICAgIG1ldGFkYXRhOm51bGwsXG4gICAgfTtcbiAgICBldmVudEluU21vb3RobmVzcy5wcm9jZXNzRnJhbWUoZnJhbWVTbW9vdGhuZXNzKTtcbiAgfVxufVxuXG4vL3ZlcnNpb24gbmFpdmUgZGUgbCdhbGdvcml0aG1lLCBsZSBmb3IgcGV1dCBldHJlIHJlbXBsYWPDqSBjb21tZSBkYW5zIGxhIGZvbmN0aW9uOiBjb21wdXRlU3BlZWRSYXRlQWRhcHRhdGl2ZVdpbmRvd1xuLy9Nb3llbm5lIGRlcyBkb25uw6llcyBkdSBqZXJrIG5vcm1hbGlzw6lcbnZhciBhcnJheUFtcGxpdHVkZSA9W107XG5mdW5jdGlvbiBjb21wdXRlQW1wbGl0dWRlV2luZG93KHdpbmRvd0xlbmd0aCwgZGF0YSl7XG4gIGxldCBhbXBsaXR1ZGVSYXRlID0gMDtcbiAgaWYoYXJyYXlBbXBsaXR1ZGUubGVuZ3RoID4gd2luZG93TGVuZ3RoKXtcbiAgICBhcnJheUFtcGxpdHVkZS5zaGlmdCgpO1xuICB9XG4gIGFycmF5QW1wbGl0dWRlLnB1c2goZGF0YSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZG93TGVuZ3RoIDsgaSsrKSB7XG4gICAgYW1wbGl0dWRlUmF0ZSArPSBhcnJheUFtcGxpdHVkZVtpXTtcbiAgfVxuICBhbXBsaXR1ZGVSYXRlIC89IHdpbmRvd0xlbmd0aDtcbiAvLyBjb25zb2xlLmxvZyhcImFtcGxpdHVkZVJhdGUgOiBcIiArIGFtcGxpdHVkZVJhdGUgKTtcbiAgcmV0dXJuIGFtcGxpdHVkZVJhdGU7XG59XG5cbndpbmRvdy5zZXRTR1dpbmRvd0xlbmd0aCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSl7XG4gIC8vY29uc29sZS5sb2coXCJuZXcgdmFsdWUgU0cgOiBcIiArIG5ld1ZhbHVlKTtcbiAgU0dXaW5kb3dMZW5ndGg9IG5ld1ZhbHVlO1xuICBvcHRpb25zID0ge2Rlcml2YXRpdmU6IDEsd2luZG93U2l6ZTogU0dXaW5kb3dMZW5ndGgtMX07XG4gIFxuICAgYXJyYXlGaWx0ZXJpbmdYID0gW107XG4gICBhcnJheUZpbHRlcmluZ1kgPSBbXTtcbiAgIGFycmF5RmlsdGVyaW5nWiA9IFtdO1xuICAgYW5zWCA9IFtdO1xuICAgYW5zWSA9IFtdO1xuICAgYW5zWiA9IFtdO1xufTtcblxud2luZG93LnNldEFtcGxpdHVkZVdpbmRvd0xlbmd0aCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICBhbXBsaXR1ZGVXaW5kb3dMZW5ndGggPSBuZXdWYWx1ZTtcbn07XG5cblxudmFyIGFycmF5UmVjb3JkZWQgPSBbXTtcbnZhciByZWNvcmRpbmcgPSBmYWxzZTtcblxuLypCdXR0b24gZnVuY3Rpb24qL1xud2luZG93LnN0YXJ0UmVjb3JkID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLmxvZyhcInJlY29yZGluZ1wiKTtcbiAgZXZlbnRJblNtb290aG5lc3Muc3RvcCgpO1xuICBTdHJlYW1Pbk9mZihcIm9mZlwiKTtcbiAgYXJyYXlSZWNvcmRlZCA9IFtdO1xuICByZWNvcmRpbmcgPSB0cnVlO1xufTtcblxud2luZG93LnN0b3BSZWNvcmQgPSBmdW5jdGlvbiAoKSB7XG4gIGV2ZW50SW5TbW9vdGhuZXNzLnN0YXJ0KCk7XG4gIHJlY29yZGluZyA9IGZhbHNlO1xufTtcblxudmFyIGkgPSAwO1xudmFyIHRpbWVyO1xuXG53aW5kb3cucGxheVJlY29yZGVkID0gZnVuY3Rpb24gKCkge1xuICB0aW1lciA9IHNldEludGVydmFsKHBsYXlpbmdSZWNvcmQsIDIwKTtcbiAgZXZlbnRJblNtb290aG5lc3NSZWNvcmRlZC5jb25uZWN0KHNvY2tldFNlbmRKZXJraW5lc3MpO1xuICBldmVudEluU21vb3RobmVzc1JlY29yZGVkLnN0YXJ0KCk7XG4gIGV2ZW50SW5TbW9vdGhuZXNzLnN0b3AoKTtcbiAgXG4gIGZ1bmN0aW9uIHBsYXlpbmdSZWNvcmQoKSB7XG4gICAgaWYoaSA8IGFycmF5UmVjb3JkZWQubGVuZ3RoICAgKXtcbiAgICAgIGxldCBmcmFtZVNtb290aG5lc3MgPSB7XG4gICAgICAgIHRpbWU6IGksXG4gICAgICAgIGRhdGE6IGFycmF5UmVjb3JkZWRbaV0sXG4gICAgICAgIC8vZGF0YTogbm9ybWFsaXNlRGF0YSxcbiAgICAgICAgbWV0YWRhdGE6bnVsbCxcbiAgICAgIH07XG4gICAgICBldmVudEluU21vb3RobmVzc1JlY29yZGVkLnByb2Nlc3NGcmFtZShmcmFtZVNtb290aG5lc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgZXZlbnRJblNtb290aG5lc3NSZWNvcmRlZC5zdG9wKCk7XG4gICAgICBldmVudEluU21vb3RobmVzcy5zdGFydCgpO1xuICAgICAgaSA9IDA7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICBcbn07XG53aW5kb3cuc3RvcGluZ1JlY29yZGVkID0gZnVuY3Rpb24gKCkge1xuICBjbGVhclRpbWVvdXQodGltZXIpO1xuICBldmVudEluU21vb3RobmVzc1JlY29yZGVkLnN0b3AoKTtcbiAgZXZlbnRJblNtb290aG5lc3Muc3RhcnQoKTtcbiAgU3RyZWFtT25PZmYoXCJvblwiKTtcbiAgXG4gIGkgPSAwO1xufTtcblxuXG4vLzIwMDAgPSBvbiwgMTAwMCA9IG9mZlxudmFyIG9uT2ZmID0gMTAwMDtcbndpbmRvdy5TdHJlYW1Pbk9mZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZih2YWx1ZSA9PT0gXCJvblwiKXtcbiAgICBvbk9mZiA9IDEwMDA7XG4gICAgZXZlbnRJblNtb290aG5lc3Muc3RhcnQoKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJvZmZcIil7XG4gICAgb25PZmYgPSAyMDAwO1xuICAgIC8vZXZlbnRJblNtb290aG5lc3Muc3RvcCgpO1xuICB9IGVsc2Uge1xuICAgIGlmKCBvbk9mZiA9PT0gMTAwMCl7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uIDogXCIgKyBvbk9mZik7XG4gICAgICBldmVudEluU21vb3RobmVzcy5zdGFydCgpO1xuICAgICAgb25PZmYgPSAyMDAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9mZiAgOiBcIiArIG9uT2ZmKTtcbiAgICAgIG9uT2ZmID0gMTAwMDtcbiAgICAgIC8vZXZlbnRJblNtb290aG5lc3Muc3RvcCgpO1xuICAgIH1cbiAgfVxuICBcbiAgbGV0IGZyYW1lU21vb3RobmVzc09uT0ZGID0ge1xuICAgIHRpbWU6IGksXG4gICAgZGF0YTogb25PZmYsXG4gICAgLy9kYXRhOiBub3JtYWxpc2VEYXRhLFxuICAgIG1ldGFkYXRhOiBudWxsLFxuICB9O1xuICBcbiAgZXZlbnRJblNtb290aG5lc3MucHJvY2Vzc0ZyYW1lKGZyYW1lU21vb3RobmVzc09uT0ZGKTtcbiAgXG59O1xuXG5cblxufSx7XCIuLi8uLi9jb25maWcvZGVmYXVsdFwiOjE4NyxcIi4vbXlvXCI6MTg1LFwibWwtc2F2aXR6a3ktZ29sYXlcIjoxMzIsXCJ3YXZlcy1sZm8vY2xpZW50XCI6MTMzfV0sMTg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuLy9pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbi8vY29uc3QgY3dkID0gcHJvY2Vzcy5jd2QoKTtcblxuXG4vLyBDb25maWd1cmF0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbi5cbi8vIE90aGVyIGVudHJpZXMgY2FuIGJlIGFkZGVkIChhcyBsb25nIGFzIHRoZWlyIG5hbWUgZG9lc24ndCBjb25mbGljdCB3aXRoXG4vLyBleGlzdGluZyBvbmVzKSB0byBkZWZpbmUgZ2xvYmFsIHBhcmFtZXRlcnMgb2YgdGhlIGFwcGxpY2F0aW9uIChlLmcuIEJQTSxcbi8vIHN5bnRoIHBhcmFtZXRlcnMpIHRoYXQgY2FuIHRoZW4gYmUgc2hhcmVkIGVhc2lseSBhbW9uZyBhbGwgY2xpZW50cyB1c2luZ1xuLy8gdGhlIGBzaGFyZWQtY29uZmlnYCBzZXJ2aWNlLlxudmFyIGNvbmZpZyA9ICB7XG4gIC8vIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uLCB1c2VkIGluIHRoZSBgLmVqc2AgdGVtcGxhdGUgYW5kIGJ5IGRlZmF1bHQgaW5cbiAgLy8gdGhlIGBwbGF0Zm9ybWAgc2VydmljZSB0byBwb3B1bGF0ZSBpdHMgdmlld1xuICBhcHBOYW1lOiAnVG9vbEJveCAtIE1vdmVPbjogQSB0ZWNobm9sb2d5IHByb2JlJyxcbiAgXG4gIC8vIG5hbWUgb2YgdGhlIGVudmlyb25uZW1lbnQgKCdwcm9kdWN0aW9uJyBlbmFibGUgY2FjaGUgaW4gZXhwcmVzcyBhcHBsaWNhdGlvbilcbiAgZW52OiAnZGV2ZWxvcG1lbnQnLFxuICBcbiAgLy8gdmVyc2lvbiBvZiBhcHBsaWNhdGlvbiwgY2FuIGJlIHVzZWQgdG8gZm9yY2UgcmVsb2FkIGNzcyBhbmQganMgZmlsZXNcbiAgLy8gZnJvbSBzZXJ2ZXIgKGNmLiBgaHRtbC9kZWZhdWx0LmVqc2ApXG4gIHZlcnNpb246ICcwLjAuMScsXG4gIFxuICBcbiAgLy8gZGVmaW5lIGZyb20gd2hlcmUgdGhlIGFzc2V0cyAoc3RhdGljIGZpbGVzKSBzaG91bGQgYmUgbG9hZGVkLCB0aGVzZSB2YWx1ZVxuICAvLyBjb3VsZCBhbHNvIHJlZmVyIHRvIGEgc2VwYXJhdGUgc2VydmVyIGZvciBzY2FsYWJpbGl0eSByZWFzb25zLiBUaGlzIHZhbHVlXG4gIC8vIHNob3VsZCBhbHNvIGJlIHVzZWQgY2xpZW50LXNpZGUgdG8gY29uZmlndXJlIHRoZSBgYXVkaW8tYnVmZmVyLW1hbmFnZXJgIHNlcnZpY2UuXG4gIGFzc2V0c0RvbWFpbjogJy8nLFxuICBcbiAgLy8gcG9ydCB1c2VkIHRvIG9wZW4gdGhlIGh0dHAgc2VydmVyLCBpbiBwcm9kdWN0aW9uIHRoaXMgdmFsdWUgaXMgdHlwaWNhbGx5IDgwXG4gIHBvcnRTZXJ2ZXI6IDgwMDAsXG4gIFxuICAvL1BvcnQgdXNlZCBieSB0aGUgbXlvXG4gIG15b1BvcnQ6IDEwMTM4LFxuICBcbiAgLy8gbG9jYXRpb24gb2YgdGhlIHB1YmxpYyBkaXJlY3RvcnkgKGFjY2Vzc2libGUgdGhyb3VnaCBodHRwKHMpIHJlcXVlc3RzKVxuICAvLyAgcHVibGljRGlyZWN0b3J5OiBwYXRoLmpvaW4oY3dkLCAncHVibGljJyksXG4gIFxuICBcbiAgLy8gY29uZmlndXJhdGlvbiBvZiB0aGUgYG9zY2Agc2VydmljZVxuICBvc2M6IHtcbiAgICAvLyBJUCBvZiB0aGUgY3VycmVudGx5IHJ1bm5pbmcgbm9kZSBzZXJ2ZXJcbiAgICByZWNlaXZlQWRkcmVzczogJzEyNy4wLjAuMScsXG4gICAgLy8gcG9ydCBsaXN0ZW5pbmcgZm9yIGluY29tbWluZyBtZXNzYWdlc1xuICAgIHJlY2VpdmVQb3J0OiA1NzEyMSxcbiAgICAvLyBJUCBvZiB0aGUgcmVtb3RlIGFwcGxpY2F0aW9uXG4gICAgc2VuZEFkZHJlc3M6ICcxMjcuMC4wLjEnLFxuICAgIC8vIHBvcnQgd2hlcmUgdGhlIHJlbW90ZSBhcHBsaWNhdGlvbiBpcyBsaXN0ZW5pbmcgZm9yIG1lc3NhZ2VzXG4gICAgc2VuZFBvcnQ6IDU3MTIwLFxuICB9LFxuICBcbiAgLy8gY29uZmlndXJhdGlvbiBvZiB0aGUgYHJhdy1zb2NrZXRgIHNlcnZpY2VcbiAgc29ja2V0U2VydmVyVG9DbGllbnQ6IHtcbiAgICAvLyBwb3J0IHVzZWQgZm9yIHNvY2tldCBjb25uZWN0aW9uIHdpdGggdGhlIGNsaWVudFxuICAgIHBvcnQ6IDkwMDJcbiAgfSxcbiAgLy8gY29uZmlndXJhdGlvbiBvZiB0aGUgYHJhdy1zb2NrZXRgIHNlcnZpY2VcbiAgc29ja2V0Q2xpZW50VG9TZXJ2ZXI6IHtcbiAgICAvLyBwb3J0IHVzZWQgZm9yIHNvY2tldCBjb25uZWN0aW9uIHdpdGggdGhlIGNsaWVudFxuICAgIHBvcnQ6IDkwMDFcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnO1xuXG59LHt9XSwxODg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxufSx7fV19LHt9LFsxODZdKTtcbiJdfQ==